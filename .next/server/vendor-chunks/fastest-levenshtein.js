"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fastest-levenshtein";
exports.ids = ["vendor-chunks/fastest-levenshtein"];
exports.modules = {

/***/ "(rsc)/./node_modules/fastest-levenshtein/esm/mod.js":
/*!*****************************************************!*\
  !*** ./node_modules/fastest-levenshtein/esm/mod.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closest: () => (/* binding */ closest),\n/* harmony export */   distance: () => (/* binding */ distance)\n/* harmony export */ });\nconst peq = new Uint32Array(0x10000);\nconst myers_32 = (a, b) => {\n    const n = a.length;\n    const m = b.length;\n    const lst = 1 << (n - 1);\n    let pv = -1;\n    let mv = 0;\n    let sc = n;\n    let i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] |= 1 << i;\n    }\n    for (i = 0; i < m; i++) {\n        let eq = peq[b.charCodeAt(i)];\n        const xv = eq | mv;\n        eq |= ((eq & pv) + pv) ^ pv;\n        mv |= ~(eq | pv);\n        pv &= eq;\n        if (mv & lst) {\n            sc++;\n        }\n        if (pv & lst) {\n            sc--;\n        }\n        mv = (mv << 1) | 1;\n        pv = (pv << 1) | ~(xv | mv);\n        mv &= xv;\n    }\n    i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] = 0;\n    }\n    return sc;\n};\nconst myers_x = (b, a) => {\n    const n = a.length;\n    const m = b.length;\n    const mhc = [];\n    const phc = [];\n    const hsize = Math.ceil(n / 32);\n    const vsize = Math.ceil(m / 32);\n    for (let i = 0; i < hsize; i++) {\n        phc[i] = -1;\n        mhc[i] = 0;\n    }\n    let j = 0;\n    for (; j < vsize - 1; j++) {\n        let mv = 0;\n        let pv = -1;\n        const start = j * 32;\n        const vlen = Math.min(32, m) + start;\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] |= 1 << k;\n        }\n        for (let i = 0; i < n; i++) {\n            const eq = peq[a.charCodeAt(i)];\n            const pb = (phc[(i / 32) | 0] >>> i) & 1;\n            const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n            const xv = eq | mv;\n            const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n            let ph = mv | ~(xh | pv);\n            let mh = pv & xh;\n            if ((ph >>> 31) ^ pb) {\n                phc[(i / 32) | 0] ^= 1 << i;\n            }\n            if ((mh >>> 31) ^ mb) {\n                mhc[(i / 32) | 0] ^= 1 << i;\n            }\n            ph = (ph << 1) | pb;\n            mh = (mh << 1) | mb;\n            pv = mh | ~(xv | ph);\n            mv = ph & xv;\n        }\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] = 0;\n        }\n    }\n    let mv = 0;\n    let pv = -1;\n    const start = j * 32;\n    const vlen = Math.min(32, m - start) + start;\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] |= 1 << k;\n    }\n    let score = m;\n    for (let i = 0; i < n; i++) {\n        const eq = peq[a.charCodeAt(i)];\n        const pb = (phc[(i / 32) | 0] >>> i) & 1;\n        const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n        const xv = eq | mv;\n        const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n        let ph = mv | ~(xh | pv);\n        let mh = pv & xh;\n        score += (ph >>> (m - 1)) & 1;\n        score -= (mh >>> (m - 1)) & 1;\n        if ((ph >>> 31) ^ pb) {\n            phc[(i / 32) | 0] ^= 1 << i;\n        }\n        if ((mh >>> 31) ^ mb) {\n            mhc[(i / 32) | 0] ^= 1 << i;\n        }\n        ph = (ph << 1) | pb;\n        mh = (mh << 1) | mb;\n        pv = mh | ~(xv | ph);\n        mv = ph & xv;\n    }\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] = 0;\n    }\n    return score;\n};\nconst distance = (a, b) => {\n    if (a.length < b.length) {\n        const tmp = b;\n        b = a;\n        a = tmp;\n    }\n    if (b.length === 0) {\n        return a.length;\n    }\n    if (a.length <= 32) {\n        return myers_32(a, b);\n    }\n    return myers_x(a, b);\n};\nconst closest = (str, arr) => {\n    let min_distance = Infinity;\n    let min_index = 0;\n    for (let i = 0; i < arr.length; i++) {\n        const dist = distance(str, arr[i]);\n        if (dist < min_distance) {\n            min_distance = dist;\n            min_index = i;\n        }\n    }\n    return arr[min_index];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFzdGVzdC1sZXZlbnNodGVpbi9lc20vbW9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9mYXN0ZXN0LWxldmVuc2h0ZWluL2VzbS9tb2QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGVxID0gbmV3IFVpbnQzMkFycmF5KDB4MTAwMDApO1xuY29uc3QgbXllcnNfMzIgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcbiAgICBjb25zdCBtID0gYi5sZW5ndGg7XG4gICAgY29uc3QgbHN0ID0gMSA8PCAobiAtIDEpO1xuICAgIGxldCBwdiA9IC0xO1xuICAgIGxldCBtdiA9IDA7XG4gICAgbGV0IHNjID0gbjtcbiAgICBsZXQgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwZXFbYS5jaGFyQ29kZUF0KGkpXSB8PSAxIDw8IGk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgbGV0IGVxID0gcGVxW2IuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGNvbnN0IHh2ID0gZXEgfCBtdjtcbiAgICAgICAgZXEgfD0gKChlcSAmIHB2KSArIHB2KSBeIHB2O1xuICAgICAgICBtdiB8PSB+KGVxIHwgcHYpO1xuICAgICAgICBwdiAmPSBlcTtcbiAgICAgICAgaWYgKG12ICYgbHN0KSB7XG4gICAgICAgICAgICBzYysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdiAmIGxzdCkge1xuICAgICAgICAgICAgc2MtLTtcbiAgICAgICAgfVxuICAgICAgICBtdiA9IChtdiA8PCAxKSB8IDE7XG4gICAgICAgIHB2ID0gKHB2IDw8IDEpIHwgfih4diB8IG12KTtcbiAgICAgICAgbXYgJj0geHY7XG4gICAgfVxuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcGVxW2EuY2hhckNvZGVBdChpKV0gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc2M7XG59O1xuY29uc3QgbXllcnNfeCA9IChiLCBhKSA9PiB7XG4gICAgY29uc3QgbiA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IG0gPSBiLmxlbmd0aDtcbiAgICBjb25zdCBtaGMgPSBbXTtcbiAgICBjb25zdCBwaGMgPSBbXTtcbiAgICBjb25zdCBoc2l6ZSA9IE1hdGguY2VpbChuIC8gMzIpO1xuICAgIGNvbnN0IHZzaXplID0gTWF0aC5jZWlsKG0gLyAzMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoc2l6ZTsgaSsrKSB7XG4gICAgICAgIHBoY1tpXSA9IC0xO1xuICAgICAgICBtaGNbaV0gPSAwO1xuICAgIH1cbiAgICBsZXQgaiA9IDA7XG4gICAgZm9yICg7IGogPCB2c2l6ZSAtIDE7IGorKykge1xuICAgICAgICBsZXQgbXYgPSAwO1xuICAgICAgICBsZXQgcHYgPSAtMTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBqICogMzI7XG4gICAgICAgIGNvbnN0IHZsZW4gPSBNYXRoLm1pbigzMiwgbSkgKyBzdGFydDtcbiAgICAgICAgZm9yIChsZXQgayA9IHN0YXJ0OyBrIDwgdmxlbjsgaysrKSB7XG4gICAgICAgICAgICBwZXFbYi5jaGFyQ29kZUF0KGspXSB8PSAxIDw8IGs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVxID0gcGVxW2EuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICBjb25zdCBwYiA9IChwaGNbKGkgLyAzMikgfCAwXSA+Pj4gaSkgJiAxO1xuICAgICAgICAgICAgY29uc3QgbWIgPSAobWhjWyhpIC8gMzIpIHwgMF0gPj4+IGkpICYgMTtcbiAgICAgICAgICAgIGNvbnN0IHh2ID0gZXEgfCBtdjtcbiAgICAgICAgICAgIGNvbnN0IHhoID0gKCgoKGVxIHwgbWIpICYgcHYpICsgcHYpIF4gcHYpIHwgZXEgfCBtYjtcbiAgICAgICAgICAgIGxldCBwaCA9IG12IHwgfih4aCB8IHB2KTtcbiAgICAgICAgICAgIGxldCBtaCA9IHB2ICYgeGg7XG4gICAgICAgICAgICBpZiAoKHBoID4+PiAzMSkgXiBwYikge1xuICAgICAgICAgICAgICAgIHBoY1soaSAvIDMyKSB8IDBdIF49IDEgPDwgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobWggPj4+IDMxKSBeIG1iKSB7XG4gICAgICAgICAgICAgICAgbWhjWyhpIC8gMzIpIHwgMF0gXj0gMSA8PCBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGggPSAocGggPDwgMSkgfCBwYjtcbiAgICAgICAgICAgIG1oID0gKG1oIDw8IDEpIHwgbWI7XG4gICAgICAgICAgICBwdiA9IG1oIHwgfih4diB8IHBoKTtcbiAgICAgICAgICAgIG12ID0gcGggJiB4djtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrID0gc3RhcnQ7IGsgPCB2bGVuOyBrKyspIHtcbiAgICAgICAgICAgIHBlcVtiLmNoYXJDb2RlQXQoayldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbXYgPSAwO1xuICAgIGxldCBwdiA9IC0xO1xuICAgIGNvbnN0IHN0YXJ0ID0gaiAqIDMyO1xuICAgIGNvbnN0IHZsZW4gPSBNYXRoLm1pbigzMiwgbSAtIHN0YXJ0KSArIHN0YXJ0O1xuICAgIGZvciAobGV0IGsgPSBzdGFydDsgayA8IHZsZW47IGsrKykge1xuICAgICAgICBwZXFbYi5jaGFyQ29kZUF0KGspXSB8PSAxIDw8IGs7XG4gICAgfVxuICAgIGxldCBzY29yZSA9IG07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXEgPSBwZXFbYS5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgY29uc3QgcGIgPSAocGhjWyhpIC8gMzIpIHwgMF0gPj4+IGkpICYgMTtcbiAgICAgICAgY29uc3QgbWIgPSAobWhjWyhpIC8gMzIpIHwgMF0gPj4+IGkpICYgMTtcbiAgICAgICAgY29uc3QgeHYgPSBlcSB8IG12O1xuICAgICAgICBjb25zdCB4aCA9ICgoKChlcSB8IG1iKSAmIHB2KSArIHB2KSBeIHB2KSB8IGVxIHwgbWI7XG4gICAgICAgIGxldCBwaCA9IG12IHwgfih4aCB8IHB2KTtcbiAgICAgICAgbGV0IG1oID0gcHYgJiB4aDtcbiAgICAgICAgc2NvcmUgKz0gKHBoID4+PiAobSAtIDEpKSAmIDE7XG4gICAgICAgIHNjb3JlIC09IChtaCA+Pj4gKG0gLSAxKSkgJiAxO1xuICAgICAgICBpZiAoKHBoID4+PiAzMSkgXiBwYikge1xuICAgICAgICAgICAgcGhjWyhpIC8gMzIpIHwgMF0gXj0gMSA8PCBpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobWggPj4+IDMxKSBeIG1iKSB7XG4gICAgICAgICAgICBtaGNbKGkgLyAzMikgfCAwXSBePSAxIDw8IGk7XG4gICAgICAgIH1cbiAgICAgICAgcGggPSAocGggPDwgMSkgfCBwYjtcbiAgICAgICAgbWggPSAobWggPDwgMSkgfCBtYjtcbiAgICAgICAgcHYgPSBtaCB8IH4oeHYgfCBwaCk7XG4gICAgICAgIG12ID0gcGggJiB4djtcbiAgICB9XG4gICAgZm9yIChsZXQgayA9IHN0YXJ0OyBrIDwgdmxlbjsgaysrKSB7XG4gICAgICAgIHBlcVtiLmNoYXJDb2RlQXQoayldID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0bXAgPSBiO1xuICAgICAgICBiID0gYTtcbiAgICAgICAgYSA9IHRtcDtcbiAgICB9XG4gICAgaWYgKGIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgIHJldHVybiBteWVyc18zMihhLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIG15ZXJzX3goYSwgYik7XG59O1xuY29uc3QgY2xvc2VzdCA9IChzdHIsIGFycikgPT4ge1xuICAgIGxldCBtaW5fZGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgbWluX2luZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkaXN0ID0gZGlzdGFuY2Uoc3RyLCBhcnJbaV0pO1xuICAgICAgICBpZiAoZGlzdCA8IG1pbl9kaXN0YW5jZSkge1xuICAgICAgICAgICAgbWluX2Rpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgIG1pbl9pbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyclttaW5faW5kZXhdO1xufTtcbmV4cG9ydCB7IGNsb3Nlc3QsIGRpc3RhbmNlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fastest-levenshtein/esm/mod.js\n");

/***/ })

};
;
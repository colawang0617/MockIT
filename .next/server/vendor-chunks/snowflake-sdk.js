/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snowflake-sdk";
exports.ids = ["vendor-chunks/snowflake-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./lib/snowflake */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/snowflake.js\");\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdUhBQTJDO0FBQzNDIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9zbm93Zmxha2UnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*\n * This software is licensed under the MIT License.\n *\n * Copyright Fedor Indutny, 2015.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst process = __webpack_require__(/*! process */ \"process\");\nconst ocsp = __webpack_require__(/*! @techteamer/ocsp */ \"(rsc)/./node_modules/@techteamer/ocsp/lib/ocsp.js\");\nconst rfc2560 = __webpack_require__(/*! asn1.js-rfc2560 */ \"(rsc)/./node_modules/asn1.js-rfc2560/index.js\");\nconst rfc5280 = __webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst bn = __webpack_require__(/*! bn.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst TOLERABLE_VALIDITY_RANGE_RATIO = 0.01;\nconst MAX_CLOCK_SKEW_IN_MILLISECONDS = 900000;\nconst MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS = 18000000;\n/**\n * Builds the certificate id for a given certificate.\n *\n * @param cert\n * @returns {*}\n */\nexports.buildCertId = function (cert) {\n    let issuer = cert.issuerCertificate;\n    cert = cert.raw;\n    try {\n        cert = rfc5280.Certificate.decode(cert, 'der');\n        if (issuer) {\n            issuer = issuer.raw;\n            issuer = rfc5280.Certificate.decode(issuer, 'der');\n        }\n    }\n    catch (e) {\n        return null; // if we encountered an error during decoding, return null\n    }\n    const tbsCert = cert.tbsCertificate;\n    const tbsIssuer = issuer.tbsCertificate;\n    const certID = {\n        hashAlgorithm: {\n            // algorithm: [ 2, 16, 840, 1, 101, 3, 4, 2, 1 ]  // sha256\n            algorithm: [1, 3, 14, 3, 2, 26], // sha1\n        },\n        issuerNameHash: sha1(rfc5280.Name.encode(tbsCert.issuer, 'der')),\n        issuerKeyHash: sha1(tbsIssuer.subjectPublicKeyInfo.subjectPublicKey.data),\n        serialNumber: tbsCert.serialNumber,\n    };\n    const certIDDer = rfc2560.CertID.encode(certID, 'der');\n    return encodeKey(certIDDer.toString('BASE64'));\n};\nfunction sha1(data) {\n    return crypto.createHash('sha1').update(data).digest();\n}\n/**\n * Parses a certificate and returns an object that contains decoded versions\n * of the certificate and its issuer.\n *\n * Note: this method might throw an error, so use a try-catch when calling it.\n *\n * @param cert\n * @returns {{cert: *, issuer: *}}\n */\nexports.decode = function (cert) {\n    let issuer = cert.issuerCertificate;\n    cert = cert.raw;\n    // note: this block might throw an error\n    cert = rfc5280.Certificate.decode(cert, 'der');\n    if (issuer) {\n        issuer = issuer.raw;\n        issuer = rfc5280.Certificate.decode(issuer, 'der');\n    }\n    return {\n        cert: cert,\n        issuer: issuer,\n    };\n};\n/**\n * Encode certID to a cache key\n * @param base64Key {Object}\n * @return cache key {string}\n */\nconst encodeKey = function (base64Key) {\n    const buff = Buffer.from(base64Key, 'base64');\n    const certID = rfc2560.CertID.decode(buff, 'der');\n    return (certID.issuerNameHash.toString('BASE64') +\n        '#' +\n        certID.issuerKeyHash.toString('BASE64') +\n        '#' +\n        certID.serialNumber.toString(10));\n};\nexports.encodeKey = encodeKey;\n/**\n * Encode certID to a cache key\n * @param cacheKey {Object}\n */\nconst decodeKey = function (cacheKey) {\n    // serialNumber.eq(certID.serialNumber)\n    const keys = cacheKey.split('#');\n    const issuerNameHash = Buffer.from(keys[0], 'base64');\n    const issuerKeyHash = Buffer.from(keys[1], 'base64');\n    const serialNumber = new bn(keys[2], 10);\n    const certID = {\n        hashAlgorithm: {\n            // algorithm: [ 2, 16, 840, 1, 101, 3, 4, 2, 1 ]  // sha256\n            algorithm: [1, 3, 14, 3, 2, 26], // sha1\n        },\n        issuerNameHash: issuerNameHash,\n        issuerKeyHash: issuerKeyHash,\n        serialNumber: serialNumber,\n    };\n    const certIDDer = rfc2560.CertID.encode(certID, 'der');\n    return certIDDer.toString('BASE64');\n};\nexports.decodeKey = decodeKey;\n/**\n * Calculates Tolerable validity\n * @param thisUpdate last update\n * @param nextUpdate next update\n * @returns {number}\n */\nconst calculateTolerableVadility = function (thisUpdate, nextUpdate) {\n    const currentRange = (nextUpdate - thisUpdate) * TOLERABLE_VALIDITY_RANGE_RATIO;\n    return currentRange > MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS\n        ? currentRange\n        : MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS;\n};\n/**\n * Checks the validity\n * @param currentTime current time\n * @param thisUpdate last update\n * @param nextUpdate next update\n * @return {boolean}\n */\nconst isValidityRange = function (currentTime, thisUpdate, nextUpdate) {\n    const tolerableValidity = calculateTolerableVadility(thisUpdate, nextUpdate);\n    return (thisUpdate - MAX_CLOCK_SKEW_IN_MILLISECONDS <= currentTime &&\n        currentTime <= nextUpdate + tolerableValidity);\n};\nexports.isValidityRange = isValidityRange;\n/**\n * Converts a epoch time in milliseconds to a UTC datetime string\n * @param epochInMilliSeconds\n * @returns {Date}\n */\nconst toUTCString = function (epochInMilliSeconds) {\n    return new Date(epochInMilliSeconds);\n};\n/**\n * Return issuer certificate or signing certificate\n * @param issuer issuer certificate\n * @param certs\n * @param raws\n */\nconst findResponder = function (issuer, certs, raws) {\n    let issuerKey = issuer.tbsCertificate.subjectPublicKeyInfo;\n    issuerKey = ocsp.utils.toPEM(rfc5280.SubjectPublicKeyInfo.encode(issuerKey, 'der'), 'PUBLIC KEY');\n    if (certs.length > 0) {\n        const currentTime = Date.now();\n        const cert = certs[0];\n        const certValidity = cert.tbsCertificate.validity;\n        if (certValidity.notAfter.value < currentTime || certValidity.notBefore.value > currentTime) {\n            return {\n                err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_CERTIFICATE_VALIDITY, 'Valid from:', toUTCString(certValidity.notBefore.value), ', Valid to:', toUTCString(certValidity.notAfter.value)),\n                responderKey: null,\n            };\n        }\n        const signAlg = ocsp.utils.sign[cert.signatureAlgorithm.algorithm.join('.')];\n        if (!signAlg) {\n            return {\n                err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM),\n                responderKey: null,\n            };\n        }\n        const verify = crypto.createVerify(signAlg);\n        verify.update(raws[0]);\n        if (!verify.verify(issuerKey, cert.signature.data)) {\n            return {\n                err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_SIGNATURE),\n                responderKey: null,\n            };\n        }\n        let certKey = cert.tbsCertificate.subjectPublicKeyInfo;\n        certKey = ocsp.utils.toPEM(rfc5280.SubjectPublicKeyInfo.encode(certKey, 'der'), 'PUBLIC KEY');\n        return { err: null, responderKey: certKey };\n    }\n    return { err: null, responderKey: issuerKey };\n};\n/**\n * Verify OCSP response. If issuer is not specified, the signature will not be\n * verified.\n * @param issuer issuer certificate\n * @param rawRes OCSP Response\n * @returns {{success, error, revoked}|{res, success, error}}\n */\nconst verifyOCSPResponse = function (issuer, rawRes) {\n    function done(err) {\n        return {\n            err: err,\n            res: rawRes,\n        };\n    }\n    let res;\n    try {\n        res = ocsp.utils.parseResponse(rawRes);\n    }\n    catch (e) {\n        return done(e);\n    }\n    const value = res.value;\n    if (issuer) {\n        // verify signature only if issuer is given\n        const certs = res.certs;\n        const rawTBS = rawRes.slice(res.start, res.end);\n        const raws = res.certsTbs.map(function (tbs) {\n            return rawRes.slice(tbs.start, tbs.end);\n        });\n        const signAlg = ocsp.utils.sign[value.signatureAlgorithm.algorithm.join('.')];\n        if (!signAlg) {\n            return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM));\n        }\n        const responderStatus = findResponder(issuer, certs, raws);\n        if (responderStatus.err) {\n            return done(responderStatus.err);\n        }\n        const responderKey = responderStatus.responderKey;\n        const v = crypto.createVerify(signAlg);\n        const signature = value.signature.data;\n        v.update(rawTBS);\n        if (!v.verify(responderKey, signature)) {\n            return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_SIGNATURE));\n        }\n    }\n    const tbs = value.tbsResponseData;\n    if (tbs.responses.length < 1) {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_RESPONSE));\n    }\n    const sd = tbs.responses[0];\n    if (sd.certStatus.type === 'revoked') {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_REVOKED));\n    }\n    const currentTime = Date.now();\n    const isInjectValidity = process.env.SF_OCSP_TEST_INJECT_VALIDITY_ERROR || '';\n    if (isInjectValidity.toLowerCase() === 'true' ||\n        !isValidityRange(currentTime, sd.thisUpdate, sd.nextUpdate)) {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_VALIDITY, 'Valid from:', toUTCString(sd.thisUpdate), ', Valid to:', toUTCString(sd.nextUpdate)));\n    }\n    const isInjectUnknown = process.env.SF_OCSP_TEST_INJECT_UNKNOWN_STATUS || '';\n    if (isInjectUnknown.toLowerCase() === 'true' || sd.certStatus.type === 'unknown') {\n        return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_UNKNOWN));\n    }\n    if (sd.certStatus.type === 'good') {\n        return done(null);\n    }\n    return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_UNKNOWN_STATE));\n};\nexports.verifyOCSPResponse = verifyOCSPResponse;\n//# sourceMappingURL=cert_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jZXJ0X3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsd0JBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDJFQUFrQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsOEVBQU87QUFDMUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixFQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYWdlbnQvY2VydF91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgRmVkb3IgSW5kdXRueSwgMjAxNS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG4ndXNlIHN0cmljdCc7XG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2VzcycpO1xuY29uc3Qgb2NzcCA9IHJlcXVpcmUoJ0B0ZWNodGVhbWVyL29jc3AnKTtcbmNvbnN0IHJmYzI1NjAgPSByZXF1aXJlKCdhc24xLmpzLXJmYzI1NjAnKTtcbmNvbnN0IHJmYzUyODAgPSByZXF1aXJlKCdhc24xLmpzLXJmYzUyODAnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgYm4gPSByZXF1aXJlKCdibi5qcycpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgVE9MRVJBQkxFX1ZBTElESVRZX1JBTkdFX1JBVElPID0gMC4wMTtcbmNvbnN0IE1BWF9DTE9DS19TS0VXX0lOX01JTExJU0VDT05EUyA9IDkwMDAwMDtcbmNvbnN0IE1JTl9DQUNIRV9XQVJNVVBfVElNRV9JTl9NSUxMSVNFQ09ORFMgPSAxODAwMDAwMDtcbi8qKlxuICogQnVpbGRzIHRoZSBjZXJ0aWZpY2F0ZSBpZCBmb3IgYSBnaXZlbiBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuYnVpbGRDZXJ0SWQgPSBmdW5jdGlvbiAoY2VydCkge1xuICAgIGxldCBpc3N1ZXIgPSBjZXJ0Lmlzc3VlckNlcnRpZmljYXRlO1xuICAgIGNlcnQgPSBjZXJ0LnJhdztcbiAgICB0cnkge1xuICAgICAgICBjZXJ0ID0gcmZjNTI4MC5DZXJ0aWZpY2F0ZS5kZWNvZGUoY2VydCwgJ2RlcicpO1xuICAgICAgICBpZiAoaXNzdWVyKSB7XG4gICAgICAgICAgICBpc3N1ZXIgPSBpc3N1ZXIucmF3O1xuICAgICAgICAgICAgaXNzdWVyID0gcmZjNTI4MC5DZXJ0aWZpY2F0ZS5kZWNvZGUoaXNzdWVyLCAnZGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGlmIHdlIGVuY291bnRlcmVkIGFuIGVycm9yIGR1cmluZyBkZWNvZGluZywgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgdGJzQ2VydCA9IGNlcnQudGJzQ2VydGlmaWNhdGU7XG4gICAgY29uc3QgdGJzSXNzdWVyID0gaXNzdWVyLnRic0NlcnRpZmljYXRlO1xuICAgIGNvbnN0IGNlcnRJRCA9IHtcbiAgICAgICAgaGFzaEFsZ29yaXRobToge1xuICAgICAgICAgICAgLy8gYWxnb3JpdGhtOiBbIDIsIDE2LCA4NDAsIDEsIDEwMSwgMywgNCwgMiwgMSBdICAvLyBzaGEyNTZcbiAgICAgICAgICAgIGFsZ29yaXRobTogWzEsIDMsIDE0LCAzLCAyLCAyNl0sIC8vIHNoYTFcbiAgICAgICAgfSxcbiAgICAgICAgaXNzdWVyTmFtZUhhc2g6IHNoYTEocmZjNTI4MC5OYW1lLmVuY29kZSh0YnNDZXJ0Lmlzc3VlciwgJ2RlcicpKSxcbiAgICAgICAgaXNzdWVyS2V5SGFzaDogc2hhMSh0YnNJc3N1ZXIuc3ViamVjdFB1YmxpY0tleUluZm8uc3ViamVjdFB1YmxpY0tleS5kYXRhKSxcbiAgICAgICAgc2VyaWFsTnVtYmVyOiB0YnNDZXJ0LnNlcmlhbE51bWJlcixcbiAgICB9O1xuICAgIGNvbnN0IGNlcnRJRERlciA9IHJmYzI1NjAuQ2VydElELmVuY29kZShjZXJ0SUQsICdkZXInKTtcbiAgICByZXR1cm4gZW5jb2RlS2V5KGNlcnRJRERlci50b1N0cmluZygnQkFTRTY0JykpO1xufTtcbmZ1bmN0aW9uIHNoYTEoZGF0YSkge1xuICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgY2VydGlmaWNhdGUgYW5kIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZGVjb2RlZCB2ZXJzaW9uc1xuICogb2YgdGhlIGNlcnRpZmljYXRlIGFuZCBpdHMgaXNzdWVyLlxuICpcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIG1pZ2h0IHRocm93IGFuIGVycm9yLCBzbyB1c2UgYSB0cnktY2F0Y2ggd2hlbiBjYWxsaW5nIGl0LlxuICpcbiAqIEBwYXJhbSBjZXJ0XG4gKiBAcmV0dXJucyB7e2NlcnQ6ICosIGlzc3VlcjogKn19XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNlcnQpIHtcbiAgICBsZXQgaXNzdWVyID0gY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZTtcbiAgICBjZXJ0ID0gY2VydC5yYXc7XG4gICAgLy8gbm90ZTogdGhpcyBibG9jayBtaWdodCB0aHJvdyBhbiBlcnJvclxuICAgIGNlcnQgPSByZmM1MjgwLkNlcnRpZmljYXRlLmRlY29kZShjZXJ0LCAnZGVyJyk7XG4gICAgaWYgKGlzc3Vlcikge1xuICAgICAgICBpc3N1ZXIgPSBpc3N1ZXIucmF3O1xuICAgICAgICBpc3N1ZXIgPSByZmM1MjgwLkNlcnRpZmljYXRlLmRlY29kZShpc3N1ZXIsICdkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2VydDogY2VydCxcbiAgICAgICAgaXNzdWVyOiBpc3N1ZXIsXG4gICAgfTtcbn07XG4vKipcbiAqIEVuY29kZSBjZXJ0SUQgdG8gYSBjYWNoZSBrZXlcbiAqIEBwYXJhbSBiYXNlNjRLZXkge09iamVjdH1cbiAqIEByZXR1cm4gY2FjaGUga2V5IHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVuY29kZUtleSA9IGZ1bmN0aW9uIChiYXNlNjRLZXkpIHtcbiAgICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oYmFzZTY0S2V5LCAnYmFzZTY0Jyk7XG4gICAgY29uc3QgY2VydElEID0gcmZjMjU2MC5DZXJ0SUQuZGVjb2RlKGJ1ZmYsICdkZXInKTtcbiAgICByZXR1cm4gKGNlcnRJRC5pc3N1ZXJOYW1lSGFzaC50b1N0cmluZygnQkFTRTY0JykgK1xuICAgICAgICAnIycgK1xuICAgICAgICBjZXJ0SUQuaXNzdWVyS2V5SGFzaC50b1N0cmluZygnQkFTRTY0JykgK1xuICAgICAgICAnIycgK1xuICAgICAgICBjZXJ0SUQuc2VyaWFsTnVtYmVyLnRvU3RyaW5nKDEwKSk7XG59O1xuZXhwb3J0cy5lbmNvZGVLZXkgPSBlbmNvZGVLZXk7XG4vKipcbiAqIEVuY29kZSBjZXJ0SUQgdG8gYSBjYWNoZSBrZXlcbiAqIEBwYXJhbSBjYWNoZUtleSB7T2JqZWN0fVxuICovXG5jb25zdCBkZWNvZGVLZXkgPSBmdW5jdGlvbiAoY2FjaGVLZXkpIHtcbiAgICAvLyBzZXJpYWxOdW1iZXIuZXEoY2VydElELnNlcmlhbE51bWJlcilcbiAgICBjb25zdCBrZXlzID0gY2FjaGVLZXkuc3BsaXQoJyMnKTtcbiAgICBjb25zdCBpc3N1ZXJOYW1lSGFzaCA9IEJ1ZmZlci5mcm9tKGtleXNbMF0sICdiYXNlNjQnKTtcbiAgICBjb25zdCBpc3N1ZXJLZXlIYXNoID0gQnVmZmVyLmZyb20oa2V5c1sxXSwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHNlcmlhbE51bWJlciA9IG5ldyBibihrZXlzWzJdLCAxMCk7XG4gICAgY29uc3QgY2VydElEID0ge1xuICAgICAgICBoYXNoQWxnb3JpdGhtOiB7XG4gICAgICAgICAgICAvLyBhbGdvcml0aG06IFsgMiwgMTYsIDg0MCwgMSwgMTAxLCAzLCA0LCAyLCAxIF0gIC8vIHNoYTI1NlxuICAgICAgICAgICAgYWxnb3JpdGhtOiBbMSwgMywgMTQsIDMsIDIsIDI2XSwgLy8gc2hhMVxuICAgICAgICB9LFxuICAgICAgICBpc3N1ZXJOYW1lSGFzaDogaXNzdWVyTmFtZUhhc2gsXG4gICAgICAgIGlzc3VlcktleUhhc2g6IGlzc3VlcktleUhhc2gsXG4gICAgICAgIHNlcmlhbE51bWJlcjogc2VyaWFsTnVtYmVyLFxuICAgIH07XG4gICAgY29uc3QgY2VydElERGVyID0gcmZjMjU2MC5DZXJ0SUQuZW5jb2RlKGNlcnRJRCwgJ2RlcicpO1xuICAgIHJldHVybiBjZXJ0SUREZXIudG9TdHJpbmcoJ0JBU0U2NCcpO1xufTtcbmV4cG9ydHMuZGVjb2RlS2V5ID0gZGVjb2RlS2V5O1xuLyoqXG4gKiBDYWxjdWxhdGVzIFRvbGVyYWJsZSB2YWxpZGl0eVxuICogQHBhcmFtIHRoaXNVcGRhdGUgbGFzdCB1cGRhdGVcbiAqIEBwYXJhbSBuZXh0VXBkYXRlIG5leHQgdXBkYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5jb25zdCBjYWxjdWxhdGVUb2xlcmFibGVWYWRpbGl0eSA9IGZ1bmN0aW9uICh0aGlzVXBkYXRlLCBuZXh0VXBkYXRlKSB7XG4gICAgY29uc3QgY3VycmVudFJhbmdlID0gKG5leHRVcGRhdGUgLSB0aGlzVXBkYXRlKSAqIFRPTEVSQUJMRV9WQUxJRElUWV9SQU5HRV9SQVRJTztcbiAgICByZXR1cm4gY3VycmVudFJhbmdlID4gTUlOX0NBQ0hFX1dBUk1VUF9USU1FX0lOX01JTExJU0VDT05EU1xuICAgICAgICA/IGN1cnJlbnRSYW5nZVxuICAgICAgICA6IE1JTl9DQUNIRV9XQVJNVVBfVElNRV9JTl9NSUxMSVNFQ09ORFM7XG59O1xuLyoqXG4gKiBDaGVja3MgdGhlIHZhbGlkaXR5XG4gKiBAcGFyYW0gY3VycmVudFRpbWUgY3VycmVudCB0aW1lXG4gKiBAcGFyYW0gdGhpc1VwZGF0ZSBsYXN0IHVwZGF0ZVxuICogQHBhcmFtIG5leHRVcGRhdGUgbmV4dCB1cGRhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVmFsaWRpdHlSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgdGhpc1VwZGF0ZSwgbmV4dFVwZGF0ZSkge1xuICAgIGNvbnN0IHRvbGVyYWJsZVZhbGlkaXR5ID0gY2FsY3VsYXRlVG9sZXJhYmxlVmFkaWxpdHkodGhpc1VwZGF0ZSwgbmV4dFVwZGF0ZSk7XG4gICAgcmV0dXJuICh0aGlzVXBkYXRlIC0gTUFYX0NMT0NLX1NLRVdfSU5fTUlMTElTRUNPTkRTIDw9IGN1cnJlbnRUaW1lICYmXG4gICAgICAgIGN1cnJlbnRUaW1lIDw9IG5leHRVcGRhdGUgKyB0b2xlcmFibGVWYWxpZGl0eSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkaXR5UmFuZ2UgPSBpc1ZhbGlkaXR5UmFuZ2U7XG4vKipcbiAqIENvbnZlcnRzIGEgZXBvY2ggdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYSBVVEMgZGF0ZXRpbWUgc3RyaW5nXG4gKiBAcGFyYW0gZXBvY2hJbk1pbGxpU2Vjb25kc1xuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmNvbnN0IHRvVVRDU3RyaW5nID0gZnVuY3Rpb24gKGVwb2NoSW5NaWxsaVNlY29uZHMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZXBvY2hJbk1pbGxpU2Vjb25kcyk7XG59O1xuLyoqXG4gKiBSZXR1cm4gaXNzdWVyIGNlcnRpZmljYXRlIG9yIHNpZ25pbmcgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSBpc3N1ZXIgaXNzdWVyIGNlcnRpZmljYXRlXG4gKiBAcGFyYW0gY2VydHNcbiAqIEBwYXJhbSByYXdzXG4gKi9cbmNvbnN0IGZpbmRSZXNwb25kZXIgPSBmdW5jdGlvbiAoaXNzdWVyLCBjZXJ0cywgcmF3cykge1xuICAgIGxldCBpc3N1ZXJLZXkgPSBpc3N1ZXIudGJzQ2VydGlmaWNhdGUuc3ViamVjdFB1YmxpY0tleUluZm87XG4gICAgaXNzdWVyS2V5ID0gb2NzcC51dGlscy50b1BFTShyZmM1MjgwLlN1YmplY3RQdWJsaWNLZXlJbmZvLmVuY29kZShpc3N1ZXJLZXksICdkZXInKSwgJ1BVQkxJQyBLRVknKTtcbiAgICBpZiAoY2VydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGNlcnQgPSBjZXJ0c1swXTtcbiAgICAgICAgY29uc3QgY2VydFZhbGlkaXR5ID0gY2VydC50YnNDZXJ0aWZpY2F0ZS52YWxpZGl0eTtcbiAgICAgICAgaWYgKGNlcnRWYWxpZGl0eS5ub3RBZnRlci52YWx1ZSA8IGN1cnJlbnRUaW1lIHx8IGNlcnRWYWxpZGl0eS5ub3RCZWZvcmUudmFsdWUgPiBjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnI6IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9JTlZBTElEX0NFUlRJRklDQVRFX1ZBTElESVRZLCAnVmFsaWQgZnJvbTonLCB0b1VUQ1N0cmluZyhjZXJ0VmFsaWRpdHkubm90QmVmb3JlLnZhbHVlKSwgJywgVmFsaWQgdG86JywgdG9VVENTdHJpbmcoY2VydFZhbGlkaXR5Lm5vdEFmdGVyLnZhbHVlKSksXG4gICAgICAgICAgICAgICAgcmVzcG9uZGVyS2V5OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduQWxnID0gb2NzcC51dGlscy5zaWduW2NlcnQuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJyldO1xuICAgICAgICBpZiAoIXNpZ25BbGcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyOiBFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfTk9fU0lHTkFUVVJFX0FMR09SSVRITSksXG4gICAgICAgICAgICAgICAgcmVzcG9uZGVyS2V5OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJpZnkgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KHNpZ25BbGcpO1xuICAgICAgICB2ZXJpZnkudXBkYXRlKHJhd3NbMF0pO1xuICAgICAgICBpZiAoIXZlcmlmeS52ZXJpZnkoaXNzdWVyS2V5LCBjZXJ0LnNpZ25hdHVyZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnI6IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9JTlZBTElEX1NJR05BVFVSRSksXG4gICAgICAgICAgICAgICAgcmVzcG9uZGVyS2V5OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VydEtleSA9IGNlcnQudGJzQ2VydGlmaWNhdGUuc3ViamVjdFB1YmxpY0tleUluZm87XG4gICAgICAgIGNlcnRLZXkgPSBvY3NwLnV0aWxzLnRvUEVNKHJmYzUyODAuU3ViamVjdFB1YmxpY0tleUluZm8uZW5jb2RlKGNlcnRLZXksICdkZXInKSwgJ1BVQkxJQyBLRVknKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBudWxsLCByZXNwb25kZXJLZXk6IGNlcnRLZXkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyOiBudWxsLCByZXNwb25kZXJLZXk6IGlzc3VlcktleSB9O1xufTtcbi8qKlxuICogVmVyaWZ5IE9DU1AgcmVzcG9uc2UuIElmIGlzc3VlciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc2lnbmF0dXJlIHdpbGwgbm90IGJlXG4gKiB2ZXJpZmllZC5cbiAqIEBwYXJhbSBpc3N1ZXIgaXNzdWVyIGNlcnRpZmljYXRlXG4gKiBAcGFyYW0gcmF3UmVzIE9DU1AgUmVzcG9uc2VcbiAqIEByZXR1cm5zIHt7c3VjY2VzcywgZXJyb3IsIHJldm9rZWR9fHtyZXMsIHN1Y2Nlc3MsIGVycm9yfX1cbiAqL1xuY29uc3QgdmVyaWZ5T0NTUFJlc3BvbnNlID0gZnVuY3Rpb24gKGlzc3VlciwgcmF3UmVzKSB7XG4gICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycjogZXJyLFxuICAgICAgICAgICAgcmVzOiByYXdSZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzID0gb2NzcC51dGlscy5wYXJzZVJlc3BvbnNlKHJhd1Jlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkb25lKGUpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHJlcy52YWx1ZTtcbiAgICBpZiAoaXNzdWVyKSB7XG4gICAgICAgIC8vIHZlcmlmeSBzaWduYXR1cmUgb25seSBpZiBpc3N1ZXIgaXMgZ2l2ZW5cbiAgICAgICAgY29uc3QgY2VydHMgPSByZXMuY2VydHM7XG4gICAgICAgIGNvbnN0IHJhd1RCUyA9IHJhd1Jlcy5zbGljZShyZXMuc3RhcnQsIHJlcy5lbmQpO1xuICAgICAgICBjb25zdCByYXdzID0gcmVzLmNlcnRzVGJzLm1hcChmdW5jdGlvbiAodGJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3UmVzLnNsaWNlKHRicy5zdGFydCwgdGJzLmVuZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduQWxnID0gb2NzcC51dGlscy5zaWduW3ZhbHVlLnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXTtcbiAgICAgICAgaWYgKCFzaWduQWxnKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfTk9fU0lHTkFUVVJFX0FMR09SSVRITSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbmRlclN0YXR1cyA9IGZpbmRSZXNwb25kZXIoaXNzdWVyLCBjZXJ0cywgcmF3cyk7XG4gICAgICAgIGlmIChyZXNwb25kZXJTdGF0dXMuZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShyZXNwb25kZXJTdGF0dXMuZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25kZXJLZXkgPSByZXNwb25kZXJTdGF0dXMucmVzcG9uZGVyS2V5O1xuICAgICAgICBjb25zdCB2ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShzaWduQWxnKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsdWUuc2lnbmF0dXJlLmRhdGE7XG4gICAgICAgIHYudXBkYXRlKHJhd1RCUyk7XG4gICAgICAgIGlmICghdi52ZXJpZnkocmVzcG9uZGVyS2V5LCBzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfSU5WQUxJRF9TSUdOQVRVUkUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YnMgPSB2YWx1ZS50YnNSZXNwb25zZURhdGE7XG4gICAgaWYgKHRicy5yZXNwb25zZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfTk9fUkVTUE9OU0UpKTtcbiAgICB9XG4gICAgY29uc3Qgc2QgPSB0YnMucmVzcG9uc2VzWzBdO1xuICAgIGlmIChzZC5jZXJ0U3RhdHVzLnR5cGUgPT09ICdyZXZva2VkJykge1xuICAgICAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfUkVWT0tFRCkpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaXNJbmplY3RWYWxpZGl0eSA9IHByb2Nlc3MuZW52LlNGX09DU1BfVEVTVF9JTkpFQ1RfVkFMSURJVFlfRVJST1IgfHwgJyc7XG4gICAgaWYgKGlzSW5qZWN0VmFsaWRpdHkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICFpc1ZhbGlkaXR5UmFuZ2UoY3VycmVudFRpbWUsIHNkLnRoaXNVcGRhdGUsIHNkLm5leHRVcGRhdGUpKSB7XG4gICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9JTlZBTElEX1ZBTElESVRZLCAnVmFsaWQgZnJvbTonLCB0b1VUQ1N0cmluZyhzZC50aGlzVXBkYXRlKSwgJywgVmFsaWQgdG86JywgdG9VVENTdHJpbmcoc2QubmV4dFVwZGF0ZSkpKTtcbiAgICB9XG4gICAgY29uc3QgaXNJbmplY3RVbmtub3duID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9URVNUX0lOSkVDVF9VTktOT1dOX1NUQVRVUyB8fCAnJztcbiAgICBpZiAoaXNJbmplY3RVbmtub3duLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJyB8fCBzZC5jZXJ0U3RhdHVzLnR5cGUgPT09ICd1bmtub3duJykge1xuICAgICAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfVU5LTk9XTikpO1xuICAgIH1cbiAgICBpZiAoc2QuY2VydFN0YXR1cy50eXBlID09PSAnZ29vZCcpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9VTktOT1dOX1NUQVRFKSk7XG59O1xuZXhwb3J0cy52ZXJpZnlPQ1NQUmVzcG9uc2UgPSB2ZXJpZnlPQ1NQUmVzcG9uc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZXJ0X3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/check.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/check.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * This software is licensed under the MIT License.\n *\n * Copyright Fedor Indutny, 2015.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst ocsp = __webpack_require__(/*! @techteamer/ocsp */ \"(rsc)/./node_modules/@techteamer/ocsp/lib/ocsp.js\");\nconst rfc2560 = __webpack_require__(/*! asn1.js-rfc2560 */ \"(rsc)/./node_modules/asn1.js-rfc2560/index.js\");\nconst SnowflakeUtil = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * OCSP specific HTTP retryable errors\n * @param statusCode\n * @returns {boolean}\n */\nconst isRetryableHttpError = function (statusCode) {\n    return ((statusCode >= 500 && statusCode < 600) ||\n        statusCode === 404 ||\n        statusCode === 403 ||\n        statusCode === 408);\n};\nfunction getResponse(uri, req, cb) {\n    uri = url.parse(uri);\n    const timeout = process.env.SF_OCSP_TEST_OCSP_RESPONDER_TIMEOUT || 10000;\n    const options = Object.assign({\n        timeout: Number(timeout),\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/ocsp-request',\n            'Content-Length': req.length,\n        },\n    }, uri);\n    function done(err, response) {\n        if (cb) {\n            cb(err, response);\n        }\n        cb = null;\n    }\n    function onResponse(response) {\n        if (response.statusCode < 200 || response.statusCode >= 400) {\n            return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE, response.statusCode), response);\n        }\n        const chunks = [];\n        response.on('readable', function () {\n            const chunk = response.read();\n            if (!chunk) {\n                return;\n            }\n            chunks.push(chunk);\n        });\n        response.on('end', function () {\n            Logger.getInstance().debug('Finish OCSP responder: %s', uri.host);\n            const ocsp = Buffer.concat(chunks);\n            done(null, ocsp);\n        });\n    }\n    const httpRequest = http.request(options, onResponse);\n    httpRequest.on('error', function (e) {\n        if (cb) {\n            cb(e);\n        }\n        cb = null;\n    });\n    httpRequest.on('timeout', function () {\n        httpRequest.abort();\n        Logger.getInstance().debug('Timeout OCSP responder: %s', uri.host);\n        if (cb) {\n            cb(Errors.createOCSPError(ErrorCodes.ERR_OCSP_RESPONDER_TIMEOUT));\n        }\n        cb = null;\n    });\n    httpRequest.end(req);\n}\nmodule.exports = function check(options, cb, mock) {\n    let sync = true;\n    const isFailClosed = GlobalConfig.getOcspMode() === GlobalConfig.ocspModes.FAIL_CLOSED;\n    const maxNumRetries = isFailClosed ? 2 : 1;\n    function done(err, data) {\n        if (sync) {\n            sync = false;\n            process.nextTick(function () {\n                cb(err, data);\n            });\n            return;\n        }\n        cb(err, data);\n    }\n    let req;\n    try {\n        req = mock ? mock.req : ocsp.request.generate(options.cert, options.issuer);\n    }\n    catch (e) {\n        return done(e);\n    }\n    const ocspMethod = rfc2560['id-pkix-ocsp'].join('.');\n    let numRetries = 1;\n    let sleep = 1;\n    function ocspResponseVerify(err, raw) {\n        let retry = false;\n        if (err) {\n            if (Object.prototype.hasOwnProperty.call(err, 'code') &&\n                err.code === ErrorCodes.ERR_OCSP_RESPONDER_TIMEOUT) {\n                retry = true;\n            }\n            else if (Object.prototype.hasOwnProperty.call(err, 'message')) {\n                const errorMessage = err.message.split(' ');\n                if (errorMessage.length === 0) {\n                    return done(err);\n                }\n                try {\n                    const statusCode = parseInt(errorMessage[errorMessage.length - 1], 10);\n                    retry = isRetryableHttpError(statusCode);\n                }\n                catch (e) {\n                    // ignore\n                }\n            }\n            if (numRetries < maxNumRetries && retry) {\n                numRetries++;\n                sleep = SnowflakeUtil.nextSleepTime(1, 10, sleep);\n                setTimeout(ocspRequestSend, sleep * 1000);\n            }\n            else {\n                Logger.getInstance().debug('Failed to all retries to OCSP responder.');\n                return done(err);\n            }\n        }\n        else {\n            const status = CertUtil.verifyOCSPResponse(req.issuer, raw);\n            done(status.err, status);\n        }\n    }\n    function setOcspResponderUrl(uri) {\n        let parsedUrl = (__webpack_require__(/*! url */ \"url\").parse)(process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL);\n        let targetUrl;\n        if (parsedUrl.port) {\n            targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}:${parsedUrl.port}/retry`;\n        }\n        else {\n            targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}/retry`;\n        }\n        const b64data = req.data.toString('base64');\n        parsedUrl = (__webpack_require__(/*! url */ \"url\").parse)(uri);\n        process.env.SF_OCSP_RESPONDER_URL = targetUrl + '/' + parsedUrl.hostname + '/' + b64data;\n    }\n    function ocspRequestCallback(err, uri) {\n        if (err) {\n            //This error message is from @techteamer/ocsp (ocsp.utils.getAuthorityInfo)\n            if (err.message === 'AuthorityInfoAccess not found in extensions') {\n                if (!isFailClosed) {\n                    Logger.getInstance().debug('OCSP Responder URL is missing from the certificate.');\n                    return done(null);\n                }\n                else {\n                    Logger.getInstance().error('OCSP Responder URL is missing from the certificate, so cannot verify with OCSP. Aborting connection attempt due to OCSP being set to FAIL_CLOSE https://docs.snowflake.com/en/user-guide/ocsp#fail-close');\n                }\n            }\n            return done(err);\n        }\n        if (process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL &&\n            process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL.includes('ocsp_response_cache.json')) {\n            setOcspResponderUrl(uri);\n        }\n        const responderUrl = process.env.SF_OCSP_RESPONDER_URL;\n        if (responderUrl) {\n            uri = responderUrl;\n        }\n        Logger.getInstance().trace('Contact OCSP responder: %s, (%s/%s)', uri, numRetries, maxNumRetries);\n        if (!mock) {\n            getResponse(uri, req.data, ocspResponseVerify);\n        }\n    }\n    function ocspRequestSend() {\n        if (!mock) {\n            ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, ocspRequestCallback);\n        }\n        else {\n            ocspRequestCallback(null, mock.uri);\n        }\n    }\n    ocspRequestSend();\n    sync = false;\n};\n//# sourceMappingURL=check.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jaGVjay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQywyRUFBa0I7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFTO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLHNGQUFrQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBb0I7QUFDNUM7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsSUFBSSxtQkFBbUIsR0FBRyxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CLElBQUksbUJBQW1CO0FBQ3JFO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NoZWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgRmVkb3IgSW5kdXRueSwgMjAxNS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG4ndXNlIHN0cmljdCc7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBvY3NwID0gcmVxdWlyZSgnQHRlY2h0ZWFtZXIvb2NzcCcpO1xuY29uc3QgcmZjMjU2MCA9IHJlcXVpcmUoJ2FzbjEuanMtcmZjMjU2MCcpO1xuY29uc3QgU25vd2ZsYWtlVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IENlcnRVdGlsID0gcmVxdWlyZSgnLi9jZXJ0X3V0aWwnKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuLyoqXG4gKiBPQ1NQIHNwZWNpZmljIEhUVFAgcmV0cnlhYmxlIGVycm9yc1xuICogQHBhcmFtIHN0YXR1c0NvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1JldHJ5YWJsZUh0dHBFcnJvciA9IGZ1bmN0aW9uIChzdGF0dXNDb2RlKSB7XG4gICAgcmV0dXJuICgoc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8IDYwMCkgfHxcbiAgICAgICAgc3RhdHVzQ29kZSA9PT0gNDA0IHx8XG4gICAgICAgIHN0YXR1c0NvZGUgPT09IDQwMyB8fFxuICAgICAgICBzdGF0dXNDb2RlID09PSA0MDgpO1xufTtcbmZ1bmN0aW9uIGdldFJlc3BvbnNlKHVyaSwgcmVxLCBjYikge1xuICAgIHVyaSA9IHVybC5wYXJzZSh1cmkpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1RFU1RfT0NTUF9SRVNQT05ERVJfVElNRU9VVCB8fCAxMDAwMDtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHRpbWVvdXQ6IE51bWJlcih0aW1lb3V0KSxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2NzcC1yZXF1ZXN0JyxcbiAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IHJlcS5sZW5ndGgsXG4gICAgICAgIH0sXG4gICAgfSwgdXJpKTtcbiAgICBmdW5jdGlvbiBkb25lKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihlcnIsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYiA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9GQUlMRURfT0JUQUlOX09DU1BfUkVTUE9OU0UsIHJlc3BvbnNlLnN0YXR1c0NvZGUpLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIHJlc3BvbnNlLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gcmVzcG9uc2UucmVhZCgpO1xuICAgICAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmluaXNoIE9DU1AgcmVzcG9uZGVyOiAlcycsIHVyaS5ob3N0KTtcbiAgICAgICAgICAgIGNvbnN0IG9jc3AgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG4gICAgICAgICAgICBkb25lKG51bGwsIG9jc3ApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaHR0cFJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucywgb25SZXNwb25zZSk7XG4gICAgaHR0cFJlcXVlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihlKTtcbiAgICAgICAgfVxuICAgICAgICBjYiA9IG51bGw7XG4gICAgfSk7XG4gICAgaHR0cFJlcXVlc3Qub24oJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdUaW1lb3V0IE9DU1AgcmVzcG9uZGVyOiAlcycsIHVyaS5ob3N0KTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfUkVTUE9OREVSX1RJTUVPVVQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYiA9IG51bGw7XG4gICAgfSk7XG4gICAgaHR0cFJlcXVlc3QuZW5kKHJlcSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNoZWNrKG9wdGlvbnMsIGNiLCBtb2NrKSB7XG4gICAgbGV0IHN5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGlzRmFpbENsb3NlZCA9IEdsb2JhbENvbmZpZy5nZXRPY3NwTW9kZSgpID09PSBHbG9iYWxDb25maWcub2NzcE1vZGVzLkZBSUxfQ0xPU0VEO1xuICAgIGNvbnN0IG1heE51bVJldHJpZXMgPSBpc0ZhaWxDbG9zZWQgPyAyIDogMTtcbiAgICBmdW5jdGlvbiBkb25lKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IoZXJyLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNiKGVyciwgZGF0YSk7XG4gICAgfVxuICAgIGxldCByZXE7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVxID0gbW9jayA/IG1vY2sucmVxIDogb2NzcC5yZXF1ZXN0LmdlbmVyYXRlKG9wdGlvbnMuY2VydCwgb3B0aW9ucy5pc3N1ZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZG9uZShlKTtcbiAgICB9XG4gICAgY29uc3Qgb2NzcE1ldGhvZCA9IHJmYzI1NjBbJ2lkLXBraXgtb2NzcCddLmpvaW4oJy4nKTtcbiAgICBsZXQgbnVtUmV0cmllcyA9IDE7XG4gICAgbGV0IHNsZWVwID0gMTtcbiAgICBmdW5jdGlvbiBvY3NwUmVzcG9uc2VWZXJpZnkoZXJyLCByYXcpIHtcbiAgICAgICAgbGV0IHJldHJ5ID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAnY29kZScpICYmXG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPT09IEVycm9yQ29kZXMuRVJSX09DU1BfUkVTUE9OREVSX1RJTUVPVVQpIHtcbiAgICAgICAgICAgICAgICByZXRyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAnbWVzc2FnZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyLm1lc3NhZ2Uuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcGFyc2VJbnQoZXJyb3JNZXNzYWdlW2Vycm9yTWVzc2FnZS5sZW5ndGggLSAxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICByZXRyeSA9IGlzUmV0cnlhYmxlSHR0cEVycm9yKHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtUmV0cmllcyA8IG1heE51bVJldHJpZXMgJiYgcmV0cnkpIHtcbiAgICAgICAgICAgICAgICBudW1SZXRyaWVzKys7XG4gICAgICAgICAgICAgICAgc2xlZXAgPSBTbm93Zmxha2VVdGlsLm5leHRTbGVlcFRpbWUoMSwgMTAsIHNsZWVwKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG9jc3BSZXF1ZXN0U2VuZCwgc2xlZXAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gYWxsIHJldHJpZXMgdG8gT0NTUCByZXNwb25kZXIuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IENlcnRVdGlsLnZlcmlmeU9DU1BSZXNwb25zZShyZXEuaXNzdWVyLCByYXcpO1xuICAgICAgICAgICAgZG9uZShzdGF0dXMuZXJyLCBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldE9jc3BSZXNwb25kZXJVcmwodXJpKSB7XG4gICAgICAgIGxldCBwYXJzZWRVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZShwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9VUkwpO1xuICAgICAgICBsZXQgdGFyZ2V0VXJsO1xuICAgICAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgICAgICAgIHRhcmdldFVybCA9IGAke3BhcnNlZFVybC5wcm90b2NvbH0vLyR7cGFyc2VkVXJsLmhvc3RuYW1lfToke3BhcnNlZFVybC5wb3J0fS9yZXRyeWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRVcmwgPSBgJHtwYXJzZWRVcmwucHJvdG9jb2x9Ly8ke3BhcnNlZFVybC5ob3N0bmFtZX0vcmV0cnlgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGI2NGRhdGEgPSByZXEuZGF0YS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIHBhcnNlZFVybCA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHVyaSk7XG4gICAgICAgIHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OREVSX1VSTCA9IHRhcmdldFVybCArICcvJyArIHBhcnNlZFVybC5ob3N0bmFtZSArICcvJyArIGI2NGRhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9jc3BSZXF1ZXN0Q2FsbGJhY2soZXJyLCB1cmkpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy9UaGlzIGVycm9yIG1lc3NhZ2UgaXMgZnJvbSBAdGVjaHRlYW1lci9vY3NwIChvY3NwLnV0aWxzLmdldEF1dGhvcml0eUluZm8pXG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09ICdBdXRob3JpdHlJbmZvQWNjZXNzIG5vdCBmb3VuZCBpbiBleHRlbnNpb25zJykge1xuICAgICAgICAgICAgICAgIGlmICghaXNGYWlsQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdPQ1NQIFJlc3BvbmRlciBVUkwgaXMgbWlzc2luZyBmcm9tIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignT0NTUCBSZXNwb25kZXIgVVJMIGlzIG1pc3NpbmcgZnJvbSB0aGUgY2VydGlmaWNhdGUsIHNvIGNhbm5vdCB2ZXJpZnkgd2l0aCBPQ1NQLiBBYm9ydGluZyBjb25uZWN0aW9uIGF0dGVtcHQgZHVlIHRvIE9DU1AgYmVpbmcgc2V0IHRvIEZBSUxfQ0xPU0UgaHR0cHM6Ly9kb2NzLnNub3dmbGFrZS5jb20vZW4vdXNlci1ndWlkZS9vY3NwI2ZhaWwtY2xvc2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9VUkwgJiZcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX1VSTC5pbmNsdWRlcygnb2NzcF9yZXNwb25zZV9jYWNoZS5qc29uJykpIHtcbiAgICAgICAgICAgIHNldE9jc3BSZXNwb25kZXJVcmwodXJpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25kZXJVcmwgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTkRFUl9VUkw7XG4gICAgICAgIGlmIChyZXNwb25kZXJVcmwpIHtcbiAgICAgICAgICAgIHVyaSA9IHJlc3BvbmRlclVybDtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29udGFjdCBPQ1NQIHJlc3BvbmRlcjogJXMsICglcy8lcyknLCB1cmksIG51bVJldHJpZXMsIG1heE51bVJldHJpZXMpO1xuICAgICAgICBpZiAoIW1vY2spIHtcbiAgICAgICAgICAgIGdldFJlc3BvbnNlKHVyaSwgcmVxLmRhdGEsIG9jc3BSZXNwb25zZVZlcmlmeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb2NzcFJlcXVlc3RTZW5kKCkge1xuICAgICAgICBpZiAoIW1vY2spIHtcbiAgICAgICAgICAgIG9jc3AudXRpbHMuZ2V0QXV0aG9yaXR5SW5mbyhyZXEuY2VydCwgb2NzcE1ldGhvZCwgb2NzcFJlcXVlc3RDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvY3NwUmVxdWVzdENhbGxiYWNrKG51bGwsIG1vY2sudXJpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvY3NwUmVxdWVzdFNlbmQoKTtcbiAgICBzeW5jID0gZmFsc2U7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/check.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CRL_MEMORY_CACHE = void 0;\nexports.getCrlFromMemory = getCrlFromMemory;\nexports.setCrlInMemory = setCrlInMemory;\nexports.clearExpiredCrlFromMemoryCache = clearExpiredCrlFromMemoryCache;\nexports.clearExpiredCrlFromDiskCache = clearExpiredCrlFromDiskCache;\nexports.getCrlFromDisk = getCrlFromDisk;\nexports.writeCrlToDisk = writeCrlToDisk;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst promises_1 = __importDefault(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst disk_cache_1 = __webpack_require__(/*! ../disk_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js\");\nconst global_config_typed_1 = __importDefault(__webpack_require__(/*! ../global_config_typed */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nexports.CRL_MEMORY_CACHE = new Map();\nfunction getCrlFromMemory(url) {\n    const cachedEntry = exports.CRL_MEMORY_CACHE.get(url);\n    if (cachedEntry) {\n        if (cachedEntry.expireAt > Date.now()) {\n            return cachedEntry.crl;\n        }\n        else {\n            exports.CRL_MEMORY_CACHE.delete(url);\n            return null;\n        }\n    }\n    else {\n        return null;\n    }\n}\nfunction setCrlInMemory(url, crl) {\n    exports.CRL_MEMORY_CACHE.set(url, {\n        expireAt: Math.min(Date.now() + global_config_typed_1.default.getValue('crlCacheValidityTime'), crl.tbsCertList.nextUpdate.value),\n        crl,\n    });\n}\nfunction clearExpiredCrlFromMemoryCache() {\n    exports.CRL_MEMORY_CACHE.forEach((entry, key) => {\n        if (entry.expireAt < Date.now()) {\n            exports.CRL_MEMORY_CACHE.delete(key);\n        }\n    });\n}\nasync function clearExpiredCrlFromDiskCache() {\n    try {\n        const cacheDir = global_config_typed_1.default.getValue('crlCacheDir');\n        for (const fileName of await promises_1.default.readdir(cacheDir)) {\n            const filePath = path_1.default.join(cacheDir, fileName);\n            const stats = await promises_1.default.stat(filePath);\n            const thirtyDaysAgo = Date.now() - 1000 * 60 * 60 * 24 * 30;\n            // NOTE:\n            // Keeping expired CRLs on disk for 30 days for debugging purposes\n            if (stats.mtime.getTime() < thirtyDaysAgo) {\n                (0, logger_1.default)().debug(`Deleting CRL file ${fileName} older than 30 days.`);\n                await promises_1.default.rm(filePath);\n            }\n        }\n    }\n    catch (error) {\n        if ((0, disk_cache_1.isFileNotFoundError)(error)) {\n            (0, logger_1.default)().debug('CRL cache directory does not exist, skipping cleanup.');\n        }\n        else {\n            (0, logger_1.default)().warn(`Failed to clear expired CRL entries from disk cache: ${error}.`);\n        }\n    }\n}\nasync function getCrlFromDisk(url) {\n    const filePath = path_1.default.join(global_config_typed_1.default.getValue('crlCacheDir'), encodeURIComponent(url));\n    try {\n        const stats = await promises_1.default.stat(filePath);\n        if (Date.now() - stats.mtime.getTime() > global_config_typed_1.default.getValue('crlCacheValidityTime')) {\n            (0, logger_1.default)().debug(`CRL ${filePath} is older than crlCacheValidityTime, ignoring.`);\n            return null;\n        }\n        const rawCrl = await promises_1.default.readFile(filePath);\n        const decodedCrl = asn1_js_rfc5280_1.default.CertificateList.decode(rawCrl, 'der');\n        if (decodedCrl.tbsCertList.nextUpdate.value > Date.now()) {\n            return decodedCrl;\n        }\n        else {\n            (0, logger_1.default)().debug(`CRL ${filePath} is expired, ignoring.`);\n            return null;\n        }\n    }\n    catch (error) {\n        if ((0, disk_cache_1.isFileNotFoundError)(error)) {\n            (0, logger_1.default)().debug(`CRL ${url} not found on disk cache.`);\n        }\n        else {\n            (0, logger_1.default)().warn(`Failed to read CRL ${filePath} from disk cache: ${error}.`);\n        }\n    }\n    return null;\n}\nasync function writeCrlToDisk(url, rawCrl) {\n    const filePath = path_1.default.join(global_config_typed_1.default.getValue('crlCacheDir'), encodeURIComponent(url));\n    try {\n        return (0, disk_cache_1.writeCacheFile)(filePath, rawCrl);\n    }\n    catch (error) {\n        (0, logger_1.default)().warn(`Failed to write CRL ${filePath} to disk cache: ${error}.`);\n    }\n}\n//# sourceMappingURL=crl_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsK0JBQStCLG1CQUFPLENBQUMsa0JBQU07QUFDN0MsbUNBQW1DLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEQsMENBQTBDLG1CQUFPLENBQUMsc0VBQWlCO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFlO0FBQzVDLDhDQUE4QyxtQkFBTyxDQUFDLGtHQUF3QjtBQUM5RSxpQ0FBaUMsbUJBQU8sQ0FBQyx3RUFBVztBQUNwRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsTUFBTTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0EsK0RBQStELFVBQVUsbUJBQW1CLE1BQU07QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVSxpQkFBaUIsTUFBTTtBQUM3RjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NybF9jYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRSA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0Q3JsRnJvbU1lbW9yeSA9IGdldENybEZyb21NZW1vcnk7XG5leHBvcnRzLnNldENybEluTWVtb3J5ID0gc2V0Q3JsSW5NZW1vcnk7XG5leHBvcnRzLmNsZWFyRXhwaXJlZENybEZyb21NZW1vcnlDYWNoZSA9IGNsZWFyRXhwaXJlZENybEZyb21NZW1vcnlDYWNoZTtcbmV4cG9ydHMuY2xlYXJFeHBpcmVkQ3JsRnJvbURpc2tDYWNoZSA9IGNsZWFyRXhwaXJlZENybEZyb21EaXNrQ2FjaGU7XG5leHBvcnRzLmdldENybEZyb21EaXNrID0gZ2V0Q3JsRnJvbURpc2s7XG5leHBvcnRzLndyaXRlQ3JsVG9EaXNrID0gd3JpdGVDcmxUb0Rpc2s7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgcHJvbWlzZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnMvcHJvbWlzZXNcIikpO1xuY29uc3QgYXNuMV9qc19yZmM1MjgwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzbjEuanMtcmZjNTI4MFwiKSk7XG5jb25zdCBkaXNrX2NhY2hlXzEgPSByZXF1aXJlKFwiLi4vZGlza19jYWNoZVwiKTtcbmNvbnN0IGdsb2JhbF9jb25maWdfdHlwZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZ2xvYmFsX2NvbmZpZ190eXBlZFwiKSk7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9nZ2VyXCIpKTtcbmV4cG9ydHMuQ1JMX01FTU9SWV9DQUNIRSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENybEZyb21NZW1vcnkodXJsKSB7XG4gICAgY29uc3QgY2FjaGVkRW50cnkgPSBleHBvcnRzLkNSTF9NRU1PUllfQ0FDSEUuZ2V0KHVybCk7XG4gICAgaWYgKGNhY2hlZEVudHJ5KSB7XG4gICAgICAgIGlmIChjYWNoZWRFbnRyeS5leHBpcmVBdCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRFbnRyeS5jcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRzLkNSTF9NRU1PUllfQ0FDSEUuZGVsZXRlKHVybCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0Q3JsSW5NZW1vcnkodXJsLCBjcmwpIHtcbiAgICBleHBvcnRzLkNSTF9NRU1PUllfQ0FDSEUuc2V0KHVybCwge1xuICAgICAgICBleHBpcmVBdDogTWF0aC5taW4oRGF0ZS5ub3coKSArIGdsb2JhbF9jb25maWdfdHlwZWRfMS5kZWZhdWx0LmdldFZhbHVlKCdjcmxDYWNoZVZhbGlkaXR5VGltZScpLCBjcmwudGJzQ2VydExpc3QubmV4dFVwZGF0ZS52YWx1ZSksXG4gICAgICAgIGNybCxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyRXhwaXJlZENybEZyb21NZW1vcnlDYWNoZSgpIHtcbiAgICBleHBvcnRzLkNSTF9NRU1PUllfQ0FDSEUuZm9yRWFjaCgoZW50cnksIGtleSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkuZXhwaXJlQXQgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICBleHBvcnRzLkNSTF9NRU1PUllfQ0FDSEUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNsZWFyRXhwaXJlZENybEZyb21EaXNrQ2FjaGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGVEaXIgPSBnbG9iYWxfY29uZmlnX3R5cGVkXzEuZGVmYXVsdC5nZXRWYWx1ZSgnY3JsQ2FjaGVEaXInKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlTmFtZSBvZiBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQucmVhZGRpcihjYWNoZURpcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aF8xLmRlZmF1bHQuam9pbihjYWNoZURpciwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQuc3RhdChmaWxlUGF0aCk7XG4gICAgICAgICAgICBjb25zdCB0aGlydHlEYXlzQWdvID0gRGF0ZS5ub3coKSAtIDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMDtcbiAgICAgICAgICAgIC8vIE5PVEU6XG4gICAgICAgICAgICAvLyBLZWVwaW5nIGV4cGlyZWQgQ1JMcyBvbiBkaXNrIGZvciAzMCBkYXlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgICAgIGlmIChzdGF0cy5tdGltZS5nZXRUaW1lKCkgPCB0aGlydHlEYXlzQWdvKSB7XG4gICAgICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYERlbGV0aW5nIENSTCBmaWxlICR7ZmlsZU5hbWV9IG9sZGVyIHRoYW4gMzAgZGF5cy5gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQucm0oZmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoKDAsIGRpc2tfY2FjaGVfMS5pc0ZpbGVOb3RGb3VuZEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdDUkwgY2FjaGUgZGlyZWN0b3J5IGRvZXMgbm90IGV4aXN0LCBza2lwcGluZyBjbGVhbnVwLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkud2FybihgRmFpbGVkIHRvIGNsZWFyIGV4cGlyZWQgQ1JMIGVudHJpZXMgZnJvbSBkaXNrIGNhY2hlOiAke2Vycm9yfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldENybEZyb21EaXNrKHVybCkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aF8xLmRlZmF1bHQuam9pbihnbG9iYWxfY29uZmlnX3R5cGVkXzEuZGVmYXVsdC5nZXRWYWx1ZSgnY3JsQ2FjaGVEaXInKSwgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgcHJvbWlzZXNfMS5kZWZhdWx0LnN0YXQoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXRzLm10aW1lLmdldFRpbWUoKSA+IGdsb2JhbF9jb25maWdfdHlwZWRfMS5kZWZhdWx0LmdldFZhbHVlKCdjcmxDYWNoZVZhbGlkaXR5VGltZScpKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgQ1JMICR7ZmlsZVBhdGh9IGlzIG9sZGVyIHRoYW4gY3JsQ2FjaGVWYWxpZGl0eVRpbWUsIGlnbm9yaW5nLmApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3Q3JsID0gYXdhaXQgcHJvbWlzZXNfMS5kZWZhdWx0LnJlYWRGaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENybCA9IGFzbjFfanNfcmZjNTI4MF8xLmRlZmF1bHQuQ2VydGlmaWNhdGVMaXN0LmRlY29kZShyYXdDcmwsICdkZXInKTtcbiAgICAgICAgaWYgKGRlY29kZWRDcmwudGJzQ2VydExpc3QubmV4dFVwZGF0ZS52YWx1ZSA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVkQ3JsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkuZGVidWcoYENSTCAke2ZpbGVQYXRofSBpcyBleHBpcmVkLCBpZ25vcmluZy5gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoKDAsIGRpc2tfY2FjaGVfMS5pc0ZpbGVOb3RGb3VuZEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBDUkwgJHt1cmx9IG5vdCBmb3VuZCBvbiBkaXNrIGNhY2hlLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGxvZ2dlcl8xLmRlZmF1bHQpKCkud2FybihgRmFpbGVkIHRvIHJlYWQgQ1JMICR7ZmlsZVBhdGh9IGZyb20gZGlzayBjYWNoZTogJHtlcnJvcn0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUNybFRvRGlzayh1cmwsIHJhd0NybCkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aF8xLmRlZmF1bHQuam9pbihnbG9iYWxfY29uZmlnX3R5cGVkXzEuZGVmYXVsdC5nZXRWYWx1ZSgnY3JsQ2FjaGVEaXInKSwgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgZGlza19jYWNoZV8xLndyaXRlQ2FjaGVGaWxlKShmaWxlUGF0aCwgcmF3Q3JsKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLndhcm4oYEZhaWxlZCB0byB3cml0ZSBDUkwgJHtmaWxlUGF0aH0gdG8gZGlzayBjYWNoZTogJHtlcnJvcn0uYCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JsX2NhY2hlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PENDING_FETCH_REQUESTS = void 0;\nexports.getCrl = getCrl;\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst global_config_typed_1 = __importDefault(__webpack_require__(/*! ../global_config_typed */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\"));\nconst crl_cache_1 = __webpack_require__(/*! ./crl_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_cache.js\");\nexports.PENDING_FETCH_REQUESTS = new Map();\nlet crlCacheCleanerCreated = false;\nasync function getCrl(url, options) {\n    const logDebug = (msg) => (0, logger_1.default)().debug(`getCrl[${url}]: ${msg}`);\n    if (!crlCacheCleanerCreated) {\n        crlCacheCleanerCreated = true;\n        const oneHour = 1000 * 60 * 60;\n        logDebug('Starting periodic memory cache cleaner');\n        setInterval(crl_cache_1.clearExpiredCrlFromMemoryCache, oneHour).unref();\n        logDebug('Starting periodic disk cache cleaner');\n        (0, crl_cache_1.clearExpiredCrlFromDiskCache)();\n        setInterval(crl_cache_1.clearExpiredCrlFromDiskCache, oneHour).unref();\n    }\n    const pendingFetchRequest = exports.PENDING_FETCH_REQUESTS.get(url);\n    if (pendingFetchRequest) {\n        logDebug(`Returning pending fetch request`);\n        return pendingFetchRequest;\n    }\n    if (options.inMemoryCache) {\n        logDebug(`Checking in-memory cache`);\n        const cachedCrl = (0, crl_cache_1.getCrlFromMemory)(url);\n        if (cachedCrl) {\n            logDebug(`Returning from in-memory cache`);\n            return cachedCrl;\n        }\n    }\n    if (options.onDiskCache) {\n        logDebug(`Checking on-disk cache`);\n        const cachedCrl = await (0, crl_cache_1.getCrlFromDisk)(url);\n        if (cachedCrl) {\n            if (options.inMemoryCache) {\n                (0, crl_cache_1.setCrlInMemory)(url, cachedCrl);\n            }\n            logDebug(`Returning from disk cache`);\n            return cachedCrl;\n        }\n    }\n    const fetchPromise = new Promise(async (resolve, reject) => {\n        try {\n            logDebug(`Downloading CRL`);\n            const { data } = await axios_1.default.get(url, {\n                timeout: global_config_typed_1.default.getValue('crlDownloadTimeout'),\n                responseType: 'arraybuffer',\n            });\n            logDebug(`Parsing CRL`);\n            const parsedCrl = asn1_js_rfc5280_1.default.CertificateList.decode(data, 'der');\n            if (options.inMemoryCache) {\n                logDebug('Saving to memory cache');\n                (0, crl_cache_1.setCrlInMemory)(url, parsedCrl);\n            }\n            if (options.onDiskCache) {\n                logDebug('Saving to disk cache');\n                await (0, crl_cache_1.writeCrlToDisk)(url, data);\n            }\n            exports.PENDING_FETCH_REQUESTS.delete(url);\n            return resolve(parsedCrl);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n    exports.PENDING_FETCH_REQUESTS.set(url, fetchPromise);\n    return fetchPromise;\n}\n//# sourceMappingURL=crl_fetcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfZmV0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjO0FBQ2QsMENBQTBDLG1CQUFPLENBQUMsc0VBQWlCO0FBQ25FLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DLGlDQUFpQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3BELDhDQUE4QyxtQkFBTyxDQUFDLGtHQUF3QjtBQUM5RSxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYTtBQUN6Qyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHNFQUFzRSxJQUFJLEtBQUssSUFBSTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfZmV0Y2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEVORElOR19GRVRDSF9SRVFVRVNUUyA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0Q3JsID0gZ2V0Q3JsO1xuY29uc3QgYXNuMV9qc19yZmM1MjgwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzbjEuanMtcmZjNTI4MFwiKSk7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGdsb2JhbF9jb25maWdfdHlwZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZ2xvYmFsX2NvbmZpZ190eXBlZFwiKSk7XG5jb25zdCBjcmxfY2FjaGVfMSA9IHJlcXVpcmUoXCIuL2NybF9jYWNoZVwiKTtcbmV4cG9ydHMuUEVORElOR19GRVRDSF9SRVFVRVNUUyA9IG5ldyBNYXAoKTtcbmxldCBjcmxDYWNoZUNsZWFuZXJDcmVhdGVkID0gZmFsc2U7XG5hc3luYyBmdW5jdGlvbiBnZXRDcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9nRGVidWcgPSAobXNnKSA9PiAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgZ2V0Q3JsWyR7dXJsfV06ICR7bXNnfWApO1xuICAgIGlmICghY3JsQ2FjaGVDbGVhbmVyQ3JlYXRlZCkge1xuICAgICAgICBjcmxDYWNoZUNsZWFuZXJDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgb25lSG91ciA9IDEwMDAgKiA2MCAqIDYwO1xuICAgICAgICBsb2dEZWJ1ZygnU3RhcnRpbmcgcGVyaW9kaWMgbWVtb3J5IGNhY2hlIGNsZWFuZXInKTtcbiAgICAgICAgc2V0SW50ZXJ2YWwoY3JsX2NhY2hlXzEuY2xlYXJFeHBpcmVkQ3JsRnJvbU1lbW9yeUNhY2hlLCBvbmVIb3VyKS51bnJlZigpO1xuICAgICAgICBsb2dEZWJ1ZygnU3RhcnRpbmcgcGVyaW9kaWMgZGlzayBjYWNoZSBjbGVhbmVyJyk7XG4gICAgICAgICgwLCBjcmxfY2FjaGVfMS5jbGVhckV4cGlyZWRDcmxGcm9tRGlza0NhY2hlKSgpO1xuICAgICAgICBzZXRJbnRlcnZhbChjcmxfY2FjaGVfMS5jbGVhckV4cGlyZWRDcmxGcm9tRGlza0NhY2hlLCBvbmVIb3VyKS51bnJlZigpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nRmV0Y2hSZXF1ZXN0ID0gZXhwb3J0cy5QRU5ESU5HX0ZFVENIX1JFUVVFU1RTLmdldCh1cmwpO1xuICAgIGlmIChwZW5kaW5nRmV0Y2hSZXF1ZXN0KSB7XG4gICAgICAgIGxvZ0RlYnVnKGBSZXR1cm5pbmcgcGVuZGluZyBmZXRjaCByZXF1ZXN0YCk7XG4gICAgICAgIHJldHVybiBwZW5kaW5nRmV0Y2hSZXF1ZXN0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbk1lbW9yeUNhY2hlKSB7XG4gICAgICAgIGxvZ0RlYnVnKGBDaGVja2luZyBpbi1tZW1vcnkgY2FjaGVgKTtcbiAgICAgICAgY29uc3QgY2FjaGVkQ3JsID0gKDAsIGNybF9jYWNoZV8xLmdldENybEZyb21NZW1vcnkpKHVybCk7XG4gICAgICAgIGlmIChjYWNoZWRDcmwpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKGBSZXR1cm5pbmcgZnJvbSBpbi1tZW1vcnkgY2FjaGVgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDcmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub25EaXNrQ2FjaGUpIHtcbiAgICAgICAgbG9nRGVidWcoYENoZWNraW5nIG9uLWRpc2sgY2FjaGVgKTtcbiAgICAgICAgY29uc3QgY2FjaGVkQ3JsID0gYXdhaXQgKDAsIGNybF9jYWNoZV8xLmdldENybEZyb21EaXNrKSh1cmwpO1xuICAgICAgICBpZiAoY2FjaGVkQ3JsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbk1lbW9yeUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgKDAsIGNybF9jYWNoZV8xLnNldENybEluTWVtb3J5KSh1cmwsIGNhY2hlZENybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgUmV0dXJuaW5nIGZyb20gZGlzayBjYWNoZWApO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmZXRjaFByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgRG93bmxvYWRpbmcgQ1JMYCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zXzEuZGVmYXVsdC5nZXQodXJsLCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogZ2xvYmFsX2NvbmZpZ190eXBlZF8xLmRlZmF1bHQuZ2V0VmFsdWUoJ2NybERvd25sb2FkVGltZW91dCcpLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nRGVidWcoYFBhcnNpbmcgQ1JMYCk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRDcmwgPSBhc24xX2pzX3JmYzUyODBfMS5kZWZhdWx0LkNlcnRpZmljYXRlTGlzdC5kZWNvZGUoZGF0YSwgJ2RlcicpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5NZW1vcnlDYWNoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdTYXZpbmcgdG8gbWVtb3J5IGNhY2hlJyk7XG4gICAgICAgICAgICAgICAgKDAsIGNybF9jYWNoZV8xLnNldENybEluTWVtb3J5KSh1cmwsIHBhcnNlZENybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkRpc2tDYWNoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdTYXZpbmcgdG8gZGlzayBjYWNoZScpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBjcmxfY2FjaGVfMS53cml0ZUNybFRvRGlzaykodXJsLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMuUEVORElOR19GRVRDSF9SRVFVRVNUUy5kZWxldGUodXJsKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHBhcnNlZENybCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZXhwb3J0cy5QRU5ESU5HX0ZFVENIX1JFUVVFU1RTLnNldCh1cmwsIGZldGNoUHJvbWlzZSk7XG4gICAgcmV0dXJuIGZldGNoUHJvbWlzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNybF9mZXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCertificateCrlUrls = exports.CRL_SIGNATURE_OID_TO_CRYPTO_DIGEST_ALGORITHM = void 0;\nexports.getCertificateDebugName = getCertificateDebugName;\nexports.isShortLivedCertificate = isShortLivedCertificate;\nexports.isCrlSignatureValid = isCrlSignatureValid;\nexports.isCertificateRevoked = isCertificateRevoked;\nexports.isIssuingDistributionPointExtensionValid = isIssuingDistributionPointExtensionValid;\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\n// TODO:\n// Implement RSASSA-PSS signature verification\n// https://snowflakecomputing.atlassian.net/browse/SNOW-2333028\nexports.CRL_SIGNATURE_OID_TO_CRYPTO_DIGEST_ALGORITHM = {\n    '1.2.840.113549.1.1.11': 'sha256',\n    '1.2.840.113549.1.1.12': 'sha384',\n    '1.2.840.113549.1.1.13': 'sha512',\n    '1.2.840.10045.4.3.2': 'sha256',\n    '1.2.840.10045.4.3.3': 'sha384',\n    '1.2.840.10045.4.3.4': 'sha512',\n};\nfunction getCertificateDebugName(certificate) {\n    return [\n        `O:${certificate.subject.O}`,\n        `CN:${certificate.subject.CN}`,\n        `SN:${certificate.serialNumber}`,\n    ].join(',');\n}\nconst getCertificateCrlUrls = (certificateName, decodedCertificate) => {\n    const logDebug = (msg, ...msgArgs) => (0, logger_1.default)().debug(`getCertificateCrlUrls[${certificateName}]: ${msg}`, ...msgArgs);\n    const crlExtension = decodedCertificate.tbsCertificate.extensions?.find((ext) => ext.extnID === 'cRLDistributionPoints');\n    if (!crlExtension) {\n        logDebug('certificate doesnt have cRLDistributionPoints extension');\n        return null;\n    }\n    const result = [];\n    for (const entry of crlExtension.extnValue) {\n        if (!entry.distributionPoint) {\n            logDebug('skipping entry without distributionPoint %j', entry);\n            continue;\n        }\n        for (const fullNameEntry of entry.distributionPoint.value) {\n            if (fullNameEntry.type !== 'uniformResourceIdentifier') {\n                logDebug('skipping non-uniformResourceIdentifier entry %j', fullNameEntry);\n                continue;\n            }\n            if (fullNameEntry.value.startsWith('http')) {\n                // Even though the spec allows multiple http urls, we only pick first one and don't handle redundancy\n                result.push(fullNameEntry.value);\n                break;\n            }\n            else {\n                logDebug('skipping non-http value %j', fullNameEntry);\n            }\n        }\n    }\n    logDebug(`found URLs: ${result.join(',')}`);\n    return result.length > 0 ? result : null;\n};\nexports.getCertificateCrlUrls = getCertificateCrlUrls;\n/**\n * See Short-lived Subscriber Certificate section\\\n * https://cabforum.org/working-groups/server/baseline-requirements/requirements/\n */\nfunction isShortLivedCertificate(decodedCertificate) {\n    const notBefore = new Date(decodedCertificate.tbsCertificate.validity.notBefore.value);\n    const notAfter = new Date(decodedCertificate.tbsCertificate.validity.notAfter.value);\n    let maximumValidityPeriod = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n    if (notBefore < new Date('2026-03-15T00:00:00.000Z')) {\n        maximumValidityPeriod = 10 * 24 * 60 * 60 * 1000; // 10 days in milliseconds\n    }\n    maximumValidityPeriod += 60 * 1000; // Fix inclusion start and end time (1 minute)\n    const certValidityPeriod = notAfter.getTime() - notBefore.getTime();\n    return maximumValidityPeriod > certValidityPeriod;\n}\nfunction isCrlSignatureValid(crl, issuerPublicKey) {\n    const signatureAlgOid = crl.signatureAlgorithm.algorithm.join('.');\n    const digestAlg = exports.CRL_SIGNATURE_OID_TO_CRYPTO_DIGEST_ALGORITHM[signatureAlgOid];\n    if (!digestAlg) {\n        throw new Error(`Unsupported signature algorithm: ${signatureAlgOid}`);\n    }\n    const verify = crypto_1.default.createVerify(digestAlg);\n    const tbsEncoded = asn1_js_rfc5280_1.default.TBSCertList.encode(crl.tbsCertList, 'der');\n    verify.update(tbsEncoded);\n    return verify.verify(issuerPublicKey, crl.signature.data);\n}\nfunction isCertificateRevoked(decodedCertificate, crl) {\n    for (const revokedCert of crl.tbsCertList.revokedCertificates) {\n        if (revokedCert.userCertificate.eq(decodedCertificate.tbsCertificate.serialNumber)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isIssuingDistributionPointExtensionValid(crl, expectedCrlUrl) {\n    const issuingDistributionPointExtension = crl.tbsCertList.crlExtensions?.find((ext) => ext.extnID === 'issuingDistributionPoint');\n    if (!issuingDistributionPointExtension) {\n        (0, logger_1.default)().debug(`CRL ${expectedCrlUrl} doesnt have issuingDistributionPoint extension, ignoring`);\n        return true;\n    }\n    for (const fullNameEntry of issuingDistributionPointExtension.extnValue.distributionPoint.value) {\n        if (fullNameEntry.type === 'uniformResourceIdentifier' &&\n            fullNameEntry.value === expectedCrlUrl) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=crl_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvREFBb0Q7QUFDcEYsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLGdEQUFnRDtBQUNoRCxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCwwQ0FBMEMsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDbkUsaUNBQWlDLG1CQUFPLENBQUMsd0VBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxnQkFBZ0IsS0FBSyxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NybF91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q2VydGlmaWNhdGVDcmxVcmxzID0gZXhwb3J0cy5DUkxfU0lHTkFUVVJFX09JRF9UT19DUllQVE9fRElHRVNUX0FMR09SSVRITSA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0Q2VydGlmaWNhdGVEZWJ1Z05hbWUgPSBnZXRDZXJ0aWZpY2F0ZURlYnVnTmFtZTtcbmV4cG9ydHMuaXNTaG9ydExpdmVkQ2VydGlmaWNhdGUgPSBpc1Nob3J0TGl2ZWRDZXJ0aWZpY2F0ZTtcbmV4cG9ydHMuaXNDcmxTaWduYXR1cmVWYWxpZCA9IGlzQ3JsU2lnbmF0dXJlVmFsaWQ7XG5leHBvcnRzLmlzQ2VydGlmaWNhdGVSZXZva2VkID0gaXNDZXJ0aWZpY2F0ZVJldm9rZWQ7XG5leHBvcnRzLmlzSXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50RXh0ZW5zaW9uVmFsaWQgPSBpc0lzc3VpbmdEaXN0cmlidXRpb25Qb2ludEV4dGVuc2lvblZhbGlkO1xuY29uc3QgY3J5cHRvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyeXB0b1wiKSk7XG5jb25zdCBhc24xX2pzX3JmYzUyODBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNuMS5qcy1yZmM1MjgwXCIpKTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9sb2dnZXJcIikpO1xuLy8gVE9ETzpcbi8vIEltcGxlbWVudCBSU0FTU0EtUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25cbi8vIGh0dHBzOi8vc25vd2ZsYWtlY29tcHV0aW5nLmF0bGFzc2lhbi5uZXQvYnJvd3NlL1NOT1ctMjMzMzAyOFxuZXhwb3J0cy5DUkxfU0lHTkFUVVJFX09JRF9UT19DUllQVE9fRElHRVNUX0FMR09SSVRITSA9IHtcbiAgICAnMS4yLjg0MC4xMTM1NDkuMS4xLjExJzogJ3NoYTI1NicsXG4gICAgJzEuMi44NDAuMTEzNTQ5LjEuMS4xMic6ICdzaGEzODQnLFxuICAgICcxLjIuODQwLjExMzU0OS4xLjEuMTMnOiAnc2hhNTEyJyxcbiAgICAnMS4yLjg0MC4xMDA0NS40LjMuMic6ICdzaGEyNTYnLFxuICAgICcxLjIuODQwLjEwMDQ1LjQuMy4zJzogJ3NoYTM4NCcsXG4gICAgJzEuMi44NDAuMTAwNDUuNC4zLjQnOiAnc2hhNTEyJyxcbn07XG5mdW5jdGlvbiBnZXRDZXJ0aWZpY2F0ZURlYnVnTmFtZShjZXJ0aWZpY2F0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGBPOiR7Y2VydGlmaWNhdGUuc3ViamVjdC5PfWAsXG4gICAgICAgIGBDTjoke2NlcnRpZmljYXRlLnN1YmplY3QuQ059YCxcbiAgICAgICAgYFNOOiR7Y2VydGlmaWNhdGUuc2VyaWFsTnVtYmVyfWAsXG4gICAgXS5qb2luKCcsJyk7XG59XG5jb25zdCBnZXRDZXJ0aWZpY2F0ZUNybFVybHMgPSAoY2VydGlmaWNhdGVOYW1lLCBkZWNvZGVkQ2VydGlmaWNhdGUpID0+IHtcbiAgICBjb25zdCBsb2dEZWJ1ZyA9IChtc2csIC4uLm1zZ0FyZ3MpID0+ICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBnZXRDZXJ0aWZpY2F0ZUNybFVybHNbJHtjZXJ0aWZpY2F0ZU5hbWV9XTogJHttc2d9YCwgLi4ubXNnQXJncyk7XG4gICAgY29uc3QgY3JsRXh0ZW5zaW9uID0gZGVjb2RlZENlcnRpZmljYXRlLnRic0NlcnRpZmljYXRlLmV4dGVuc2lvbnM/LmZpbmQoKGV4dCkgPT4gZXh0LmV4dG5JRCA9PT0gJ2NSTERpc3RyaWJ1dGlvblBvaW50cycpO1xuICAgIGlmICghY3JsRXh0ZW5zaW9uKSB7XG4gICAgICAgIGxvZ0RlYnVnKCdjZXJ0aWZpY2F0ZSBkb2VzbnQgaGF2ZSBjUkxEaXN0cmlidXRpb25Qb2ludHMgZXh0ZW5zaW9uJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGNybEV4dGVuc2lvbi5leHRuVmFsdWUpIHtcbiAgICAgICAgaWYgKCFlbnRyeS5kaXN0cmlidXRpb25Qb2ludCkge1xuICAgICAgICAgICAgbG9nRGVidWcoJ3NraXBwaW5nIGVudHJ5IHdpdGhvdXQgZGlzdHJpYnV0aW9uUG9pbnQgJWonLCBlbnRyeSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZ1bGxOYW1lRW50cnkgb2YgZW50cnkuZGlzdHJpYnV0aW9uUG9pbnQudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChmdWxsTmFtZUVudHJ5LnR5cGUgIT09ICd1bmlmb3JtUmVzb3VyY2VJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdza2lwcGluZyBub24tdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBlbnRyeSAlaicsIGZ1bGxOYW1lRW50cnkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bGxOYW1lRW50cnkudmFsdWUuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIHNwZWMgYWxsb3dzIG11bHRpcGxlIGh0dHAgdXJscywgd2Ugb25seSBwaWNrIGZpcnN0IG9uZSBhbmQgZG9uJ3QgaGFuZGxlIHJlZHVuZGFuY3lcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmdWxsTmFtZUVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdza2lwcGluZyBub24taHR0cCB2YWx1ZSAlaicsIGZ1bGxOYW1lRW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ0RlYnVnKGBmb3VuZCBVUkxzOiAke3Jlc3VsdC5qb2luKCcsJyl9YCk7XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogbnVsbDtcbn07XG5leHBvcnRzLmdldENlcnRpZmljYXRlQ3JsVXJscyA9IGdldENlcnRpZmljYXRlQ3JsVXJscztcbi8qKlxuICogU2VlIFNob3J0LWxpdmVkIFN1YnNjcmliZXIgQ2VydGlmaWNhdGUgc2VjdGlvblxcXG4gKiBodHRwczovL2NhYmZvcnVtLm9yZy93b3JraW5nLWdyb3Vwcy9zZXJ2ZXIvYmFzZWxpbmUtcmVxdWlyZW1lbnRzL3JlcXVpcmVtZW50cy9cbiAqL1xuZnVuY3Rpb24gaXNTaG9ydExpdmVkQ2VydGlmaWNhdGUoZGVjb2RlZENlcnRpZmljYXRlKSB7XG4gICAgY29uc3Qgbm90QmVmb3JlID0gbmV3IERhdGUoZGVjb2RlZENlcnRpZmljYXRlLnRic0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZS52YWx1ZSk7XG4gICAgY29uc3Qgbm90QWZ0ZXIgPSBuZXcgRGF0ZShkZWNvZGVkQ2VydGlmaWNhdGUudGJzQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIudmFsdWUpO1xuICAgIGxldCBtYXhpbXVtVmFsaWRpdHlQZXJpb2QgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gNyBkYXlzIGluIG1pbGxpc2Vjb25kc1xuICAgIGlmIChub3RCZWZvcmUgPCBuZXcgRGF0ZSgnMjAyNi0wMy0xNVQwMDowMDowMC4wMDBaJykpIHtcbiAgICAgICAgbWF4aW11bVZhbGlkaXR5UGVyaW9kID0gMTAgKiAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAxMCBkYXlzIGluIG1pbGxpc2Vjb25kc1xuICAgIH1cbiAgICBtYXhpbXVtVmFsaWRpdHlQZXJpb2QgKz0gNjAgKiAxMDAwOyAvLyBGaXggaW5jbHVzaW9uIHN0YXJ0IGFuZCBlbmQgdGltZSAoMSBtaW51dGUpXG4gICAgY29uc3QgY2VydFZhbGlkaXR5UGVyaW9kID0gbm90QWZ0ZXIuZ2V0VGltZSgpIC0gbm90QmVmb3JlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbWF4aW11bVZhbGlkaXR5UGVyaW9kID4gY2VydFZhbGlkaXR5UGVyaW9kO1xufVxuZnVuY3Rpb24gaXNDcmxTaWduYXR1cmVWYWxpZChjcmwsIGlzc3VlclB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZUFsZ09pZCA9IGNybC5zaWduYXR1cmVBbGdvcml0aG0uYWxnb3JpdGhtLmpvaW4oJy4nKTtcbiAgICBjb25zdCBkaWdlc3RBbGcgPSBleHBvcnRzLkNSTF9TSUdOQVRVUkVfT0lEX1RPX0NSWVBUT19ESUdFU1RfQUxHT1JJVEhNW3NpZ25hdHVyZUFsZ09pZF07XG4gICAgaWYgKCFkaWdlc3RBbGcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzaWduYXR1cmUgYWxnb3JpdGhtOiAke3NpZ25hdHVyZUFsZ09pZH1gKTtcbiAgICB9XG4gICAgY29uc3QgdmVyaWZ5ID0gY3J5cHRvXzEuZGVmYXVsdC5jcmVhdGVWZXJpZnkoZGlnZXN0QWxnKTtcbiAgICBjb25zdCB0YnNFbmNvZGVkID0gYXNuMV9qc19yZmM1MjgwXzEuZGVmYXVsdC5UQlNDZXJ0TGlzdC5lbmNvZGUoY3JsLnRic0NlcnRMaXN0LCAnZGVyJyk7XG4gICAgdmVyaWZ5LnVwZGF0ZSh0YnNFbmNvZGVkKTtcbiAgICByZXR1cm4gdmVyaWZ5LnZlcmlmeShpc3N1ZXJQdWJsaWNLZXksIGNybC5zaWduYXR1cmUuZGF0YSk7XG59XG5mdW5jdGlvbiBpc0NlcnRpZmljYXRlUmV2b2tlZChkZWNvZGVkQ2VydGlmaWNhdGUsIGNybCkge1xuICAgIGZvciAoY29uc3QgcmV2b2tlZENlcnQgb2YgY3JsLnRic0NlcnRMaXN0LnJldm9rZWRDZXJ0aWZpY2F0ZXMpIHtcbiAgICAgICAgaWYgKHJldm9rZWRDZXJ0LnVzZXJDZXJ0aWZpY2F0ZS5lcShkZWNvZGVkQ2VydGlmaWNhdGUudGJzQ2VydGlmaWNhdGUuc2VyaWFsTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRFeHRlbnNpb25WYWxpZChjcmwsIGV4cGVjdGVkQ3JsVXJsKSB7XG4gICAgY29uc3QgaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50RXh0ZW5zaW9uID0gY3JsLnRic0NlcnRMaXN0LmNybEV4dGVuc2lvbnM/LmZpbmQoKGV4dCkgPT4gZXh0LmV4dG5JRCA9PT0gJ2lzc3VpbmdEaXN0cmlidXRpb25Qb2ludCcpO1xuICAgIGlmICghaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50RXh0ZW5zaW9uKSB7XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBDUkwgJHtleHBlY3RlZENybFVybH0gZG9lc250IGhhdmUgaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50IGV4dGVuc2lvbiwgaWdub3JpbmdgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZnVsbE5hbWVFbnRyeSBvZiBpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRFeHRlbnNpb24uZXh0blZhbHVlLmRpc3RyaWJ1dGlvblBvaW50LnZhbHVlKSB7XG4gICAgICAgIGlmIChmdWxsTmFtZUVudHJ5LnR5cGUgPT09ICd1bmlmb3JtUmVzb3VyY2VJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgZnVsbE5hbWVFbnRyeS52YWx1ZSA9PT0gZXhwZWN0ZWRDcmxVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNybF91dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CertificateRevokedError = exports.CRL_VALIDATOR_INTERNAL = void 0;\nexports.isCrlValidationEnabled = isCrlValidationEnabled;\nexports.corkSocketAndValidateCrl = corkSocketAndValidateCrl;\nexports.validateCrl = validateCrl;\nconst asn1_js_rfc5280_1 = __importDefault(__webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\"));\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst crl_utils_1 = __webpack_require__(/*! ./crl_utils */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_utils.js\");\nconst crl_fetcher_1 = __webpack_require__(/*! ./crl_fetcher */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_fetcher.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n// Allows to mock/spy internal calls in tests\nexports.CRL_VALIDATOR_INTERNAL = {\n    validateCrl: (...args) => validateCrl(...args),\n};\nclass CertificateRevokedError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CertificateRevokedError';\n    }\n}\nexports.CertificateRevokedError = CertificateRevokedError;\nfunction isCrlValidationEnabled(config) {\n    return config.checkMode !== 'DISABLED';\n}\nfunction corkSocketAndValidateCrl(socket, config) {\n    socket.once('secureConnect', async () => {\n        const certChain = socket.getPeerCertificate(true);\n        try {\n            await exports.CRL_VALIDATOR_INTERNAL.validateCrl(certChain, config);\n        }\n        catch (error) {\n            if (!(error instanceof CertificateRevokedError) && config.checkMode === 'ADVISORY') {\n                (0, logger_1.default)().debug('Failed to check CRL revocation, but checkMode=ADVISORY. Allowing connection. Error: %j', error);\n            }\n            else {\n                // NOTE: Wrap error into CrlError to prevent retries\n                socket.destroy((0, errors_1.createCrlError)(error));\n            }\n        }\n        socket.uncork();\n    });\n    socket.cork();\n}\nfunction* iterateCertChain(cert) {\n    let current = cert;\n    while (current) {\n        if (current === current.issuerCertificate)\n            break; // Root is self-signed, ignoring\n        yield current;\n        current = current.issuerCertificate;\n    }\n}\n// NOTE:\n// Sticking with asn1.js-rfc5280 + custom signature validation, because popular libraries have issues:\n// - jsrsasign: has outdated crypto library with CEV issues\n// - pkijs: takes 4 seconds to parse 9Mb CRL\n// - @peculiar/x509: takes 2.5 seconds to parse 9Mb CRL\nasync function validateCrl(certChain, config) {\n    for (const certificate of iterateCertChain(certChain)) {\n        const decodedCertificate = asn1_js_rfc5280_1.default.Certificate.decode(certificate.raw, 'der');\n        const name = (0, crl_utils_1.getCertificateDebugName)(certificate);\n        const logDebug = (msg) => (0, logger_1.default)().debug(`validateCrl[${name}]: ${msg}`);\n        logDebug('starting validation');\n        if ((0, crl_utils_1.isShortLivedCertificate)(decodedCertificate)) {\n            logDebug('certificate is short-lived, skipping');\n            continue;\n        }\n        logDebug('getting CRL distribution points');\n        const crlUrls = (0, crl_utils_1.getCertificateCrlUrls)(name, decodedCertificate);\n        if (!crlUrls) {\n            if (config.allowCertificatesWithoutCrlURL) {\n                logDebug('certificate has no CRL distribution points, skipping');\n                continue;\n            }\n            throw new Error(`Certificate ${name} does not have CRL http URL. This could be disabled with allowCertificatesWithoutCrlURL`);\n        }\n        const decodedIssuerCertificate = asn1_js_rfc5280_1.default.Certificate.decode(certificate.issuerCertificate.raw, 'der');\n        const issuerSubject = JSON.stringify(decodedIssuerCertificate.tbsCertificate.subject);\n        const issuerPublicKey = crypto_1.default\n            .createPublicKey({\n            key: certificate.issuerCertificate.pubkey,\n            format: 'der',\n            type: 'spki',\n        })\n            .export({ format: 'pem', type: 'spki' });\n        for (const crlUrl of crlUrls) {\n            logDebug(`fetching ${crlUrl}`);\n            const crl = await (0, crl_fetcher_1.getCrl)(crlUrl, {\n                inMemoryCache: config.inMemoryCache,\n                onDiskCache: config.onDiskCache,\n            });\n            logDebug(`validating ${crlUrl} signature`);\n            if (!(0, crl_utils_1.isCrlSignatureValid)(crl, issuerPublicKey)) {\n                throw new Error(`CRL ${crlUrl} signature is invalid. Expected signature by ${(0, crl_utils_1.getCertificateDebugName)(certificate.issuerCertificate)}`);\n            }\n            logDebug(`validating ${crlUrl} issuingDistributionPoint extension`);\n            if (!(0, crl_utils_1.isIssuingDistributionPointExtensionValid)(crl, crlUrl)) {\n                throw new Error(`CRL ${crlUrl} issuingDistributionPoint extension is invalid`);\n            }\n            logDebug(`validating ${crlUrl} issuer`);\n            const crlIssuer = JSON.stringify(crl.tbsCertList.issuer);\n            if (issuerSubject !== crlIssuer) {\n                throw new Error(`CRL ${crlUrl} issuer is invalid. Expected ${issuerSubject} but got ${crlIssuer}`);\n            }\n            logDebug(`validating ${crlUrl} nextUpdate`);\n            if (crl.tbsCertList.nextUpdate.value < Date.now()) {\n                throw new Error(`CRL ${crlUrl} nextUpdate is expired`);\n            }\n            logDebug(`checking if certificate is revoked in ${crlUrl}`);\n            if ((0, crl_utils_1.isCertificateRevoked)(decodedCertificate, crl)) {\n                throw new CertificateRevokedError(`Certificate ${name} is revoked in ${crlUrl}`);\n            }\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=crl_validator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9jcmxfdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsOEJBQThCO0FBQ2hFLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLDBDQUEwQyxtQkFBTyxDQUFDLHNFQUFpQjtBQUNuRSxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCxpQ0FBaUMsbUJBQU8sQ0FBQyx3RUFBVztBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBZTtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVztBQUNwQztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxLQUFLLEtBQUssSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSx1Q0FBdUMsUUFBUSw4Q0FBOEMsd0VBQXdFO0FBQ3JLO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSw4QkFBOEIsZUFBZSxVQUFVLFVBQVU7QUFDaEg7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQSxpRUFBaUUsTUFBTSxnQkFBZ0IsT0FBTztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2NybF92YWxpZGF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNlcnRpZmljYXRlUmV2b2tlZEVycm9yID0gZXhwb3J0cy5DUkxfVkFMSURBVE9SX0lOVEVSTkFMID0gdm9pZCAwO1xuZXhwb3J0cy5pc0NybFZhbGlkYXRpb25FbmFibGVkID0gaXNDcmxWYWxpZGF0aW9uRW5hYmxlZDtcbmV4cG9ydHMuY29ya1NvY2tldEFuZFZhbGlkYXRlQ3JsID0gY29ya1NvY2tldEFuZFZhbGlkYXRlQ3JsO1xuZXhwb3J0cy52YWxpZGF0ZUNybCA9IHZhbGlkYXRlQ3JsO1xuY29uc3QgYXNuMV9qc19yZmM1MjgwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzbjEuanMtcmZjNTI4MFwiKSk7XG5jb25zdCBjcnlwdG9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9sb2dnZXJcIikpO1xuY29uc3QgY3JsX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9jcmxfdXRpbHNcIik7XG5jb25zdCBjcmxfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4vY3JsX2ZldGNoZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG4vLyBBbGxvd3MgdG8gbW9jay9zcHkgaW50ZXJuYWwgY2FsbHMgaW4gdGVzdHNcbmV4cG9ydHMuQ1JMX1ZBTElEQVRPUl9JTlRFUk5BTCA9IHtcbiAgICB2YWxpZGF0ZUNybDogKC4uLmFyZ3MpID0+IHZhbGlkYXRlQ3JsKC4uLmFyZ3MpLFxufTtcbmNsYXNzIENlcnRpZmljYXRlUmV2b2tlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDZXJ0aWZpY2F0ZVJldm9rZWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5DZXJ0aWZpY2F0ZVJldm9rZWRFcnJvciA9IENlcnRpZmljYXRlUmV2b2tlZEVycm9yO1xuZnVuY3Rpb24gaXNDcmxWYWxpZGF0aW9uRW5hYmxlZChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnLmNoZWNrTW9kZSAhPT0gJ0RJU0FCTEVEJztcbn1cbmZ1bmN0aW9uIGNvcmtTb2NrZXRBbmRWYWxpZGF0ZUNybChzb2NrZXQsIGNvbmZpZykge1xuICAgIHNvY2tldC5vbmNlKCdzZWN1cmVDb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjZXJ0Q2hhaW4gPSBzb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXhwb3J0cy5DUkxfVkFMSURBVE9SX0lOVEVSTkFMLnZhbGlkYXRlQ3JsKGNlcnRDaGFpbiwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgQ2VydGlmaWNhdGVSZXZva2VkRXJyb3IpICYmIGNvbmZpZy5jaGVja01vZGUgPT09ICdBRFZJU09SWScpIHtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnRmFpbGVkIHRvIGNoZWNrIENSTCByZXZvY2F0aW9uLCBidXQgY2hlY2tNb2RlPUFEVklTT1JZLiBBbGxvd2luZyBjb25uZWN0aW9uLiBFcnJvcjogJWonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBXcmFwIGVycm9yIGludG8gQ3JsRXJyb3IgdG8gcHJldmVudCByZXRyaWVzXG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKDAsIGVycm9yc18xLmNyZWF0ZUNybEVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNvY2tldC51bmNvcmsoKTtcbiAgICB9KTtcbiAgICBzb2NrZXQuY29yaygpO1xufVxuZnVuY3Rpb24qIGl0ZXJhdGVDZXJ0Q2hhaW4oY2VydCkge1xuICAgIGxldCBjdXJyZW50ID0gY2VydDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gY3VycmVudC5pc3N1ZXJDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgIGJyZWFrOyAvLyBSb290IGlzIHNlbGYtc2lnbmVkLCBpZ25vcmluZ1xuICAgICAgICB5aWVsZCBjdXJyZW50O1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5pc3N1ZXJDZXJ0aWZpY2F0ZTtcbiAgICB9XG59XG4vLyBOT1RFOlxuLy8gU3RpY2tpbmcgd2l0aCBhc24xLmpzLXJmYzUyODAgKyBjdXN0b20gc2lnbmF0dXJlIHZhbGlkYXRpb24sIGJlY2F1c2UgcG9wdWxhciBsaWJyYXJpZXMgaGF2ZSBpc3N1ZXM6XG4vLyAtIGpzcnNhc2lnbjogaGFzIG91dGRhdGVkIGNyeXB0byBsaWJyYXJ5IHdpdGggQ0VWIGlzc3Vlc1xuLy8gLSBwa2lqczogdGFrZXMgNCBzZWNvbmRzIHRvIHBhcnNlIDlNYiBDUkxcbi8vIC0gQHBlY3VsaWFyL3g1MDk6IHRha2VzIDIuNSBzZWNvbmRzIHRvIHBhcnNlIDlNYiBDUkxcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQ3JsKGNlcnRDaGFpbiwgY29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBjZXJ0aWZpY2F0ZSBvZiBpdGVyYXRlQ2VydENoYWluKGNlcnRDaGFpbikpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZENlcnRpZmljYXRlID0gYXNuMV9qc19yZmM1MjgwXzEuZGVmYXVsdC5DZXJ0aWZpY2F0ZS5kZWNvZGUoY2VydGlmaWNhdGUucmF3LCAnZGVyJyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoMCwgY3JsX3V0aWxzXzEuZ2V0Q2VydGlmaWNhdGVEZWJ1Z05hbWUpKGNlcnRpZmljYXRlKTtcbiAgICAgICAgY29uc3QgbG9nRGVidWcgPSAobXNnKSA9PiAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZyhgdmFsaWRhdGVDcmxbJHtuYW1lfV06ICR7bXNnfWApO1xuICAgICAgICBsb2dEZWJ1Zygnc3RhcnRpbmcgdmFsaWRhdGlvbicpO1xuICAgICAgICBpZiAoKDAsIGNybF91dGlsc18xLmlzU2hvcnRMaXZlZENlcnRpZmljYXRlKShkZWNvZGVkQ2VydGlmaWNhdGUpKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnY2VydGlmaWNhdGUgaXMgc2hvcnQtbGl2ZWQsIHNraXBwaW5nJyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsb2dEZWJ1ZygnZ2V0dGluZyBDUkwgZGlzdHJpYnV0aW9uIHBvaW50cycpO1xuICAgICAgICBjb25zdCBjcmxVcmxzID0gKDAsIGNybF91dGlsc18xLmdldENlcnRpZmljYXRlQ3JsVXJscykobmFtZSwgZGVjb2RlZENlcnRpZmljYXRlKTtcbiAgICAgICAgaWYgKCFjcmxVcmxzKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmFsbG93Q2VydGlmaWNhdGVzV2l0aG91dENybFVSTCkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdjZXJ0aWZpY2F0ZSBoYXMgbm8gQ1JMIGRpc3RyaWJ1dGlvbiBwb2ludHMsIHNraXBwaW5nJyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENlcnRpZmljYXRlICR7bmFtZX0gZG9lcyBub3QgaGF2ZSBDUkwgaHR0cCBVUkwuIFRoaXMgY291bGQgYmUgZGlzYWJsZWQgd2l0aCBhbGxvd0NlcnRpZmljYXRlc1dpdGhvdXRDcmxVUkxgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVkSXNzdWVyQ2VydGlmaWNhdGUgPSBhc24xX2pzX3JmYzUyODBfMS5kZWZhdWx0LkNlcnRpZmljYXRlLmRlY29kZShjZXJ0aWZpY2F0ZS5pc3N1ZXJDZXJ0aWZpY2F0ZS5yYXcsICdkZXInKTtcbiAgICAgICAgY29uc3QgaXNzdWVyU3ViamVjdCA9IEpTT04uc3RyaW5naWZ5KGRlY29kZWRJc3N1ZXJDZXJ0aWZpY2F0ZS50YnNDZXJ0aWZpY2F0ZS5zdWJqZWN0KTtcbiAgICAgICAgY29uc3QgaXNzdWVyUHVibGljS2V5ID0gY3J5cHRvXzEuZGVmYXVsdFxuICAgICAgICAgICAgLmNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgICAgICBrZXk6IGNlcnRpZmljYXRlLmlzc3VlckNlcnRpZmljYXRlLnB1YmtleSxcbiAgICAgICAgICAgIGZvcm1hdDogJ2RlcicsXG4gICAgICAgICAgICB0eXBlOiAnc3BraScsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZXhwb3J0KHsgZm9ybWF0OiAncGVtJywgdHlwZTogJ3Nwa2knIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGNybFVybCBvZiBjcmxVcmxzKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgZmV0Y2hpbmcgJHtjcmxVcmx9YCk7XG4gICAgICAgICAgICBjb25zdCBjcmwgPSBhd2FpdCAoMCwgY3JsX2ZldGNoZXJfMS5nZXRDcmwpKGNybFVybCwge1xuICAgICAgICAgICAgICAgIGluTWVtb3J5Q2FjaGU6IGNvbmZpZy5pbk1lbW9yeUNhY2hlLFxuICAgICAgICAgICAgICAgIG9uRGlza0NhY2hlOiBjb25maWcub25EaXNrQ2FjaGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKGB2YWxpZGF0aW5nICR7Y3JsVXJsfSBzaWduYXR1cmVgKTtcbiAgICAgICAgICAgIGlmICghKDAsIGNybF91dGlsc18xLmlzQ3JsU2lnbmF0dXJlVmFsaWQpKGNybCwgaXNzdWVyUHVibGljS2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ1JMICR7Y3JsVXJsfSBzaWduYXR1cmUgaXMgaW52YWxpZC4gRXhwZWN0ZWQgc2lnbmF0dXJlIGJ5ICR7KDAsIGNybF91dGlsc18xLmdldENlcnRpZmljYXRlRGVidWdOYW1lKShjZXJ0aWZpY2F0ZS5pc3N1ZXJDZXJ0aWZpY2F0ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgdmFsaWRhdGluZyAke2NybFVybH0gaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50IGV4dGVuc2lvbmApO1xuICAgICAgICAgICAgaWYgKCEoMCwgY3JsX3V0aWxzXzEuaXNJc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRFeHRlbnNpb25WYWxpZCkoY3JsLCBjcmxVcmwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDUkwgJHtjcmxVcmx9IGlzc3VpbmdEaXN0cmlidXRpb25Qb2ludCBleHRlbnNpb24gaXMgaW52YWxpZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoYHZhbGlkYXRpbmcgJHtjcmxVcmx9IGlzc3VlcmApO1xuICAgICAgICAgICAgY29uc3QgY3JsSXNzdWVyID0gSlNPTi5zdHJpbmdpZnkoY3JsLnRic0NlcnRMaXN0Lmlzc3Vlcik7XG4gICAgICAgICAgICBpZiAoaXNzdWVyU3ViamVjdCAhPT0gY3JsSXNzdWVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDUkwgJHtjcmxVcmx9IGlzc3VlciBpcyBpbnZhbGlkLiBFeHBlY3RlZCAke2lzc3VlclN1YmplY3R9IGJ1dCBnb3QgJHtjcmxJc3N1ZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dEZWJ1ZyhgdmFsaWRhdGluZyAke2NybFVybH0gbmV4dFVwZGF0ZWApO1xuICAgICAgICAgICAgaWYgKGNybC50YnNDZXJ0TGlzdC5uZXh0VXBkYXRlLnZhbHVlIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ1JMICR7Y3JsVXJsfSBuZXh0VXBkYXRlIGlzIGV4cGlyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ0RlYnVnKGBjaGVja2luZyBpZiBjZXJ0aWZpY2F0ZSBpcyByZXZva2VkIGluICR7Y3JsVXJsfWApO1xuICAgICAgICAgICAgaWYgKCgwLCBjcmxfdXRpbHNfMS5pc0NlcnRpZmljYXRlUmV2b2tlZCkoZGVjb2RlZENlcnRpZmljYXRlLCBjcmwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlUmV2b2tlZEVycm9yKGBDZXJ0aWZpY2F0ZSAke25hbWV9IGlzIHJldm9rZWQgaW4gJHtjcmxVcmx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmxfdmFsaWRhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\nconst crl_validator_1 = __webpack_require__(/*! ./crl_validator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\");\n// TODO: when OCSP is removed, rename to HttpsAgent\nclass HttpsCrlAgent extends https_1.Agent {\n    crlValidatorConfig;\n    constructor(opts) {\n        const { crlValidatorConfig, ...agentOptions } = opts;\n        super(agentOptions);\n        this.crlValidatorConfig = crlValidatorConfig;\n    }\n    createConnection(...args) {\n        const createConnection = https_1.Agent.prototype.createConnection;\n        const socket = createConnection.apply(this, args);\n        (0, crl_validator_1.corkSocketAndValidateCrl)(socket, this.crlValidatorConfig);\n        return socket;\n    }\n}\nexports[\"default\"] = HttpsCrlAgent;\n//# sourceMappingURL=https_crl_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19jcmxfYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsb0JBQU87QUFDL0Isd0JBQXdCLG1CQUFPLENBQUMsMkZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L2h0dHBzX2NybF9hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGh0dHBzXzEgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5jb25zdCBjcmxfdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwiLi9jcmxfdmFsaWRhdG9yXCIpO1xuLy8gVE9ETzogd2hlbiBPQ1NQIGlzIHJlbW92ZWQsIHJlbmFtZSB0byBIdHRwc0FnZW50XG5jbGFzcyBIdHRwc0NybEFnZW50IGV4dGVuZHMgaHR0cHNfMS5BZ2VudCB7XG4gICAgY3JsVmFsaWRhdG9yQ29uZmlnO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjcmxWYWxpZGF0b3JDb25maWcsIC4uLmFnZW50T3B0aW9ucyB9ID0gb3B0cztcbiAgICAgICAgc3VwZXIoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5jcmxWYWxpZGF0b3JDb25maWcgPSBjcmxWYWxpZGF0b3JDb25maWc7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBjcmVhdGVDb25uZWN0aW9uID0gaHR0cHNfMS5BZ2VudC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbjtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gY3JlYXRlQ29ubmVjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgKDAsIGNybF92YWxpZGF0b3JfMS5jb3JrU29ja2V0QW5kVmFsaWRhdGVDcmwpKHNvY2tldCwgdGhpcy5jcmxWYWxpZGF0b3JDb25maWcpO1xuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHBzQ3JsQWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwc19jcmxfYWdlbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst HttpsAgent = (__webpack_require__(/*! https */ \"https\").Agent);\nconst SocketUtil = __webpack_require__(/*! ./socket_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js\");\n/**\n * Creates a new HttpsOcspAgent.\n *\n * @param {Object} options\n *\n * @returns {HttpsOcspAgent}\n * @constructor\n */\nfunction HttpsOcspAgent(options) {\n    const agent = HttpsAgent.apply(this, [options]);\n    agent.createConnection = function (port, host, options) {\n        // make sure the 'options' variables references the argument that actually\n        // contains the options\n        // Note: look at the Node.js https agent to understand why this code is\n        // written this way\n        if (port !== null && typeof port === 'object') {\n            options = port;\n        }\n        else if (host !== null && typeof host === 'object') {\n            options = host;\n        }\n        else if (options === null || typeof options !== 'object') {\n            options = {};\n        }\n        if (typeof host !== 'string') {\n            host = options.host;\n        }\n        // call super\n        const socket = HttpsAgent.prototype.createConnection.apply(this, arguments);\n        // secure the socket and return it\n        return SocketUtil.secureSocket(socket, host, null);\n    };\n    return agent;\n}\nmodule.exports = HttpsOcspAgent;\n//# sourceMappingURL=https_ocsp_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19vY3NwX2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsbUJBQW1CLGlEQUFzQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19vY3NwX2FnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgSHR0cHNBZ2VudCA9IHJlcXVpcmUoJ2h0dHBzJykuQWdlbnQ7XG5jb25zdCBTb2NrZXRVdGlsID0gcmVxdWlyZSgnLi9zb2NrZXRfdXRpbCcpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEh0dHBzT2NzcEFnZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge0h0dHBzT2NzcEFnZW50fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0dHBzT2NzcEFnZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhZ2VudCA9IEh0dHBzQWdlbnQuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBhZ2VudC5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gKHBvcnQsIGhvc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSAnb3B0aW9ucycgdmFyaWFibGVzIHJlZmVyZW5jZXMgdGhlIGFyZ3VtZW50IHRoYXQgYWN0dWFsbHlcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIG9wdGlvbnNcbiAgICAgICAgLy8gTm90ZTogbG9vayBhdCB0aGUgTm9kZS5qcyBodHRwcyBhZ2VudCB0byB1bmRlcnN0YW5kIHdoeSB0aGlzIGNvZGUgaXNcbiAgICAgICAgLy8gd3JpdHRlbiB0aGlzIHdheVxuICAgICAgICBpZiAocG9ydCAhPT0gbnVsbCAmJiB0eXBlb2YgcG9ydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvc3QgIT09IG51bGwgJiYgdHlwZW9mIGhvc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbCBzdXBlclxuICAgICAgICBjb25zdCBzb2NrZXQgPSBIdHRwc0FnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHNlY3VyZSB0aGUgc29ja2V0IGFuZCByZXR1cm4gaXRcbiAgICAgICAgcmV0dXJuIFNvY2tldFV0aWwuc2VjdXJlU29ja2V0KHNvY2tldCwgaG9zdCwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gYWdlbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBzT2NzcEFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cHNfb2NzcF9hZ2VudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst https_proxy_agent_1 = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\");\nconst crl_validator_1 = __webpack_require__(/*! ./crl_validator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\");\nconst socket_util_1 = __importDefault(__webpack_require__(/*! ./socket_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js\"));\nconst proxy_util_1 = __importDefault(__webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nclass SnowflakeHttpsProxyAgent extends https_proxy_agent_1.HttpsProxyAgent {\n    useForOCSP;\n    crlValidatorConfig;\n    constructor(opts) {\n        const { host, port, user, password, protocol: rawProtocol, useForOCSP, crlValidatorConfig, ...agentOptions } = opts;\n        const protocol = rawProtocol.endsWith(':') ? rawProtocol : `${rawProtocol}:`;\n        const proxyUrl = new url_1.URL(`${protocol}//${host}:${port}`);\n        proxyUrl.username = user ?? '';\n        proxyUrl.password = password ?? '';\n        super(proxyUrl, agentOptions);\n        this.useForOCSP = useForOCSP;\n        this.crlValidatorConfig = crlValidatorConfig;\n    }\n    async connect(req, opts) {\n        (0, logger_1.default)().debug('Using proxy=%s for host %s', this.proxy.hostname, opts.host);\n        const socket = await super.connect(req, opts);\n        if (socket instanceof tls.TLSSocket) {\n            if ((0, crl_validator_1.isCrlValidationEnabled)(this.crlValidatorConfig)) {\n                (0, crl_validator_1.corkSocketAndValidateCrl)(socket, this.crlValidatorConfig);\n            }\n            else {\n                const isProxyRequiredForOCSP = this.useForOCSP &&\n                    !proxy_util_1.default.isByPassProxy(this.proxy, socket_util_1.default.REGEX_SNOWFLAKE_ENDPOINT);\n                socket_util_1.default.secureSocket(socket, this.proxy.hostname, isProxyRequiredForOCSP ? this : null);\n            }\n        }\n        return socket;\n    }\n}\nmodule.exports = SnowflakeHttpsProxyAgent;\n//# sourceMappingURL=https_proxy_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9odHRwc19wcm94eV9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixtQkFBTyxDQUFDLGdCQUFLO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiw0QkFBNEIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDdkQsd0JBQXdCLG1CQUFPLENBQUMsMkZBQWlCO0FBQ2pELHNDQUFzQyxtQkFBTyxDQUFDLHVGQUFlO0FBQzdELHFDQUFxQyxtQkFBTyxDQUFDLGdGQUFlO0FBQzVELGlDQUFpQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFHQUFxRztBQUNySCxzRUFBc0UsWUFBWTtBQUNsRiwwQ0FBMEMsU0FBUyxJQUFJLEtBQUssR0FBRyxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYWdlbnQvaHR0cHNfcHJveHlfYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidGxzXCIpKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGh0dHBzX3Byb3h5X2FnZW50XzEgPSByZXF1aXJlKFwiaHR0cHMtcHJveHktYWdlbnRcIik7XG5jb25zdCBjcmxfdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwiLi9jcmxfdmFsaWRhdG9yXCIpO1xuY29uc3Qgc29ja2V0X3V0aWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zb2NrZXRfdXRpbFwiKSk7XG5jb25zdCBwcm94eV91dGlsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3Byb3h5X3V0aWxcIikpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xvZ2dlclwiKSk7XG5jbGFzcyBTbm93Zmxha2VIdHRwc1Byb3h5QWdlbnQgZXh0ZW5kcyBodHRwc19wcm94eV9hZ2VudF8xLkh0dHBzUHJveHlBZ2VudCB7XG4gICAgdXNlRm9yT0NTUDtcbiAgICBjcmxWYWxpZGF0b3JDb25maWc7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBjb25zdCB7IGhvc3QsIHBvcnQsIHVzZXIsIHBhc3N3b3JkLCBwcm90b2NvbDogcmF3UHJvdG9jb2wsIHVzZUZvck9DU1AsIGNybFZhbGlkYXRvckNvbmZpZywgLi4uYWdlbnRPcHRpb25zIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJhd1Byb3RvY29sLmVuZHNXaXRoKCc6JykgPyByYXdQcm90b2NvbCA6IGAke3Jhd1Byb3RvY29sfTpgO1xuICAgICAgICBjb25zdCBwcm94eVVybCA9IG5ldyB1cmxfMS5VUkwoYCR7cHJvdG9jb2x9Ly8ke2hvc3R9OiR7cG9ydH1gKTtcbiAgICAgICAgcHJveHlVcmwudXNlcm5hbWUgPSB1c2VyID8/ICcnO1xuICAgICAgICBwcm94eVVybC5wYXNzd29yZCA9IHBhc3N3b3JkID8/ICcnO1xuICAgICAgICBzdXBlcihwcm94eVVybCwgYWdlbnRPcHRpb25zKTtcbiAgICAgICAgdGhpcy51c2VGb3JPQ1NQID0gdXNlRm9yT0NTUDtcbiAgICAgICAgdGhpcy5jcmxWYWxpZGF0b3JDb25maWcgPSBjcmxWYWxpZGF0b3JDb25maWc7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QocmVxLCBvcHRzKSB7XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdVc2luZyBwcm94eT0lcyBmb3IgaG9zdCAlcycsIHRoaXMucHJveHkuaG9zdG5hbWUsIG9wdHMuaG9zdCk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IHN1cGVyLmNvbm5lY3QocmVxLCBvcHRzKTtcbiAgICAgICAgaWYgKHNvY2tldCBpbnN0YW5jZW9mIHRscy5UTFNTb2NrZXQpIHtcbiAgICAgICAgICAgIGlmICgoMCwgY3JsX3ZhbGlkYXRvcl8xLmlzQ3JsVmFsaWRhdGlvbkVuYWJsZWQpKHRoaXMuY3JsVmFsaWRhdG9yQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgICgwLCBjcmxfdmFsaWRhdG9yXzEuY29ya1NvY2tldEFuZFZhbGlkYXRlQ3JsKShzb2NrZXQsIHRoaXMuY3JsVmFsaWRhdG9yQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJveHlSZXF1aXJlZEZvck9DU1AgPSB0aGlzLnVzZUZvck9DU1AgJiZcbiAgICAgICAgICAgICAgICAgICAgIXByb3h5X3V0aWxfMS5kZWZhdWx0LmlzQnlQYXNzUHJveHkodGhpcy5wcm94eSwgc29ja2V0X3V0aWxfMS5kZWZhdWx0LlJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVCk7XG4gICAgICAgICAgICAgICAgc29ja2V0X3V0aWxfMS5kZWZhdWx0LnNlY3VyZVNvY2tldChzb2NrZXQsIHRoaXMucHJveHkuaG9zdG5hbWUsIGlzUHJveHlSZXF1aXJlZEZvck9DU1AgPyB0aGlzIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNub3dmbGFrZUh0dHBzUHJveHlBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBzX3Byb3h5X2FnZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst SimpleCache = __webpack_require__(/*! simple-lru-cache */ \"(rsc)/./node_modules/simple-lru-cache/index.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst status = {\n    NOT_START: 'not_start',\n    STARTED: 'started',\n    FINISHED: 'finish',\n};\n// validate input\nconst sizeLimit = GlobalConfig.getOcspResponseCacheSizeLimit();\n// ocsp cache max age in second\nlet maxAgeSec = GlobalConfig.getOcspResponseCacheMaxAge();\nErrors.assertInternal(Util.number.isPositiveInteger(sizeLimit));\nErrors.assertInternal(Util.number.isPositiveInteger(maxAgeSec));\nconst cacheDir = GlobalConfig.mkdirCacheDir();\nconst cacheFileName = path.join(cacheDir, 'ocsp_response_cache.json');\n// create a cache to store the responses, dynamically changes in size\nlet cache;\n// Cache updated time, in seconds, initialized as current time.\n// Will be updated when load from local cache file or refresh by downloading\nfunction deleteCache() {\n    try {\n        cache.reset();\n        fs.unlinkSync(cacheFileName);\n    }\n    catch (e) {\n        Logger.getInstance().debug('Failed to delete OCSP cache file: %s, err: %s', cacheFileName, e);\n    }\n}\nexports.deleteCache = deleteCache;\n/**\n * Cache for storing OCSP responses. This covers both client and server caches.\n *\n * @constructor\n */\nfunction OcspResponseCache() {\n    let downloadStatus = status.NOT_START;\n    let cacheUpdated = false;\n    let cacheInitialized = false;\n    let proxyAgent = null;\n    /**\n     * Reads OCSP cache file.\n     */\n    // Cache update time in second\n    let cacheUpdateTimeSec = Date.now() / 1000;\n    let OCSP_URL = process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL;\n    if (!OCSP_URL) {\n        OCSP_URL = 'http://ocsp.snowflakecomputing.com/ocsp_response_cache.json';\n    }\n    try {\n        Logger.getInstance().debug('Reading OCSP cache file. %s', cacheFileName);\n        const contents = fs.readFileSync(cacheFileName, 'utf-8');\n        const jsonCacheFromFile = JSON.parse(contents);\n        updateCache(jsonCacheFromFile);\n        cacheInitialized = true;\n    }\n    catch (e) {\n        Logger.getInstance().debug('Failed to read OCSP cache file: %s, err: %s', cacheFileName, e);\n    }\n    /**\n     * set proxy agent for ocsp validation\n     *\n     * @param agent\n     */\n    this.setAgent = function setAgent(agent) {\n        proxyAgent = agent;\n    };\n    /**\n     * Initializes the cache\n     *\n     * @param cert\n     * @param response\n     */\n    this.initCache = function initCache(cert, response) {\n        cache = new SimpleCache({ maxSize: 1 });\n        this.set(cert, response);\n    };\n    /**\n     * Is OCSP Cache initialized?\n     * @returns {boolean}\n     */\n    this.isInitialized = function () {\n        return cacheInitialized;\n    };\n    /**\n     * Is OCSP Cache download finished?\n     * @returns {boolean}\n     */\n    this.isDownloadFinished = function () {\n        return downloadStatus === status.FINISHED;\n    };\n    /**\n     * Forces download status to finish\n     */\n    this.forceDownloadToFinish = function () {\n        downloadStatus = status.FINISHED;\n    };\n    /**\n     * Is local OCSP Cache expired?\n     * @returns {boolean}\n     */\n    this.IsCacheExpired = function () {\n        if (!cacheInitialized) {\n            return false;\n        }\n        // Update maxAge in case it could be changed through environment variable\n        maxAgeSec = GlobalConfig.getOcspResponseCacheMaxAge();\n        // Current time in seconds\n        const currentTimeSec = Date.now() / 1000;\n        if (currentTimeSec - cacheUpdateTimeSec > maxAgeSec) {\n            Logger.getInstance().debug('OCSP local cache validity is out of range. currentTime: %s, timestamp: %s, maxAge: %s', currentTimeSec, cacheUpdateTimeSec, maxAgeSec);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Resets OCSP Cache status\n     */\n    this.resetCacheStatus = function () {\n        downloadStatus = status.NOT_START;\n        if (cacheUpdated) {\n            Logger.getInstance().debug(cacheFileName);\n            // current time in second\n            const currentTimeSec = Date.now() / 1000;\n            const cacheOutput = {};\n            cache.forEach(function (v, k) {\n                const certIdInBase64 = CertUtil.decodeKey(k);\n                const ocspResponseInBase64 = v.toString('BASE64');\n                cacheOutput[certIdInBase64] = [currentTimeSec, ocspResponseInBase64];\n            });\n            const writeContent = JSON.stringify(cacheOutput);\n            Logger.getInstance().debug('Writing OCSP cache file. %s', cacheFileName);\n            try {\n                fs.writeFileSync(cacheFileName, writeContent, 'utf-8');\n            }\n            catch (e) {\n                Logger.getInstance().debug('Failed to update OCSP cache file: %s, err: %s', cacheFileName, e);\n            }\n            cacheUpdated = false;\n        }\n    };\n    /**\n     * Adds an entry to the cache.\n     *\n     * @param cert\n     * @param response\n     */\n    this.set = function set(cert, response) {\n        try {\n            const certId = CertUtil.buildCertId(cert);\n            cache.set(certId, response);\n            cacheUpdated = true;\n        }\n        catch (e) {\n            Logger.getInstance().debug('Failed to add certificate to OCSP cache file. err: %s', e);\n        }\n    };\n    /**\n     * Returns an entry from the cache.\n     *\n     * @param cert\n     * @returns {*}\n     */\n    this.get = function get(cert) {\n        try {\n            const certId = CertUtil.buildCertId(cert);\n            return cache.get(certId);\n        }\n        catch (e) {\n            Logger.getInstance().debug('Failed to get certificate from OCSP cache. err: %s', e);\n            return null;\n        }\n    };\n    /**\n     * Downloads OCSP cache from the Snowflake OCSP cache server.\n     * @param cb callback\n     */\n    this.downloadCache = function (cb) {\n        if (downloadStatus === status.STARTED) {\n            // reschedule calling cb\n            return false;\n        }\n        else if (downloadStatus === status.FINISHED) {\n            // call cb immediately\n            cb(null, false);\n            return true;\n        }\n        downloadStatus = status.STARTED;\n        function checkOCSPResponse(err, cacheContent) {\n            if (downloadStatus === status.FINISHED) {\n                return;\n            }\n            downloadStatus = status.FINISHED;\n            Logger.getInstance().debug('Finish OCSP Cache Server: %s', OCSP_URL);\n            if (err) {\n                Logger.getInstance().debug('Failed to download OCSP cache file. %s. Ignored', err);\n                return cb(err, false);\n            }\n            try {\n                const jsonParsed = JSON.parse(cacheContent);\n                updateCache(jsonParsed);\n                cacheUpdated = true;\n                return cb(null, false);\n            }\n            catch (e) {\n                cb(e, false);\n            }\n        }\n        function onResponse(response) {\n            if (response.statusCode < 200 || response.statusCode >= 400) {\n                return checkOCSPResponse(new Error('Failed to obtain OCSP response: ' + response.statusCode), null);\n            }\n            let rawData = '';\n            // A chunk of data has been received.\n            response.on('data', function (chunk) {\n                rawData += chunk;\n            });\n            // The whole response has been received. Print out the result.\n            response.on('end', function () {\n                checkOCSPResponse(null, rawData);\n            });\n        }\n        const uri = url.parse(OCSP_URL);\n        const timeout = process.env.SF_OCSP_TEST_OCSP_RESPONSE_CACHE_SERVER_TIMEOUT || 5000;\n        const options = Object.assign({\n            timeout: Number(timeout),\n            method: 'GET',\n            agent: proxyAgent,\n        }, uri);\n        const httpRequest = http.request(options, onResponse);\n        httpRequest.on('error', function (e) {\n            downloadStatus = status.FINISHED;\n            if (cb) {\n                cb(e, false);\n            }\n            cb = null;\n        });\n        httpRequest.on('timeout', function () {\n            downloadStatus = status.FINISHED;\n            httpRequest.abort();\n            Logger.getInstance().debug('Timeout OCSP responder: %s, %ss', OCSP_URL, options.timeout);\n            if (cb) {\n                cb(Errors.createOCSPError(ErrorCodes.ERR_OCSP_CACHE_SERVER_TIMEOUT), false);\n            }\n            cb = null;\n        });\n        httpRequest.end();\n        Logger.getInstance().trace('Contact OCSP Cache Server: %s', OCSP_URL);\n        return true;\n    };\n    /**\n     * Validate cache entry\n     * @param certIdBase64 cache key\n     * @param ocspResponseBase64 cache value\n     * @returns {Object}\n     */\n    function validateCacheEntry(certIdBase64, ocspResponseBase64) {\n        let err;\n        if (ocspResponseBase64.length !== 2) {\n            Logger.getInstance().debug(\"OCSP cache value doesn't consist of two elements. Ignored.\");\n            err = Errors.createOCSPError(ErrorCodes.ERR_OCSP_NOT_TWO_ELEMENTS);\n        }\n        const cacheEntryWriteTime = ocspResponseBase64[0];\n        const currentTimeSec = Date.now() / 1000;\n        if (currentTimeSec - cacheEntryWriteTime > maxAgeSec) {\n            Logger.getInstance().debug('OCSP cache validity is out of range. currentTime: %s, timestamp: %s, maxAge: %s', currentTimeSec, cacheEntryWriteTime, maxAgeSec);\n            err = Errors.createOCSPError(ErrorCodes.ERR_OCSP_CACHE_EXPIRED);\n        }\n        try {\n            const k = CertUtil.encodeKey(certIdBase64);\n            if (err) {\n                return { err: err, key: k };\n            }\n            const cacheEntryOcspResponse = ocspResponseBase64[1];\n            const rawOCSPResponse = Buffer.from(cacheEntryOcspResponse, 'base64');\n            const status = CertUtil.verifyOCSPResponse(null, rawOCSPResponse);\n            if (!status.err) {\n                return { err: null, key: k, value: rawOCSPResponse };\n            }\n            return { err: status.err };\n        }\n        catch (e) {\n            Logger.getInstance().debug('Failed to parse OCSP response. %s. Ignored.', e);\n            return { err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_FAILED_PARSE_RESPONSE) };\n        }\n    }\n    function updateCache(jsonObject) {\n        // Get the size of cache\n        const cacheSize = Object.keys(jsonObject).length;\n        // Create cache using response cache size if it doesn't exceed the upper limit\n        cache = new SimpleCache({ maxSize: cacheSize < sizeLimit ? cacheSize : sizeLimit });\n        // Add new entries\n        setCacheEntries(jsonObject);\n        // set cache update time\n        cacheInitialized = true;\n    }\n    function setCacheEntries(jsonObject) {\n        let cacheUpdateTime = Date.now() / 1000;\n        for (const entry in jsonObject) {\n            if (Object.prototype.hasOwnProperty.call(jsonObject, entry)) {\n                const newUpdateTime = validateAndSetEntry(jsonObject, entry, cacheUpdateTime);\n                if (newUpdateTime) {\n                    cacheUpdateTime = newUpdateTime;\n                }\n            }\n        }\n        cacheUpdateTimeSec = cacheUpdateTime;\n    }\n    function validateAndSetEntry(jsonObject, entry, cacheUpdateTime) {\n        const status = validateCacheEntry(entry, jsonObject[entry]);\n        if (!status.err) {\n            // Add new entry or update existing one\n            cache.set(status.key, status.value);\n            // change cache update time if needed\n            if (jsonObject[entry][0] < cacheUpdateTime) {\n                return jsonObject[entry][0];\n            }\n        }\n        else {\n            Logger.getInstance().trace('Error when validating OCSP cache entry %s, %s', entry, status.err.toString());\n        }\n    }\n}\nexports.OcspResponseCache = OcspResponseCache;\n//# sourceMappingURL=ocsp_response_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9vY3NwX3Jlc3BvbnNlX2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWtCO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBYTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0RBQXdEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L29jc3BfcmVzcG9uc2VfY2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgU2ltcGxlQ2FjaGUgPSByZXF1aXJlKCdzaW1wbGUtbHJ1LWNhY2hlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgQ2VydFV0aWwgPSByZXF1aXJlKCcuL2NlcnRfdXRpbCcpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBzdGF0dXMgPSB7XG4gICAgTk9UX1NUQVJUOiAnbm90X3N0YXJ0JyxcbiAgICBTVEFSVEVEOiAnc3RhcnRlZCcsXG4gICAgRklOSVNIRUQ6ICdmaW5pc2gnLFxufTtcbi8vIHZhbGlkYXRlIGlucHV0XG5jb25zdCBzaXplTGltaXQgPSBHbG9iYWxDb25maWcuZ2V0T2NzcFJlc3BvbnNlQ2FjaGVTaXplTGltaXQoKTtcbi8vIG9jc3AgY2FjaGUgbWF4IGFnZSBpbiBzZWNvbmRcbmxldCBtYXhBZ2VTZWMgPSBHbG9iYWxDb25maWcuZ2V0T2NzcFJlc3BvbnNlQ2FjaGVNYXhBZ2UoKTtcbkVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLm51bWJlci5pc1Bvc2l0aXZlSW50ZWdlcihzaXplTGltaXQpKTtcbkVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLm51bWJlci5pc1Bvc2l0aXZlSW50ZWdlcihtYXhBZ2VTZWMpKTtcbmNvbnN0IGNhY2hlRGlyID0gR2xvYmFsQ29uZmlnLm1rZGlyQ2FjaGVEaXIoKTtcbmNvbnN0IGNhY2hlRmlsZU5hbWUgPSBwYXRoLmpvaW4oY2FjaGVEaXIsICdvY3NwX3Jlc3BvbnNlX2NhY2hlLmpzb24nKTtcbi8vIGNyZWF0ZSBhIGNhY2hlIHRvIHN0b3JlIHRoZSByZXNwb25zZXMsIGR5bmFtaWNhbGx5IGNoYW5nZXMgaW4gc2l6ZVxubGV0IGNhY2hlO1xuLy8gQ2FjaGUgdXBkYXRlZCB0aW1lLCBpbiBzZWNvbmRzLCBpbml0aWFsaXplZCBhcyBjdXJyZW50IHRpbWUuXG4vLyBXaWxsIGJlIHVwZGF0ZWQgd2hlbiBsb2FkIGZyb20gbG9jYWwgY2FjaGUgZmlsZSBvciByZWZyZXNoIGJ5IGRvd25sb2FkaW5nXG5mdW5jdGlvbiBkZWxldGVDYWNoZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWNoZS5yZXNldCgpO1xuICAgICAgICBmcy51bmxpbmtTeW5jKGNhY2hlRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIGRlbGV0ZSBPQ1NQIGNhY2hlIGZpbGU6ICVzLCBlcnI6ICVzJywgY2FjaGVGaWxlTmFtZSwgZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWxldGVDYWNoZSA9IGRlbGV0ZUNhY2hlO1xuLyoqXG4gKiBDYWNoZSBmb3Igc3RvcmluZyBPQ1NQIHJlc3BvbnNlcy4gVGhpcyBjb3ZlcnMgYm90aCBjbGllbnQgYW5kIHNlcnZlciBjYWNoZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE9jc3BSZXNwb25zZUNhY2hlKCkge1xuICAgIGxldCBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5OT1RfU1RBUlQ7XG4gICAgbGV0IGNhY2hlVXBkYXRlZCA9IGZhbHNlO1xuICAgIGxldCBjYWNoZUluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgbGV0IHByb3h5QWdlbnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFJlYWRzIE9DU1AgY2FjaGUgZmlsZS5cbiAgICAgKi9cbiAgICAvLyBDYWNoZSB1cGRhdGUgdGltZSBpbiBzZWNvbmRcbiAgICBsZXQgY2FjaGVVcGRhdGVUaW1lU2VjID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgbGV0IE9DU1BfVVJMID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfVVJMO1xuICAgIGlmICghT0NTUF9VUkwpIHtcbiAgICAgICAgT0NTUF9VUkwgPSAnaHR0cDovL29jc3Auc25vd2ZsYWtlY29tcHV0aW5nLmNvbS9vY3NwX3Jlc3BvbnNlX2NhY2hlLmpzb24nO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVhZGluZyBPQ1NQIGNhY2hlIGZpbGUuICVzJywgY2FjaGVGaWxlTmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGNhY2hlRmlsZU5hbWUsICd1dGYtOCcpO1xuICAgICAgICBjb25zdCBqc29uQ2FjaGVGcm9tRmlsZSA9IEpTT04ucGFyc2UoY29udGVudHMpO1xuICAgICAgICB1cGRhdGVDYWNoZShqc29uQ2FjaGVGcm9tRmlsZSk7XG4gICAgICAgIGNhY2hlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIHJlYWQgT0NTUCBjYWNoZSBmaWxlOiAlcywgZXJyOiAlcycsIGNhY2hlRmlsZU5hbWUsIGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgcHJveHkgYWdlbnQgZm9yIG9jc3AgdmFsaWRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGFnZW50XG4gICAgICovXG4gICAgdGhpcy5zZXRBZ2VudCA9IGZ1bmN0aW9uIHNldEFnZW50KGFnZW50KSB7XG4gICAgICAgIHByb3h5QWdlbnQgPSBhZ2VudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjYWNoZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnRcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmluaXRDYWNoZSA9IGZ1bmN0aW9uIGluaXRDYWNoZShjZXJ0LCByZXNwb25zZSkge1xuICAgICAgICBjYWNoZSA9IG5ldyBTaW1wbGVDYWNoZSh7IG1heFNpemU6IDEgfSk7XG4gICAgICAgIHRoaXMuc2V0KGNlcnQsIHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzIE9DU1AgQ2FjaGUgaW5pdGlhbGl6ZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FjaGVJbml0aWFsaXplZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzIE9DU1AgQ2FjaGUgZG93bmxvYWQgZmluaXNoZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0Rvd25sb2FkRmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb3dubG9hZFN0YXR1cyA9PT0gc3RhdHVzLkZJTklTSEVEO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yY2VzIGRvd25sb2FkIHN0YXR1cyB0byBmaW5pc2hcbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlRG93bmxvYWRUb0ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG93bmxvYWRTdGF0dXMgPSBzdGF0dXMuRklOSVNIRUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJcyBsb2NhbCBPQ1NQIENhY2hlIGV4cGlyZWQ/XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5Jc0NhY2hlRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjYWNoZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIG1heEFnZSBpbiBjYXNlIGl0IGNvdWxkIGJlIGNoYW5nZWQgdGhyb3VnaCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgICAgICBtYXhBZ2VTZWMgPSBHbG9iYWxDb25maWcuZ2V0T2NzcFJlc3BvbnNlQ2FjaGVNYXhBZ2UoKTtcbiAgICAgICAgLy8gQ3VycmVudCB0aW1lIGluIHNlY29uZHNcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVTZWMgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lU2VjIC0gY2FjaGVVcGRhdGVUaW1lU2VjID4gbWF4QWdlU2VjKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnT0NTUCBsb2NhbCBjYWNoZSB2YWxpZGl0eSBpcyBvdXQgb2YgcmFuZ2UuIGN1cnJlbnRUaW1lOiAlcywgdGltZXN0YW1wOiAlcywgbWF4QWdlOiAlcycsIGN1cnJlbnRUaW1lU2VjLCBjYWNoZVVwZGF0ZVRpbWVTZWMsIG1heEFnZVNlYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgT0NTUCBDYWNoZSBzdGF0dXNcbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0Q2FjaGVTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLk5PVF9TVEFSVDtcbiAgICAgICAgaWYgKGNhY2hlVXBkYXRlZCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoY2FjaGVGaWxlTmFtZSk7XG4gICAgICAgICAgICAvLyBjdXJyZW50IHRpbWUgaW4gc2Vjb25kXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZVNlYyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVPdXRwdXQgPSB7fTtcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0SWRJbkJhc2U2NCA9IENlcnRVdGlsLmRlY29kZUtleShrKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvY3NwUmVzcG9uc2VJbkJhc2U2NCA9IHYudG9TdHJpbmcoJ0JBU0U2NCcpO1xuICAgICAgICAgICAgICAgIGNhY2hlT3V0cHV0W2NlcnRJZEluQmFzZTY0XSA9IFtjdXJyZW50VGltZVNlYywgb2NzcFJlc3BvbnNlSW5CYXNlNjRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB3cml0ZUNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjYWNoZU91dHB1dCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnV3JpdGluZyBPQ1NQIGNhY2hlIGZpbGUuICVzJywgY2FjaGVGaWxlTmFtZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoY2FjaGVGaWxlTmFtZSwgd3JpdGVDb250ZW50LCAndXRmLTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byB1cGRhdGUgT0NTUCBjYWNoZSBmaWxlOiAlcywgZXJyOiAlcycsIGNhY2hlRmlsZU5hbWUsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGVVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnkgdG8gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnRcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIHNldChjZXJ0LCByZXNwb25zZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2VydElkID0gQ2VydFV0aWwuYnVpbGRDZXJ0SWQoY2VydCk7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY2VydElkLCByZXNwb25zZSk7XG4gICAgICAgICAgICBjYWNoZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIGFkZCBjZXJ0aWZpY2F0ZSB0byBPQ1NQIGNhY2hlIGZpbGUuIGVycjogJXMnLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbnRyeSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZXJ0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiBnZXQoY2VydCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2VydElkID0gQ2VydFV0aWwuYnVpbGRDZXJ0SWQoY2VydCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGNlcnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gZ2V0IGNlcnRpZmljYXRlIGZyb20gT0NTUCBjYWNoZS4gZXJyOiAlcycsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBPQ1NQIGNhY2hlIGZyb20gdGhlIFNub3dmbGFrZSBPQ1NQIGNhY2hlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gY2IgY2FsbGJhY2tcbiAgICAgKi9cbiAgICB0aGlzLmRvd25sb2FkQ2FjaGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgaWYgKGRvd25sb2FkU3RhdHVzID09PSBzdGF0dXMuU1RBUlRFRCkge1xuICAgICAgICAgICAgLy8gcmVzY2hlZHVsZSBjYWxsaW5nIGNiXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG93bmxvYWRTdGF0dXMgPT09IHN0YXR1cy5GSU5JU0hFRCkge1xuICAgICAgICAgICAgLy8gY2FsbCBjYiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgY2IobnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZG93bmxvYWRTdGF0dXMgPSBzdGF0dXMuU1RBUlRFRDtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tPQ1NQUmVzcG9uc2UoZXJyLCBjYWNoZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChkb3dubG9hZFN0YXR1cyA9PT0gc3RhdHVzLkZJTklTSEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG93bmxvYWRTdGF0dXMgPSBzdGF0dXMuRklOSVNIRUQ7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmluaXNoIE9DU1AgQ2FjaGUgU2VydmVyOiAlcycsIE9DU1BfVVJMKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIGRvd25sb2FkIE9DU1AgY2FjaGUgZmlsZS4gJXMuIElnbm9yZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvblBhcnNlZCA9IEpTT04ucGFyc2UoY2FjaGVDb250ZW50KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWNoZShqc29uUGFyc2VkKTtcbiAgICAgICAgICAgICAgICBjYWNoZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNiKGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja09DU1BSZXNwb25zZShuZXcgRXJyb3IoJ0ZhaWxlZCB0byBvYnRhaW4gT0NTUCByZXNwb25zZTogJyArIHJlc3BvbnNlLnN0YXR1c0NvZGUpLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYXdEYXRhID0gJyc7XG4gICAgICAgICAgICAvLyBBIGNodW5rIG9mIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgICAgICByZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgKz0gY2h1bms7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZC4gUHJpbnQgb3V0IHRoZSByZXN1bHQuXG4gICAgICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNoZWNrT0NTUFJlc3BvbnNlKG51bGwsIHJhd0RhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gdXJsLnBhcnNlKE9DU1BfVVJMKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHByb2Nlc3MuZW52LlNGX09DU1BfVEVTVF9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9USU1FT1VUIHx8IDUwMDA7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IE51bWJlcih0aW1lb3V0KSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBhZ2VudDogcHJveHlBZ2VudCxcbiAgICAgICAgfSwgdXJpKTtcbiAgICAgICAgY29uc3QgaHR0cFJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucywgb25SZXNwb25zZSk7XG4gICAgICAgIGh0dHBSZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5GSU5JU0hFRDtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHBSZXF1ZXN0Lm9uKCd0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG93bmxvYWRTdGF0dXMgPSBzdGF0dXMuRklOSVNIRUQ7XG4gICAgICAgICAgICBodHRwUmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1RpbWVvdXQgT0NTUCByZXNwb25kZXI6ICVzLCAlc3MnLCBPQ1NQX1VSTCwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9DQUNIRV9TRVJWRVJfVElNRU9VVCksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmVuZCgpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29udGFjdCBPQ1NQIENhY2hlIFNlcnZlcjogJXMnLCBPQ1NQX1VSTCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgY2FjaGUgZW50cnlcbiAgICAgKiBAcGFyYW0gY2VydElkQmFzZTY0IGNhY2hlIGtleVxuICAgICAqIEBwYXJhbSBvY3NwUmVzcG9uc2VCYXNlNjQgY2FjaGUgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2FjaGVFbnRyeShjZXJ0SWRCYXNlNjQsIG9jc3BSZXNwb25zZUJhc2U2NCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAob2NzcFJlc3BvbnNlQmFzZTY0Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoXCJPQ1NQIGNhY2hlIHZhbHVlIGRvZXNuJ3QgY29uc2lzdCBvZiB0d28gZWxlbWVudHMuIElnbm9yZWQuXCIpO1xuICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX05PVF9UV09fRUxFTUVOVFMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlRW50cnlXcml0ZVRpbWUgPSBvY3NwUmVzcG9uc2VCYXNlNjRbMF07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU2VjID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIGlmIChjdXJyZW50VGltZVNlYyAtIGNhY2hlRW50cnlXcml0ZVRpbWUgPiBtYXhBZ2VTZWMpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdPQ1NQIGNhY2hlIHZhbGlkaXR5IGlzIG91dCBvZiByYW5nZS4gY3VycmVudFRpbWU6ICVzLCB0aW1lc3RhbXA6ICVzLCBtYXhBZ2U6ICVzJywgY3VycmVudFRpbWVTZWMsIGNhY2hlRW50cnlXcml0ZVRpbWUsIG1heEFnZVNlYyk7XG4gICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfQ0FDSEVfRVhQSVJFRCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBDZXJ0VXRpbC5lbmNvZGVLZXkoY2VydElkQmFzZTY0KTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnI6IGVyciwga2V5OiBrIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5T2NzcFJlc3BvbnNlID0gb2NzcFJlc3BvbnNlQmFzZTY0WzFdO1xuICAgICAgICAgICAgY29uc3QgcmF3T0NTUFJlc3BvbnNlID0gQnVmZmVyLmZyb20oY2FjaGVFbnRyeU9jc3BSZXNwb25zZSwgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gQ2VydFV0aWwudmVyaWZ5T0NTUFJlc3BvbnNlKG51bGwsIHJhd09DU1BSZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXR1cy5lcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnI6IG51bGwsIGtleTogaywgdmFsdWU6IHJhd09DU1BSZXNwb25zZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyOiBzdGF0dXMuZXJyIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gcGFyc2UgT0NTUCByZXNwb25zZS4gJXMuIElnbm9yZWQuJywgZSk7XG4gICAgICAgICAgICByZXR1cm4geyBlcnI6IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9GQUlMRURfUEFSU0VfUkVTUE9OU0UpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2FjaGUoanNvbk9iamVjdCkge1xuICAgICAgICAvLyBHZXQgdGhlIHNpemUgb2YgY2FjaGVcbiAgICAgICAgY29uc3QgY2FjaGVTaXplID0gT2JqZWN0LmtleXMoanNvbk9iamVjdCkubGVuZ3RoO1xuICAgICAgICAvLyBDcmVhdGUgY2FjaGUgdXNpbmcgcmVzcG9uc2UgY2FjaGUgc2l6ZSBpZiBpdCBkb2Vzbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXRcbiAgICAgICAgY2FjaGUgPSBuZXcgU2ltcGxlQ2FjaGUoeyBtYXhTaXplOiBjYWNoZVNpemUgPCBzaXplTGltaXQgPyBjYWNoZVNpemUgOiBzaXplTGltaXQgfSk7XG4gICAgICAgIC8vIEFkZCBuZXcgZW50cmllc1xuICAgICAgICBzZXRDYWNoZUVudHJpZXMoanNvbk9iamVjdCk7XG4gICAgICAgIC8vIHNldCBjYWNoZSB1cGRhdGUgdGltZVxuICAgICAgICBjYWNoZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVFbnRyaWVzKGpzb25PYmplY3QpIHtcbiAgICAgICAgbGV0IGNhY2hlVXBkYXRlVGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IGluIGpzb25PYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbk9iamVjdCwgZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VXBkYXRlVGltZSA9IHZhbGlkYXRlQW5kU2V0RW50cnkoanNvbk9iamVjdCwgZW50cnksIGNhY2hlVXBkYXRlVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1VwZGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVcGRhdGVUaW1lID0gbmV3VXBkYXRlVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVVcGRhdGVUaW1lU2VjID0gY2FjaGVVcGRhdGVUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFuZFNldEVudHJ5KGpzb25PYmplY3QsIGVudHJ5LCBjYWNoZVVwZGF0ZVRpbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdmFsaWRhdGVDYWNoZUVudHJ5KGVudHJ5LCBqc29uT2JqZWN0W2VudHJ5XSk7XG4gICAgICAgIGlmICghc3RhdHVzLmVycikge1xuICAgICAgICAgICAgLy8gQWRkIG5ldyBlbnRyeSBvciB1cGRhdGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgICBjYWNoZS5zZXQoc3RhdHVzLmtleSwgc3RhdHVzLnZhbHVlKTtcbiAgICAgICAgICAgIC8vIGNoYW5nZSBjYWNoZSB1cGRhdGUgdGltZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChqc29uT2JqZWN0W2VudHJ5XVswXSA8IGNhY2hlVXBkYXRlVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uT2JqZWN0W2VudHJ5XVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdFcnJvciB3aGVuIHZhbGlkYXRpbmcgT0NTUCBjYWNoZSBlbnRyeSAlcywgJXMnLCBlbnRyeSwgc3RhdHVzLmVyci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT2NzcFJlc3BvbnNlQ2FjaGUgPSBPY3NwUmVzcG9uc2VDYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9jc3BfcmVzcG9uc2VfY2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Check = __webpack_require__(/*! ./check */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/check.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/cert_util.js\");\nconst OcspResponseCache = __webpack_require__(/*! ./ocsp_response_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/ocsp_response_cache.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst ProxyAgent = __webpack_require__(/*! ../agent/https_proxy_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js\");\nconst ErrorCodes = Errors.codes;\nconst REGEX_SNOWFLAKE_ENDPOINT = /.snowflakecomputing./;\nexports.REGEX_SNOWFLAKE_ENDPOINT = REGEX_SNOWFLAKE_ENDPOINT;\nconst socketSecuredEvent = 'secureConnect';\nconst rawOcspFlag = process.env.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED;\nconst variables = {\n    SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED: !rawOcspFlag || (rawOcspFlag && rawOcspFlag.toLowerCase() !== 'false'),\n    OCSP_RESPONSE_CACHE: undefined,\n};\n/**\n * Returns the ocsp response cache.\n *\n * @returns {*}\n */\nfunction getOcspResponseCache() {\n    // initialize the ocsp response cache if needed\n    if (!variables.OCSP_RESPONSE_CACHE) {\n        variables.OCSP_RESPONSE_CACHE = new OcspResponseCache.OcspResponseCache();\n    }\n    return variables.OCSP_RESPONSE_CACHE;\n}\nexports.variables = variables;\n/**\n * Secures a given TLSSocket by blocking all writes until the certificate\n * associated with the socket has been validated.\n *\n * @param {Object} socket\n * @param {String} host\n * @param {Object|null} agent\n * @param {Object} [mock]\n *\n * @returns {Object}\n */\nexports.secureSocket = function (socket, host, agent, mock) {\n    // if ocsp validation is disabled for the given host, return the socket as is\n    if (isOcspValidationDisabled(host)) {\n        Logger.getInstance().debug('OCSP validation disabled for %s', host);\n        return socket;\n    }\n    if (agent != null) {\n        getOcspResponseCache().setAgent(agent);\n    }\n    else if (GlobalConfig.isEnvProxyActive()) {\n        const httpProxy = ProxyUtil.getProxyFromEnv(false);\n        if (httpProxy && !ProxyUtil.isByPassProxy(httpProxy, REGEX_SNOWFLAKE_ENDPOINT)) {\n            agent = ProxyAgent(httpProxy);\n            getOcspResponseCache().setAgent(agent);\n        }\n    }\n    const validate = function () {\n        // stop listening for the secure event\n        socket.removeListener(socketSecuredEvent, validate);\n        Logger.getInstance().trace('socket reused = %s', socket.isSessionReused());\n        // if the server has resumed our existing session, unblock all\n        // writes without performing any additional validation\n        if (socket.isSessionReused()) {\n            socket.uncork();\n        }\n        else {\n            if (!socket.authorized) {\n                Logger.getInstance().warn('Socket is not authorized: %s', socket.authorizationError);\n                return socket.destroy(socket.authorizationError);\n            }\n            // use ocsp to make sure the entire certificate chain can be trusted\n            const certChain = socket.getPeerCertificate(true);\n            const vcc = mock ? mock.validateCertChain : validateCertChain;\n            vcc(certChain, function (err) {\n                getOcspResponseCache().resetCacheStatus();\n                if (err) {\n                    // if there's an error, destroy the socket\n                    Logger.getInstance().error('OCSP validation failed: %s', err);\n                    return socket.destroy(err);\n                }\n                Logger.getInstance().trace('OCSP validation succeeded for %s', host);\n                // unblock all writes\n                socket.uncork();\n            });\n        }\n    };\n    // when the socket is secure, perform additional validation\n    socket.on(socketSecuredEvent, validate);\n    // block all writes until validation is complete\n    socket.cork();\n    return socket;\n};\n/**\n * Determines if ocsp validation is disabled for a given host.\n *\n * @param {String} host\n * @returns {boolean}\n */\nfunction isOcspValidationDisabled(host) {\n    // ocsp is disabled if insecure-connect is enabled, or if we've disabled ocsp\n    // for non-snowflake endpoints and the host is a non-snowflake endpoint\n    return (GlobalConfig.isOCSPChecksDisabled() ||\n        (Parameters.getValue(Parameters.names.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS) &&\n            !REGEX_SNOWFLAKE_ENDPOINT.test(host)));\n}\n/**\n * Is valid OCSP error for cache\n * @param err\n * @returns {boolean}\n */\nfunction isValidOCSPError(err) {\n    return (err && (err.code === ErrorCodes.ERR_OCSP_REVOKED || err.code === ErrorCodes.ERR_OCSP_UNKNOWN));\n}\n/**\n * Return err if any valid error is found.\n * @param errors\n * @returns {null|*}\n */\nfunction canEarlyExitForOCSP(errors) {\n    if (GlobalConfig.getOcspMode() === GlobalConfig.ocspModes.FAIL_CLOSED) {\n        for (let errorIndex = 0, length = errors.length; errorIndex < length; errorIndex++) {\n            // first error\n            const err = errors[errorIndex];\n            if (err) {\n                return Object.prototype.hasOwnProperty.call(err, 'err') ? err.err : err;\n            }\n        }\n    }\n    else {\n        let anyRevoked = null;\n        for (let errorIndex = 0, length = errors.length; errorIndex < length; errorIndex++) {\n            // first error\n            const err = errors[errorIndex];\n            if (err && !isValidOCSPError(err)) {\n                // any of the errors is NOT good/revoked/unknown\n                Logger.getInstance().debug(`OCSP responder didn't respond correctly. Assuming certificate is not revoked. Details: ${err}`);\n                return null;\n            }\n            else if (err && err.code === ErrorCodes.ERR_OCSP_REVOKED) {\n                anyRevoked = err;\n            }\n        }\n        return anyRevoked;\n    }\n}\nexports.canEarlyExitForOCSP = canEarlyExitForOCSP;\n/**\n * Validates a certificate chain using OCSP.\n *\n * @param {Object} cert a top-level cert that represents the leaf of a\n *   certificate chain.\n * @param {Function} cb the callback to invoke once the validation is complete.\n */\nfunction validateCertChain(cert, cb) {\n    // walk up the certificate chain and collect all the certificates in an array\n    const certs = [];\n    while (cert &&\n        cert.issuerCertificate &&\n        cert.fingerprint !== cert.issuerCertificate.fingerprint) {\n        certs.push(cert);\n        cert = cert.issuerCertificate;\n    }\n    // create an array to store any errors encountered\n    // while validating the certificate chain\n    const errors = new Array(certs.length);\n    /**\n     * Called for every certificate as we traverse the certificate chain and\n     * validate each one.\n     *\n     * @param certs\n     * @param index\n     */\n    const eachCallback = function (certs, index) {\n        const cert = certs[index];\n        validateCert(cert, function (err, data) {\n            completed++;\n            errors[index] = err;\n            if (err) {\n                Logger.getInstance().debug(err);\n            }\n            // if we have an ocsp response, cache it\n            if (data && (!data.err || isValidOCSPError(data.err))) {\n                // check if cache is initialized before setting entry\n                if (getOcspResponseCache().isInitialized()) {\n                    getOcspResponseCache().set(cert, data.res);\n                }\n                else {\n                    getOcspResponseCache().initCache(cert, data.res);\n                }\n                if (data.err) {\n                    err = data.err;\n                    errors[index] = err;\n                }\n            }\n            // if this is the last request to complete\n            if (completed === certs.length) {\n                const validError = canEarlyExitForOCSP(errors);\n                cb(validError);\n            }\n        });\n    };\n    // fire off requests to validate all the certificates in the chain\n    let completed = 0;\n    for (let index = 0, length = certs.length; index < length; index++) {\n        eachCallback(certs, index);\n    }\n}\n/**\n * Validates a certificate using OCSP.\n *\n * @param cert the certificate to validate.\n * @param cb the callback to invoke once the validation is complete.\n */\nfunction validateCert(cert, cb) {\n    function getOcspCache() {\n        try {\n            if (!getOcspResponseCache().downloadCache(getOcspResonseAndVerify)) {\n                setTimeout(getOcspCache, 10);\n            }\n        }\n        catch (e) {\n            process.nextTick(function () {\n                cb(e);\n            });\n        }\n    }\n    /**\n     * Gets and Verifies OCSP Response\n     * @param err {object}\n     * @param useCacheServer {boolean}\n     */\n    function getOcspResonseAndVerify(err, useCacheServer) {\n        if (!useCacheServer && !getOcspResponseCache().isDownloadFinished()) {\n            setTimeout(getOcspResonseAndVerify, 10); // ms\n            return;\n        }\n        let decoded;\n        try {\n            decoded = CertUtil.decode(cert);\n        }\n        catch (e) {\n            process.nextTick(function () {\n                cb(e);\n            });\n        }\n        let ocspResponse;\n        // check if cache is initialized before getting entry\n        if (getOcspResponseCache().isInitialized()) {\n            if (getOcspResponseCache().IsCacheExpired()) {\n                // reset cache status so it can be refreshed\n                getOcspResponseCache().resetCacheStatus();\n            }\n            else {\n                // if we already have a valid entry in the cache, use it\n                ocspResponse = getOcspResponseCache().get(cert);\n            }\n        }\n        if (ocspResponse) {\n            Logger.getInstance().trace('Returning OCSP status for certificate %s from cache', cert.serialNumber);\n            const status = CertUtil.verifyOCSPResponse(decoded.issuer, ocspResponse);\n            if (!status.err) {\n                // verification was success with the cache\n                process.nextTick(function () {\n                    cb(null, null);\n                });\n            }\n            else {\n                // verification was failure with the cache\n                process.nextTick(function () {\n                    cb(status.err, null);\n                });\n            }\n        }\n        else {\n            if (useCacheServer) {\n                process.nextTick(function () {\n                    getOcspCache();\n                });\n            }\n            else {\n                Check(decoded, cb);\n            }\n        }\n    }\n    if (!variables.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED) {\n        getOcspResponseCache().forceDownloadToFinish();\n    }\n    getOcspResonseAndVerify(null, variables.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED);\n}\n//# sourceMappingURL=socket_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hZ2VudC9zb2NrZXRfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQywyRUFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3RDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUF1QjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsMEdBQTRCO0FBQ3ZEO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLElBQUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2FnZW50L3NvY2tldF91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQ2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuLi9wYXJhbWV0ZXJzJyk7XG5jb25zdCBDZXJ0VXRpbCA9IHJlcXVpcmUoJy4vY2VydF91dGlsJyk7XG5jb25zdCBPY3NwUmVzcG9uc2VDYWNoZSA9IHJlcXVpcmUoJy4vb2NzcF9yZXNwb25zZV9jYWNoZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBQcm94eVV0aWwgPSByZXF1aXJlKCcuLi9wcm94eV91dGlsJyk7XG5jb25zdCBQcm94eUFnZW50ID0gcmVxdWlyZSgnLi4vYWdlbnQvaHR0cHNfcHJveHlfYWdlbnQnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBSRUdFWF9TTk9XRkxBS0VfRU5EUE9JTlQgPSAvLnNub3dmbGFrZWNvbXB1dGluZy4vO1xuZXhwb3J0cy5SRUdFWF9TTk9XRkxBS0VfRU5EUE9JTlQgPSBSRUdFWF9TTk9XRkxBS0VfRU5EUE9JTlQ7XG5jb25zdCBzb2NrZXRTZWN1cmVkRXZlbnQgPSAnc2VjdXJlQ29ubmVjdCc7XG5jb25zdCByYXdPY3NwRmxhZyA9IHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX0VOQUJMRUQ7XG5jb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfRU5BQkxFRDogIXJhd09jc3BGbGFnIHx8IChyYXdPY3NwRmxhZyAmJiByYXdPY3NwRmxhZy50b0xvd2VyQ2FzZSgpICE9PSAnZmFsc2UnKSxcbiAgICBPQ1NQX1JFU1BPTlNFX0NBQ0hFOiB1bmRlZmluZWQsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBvY3NwIHJlc3BvbnNlIGNhY2hlLlxuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpIHtcbiAgICAvLyBpbml0aWFsaXplIHRoZSBvY3NwIHJlc3BvbnNlIGNhY2hlIGlmIG5lZWRlZFxuICAgIGlmICghdmFyaWFibGVzLk9DU1BfUkVTUE9OU0VfQ0FDSEUpIHtcbiAgICAgICAgdmFyaWFibGVzLk9DU1BfUkVTUE9OU0VfQ0FDSEUgPSBuZXcgT2NzcFJlc3BvbnNlQ2FjaGUuT2NzcFJlc3BvbnNlQ2FjaGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlcy5PQ1NQX1JFU1BPTlNFX0NBQ0hFO1xufVxuZXhwb3J0cy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4vKipcbiAqIFNlY3VyZXMgYSBnaXZlbiBUTFNTb2NrZXQgYnkgYmxvY2tpbmcgYWxsIHdyaXRlcyB1bnRpbCB0aGUgY2VydGlmaWNhdGVcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgc29ja2V0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc29ja2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gaG9zdFxuICogQHBhcmFtIHtPYmplY3R8bnVsbH0gYWdlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbW9ja11cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLnNlY3VyZVNvY2tldCA9IGZ1bmN0aW9uIChzb2NrZXQsIGhvc3QsIGFnZW50LCBtb2NrKSB7XG4gICAgLy8gaWYgb2NzcCB2YWxpZGF0aW9uIGlzIGRpc2FibGVkIGZvciB0aGUgZ2l2ZW4gaG9zdCwgcmV0dXJuIHRoZSBzb2NrZXQgYXMgaXNcbiAgICBpZiAoaXNPY3NwVmFsaWRhdGlvbkRpc2FibGVkKGhvc3QpKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdPQ1NQIHZhbGlkYXRpb24gZGlzYWJsZWQgZm9yICVzJywgaG9zdCk7XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxuICAgIGlmIChhZ2VudCAhPSBudWxsKSB7XG4gICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkuc2V0QWdlbnQoYWdlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChHbG9iYWxDb25maWcuaXNFbnZQcm94eUFjdGl2ZSgpKSB7XG4gICAgICAgIGNvbnN0IGh0dHBQcm94eSA9IFByb3h5VXRpbC5nZXRQcm94eUZyb21FbnYoZmFsc2UpO1xuICAgICAgICBpZiAoaHR0cFByb3h5ICYmICFQcm94eVV0aWwuaXNCeVBhc3NQcm94eShodHRwUHJveHksIFJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVCkpIHtcbiAgICAgICAgICAgIGFnZW50ID0gUHJveHlBZ2VudChodHRwUHJveHkpO1xuICAgICAgICAgICAgZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5zZXRBZ2VudChhZ2VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIGZvciB0aGUgc2VjdXJlIGV2ZW50XG4gICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcihzb2NrZXRTZWN1cmVkRXZlbnQsIHZhbGlkYXRlKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ3NvY2tldCByZXVzZWQgPSAlcycsIHNvY2tldC5pc1Nlc3Npb25SZXVzZWQoKSk7XG4gICAgICAgIC8vIGlmIHRoZSBzZXJ2ZXIgaGFzIHJlc3VtZWQgb3VyIGV4aXN0aW5nIHNlc3Npb24sIHVuYmxvY2sgYWxsXG4gICAgICAgIC8vIHdyaXRlcyB3aXRob3V0IHBlcmZvcm1pbmcgYW55IGFkZGl0aW9uYWwgdmFsaWRhdGlvblxuICAgICAgICBpZiAoc29ja2V0LmlzU2Vzc2lvblJldXNlZCgpKSB7XG4gICAgICAgICAgICBzb2NrZXQudW5jb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNvY2tldC5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignU29ja2V0IGlzIG5vdCBhdXRob3JpemVkOiAlcycsIHNvY2tldC5hdXRob3JpemF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveShzb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSBvY3NwIHRvIG1ha2Ugc3VyZSB0aGUgZW50aXJlIGNlcnRpZmljYXRlIGNoYWluIGNhbiBiZSB0cnVzdGVkXG4gICAgICAgICAgICBjb25zdCBjZXJ0Q2hhaW4gPSBzb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgdmNjID0gbW9jayA/IG1vY2sudmFsaWRhdGVDZXJ0Q2hhaW4gOiB2YWxpZGF0ZUNlcnRDaGFpbjtcbiAgICAgICAgICAgIHZjYyhjZXJ0Q2hhaW4sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLnJlc2V0Q2FjaGVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYW4gZXJyb3IsIGRlc3Ryb3kgdGhlIHNvY2tldFxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignT0NTUCB2YWxpZGF0aW9uIGZhaWxlZDogJXMnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LmRlc3Ryb3koZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ09DU1AgdmFsaWRhdGlvbiBzdWNjZWVkZWQgZm9yICVzJywgaG9zdCk7XG4gICAgICAgICAgICAgICAgLy8gdW5ibG9jayBhbGwgd3JpdGVzXG4gICAgICAgICAgICAgICAgc29ja2V0LnVuY29yaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHdoZW4gdGhlIHNvY2tldCBpcyBzZWN1cmUsIHBlcmZvcm0gYWRkaXRpb25hbCB2YWxpZGF0aW9uXG4gICAgc29ja2V0Lm9uKHNvY2tldFNlY3VyZWRFdmVudCwgdmFsaWRhdGUpO1xuICAgIC8vIGJsb2NrIGFsbCB3cml0ZXMgdW50aWwgdmFsaWRhdGlvbiBpcyBjb21wbGV0ZVxuICAgIHNvY2tldC5jb3JrKCk7XG4gICAgcmV0dXJuIHNvY2tldDtcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgb2NzcCB2YWxpZGF0aW9uIGlzIGRpc2FibGVkIGZvciBhIGdpdmVuIGhvc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhvc3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc09jc3BWYWxpZGF0aW9uRGlzYWJsZWQoaG9zdCkge1xuICAgIC8vIG9jc3AgaXMgZGlzYWJsZWQgaWYgaW5zZWN1cmUtY29ubmVjdCBpcyBlbmFibGVkLCBvciBpZiB3ZSd2ZSBkaXNhYmxlZCBvY3NwXG4gICAgLy8gZm9yIG5vbi1zbm93Zmxha2UgZW5kcG9pbnRzIGFuZCB0aGUgaG9zdCBpcyBhIG5vbi1zbm93Zmxha2UgZW5kcG9pbnRcbiAgICByZXR1cm4gKEdsb2JhbENvbmZpZy5pc09DU1BDaGVja3NEaXNhYmxlZCgpIHx8XG4gICAgICAgIChQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuSlNfRFJJVkVSX0RJU0FCTEVfT0NTUF9GT1JfTk9OX1NGX0VORFBPSU5UUykgJiZcbiAgICAgICAgICAgICFSRUdFWF9TTk9XRkxBS0VfRU5EUE9JTlQudGVzdChob3N0KSkpO1xufVxuLyoqXG4gKiBJcyB2YWxpZCBPQ1NQIGVycm9yIGZvciBjYWNoZVxuICogQHBhcmFtIGVyclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRPQ1NQRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIChlcnIgJiYgKGVyci5jb2RlID09PSBFcnJvckNvZGVzLkVSUl9PQ1NQX1JFVk9LRUQgfHwgZXJyLmNvZGUgPT09IEVycm9yQ29kZXMuRVJSX09DU1BfVU5LTk9XTikpO1xufVxuLyoqXG4gKiBSZXR1cm4gZXJyIGlmIGFueSB2YWxpZCBlcnJvciBpcyBmb3VuZC5cbiAqIEBwYXJhbSBlcnJvcnNcbiAqIEByZXR1cm5zIHtudWxsfCp9XG4gKi9cbmZ1bmN0aW9uIGNhbkVhcmx5RXhpdEZvck9DU1AoZXJyb3JzKSB7XG4gICAgaWYgKEdsb2JhbENvbmZpZy5nZXRPY3NwTW9kZSgpID09PSBHbG9iYWxDb25maWcub2NzcE1vZGVzLkZBSUxfQ0xPU0VEKSB7XG4gICAgICAgIGZvciAobGV0IGVycm9ySW5kZXggPSAwLCBsZW5ndGggPSBlcnJvcnMubGVuZ3RoOyBlcnJvckluZGV4IDwgbGVuZ3RoOyBlcnJvckluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGVycm9yXG4gICAgICAgICAgICBjb25zdCBlcnIgPSBlcnJvcnNbZXJyb3JJbmRleF07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsICdlcnInKSA/IGVyci5lcnIgOiBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBhbnlSZXZva2VkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZXJyb3JJbmRleCA9IDAsIGxlbmd0aCA9IGVycm9ycy5sZW5ndGg7IGVycm9ySW5kZXggPCBsZW5ndGg7IGVycm9ySW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZmlyc3QgZXJyb3JcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGVycm9yc1tlcnJvckluZGV4XTtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgIWlzVmFsaWRPQ1NQRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgIC8vIGFueSBvZiB0aGUgZXJyb3JzIGlzIE5PVCBnb29kL3Jldm9rZWQvdW5rbm93blxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBPQ1NQIHJlc3BvbmRlciBkaWRuJ3QgcmVzcG9uZCBjb3JyZWN0bHkuIEFzc3VtaW5nIGNlcnRpZmljYXRlIGlzIG5vdCByZXZva2VkLiBEZXRhaWxzOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gRXJyb3JDb2Rlcy5FUlJfT0NTUF9SRVZPS0VEKSB7XG4gICAgICAgICAgICAgICAgYW55UmV2b2tlZCA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW55UmV2b2tlZDtcbiAgICB9XG59XG5leHBvcnRzLmNhbkVhcmx5RXhpdEZvck9DU1AgPSBjYW5FYXJseUV4aXRGb3JPQ1NQO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBjZXJ0aWZpY2F0ZSBjaGFpbiB1c2luZyBPQ1NQLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjZXJ0IGEgdG9wLWxldmVsIGNlcnQgdGhhdCByZXByZXNlbnRzIHRoZSBsZWFmIG9mIGFcbiAqICAgY2VydGlmaWNhdGUgY2hhaW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgdGhlIHZhbGlkYXRpb24gaXMgY29tcGxldGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2VydENoYWluKGNlcnQsIGNiKSB7XG4gICAgLy8gd2FsayB1cCB0aGUgY2VydGlmaWNhdGUgY2hhaW4gYW5kIGNvbGxlY3QgYWxsIHRoZSBjZXJ0aWZpY2F0ZXMgaW4gYW4gYXJyYXlcbiAgICBjb25zdCBjZXJ0cyA9IFtdO1xuICAgIHdoaWxlIChjZXJ0ICYmXG4gICAgICAgIGNlcnQuaXNzdWVyQ2VydGlmaWNhdGUgJiZcbiAgICAgICAgY2VydC5maW5nZXJwcmludCAhPT0gY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZS5maW5nZXJwcmludCkge1xuICAgICAgICBjZXJ0cy5wdXNoKGNlcnQpO1xuICAgICAgICBjZXJ0ID0gY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGFuIGFycmF5IHRvIHN0b3JlIGFueSBlcnJvcnMgZW5jb3VudGVyZWRcbiAgICAvLyB3aGlsZSB2YWxpZGF0aW5nIHRoZSBjZXJ0aWZpY2F0ZSBjaGFpblxuICAgIGNvbnN0IGVycm9ycyA9IG5ldyBBcnJheShjZXJ0cy5sZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBmb3IgZXZlcnkgY2VydGlmaWNhdGUgYXMgd2UgdHJhdmVyc2UgdGhlIGNlcnRpZmljYXRlIGNoYWluIGFuZFxuICAgICAqIHZhbGlkYXRlIGVhY2ggb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnRzXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgY29uc3QgZWFjaENhbGxiYWNrID0gZnVuY3Rpb24gKGNlcnRzLCBpbmRleCkge1xuICAgICAgICBjb25zdCBjZXJ0ID0gY2VydHNbaW5kZXhdO1xuICAgICAgICB2YWxpZGF0ZUNlcnQoY2VydCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgY29tcGxldGVkKys7XG4gICAgICAgICAgICBlcnJvcnNbaW5kZXhdID0gZXJyO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIG9jc3AgcmVzcG9uc2UsIGNhY2hlIGl0XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAoIWRhdGEuZXJyIHx8IGlzVmFsaWRPQ1NQRXJyb3IoZGF0YS5lcnIpKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGNhY2hlIGlzIGluaXRpYWxpemVkIGJlZm9yZSBzZXR0aW5nIGVudHJ5XG4gICAgICAgICAgICAgICAgaWYgKGdldE9jc3BSZXNwb25zZUNhY2hlKCkuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkuc2V0KGNlcnQsIGRhdGEucmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkuaW5pdENhY2hlKGNlcnQsIGRhdGEucmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGRhdGEuZXJyO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnNbaW5kZXhdID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVxdWVzdCB0byBjb21wbGV0ZVxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gY2VydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRFcnJvciA9IGNhbkVhcmx5RXhpdEZvck9DU1AoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBjYih2YWxpZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBmaXJlIG9mZiByZXF1ZXN0cyB0byB2YWxpZGF0ZSBhbGwgdGhlIGNlcnRpZmljYXRlcyBpbiB0aGUgY2hhaW5cbiAgICBsZXQgY29tcGxldGVkID0gMDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IGNlcnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgZWFjaENhbGxiYWNrKGNlcnRzLCBpbmRleCk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBjZXJ0aWZpY2F0ZSB1c2luZyBPQ1NQLlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBjYiB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgdGhlIHZhbGlkYXRpb24gaXMgY29tcGxldGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2VydChjZXJ0LCBjYikge1xuICAgIGZ1bmN0aW9uIGdldE9jc3BDYWNoZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5kb3dubG9hZENhY2hlKGdldE9jc3BSZXNvbnNlQW5kVmVyaWZ5KSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZ2V0T2NzcENhY2hlLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbmQgVmVyaWZpZXMgT0NTUCBSZXNwb25zZVxuICAgICAqIEBwYXJhbSBlcnIge29iamVjdH1cbiAgICAgKiBAcGFyYW0gdXNlQ2FjaGVTZXJ2ZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T2NzcFJlc29uc2VBbmRWZXJpZnkoZXJyLCB1c2VDYWNoZVNlcnZlcikge1xuICAgICAgICBpZiAoIXVzZUNhY2hlU2VydmVyICYmICFnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLmlzRG93bmxvYWRGaW5pc2hlZCgpKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGdldE9jc3BSZXNvbnNlQW5kVmVyaWZ5LCAxMCk7IC8vIG1zXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY29kZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVkID0gQ2VydFV0aWwuZGVjb2RlKGNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvY3NwUmVzcG9uc2U7XG4gICAgICAgIC8vIGNoZWNrIGlmIGNhY2hlIGlzIGluaXRpYWxpemVkIGJlZm9yZSBnZXR0aW5nIGVudHJ5XG4gICAgICAgIGlmIChnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgaWYgKGdldE9jc3BSZXNwb25zZUNhY2hlKCkuSXNDYWNoZUV4cGlyZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNhY2hlIHN0YXR1cyBzbyBpdCBjYW4gYmUgcmVmcmVzaGVkXG4gICAgICAgICAgICAgICAgZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5yZXNldENhY2hlU3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSB2YWxpZCBlbnRyeSBpbiB0aGUgY2FjaGUsIHVzZSBpdFxuICAgICAgICAgICAgICAgIG9jc3BSZXNwb25zZSA9IGdldE9jc3BSZXNwb25zZUNhY2hlKCkuZ2V0KGNlcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvY3NwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXR1cm5pbmcgT0NTUCBzdGF0dXMgZm9yIGNlcnRpZmljYXRlICVzIGZyb20gY2FjaGUnLCBjZXJ0LnNlcmlhbE51bWJlcik7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBDZXJ0VXRpbC52ZXJpZnlPQ1NQUmVzcG9uc2UoZGVjb2RlZC5pc3N1ZXIsIG9jc3BSZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXR1cy5lcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB2ZXJpZmljYXRpb24gd2FzIHN1Y2Nlc3Mgd2l0aCB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2ZXJpZmljYXRpb24gd2FzIGZhaWx1cmUgd2l0aCB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2Ioc3RhdHVzLmVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodXNlQ2FjaGVTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0T2NzcENhY2hlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBDaGVjayhkZWNvZGVkLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF2YXJpYWJsZXMuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfRU5BQkxFRCkge1xuICAgICAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLmZvcmNlRG93bmxvYWRUb0ZpbmlzaCgpO1xuICAgIH1cbiAgICBnZXRPY3NwUmVzb25zZUFuZFZlcmlmeShudWxsLCB2YXJpYWJsZXMuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfRU5BQkxFRCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2NrZXRfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/socket_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst mfaAuthenticator = (__webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\").USER_PWD_MFA_AUTHENTICATOR);\n/**\n * Creates a default authenticator.\n *\n * @param {String} password\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthDefault(connectionConfig) {\n    const password = connectionConfig.password;\n    const mfaToken = connectionConfig.mfaToken;\n    const passcode = connectionConfig.getPasscode();\n    const isPasscodeInPassword = connectionConfig.getPasscodeInPassword();\n    /**\n     * Update JSON body with password or token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['PASSWORD'] = password;\n        if (isMFAAuth()) {\n            setMFASessionParams(body);\n        }\n    };\n    function isMFAAuth() {\n        return (connectionConfig.getAuthenticator() === mfaAuthenticator ||\n            mfaToken ||\n            passcode ||\n            isPasscodeInPassword);\n    }\n    function setMFASessionParams(body) {\n        body['data']['TOKEN'] = mfaToken;\n        body['data']['AUTHENTICATOR'] = mfaAuthenticator;\n        if (isPasscodeInPassword) {\n            body['data']['EXT_AUTHN_DUO_METHOD'] = 'passcode';\n            body['data']['passcodeInPassword'] = true;\n        }\n        else if (passcode) {\n            body['data']['EXT_AUTHN_DUO_METHOD'] = 'passcode';\n            body['data']['PASSCODE'] = passcode;\n        }\n        else {\n            body['data']['EXT_AUTHN_DUO_METHOD'] = 'push';\n        }\n    }\n    this.authenticate = async function () {\n        return;\n    };\n}\nmodule.exports = AuthDefault;\n//# sourceMappingURL=auth_default.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2RlZmF1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix5QkFBeUIsb0tBQTREO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9kZWZhdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbWZhQXV0aGVudGljYXRvciA9IHJlcXVpcmUoJy4vYXV0aGVudGljYXRpb25fdHlwZXMnKS5VU0VSX1BXRF9NRkFfQVVUSEVOVElDQVRPUjtcbi8qKlxuICogQ3JlYXRlcyBhIGRlZmF1bHQgYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhEZWZhdWx0KGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICBjb25zdCBwYXNzd29yZCA9IGNvbm5lY3Rpb25Db25maWcucGFzc3dvcmQ7XG4gICAgY29uc3QgbWZhVG9rZW4gPSBjb25uZWN0aW9uQ29uZmlnLm1mYVRva2VuO1xuICAgIGNvbnN0IHBhc3Njb2RlID0gY29ubmVjdGlvbkNvbmZpZy5nZXRQYXNzY29kZSgpO1xuICAgIGNvbnN0IGlzUGFzc2NvZGVJblBhc3N3b3JkID0gY29ubmVjdGlvbkNvbmZpZy5nZXRQYXNzY29kZUluUGFzc3dvcmQoKTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgSlNPTiBib2R5IHdpdGggcGFzc3dvcmQgb3IgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnUEFTU1dPUkQnXSA9IHBhc3N3b3JkO1xuICAgICAgICBpZiAoaXNNRkFBdXRoKCkpIHtcbiAgICAgICAgICAgIHNldE1GQVNlc3Npb25QYXJhbXMoYm9keSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzTUZBQXV0aCgpIHtcbiAgICAgICAgcmV0dXJuIChjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSA9PT0gbWZhQXV0aGVudGljYXRvciB8fFxuICAgICAgICAgICAgbWZhVG9rZW4gfHxcbiAgICAgICAgICAgIHBhc3Njb2RlIHx8XG4gICAgICAgICAgICBpc1Bhc3Njb2RlSW5QYXNzd29yZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldE1GQVNlc3Npb25QYXJhbXMoYm9keSkge1xuICAgICAgICBib2R5WydkYXRhJ11bJ1RPS0VOJ10gPSBtZmFUb2tlbjtcbiAgICAgICAgYm9keVsnZGF0YSddWydBVVRIRU5USUNBVE9SJ10gPSBtZmFBdXRoZW50aWNhdG9yO1xuICAgICAgICBpZiAoaXNQYXNzY29kZUluUGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGJvZHlbJ2RhdGEnXVsnRVhUX0FVVEhOX0RVT19NRVRIT0QnXSA9ICdwYXNzY29kZSc7XG4gICAgICAgICAgICBib2R5WydkYXRhJ11bJ3Bhc3Njb2RlSW5QYXNzd29yZCddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXNzY29kZSkge1xuICAgICAgICAgICAgYm9keVsnZGF0YSddWydFWFRfQVVUSE5fRFVPX01FVEhPRCddID0gJ3Bhc3Njb2RlJztcbiAgICAgICAgICAgIGJvZHlbJ2RhdGEnXVsnUEFTU0NPREUnXSA9IHBhc3Njb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keVsnZGF0YSddWydFWFRfQVVUSE5fRFVPX01FVEhPRCddID0gJ3B1c2gnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aERlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX2RlZmF1bHQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AuthWeb = __webpack_require__(/*! ./auth_web */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\n/**\n * Creates an ID token authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {module} webbrowser\n *\n * @returns {Object} the authenticator\n * @constructor\n */\nfunction AuthIDToken(connectionConfig, httpClient, webbrowser) {\n    this.idToken = connectionConfig.idToken;\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = this.idToken;\n        body['data']['AUTHENTICATOR'] = 'ID_TOKEN';\n    };\n    this.authenticate = async function () { };\n    this.reauthenticate = async function (body) {\n        const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n        await GlobalConfig.getCredentialManager().remove(key);\n        const auth = new AuthWeb(connectionConfig, httpClient, webbrowser);\n        await auth.authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username);\n        auth.updateBody(body);\n    };\n}\nmodule.exports = AuthIDToken;\n//# sourceMappingURL=auth_idtoken.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2lkdG9rZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBWTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsNEJBQTRCLG1CQUFPLENBQUMsa0hBQXdCO0FBQzVELHFCQUFxQixtQkFBTyxDQUFDLHNGQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9pZHRva2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQXV0aFdlYiA9IHJlcXVpcmUoJy4vYXV0aF93ZWInKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBBdXRoZW50aWNhdGlvblR5cGVzID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl90eXBlcycpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuLyoqXG4gKiBDcmVhdGVzIGFuIElEIHRva2VuIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge21vZHVsZX0gd2ViYnJvd3NlclxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBhdXRoZW50aWNhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aElEVG9rZW4oY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgd2ViYnJvd3Nlcikge1xuICAgIHRoaXMuaWRUb2tlbiA9IGNvbm5lY3Rpb25Db25maWcuaWRUb2tlbjtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgSlNPTiBib2R5IHdpdGggdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnVE9LRU4nXSA9IHRoaXMuaWRUb2tlbjtcbiAgICAgICAgYm9keVsnZGF0YSddWydBVVRIRU5USUNBVE9SJ10gPSAnSURfVE9LRU4nO1xuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7IH07XG4gICAgdGhpcy5yZWF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLklEX1RPS0VOX0FVVEhFTlRJQ0FUT1IpO1xuICAgICAgICBhd2FpdCBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS5yZW1vdmUoa2V5KTtcbiAgICAgICAgY29uc3QgYXV0aCA9IG5ldyBBdXRoV2ViKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIHdlYmJyb3dzZXIpO1xuICAgICAgICBhd2FpdCBhdXRoLmF1dGhlbnRpY2F0ZShjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRTZXJ2aWNlTmFtZSgpLCBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUpO1xuICAgICAgICBhdXRoLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aElEVG9rZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX2lkdG9rZW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst jwt = __webpack_require__(/*! jsonwebtoken */ \"(rsc)/./node_modules/jsonwebtoken/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\n/**\n * Creates a key-pair authenticator.\n *\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthKeypair(connectionConfig) {\n    let privateKey = connectionConfig.getPrivateKey();\n    const privateKeyPath = connectionConfig.getPrivateKeyPath();\n    const privateKeyPass = connectionConfig.getPrivateKeyPass();\n    let jwtToken;\n    const LIFETIME = 120; // seconds\n    const ALGORITHM = 'RS256';\n    const ISSUER = 'iss';\n    const SUBJECT = 'sub';\n    const EXPIRE_TIME = 'exp';\n    const ISSUE_TIME = 'iat';\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = jwtToken;\n    };\n    /**\n     * Load private key from specified file location.\n     *\n     * @param {String} privateKeyPath\n     * @param {String} privateKeyPass\n     *\n     * @returns {String} the private key.\n     */\n    function loadPrivateKey(privateKeyPath, privateKeyPass) {\n        // Load private key file\n        const privateKeyFile = fs.readFileSync(privateKeyPath);\n        let privateKeyObject;\n        // For encrypted private key\n        if (privateKeyPass) {\n            // Get private key with passphrase\n            privateKeyObject = crypto.createPrivateKey({\n                key: privateKeyFile,\n                format: 'pem',\n                passphrase: privateKeyPass,\n            });\n        }\n        else {\n            // For unencrypted private key\n            privateKeyObject = crypto.createPrivateKey({\n                key: privateKeyFile,\n                format: 'pem',\n            });\n        }\n        const privateKey = privateKeyObject.export({\n            format: 'pem',\n            type: 'pkcs8',\n        });\n        return privateKey;\n    }\n    /**\n     * Get public key fingerprint from private key.\n     *\n     * @param {String} privateKey\n     *\n     * @returns {String} the public key fingerprint.\n     */\n    function calculatePublicKeyFingerprint(privateKey) {\n        // Extract public key object from private key\n        const pubKeyObject = crypto.createPublicKey({\n            key: privateKey,\n            format: 'pem',\n        });\n        // Obtain public key string\n        const publicKey = pubKeyObject.export({\n            format: 'der',\n            type: 'spki',\n        });\n        // Generate SHA256 hash of public key and encode in base64\n        const publicKeyFingerprint = 'SHA256:' + crypto.createHash('sha256').update(publicKey, 'utf8').digest('base64');\n        return publicKeyFingerprint;\n    }\n    /**\n     * Generate JWT token using RS256 algorithm.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {null}\n     */\n    this.authenticate = async function (authenticator, serviceName, account, username) {\n        let publicKeyFingerprint;\n        // Use private key if already set in connection string, otherwise use private key file location\n        if (privateKey) {\n            // Get public key fingerprint\n            publicKeyFingerprint = calculatePublicKeyFingerprint(privateKey);\n        }\n        else if (privateKeyPath) {\n            // Extract private key and get fingerprint\n            privateKey = loadPrivateKey(privateKeyPath, privateKeyPass);\n            publicKeyFingerprint = calculatePublicKeyFingerprint(privateKey);\n        }\n        // Current time + 120 seconds\n        const currentTime = Date.now();\n        const jwtTokenExp = currentTime + LIFETIME * 1000;\n        // Create payload containing jwt token and lifetime span\n        const payload = {\n            [ISSUER]: util.format('%s.%s.%s', account.toUpperCase(), username.toUpperCase(), publicKeyFingerprint),\n            [SUBJECT]: util.format('%s.%s', account.toUpperCase(), username.toUpperCase()),\n            [ISSUE_TIME]: currentTime,\n            [EXPIRE_TIME]: jwtTokenExp,\n        };\n        // Sign payload with RS256 algorithm\n        jwtToken = jwt.sign(payload, privateKey, { algorithm: ALGORITHM });\n    };\n    this.reauthenticate = async function (body) {\n        this.authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username);\n        this.updateBody(body);\n    };\n}\nmodule.exports = AuthKeypair;\n//# sourceMappingURL=auth_keypair.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLGdFQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGp3dCA9IHJlcXVpcmUoJ2pzb253ZWJ0b2tlbicpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbi8qKlxuICogQ3JlYXRlcyBhIGtleS1wYWlyIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhLZXlwYWlyKGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICBsZXQgcHJpdmF0ZUtleSA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UHJpdmF0ZUtleSgpO1xuICAgIGNvbnN0IHByaXZhdGVLZXlQYXRoID0gY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5UGF0aCgpO1xuICAgIGNvbnN0IHByaXZhdGVLZXlQYXNzID0gY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5UGFzcygpO1xuICAgIGxldCBqd3RUb2tlbjtcbiAgICBjb25zdCBMSUZFVElNRSA9IDEyMDsgLy8gc2Vjb25kc1xuICAgIGNvbnN0IEFMR09SSVRITSA9ICdSUzI1Nic7XG4gICAgY29uc3QgSVNTVUVSID0gJ2lzcyc7XG4gICAgY29uc3QgU1VCSkVDVCA9ICdzdWInO1xuICAgIGNvbnN0IEVYUElSRV9USU1FID0gJ2V4cCc7XG4gICAgY29uc3QgSVNTVUVfVElNRSA9ICdpYXQnO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gand0VG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkIHByaXZhdGUga2V5IGZyb20gc3BlY2lmaWVkIGZpbGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpdmF0ZUtleVBhdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpdmF0ZUtleVBhc3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkUHJpdmF0ZUtleShwcml2YXRlS2V5UGF0aCwgcHJpdmF0ZUtleVBhc3MpIHtcbiAgICAgICAgLy8gTG9hZCBwcml2YXRlIGtleSBmaWxlXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXlGaWxlID0gZnMucmVhZEZpbGVTeW5jKHByaXZhdGVLZXlQYXRoKTtcbiAgICAgICAgbGV0IHByaXZhdGVLZXlPYmplY3Q7XG4gICAgICAgIC8vIEZvciBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKHByaXZhdGVLZXlQYXNzKSB7XG4gICAgICAgICAgICAvLyBHZXQgcHJpdmF0ZSBrZXkgd2l0aCBwYXNzcGhyYXNlXG4gICAgICAgICAgICBwcml2YXRlS2V5T2JqZWN0ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkoe1xuICAgICAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleUZpbGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAncGVtJyxcbiAgICAgICAgICAgICAgICBwYXNzcGhyYXNlOiBwcml2YXRlS2V5UGFzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIHVuZW5jcnlwdGVkIHByaXZhdGUga2V5XG4gICAgICAgICAgICBwcml2YXRlS2V5T2JqZWN0ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkoe1xuICAgICAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleUZpbGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAncGVtJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwcml2YXRlS2V5T2JqZWN0LmV4cG9ydCh7XG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nLFxuICAgICAgICAgICAgdHlwZTogJ3BrY3M4JyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcHVibGljIGtleSBmaW5nZXJwcmludCBmcm9tIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByaXZhdGVLZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBwdWJsaWMga2V5IGZpbmdlcnByaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVB1YmxpY0tleUZpbmdlcnByaW50KHByaXZhdGVLZXkpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBwdWJsaWMga2V5IG9iamVjdCBmcm9tIHByaXZhdGUga2V5XG4gICAgICAgIGNvbnN0IHB1YktleU9iamVjdCA9IGNyeXB0by5jcmVhdGVQdWJsaWNLZXkoe1xuICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5LFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9idGFpbiBwdWJsaWMga2V5IHN0cmluZ1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBwdWJLZXlPYmplY3QuZXhwb3J0KHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2RlcicsXG4gICAgICAgICAgICB0eXBlOiAnc3BraScsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBHZW5lcmF0ZSBTSEEyNTYgaGFzaCBvZiBwdWJsaWMga2V5IGFuZCBlbmNvZGUgaW4gYmFzZTY0XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleUZpbmdlcnByaW50ID0gJ1NIQTI1NjonICsgY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShwdWJsaWNLZXksICd1dGY4JykuZGlnZXN0KCdiYXNlNjQnKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleUZpbmdlcnByaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBKV1QgdG9rZW4gdXNpbmcgUlMyNTYgYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZU5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIHVzZXJuYW1lKSB7XG4gICAgICAgIGxldCBwdWJsaWNLZXlGaW5nZXJwcmludDtcbiAgICAgICAgLy8gVXNlIHByaXZhdGUga2V5IGlmIGFscmVhZHkgc2V0IGluIGNvbm5lY3Rpb24gc3RyaW5nLCBvdGhlcndpc2UgdXNlIHByaXZhdGUga2V5IGZpbGUgbG9jYXRpb25cbiAgICAgICAgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIC8vIEdldCBwdWJsaWMga2V5IGZpbmdlcnByaW50XG4gICAgICAgICAgICBwdWJsaWNLZXlGaW5nZXJwcmludCA9IGNhbGN1bGF0ZVB1YmxpY0tleUZpbmdlcnByaW50KHByaXZhdGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaXZhdGVLZXlQYXRoKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHByaXZhdGUga2V5IGFuZCBnZXQgZmluZ2VycHJpbnRcbiAgICAgICAgICAgIHByaXZhdGVLZXkgPSBsb2FkUHJpdmF0ZUtleShwcml2YXRlS2V5UGF0aCwgcHJpdmF0ZUtleVBhc3MpO1xuICAgICAgICAgICAgcHVibGljS2V5RmluZ2VycHJpbnQgPSBjYWxjdWxhdGVQdWJsaWNLZXlGaW5nZXJwcmludChwcml2YXRlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDdXJyZW50IHRpbWUgKyAxMjAgc2Vjb25kc1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGp3dFRva2VuRXhwID0gY3VycmVudFRpbWUgKyBMSUZFVElNRSAqIDEwMDA7XG4gICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGNvbnRhaW5pbmcgand0IHRva2VuIGFuZCBsaWZldGltZSBzcGFuXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBbSVNTVUVSXTogdXRpbC5mb3JtYXQoJyVzLiVzLiVzJywgYWNjb3VudC50b1VwcGVyQ2FzZSgpLCB1c2VybmFtZS50b1VwcGVyQ2FzZSgpLCBwdWJsaWNLZXlGaW5nZXJwcmludCksXG4gICAgICAgICAgICBbU1VCSkVDVF06IHV0aWwuZm9ybWF0KCclcy4lcycsIGFjY291bnQudG9VcHBlckNhc2UoKSwgdXNlcm5hbWUudG9VcHBlckNhc2UoKSksXG4gICAgICAgICAgICBbSVNTVUVfVElNRV06IGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgW0VYUElSRV9USU1FXTogand0VG9rZW5FeHAsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNpZ24gcGF5bG9hZCB3aXRoIFJTMjU2IGFsZ29yaXRobVxuICAgICAgICBqd3RUb2tlbiA9IGp3dC5zaWduKHBheWxvYWQsIHByaXZhdGVLZXksIHsgYWxnb3JpdGhtOiBBTEdPUklUSE0gfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGUoY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0U2VydmljZU5hbWUoKSwgY29ubmVjdGlvbkNvbmZpZy5hY2NvdW50LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lKTtcbiAgICAgICAgdGhpcy51cGRhdGVCb2R5KGJvZHkpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhLZXlwYWlyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF9rZXlwYWlyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * Creates an oauth authenticator.\n *\n * @param {String} token\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauth(token) {\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = token;\n    };\n    this.authenticate = async function () { };\n}\nmodule.exports = AuthOauth;\n//# sourceMappingURL=auth_oauth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDcmVhdGVzIGFuIG9hdXRoIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBdXRoT2F1dGgodG9rZW4pIHtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgSlNPTiBib2R5IHdpdGggdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnVE9LRU4nXSA9IHRva2VuO1xuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7IH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhPYXV0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfb2F1dGguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = (__webpack_require__(/*! ./../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst authUtil = __webpack_require__(/*! ../authentication/authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst { getFreePort, format } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst { withBrowserActionTimeout, writeToCache, removeFromCache, readCache, } = __webpack_require__(/*! ./authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst open = __webpack_require__(/*! open */ \"(rsc)/./node_modules/open/index.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\n/**\n * Creates an oauth authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauthAuthorizationCode(connectionConfig, httpClient) {\n    const DEFAULT_REDIRECT_HOST = 'http://127.0.0.1';\n    const browserActionTimeout = connectionConfig.getBrowserActionTimeout();\n    let oauth;\n    let token;\n    const clientId = connectionConfig.getOauthClientId();\n    const clientSecret = connectionConfig.getOauthClientSecret();\n    const authorizationUrl = getAuthorizationUrl(connectionConfig);\n    const tokenUrl = authUtil.getTokenUrl(connectionConfig);\n    const accessTokenKey = authUtil.buildOauthAccessTokenCacheKey(authorizationUrl.host, connectionConfig.username, AuthenticationTypes.OAUTH_AUTHORIZATION_CODE);\n    const refreshTokenKey = authUtil.buildOauthRefreshTokenCacheKey(tokenUrl.host, connectionConfig.username, AuthenticationTypes.OAUTH_AUTHORIZATION_CODE);\n    /**\n     * Update JSON body with token.\n     * @param {JSON} body\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        if (token) {\n            body.data.TOKEN = token;\n        }\n        body.data.AUTHENTICATOR = AuthenticationTypes.OAUTH_AUTHENTICATOR;\n        body.data.CLIENT_ENVIRONMENT.OAUTH_TYPE = AuthenticationTypes.OAUTH_AUTHORIZATION_CODE;\n    };\n    this.loadOauth4webapi = async function () {\n        if (!oauth) {\n            oauth = await Util.dynamicImportESMInTypescriptWithCommonJS('oauth4webapi');\n        }\n    };\n    this.authenticate = async function () {\n        globalThis.crypto ??= (__webpack_require__(/*! node:crypto */ \"node:crypto\").webcrypto);\n        //verify that there is access token in the cache\n        const accessTokenFromCache = await readCache(accessTokenKey);\n        //verify that there is refresh token in the cache\n        const refreshTokenFromCache = await readCache(refreshTokenKey);\n        if (accessTokenFromCache && connectionConfig.getClientStoreTemporaryCredential()) {\n            token = accessTokenFromCache;\n        }\n        else if (refreshTokenFromCache && connectionConfig.getClientStoreTemporaryCredential()) {\n            token = await this.getAccessTokenUsingRefreshToken(refreshTokenFromCache);\n        }\n        else {\n            token = await this.executeFullAuthorizationCodeFlow();\n        }\n    };\n    this.reauthenticate = async function (body) {\n        await removeFromCache(accessTokenKey);\n        const refreshToken = await readCache(refreshTokenKey);\n        if (refreshToken) {\n            try {\n                await this.getAccessTokenUsingRefreshToken(refreshToken);\n                this.updateBody(body);\n            }\n            catch (error) {\n                await removeFromCache(refreshTokenKey);\n                Logger().warn(format('Error while getting access token using refresh token. Message: %s. The refresh token is removed form cache - authentication must be proceed from the beginning', error.message));\n                await this.authenticate();\n                this.updateBody(body);\n            }\n        }\n        else {\n            await this.authenticate();\n            this.updateBody(body);\n        }\n    };\n    this.executeFullAuthorizationCodeFlow = async function () {\n        await this.loadOauth4webapi(); // import module using the dynamic import\n        const codeChallengeMethod = connectionConfig.getOauthChallengeMethod() || 'S256'; // TODO: should be verified with \"discovery\" response\n        //An issuer is a obligatory parameter in validation processed by oauth4webapi library, even when it isn't used\n        const issuer = connectionConfig.issuer || 'UNKNOWN';\n        const codeVerifier = oauth.generateRandomCodeVerifier();\n        const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);\n        const as = { issuer: issuer };\n        // eslint-disable-next-line camelcase\n        const client = { client_id: clientId };\n        const clientAuth = oauth.ClientSecretPost(clientSecret);\n        const redirectUri = await buildRedirectUri(connectionConfig);\n        const scope = await authUtil.prepareScope(connectionConfig);\n        const authorizationUrlWithParams = await prepareAuthorizationUrl(authorizationUrl, client, redirectUri, codeChallenge, codeChallengeMethod, as, scope);\n        const authorizationCodeResponse = await requestAuthorizationCode(authorizationUrlWithParams, browserActionTimeout);\n        const params = oauth.validateAuthResponse(as, client, authorizationUrlWithParams, authorizationCodeResponse.state);\n        params.set('code', authorizationCodeResponse.code);\n        Logger().trace('Requesting token');\n        const token = await requestToken(as, tokenUrl, client, clientAuth, params, redirectUri, codeVerifier);\n        return token;\n    };\n    this.getAccessTokenUsingRefreshToken = async function (refreshToken) {\n        globalThis.crypto ??= (__webpack_require__(/*! node:crypto */ \"node:crypto\").webcrypto);\n        await this.loadOauth4webapi(); // import module using the dynamic import\n        const issuer = connectionConfig.issuer || 'UNKNOWN';\n        const as = { issuer: issuer };\n        const clientId = connectionConfig.getOauthClientId();\n        const clientSecret = connectionConfig.getOauthClientSecret();\n        // eslint-disable-next-line camelcase\n        const client = { client_id: clientId };\n        const clientAuth = oauth.ClientSecretPost(clientSecret);\n        // Refresh Token Grant Request & Response\n        const tokenUrl = authUtil.getTokenUrl(connectionConfig);\n        Logger().trace(`Receiving new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n        as['token_endpoint'] = tokenUrl.href;\n        const response = await oauth.refreshTokenGrantRequest(as, client, clientAuth, refreshToken, {\n            [oauth.allowInsecureRequests]: connectionConfig.getOauthHttpAllowed(),\n            [oauth.customFetch]: async (url, options) => await convertToResponseType(httpClient, url, options),\n        });\n        const result = await oauth.processRefreshTokenResponse(as, client, response);\n        if (result.access_token) {\n            //cache access token\n            Logger().debug(`Received new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n            await writeToCache(accessTokenKey, result.access_token);\n            //cache refreshToken if exists\n            if (result.refresh_token) {\n                //cache refresh token\n                Logger().debug(`Received new OAuth refresh token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n                await writeToCache(refreshTokenKey, result.refresh_token);\n            }\n            else {\n                Logger().warn('There is no refresh_token value to write to cache. Clearing refresh token in cache');\n                await removeFromCache(refreshTokenKey);\n            }\n        }\n        else {\n            throw Error(`Response doesn't contain OAuth access token. Requested URI: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n        }\n        return result.access_token;\n    };\n    async function prepareAuthorizationUrl(authorizationUrl, client, redirectUri, codeChallenge, codeChallengeMethod, as, scope) {\n        authorizationUrl.searchParams.set('client_id', client.client_id);\n        authorizationUrl.searchParams.set('redirect_uri', redirectUri);\n        authorizationUrl.searchParams.set('response_type', 'code');\n        authorizationUrl.searchParams.set('scope', scope);\n        authorizationUrl.searchParams.set('code_challenge', codeChallenge);\n        authorizationUrl.searchParams.set('code_challenge_method', codeChallengeMethod);\n        /**\n         * We cannot be sure PKCE is supported then the state should be used.\n         */\n        if (as.code_challenge_methods_supported?.includes('S256') !== true) {\n            const state = oauth.generateRandomState();\n            authorizationUrl.searchParams.set('state', state);\n        }\n        return authorizationUrl;\n    }\n    async function verifyPortIsAvailable(server, redirectPort) {\n        return Util.isPortOpen(redirectPort).catch((rejected) => {\n            server.close();\n            throw new Error(`Cannot run server using provided redirect url. ${rejected}`);\n        });\n    }\n    async function requestAuthorizationCode(authorizationUrl, browserActionTimeout) {\n        if (!Util.number.isPositiveInteger(browserActionTimeout)) {\n            throw new Error(`Invalid value for browser action timeout: ${browserActionTimeout}`);\n        }\n        let server;\n        const receiveData = new Promise((resolve, reject) => {\n            server = authUtil.createServer(resolve, reject);\n        }).then((result) => {\n            return result;\n        });\n        const redirectUri = new URL(authorizationUrl.searchParams.get('redirect_uri'));\n        await verifyPortIsAvailable(server, redirectUri.port);\n        server.listen(redirectUri.port || 0, 0);\n        const authorizationCodeProvider = GlobalConfig.getCustomRedirectingClient();\n        const codeProvider = authorizationCodeProvider\n            ? authorizationCodeProvider\n            : browserAuthorizationCodeProvider;\n        await codeProvider(authorizationUrl);\n        const codeResponse = await withBrowserActionTimeout(browserActionTimeout, receiveData).catch((rejected) => {\n            server.close();\n            throw new Error(rejected);\n        });\n        const autorizationCodeResponseParameters = querystring.parse(codeResponse.substring(codeResponse.indexOf('?') + 1));\n        const code = autorizationCodeResponseParameters['code'];\n        const state = autorizationCodeResponseParameters['state'].replace(new RegExp('\\\\sHTTP/.*'), '');\n        Logger().debug(`Received new OAuth authorization code from: Host: ${authorizationUrl.host} Path: ${authorizationUrl.pathname}`);\n        return { code: code, state: state };\n    }\n    async function convertToResponseType(httpClient, url, options) {\n        function asResponseType(response) {\n            return new Response(response.json, {\n                staus: response.statusCode,\n                statusText: response.statusText,\n                headers: response.headers,\n            });\n        }\n        options.url = url;\n        return asResponseType(await httpClient.requestAsync(options));\n    }\n    async function requestToken(as, tokenUrl, client, clientAuth, params, redirectUri, codeVerifier) {\n        try {\n            Logger().trace(`Receiving new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n            as['token_endpoint'] = tokenUrl.href;\n            const response = await oauth.authorizationCodeGrantRequest(as, client, clientAuth, params, redirectUri, codeVerifier, {\n                [oauth.allowInsecureRequests]: connectionConfig.getOauthHttpAllowed(),\n                [oauth.customFetch]: async (url, options) => await convertToResponseType(httpClient, url, options),\n                additionalParameters: connectionConfig.oauthEnableSingleUseRefreshTokens\n                    ? {\n                        // eslint-disable-next-line camelcase\n                        enable_single_use_refresh_tokens: 'true',\n                    }\n                    : undefined,\n            });\n            const result = await oauth.processAuthorizationCodeResponse(as, client, response);\n            if (result.access_token) {\n                //cache access token\n                Logger().debug(`Received new OAuth access token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n                await writeToCache(accessTokenKey, result.access_token);\n                //cache refreshToken if exists\n                if (result.refresh_token) {\n                    //cache refresh token\n                    Logger().debug(`Received new OAuth refresh token from: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n                    await writeToCache(refreshTokenKey, result.refresh_token);\n                }\n            }\n            else {\n                throw Error(`Response doesn't contain OAuth access token. Requested URI: Host: ${tokenUrl.host} Path: ${tokenUrl.pathname}`);\n            }\n            return result.access_token;\n        }\n        catch (error) {\n            throw new Error(format('Error while getting access token. Message: %s', error.message));\n        }\n    }\n    function getAuthorizationUrl(options) {\n        const authCodeUrl = options.getOauthAuthorizationUrl();\n        Logger().debug(`Url used for receiving authorization code: ${authCodeUrl}`);\n        return new URL(authCodeUrl);\n    }\n    async function buildRedirectUri(options) {\n        const redirectUri = options.getOauthRedirectUri() || (await createDefaultRedirectUri());\n        Logger().debug(`Authorization code redirect URL: ${redirectUri}`);\n        return redirectUri;\n    }\n    async function createDefaultRedirectUri() {\n        const redirectPort = await getFreePort();\n        return `${DEFAULT_REDIRECT_HOST}:${redirectPort}`;\n    }\n    async function browserAuthorizationCodeProvider(authorizationUrl) {\n        Logger().debug(`Opening your browser to obtain the authorization code: ${authorizationUrl}`);\n        return open(authorizationUrl.href);\n    }\n}\nmodule.exports = AuthOauthAuthorizationCode;\n//# sourceMappingURL=auth_oauth_authorization_code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2F1dGhvcml6YXRpb25fY29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsNEdBQThCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLGdJQUF1QztBQUNoRSxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsb0VBQVM7QUFDakQsUUFBUSxzRUFBc0UsRUFBRSxtQkFBTyxDQUFDLGdIQUF1QjtBQUMvRyxvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGdEQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5Qiw0QkFBNEIsbUJBQU8sQ0FBQyxrSEFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBZ0M7QUFDOUQsdUNBQXVDO0FBQ3ZDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZUFBZSxRQUFRLGtCQUFrQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZSxRQUFRLGtCQUFrQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlLFFBQVEsa0JBQWtCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBZSxRQUFRLGtCQUFrQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxTQUFTO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUscUJBQXFCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHVCQUF1QixRQUFRLDBCQUEwQjtBQUNySSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGVBQWUsUUFBUSxrQkFBa0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGVBQWUsUUFBUSxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsZUFBZSxRQUFRLGtCQUFrQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlLFFBQVEsa0JBQWtCO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCLEdBQUcsYUFBYTtBQUN4RDtBQUNBO0FBQ0EsaUZBQWlGLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2F1dGhvcml6YXRpb25fY29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vLi4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IGF1dGhVdGlsID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdXRpbCcpO1xuY29uc3QgeyBnZXRGcmVlUG9ydCwgZm9ybWF0IH0gPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB7IHdpdGhCcm93c2VyQWN0aW9uVGltZW91dCwgd3JpdGVUb0NhY2hlLCByZW1vdmVGcm9tQ2FjaGUsIHJlYWRDYWNoZSwgfSA9IHJlcXVpcmUoJy4vYXV0aGVudGljYXRpb25fdXRpbCcpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3Qgb3BlbiA9IHJlcXVpcmUoJ29wZW4nKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBBdXRoZW50aWNhdGlvblR5cGVzID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl90eXBlcycpO1xuLyoqXG4gKiBDcmVhdGVzIGFuIG9hdXRoIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBdXRoT2F1dGhBdXRob3JpemF0aW9uQ29kZShjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50KSB7XG4gICAgY29uc3QgREVGQVVMVF9SRURJUkVDVF9IT1NUID0gJ2h0dHA6Ly8xMjcuMC4wLjEnO1xuICAgIGNvbnN0IGJyb3dzZXJBY3Rpb25UaW1lb3V0ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRCcm93c2VyQWN0aW9uVGltZW91dCgpO1xuICAgIGxldCBvYXV0aDtcbiAgICBsZXQgdG9rZW47XG4gICAgY29uc3QgY2xpZW50SWQgPSBjb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoQ2xpZW50SWQoKTtcbiAgICBjb25zdCBjbGllbnRTZWNyZXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoQ2xpZW50U2VjcmV0KCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvblVybCA9IGdldEF1dGhvcml6YXRpb25VcmwoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgY29uc3QgdG9rZW5VcmwgPSBhdXRoVXRpbC5nZXRUb2tlblVybChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBhY2Nlc3NUb2tlbktleSA9IGF1dGhVdGlsLmJ1aWxkT2F1dGhBY2Nlc3NUb2tlbkNhY2hlS2V5KGF1dGhvcml6YXRpb25VcmwuaG9zdCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9BVVRIT1JJWkFUSU9OX0NPREUpO1xuICAgIGNvbnN0IHJlZnJlc2hUb2tlbktleSA9IGF1dGhVdGlsLmJ1aWxkT2F1dGhSZWZyZXNoVG9rZW5DYWNoZUtleSh0b2tlblVybC5ob3N0LCBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSk7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHRva2VuLlxuICAgICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgYm9keS5kYXRhLlRPS0VOID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5kYXRhLkFVVEhFTlRJQ0FUT1IgPSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhFTlRJQ0FUT1I7XG4gICAgICAgIGJvZHkuZGF0YS5DTElFTlRfRU5WSVJPTk1FTlQuT0FVVEhfVFlQRSA9IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSE9SSVpBVElPTl9DT0RFO1xuICAgIH07XG4gICAgdGhpcy5sb2FkT2F1dGg0d2ViYXBpID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIW9hdXRoKSB7XG4gICAgICAgICAgICBvYXV0aCA9IGF3YWl0IFV0aWwuZHluYW1pY0ltcG9ydEVTTUluVHlwZXNjcmlwdFdpdGhDb21tb25KUygnb2F1dGg0d2ViYXBpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0byA/Pz0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKS53ZWJjcnlwdG87XG4gICAgICAgIC8vdmVyaWZ5IHRoYXQgdGhlcmUgaXMgYWNjZXNzIHRva2VuIGluIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbkZyb21DYWNoZSA9IGF3YWl0IHJlYWRDYWNoZShhY2Nlc3NUb2tlbktleSk7XG4gICAgICAgIC8vdmVyaWZ5IHRoYXQgdGhlcmUgaXMgcmVmcmVzaCB0b2tlbiBpbiB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuRnJvbUNhY2hlID0gYXdhaXQgcmVhZENhY2hlKHJlZnJlc2hUb2tlbktleSk7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbkZyb21DYWNoZSAmJiBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGFjY2Vzc1Rva2VuRnJvbUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZnJlc2hUb2tlbkZyb21DYWNoZSAmJiBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW5Vc2luZ1JlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW5Gcm9tQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW4gPSBhd2FpdCB0aGlzLmV4ZWN1dGVGdWxsQXV0aG9yaXphdGlvbkNvZGVGbG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVhdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBhd2FpdCByZW1vdmVGcm9tQ2FjaGUoYWNjZXNzVG9rZW5LZXkpO1xuICAgICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBhd2FpdCByZWFkQ2FjaGUocmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgaWYgKHJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuVXNpbmdSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVGcm9tQ2FjaGUocmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICBMb2dnZXIoKS53YXJuKGZvcm1hdCgnRXJyb3Igd2hpbGUgZ2V0dGluZyBhY2Nlc3MgdG9rZW4gdXNpbmcgcmVmcmVzaCB0b2tlbi4gTWVzc2FnZTogJXMuIFRoZSByZWZyZXNoIHRva2VuIGlzIHJlbW92ZWQgZm9ybSBjYWNoZSAtIGF1dGhlbnRpY2F0aW9uIG11c3QgYmUgcHJvY2VlZCBmcm9tIHRoZSBiZWdpbm5pbmcnLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCb2R5KGJvZHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmV4ZWN1dGVGdWxsQXV0aG9yaXphdGlvbkNvZGVGbG93ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRPYXV0aDR3ZWJhcGkoKTsgLy8gaW1wb3J0IG1vZHVsZSB1c2luZyB0aGUgZHluYW1pYyBpbXBvcnRcbiAgICAgICAgY29uc3QgY29kZUNoYWxsZW5nZU1ldGhvZCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0T2F1dGhDaGFsbGVuZ2VNZXRob2QoKSB8fCAnUzI1Nic7IC8vIFRPRE86IHNob3VsZCBiZSB2ZXJpZmllZCB3aXRoIFwiZGlzY292ZXJ5XCIgcmVzcG9uc2VcbiAgICAgICAgLy9BbiBpc3N1ZXIgaXMgYSBvYmxpZ2F0b3J5IHBhcmFtZXRlciBpbiB2YWxpZGF0aW9uIHByb2Nlc3NlZCBieSBvYXV0aDR3ZWJhcGkgbGlicmFyeSwgZXZlbiB3aGVuIGl0IGlzbid0IHVzZWRcbiAgICAgICAgY29uc3QgaXNzdWVyID0gY29ubmVjdGlvbkNvbmZpZy5pc3N1ZXIgfHwgJ1VOS05PV04nO1xuICAgICAgICBjb25zdCBjb2RlVmVyaWZpZXIgPSBvYXV0aC5nZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllcigpO1xuICAgICAgICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gYXdhaXQgb2F1dGguY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbiAgICAgICAgY29uc3QgYXMgPSB7IGlzc3VlcjogaXNzdWVyIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgY29uc3QgY2xpZW50ID0geyBjbGllbnRfaWQ6IGNsaWVudElkIH07XG4gICAgICAgIGNvbnN0IGNsaWVudEF1dGggPSBvYXV0aC5DbGllbnRTZWNyZXRQb3N0KGNsaWVudFNlY3JldCk7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gYXdhaXQgYnVpbGRSZWRpcmVjdFVyaShjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBhd2FpdCBhdXRoVXRpbC5wcmVwYXJlU2NvcGUoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25VcmxXaXRoUGFyYW1zID0gYXdhaXQgcHJlcGFyZUF1dGhvcml6YXRpb25VcmwoYXV0aG9yaXphdGlvblVybCwgY2xpZW50LCByZWRpcmVjdFVyaSwgY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZCwgYXMsIHNjb3BlKTtcbiAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBdXRob3JpemF0aW9uQ29kZShhdXRob3JpemF0aW9uVXJsV2l0aFBhcmFtcywgYnJvd3NlckFjdGlvblRpbWVvdXQpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBvYXV0aC52YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCBhdXRob3JpemF0aW9uVXJsV2l0aFBhcmFtcywgYXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZS5zdGF0ZSk7XG4gICAgICAgIHBhcmFtcy5zZXQoJ2NvZGUnLCBhdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlLmNvZGUpO1xuICAgICAgICBMb2dnZXIoKS50cmFjZSgnUmVxdWVzdGluZyB0b2tlbicpO1xuICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHJlcXVlc3RUb2tlbihhcywgdG9rZW5VcmwsIGNsaWVudCwgY2xpZW50QXV0aCwgcGFyYW1zLCByZWRpcmVjdFVyaSwgY29kZVZlcmlmaWVyKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG4gICAgdGhpcy5nZXRBY2Nlc3NUb2tlblVzaW5nUmVmcmVzaFRva2VuID0gYXN5bmMgZnVuY3Rpb24gKHJlZnJlc2hUb2tlbikge1xuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0byA/Pz0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKS53ZWJjcnlwdG87XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE9hdXRoNHdlYmFwaSgpOyAvLyBpbXBvcnQgbW9kdWxlIHVzaW5nIHRoZSBkeW5hbWljIGltcG9ydFxuICAgICAgICBjb25zdCBpc3N1ZXIgPSBjb25uZWN0aW9uQ29uZmlnLmlzc3VlciB8fCAnVU5LTk9XTic7XG4gICAgICAgIGNvbnN0IGFzID0geyBpc3N1ZXI6IGlzc3VlciB9O1xuICAgICAgICBjb25zdCBjbGllbnRJZCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0T2F1dGhDbGllbnRJZCgpO1xuICAgICAgICBjb25zdCBjbGllbnRTZWNyZXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldE9hdXRoQ2xpZW50U2VjcmV0KCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgY29uc3QgY2xpZW50ID0geyBjbGllbnRfaWQ6IGNsaWVudElkIH07XG4gICAgICAgIGNvbnN0IGNsaWVudEF1dGggPSBvYXV0aC5DbGllbnRTZWNyZXRQb3N0KGNsaWVudFNlY3JldCk7XG4gICAgICAgIC8vIFJlZnJlc2ggVG9rZW4gR3JhbnQgUmVxdWVzdCAmIFJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHRva2VuVXJsID0gYXV0aFV0aWwuZ2V0VG9rZW5VcmwoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIExvZ2dlcigpLnRyYWNlKGBSZWNlaXZpbmcgbmV3IE9BdXRoIGFjY2VzcyB0b2tlbiBmcm9tOiBIb3N0OiAke3Rva2VuVXJsLmhvc3R9IFBhdGg6ICR7dG9rZW5VcmwucGF0aG5hbWV9YCk7XG4gICAgICAgIGFzWyd0b2tlbl9lbmRwb2ludCddID0gdG9rZW5VcmwuaHJlZjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aC5yZWZyZXNoVG9rZW5HcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aCwgcmVmcmVzaFRva2VuLCB7XG4gICAgICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aEh0dHBBbGxvd2VkKCksXG4gICAgICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBhc3luYyAodXJsLCBvcHRpb25zKSA9PiBhd2FpdCBjb252ZXJ0VG9SZXNwb25zZVR5cGUoaHR0cENsaWVudCwgdXJsLCBvcHRpb25zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9hdXRoLnByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG4gICAgICAgIGlmIChyZXN1bHQuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAvL2NhY2hlIGFjY2VzcyB0b2tlblxuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFJlY2VpdmVkIG5ldyBPQXV0aCBhY2Nlc3MgdG9rZW4gZnJvbTogSG9zdDogJHt0b2tlblVybC5ob3N0fSBQYXRoOiAke3Rva2VuVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVUb0NhY2hlKGFjY2Vzc1Rva2VuS2V5LCByZXN1bHQuYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIC8vY2FjaGUgcmVmcmVzaFRva2VuIGlmIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgLy9jYWNoZSByZWZyZXNoIHRva2VuXG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFJlY2VpdmVkIG5ldyBPQXV0aCByZWZyZXNoIHRva2VuIGZyb206IEhvc3Q6ICR7dG9rZW5VcmwuaG9zdH0gUGF0aDogJHt0b2tlblVybC5wYXRobmFtZX1gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZVRvQ2FjaGUocmVmcmVzaFRva2VuS2V5LCByZXN1bHQucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIoKS53YXJuKCdUaGVyZSBpcyBubyByZWZyZXNoX3Rva2VuIHZhbHVlIHRvIHdyaXRlIHRvIGNhY2hlLiBDbGVhcmluZyByZWZyZXNoIHRva2VuIGluIGNhY2hlJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlRnJvbUNhY2hlKHJlZnJlc2hUb2tlbktleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgUmVzcG9uc2UgZG9lc24ndCBjb250YWluIE9BdXRoIGFjY2VzcyB0b2tlbi4gUmVxdWVzdGVkIFVSSTogSG9zdDogJHt0b2tlblVybC5ob3N0fSBQYXRoOiAke3Rva2VuVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuYWNjZXNzX3Rva2VuO1xuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUF1dGhvcml6YXRpb25VcmwoYXV0aG9yaXphdGlvblVybCwgY2xpZW50LCByZWRpcmVjdFVyaSwgY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZCwgYXMsIHNjb3BlKSB7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgncmVkaXJlY3RfdXJpJywgcmVkaXJlY3RVcmkpO1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Jlc3BvbnNlX3R5cGUnLCAnY29kZScpO1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Njb3BlJywgc2NvcGUpO1xuICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvZGVfY2hhbGxlbmdlJywgY29kZUNoYWxsZW5nZSk7XG4gICAgICAgIGF1dGhvcml6YXRpb25Vcmwuc2VhcmNoUGFyYW1zLnNldCgnY29kZV9jaGFsbGVuZ2VfbWV0aG9kJywgY29kZUNoYWxsZW5nZU1ldGhvZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBjYW5ub3QgYmUgc3VyZSBQS0NFIGlzIHN1cHBvcnRlZCB0aGVuIHRoZSBzdGF0ZSBzaG91bGQgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChhcy5jb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZD8uaW5jbHVkZXMoJ1MyNTYnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBvYXV0aC5nZW5lcmF0ZVJhbmRvbVN0YXRlKCk7XG4gICAgICAgICAgICBhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3N0YXRlJywgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uVXJsO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQb3J0SXNBdmFpbGFibGUoc2VydmVyLCByZWRpcmVjdFBvcnQpIHtcbiAgICAgICAgcmV0dXJuIFV0aWwuaXNQb3J0T3BlbihyZWRpcmVjdFBvcnQpLmNhdGNoKChyZWplY3RlZCkgPT4ge1xuICAgICAgICAgICAgc2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBydW4gc2VydmVyIHVzaW5nIHByb3ZpZGVkIHJlZGlyZWN0IHVybC4gJHtyZWplY3RlZH1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RBdXRob3JpemF0aW9uQ29kZShhdXRob3JpemF0aW9uVXJsLCBicm93c2VyQWN0aW9uVGltZW91dCkge1xuICAgICAgICBpZiAoIVV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKGJyb3dzZXJBY3Rpb25UaW1lb3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBicm93c2VyIGFjdGlvbiB0aW1lb3V0OiAke2Jyb3dzZXJBY3Rpb25UaW1lb3V0fWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXJ2ZXI7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVEYXRhID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2VydmVyID0gYXV0aFV0aWwuY3JlYXRlU2VydmVyKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gbmV3IFVSTChhdXRob3JpemF0aW9uVXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3JlZGlyZWN0X3VyaScpKTtcbiAgICAgICAgYXdhaXQgdmVyaWZ5UG9ydElzQXZhaWxhYmxlKHNlcnZlciwgcmVkaXJlY3RVcmkucG9ydCk7XG4gICAgICAgIHNlcnZlci5saXN0ZW4ocmVkaXJlY3RVcmkucG9ydCB8fCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbkNvZGVQcm92aWRlciA9IEdsb2JhbENvbmZpZy5nZXRDdXN0b21SZWRpcmVjdGluZ0NsaWVudCgpO1xuICAgICAgICBjb25zdCBjb2RlUHJvdmlkZXIgPSBhdXRob3JpemF0aW9uQ29kZVByb3ZpZGVyXG4gICAgICAgICAgICA/IGF1dGhvcml6YXRpb25Db2RlUHJvdmlkZXJcbiAgICAgICAgICAgIDogYnJvd3NlckF1dGhvcml6YXRpb25Db2RlUHJvdmlkZXI7XG4gICAgICAgIGF3YWl0IGNvZGVQcm92aWRlcihhdXRob3JpemF0aW9uVXJsKTtcbiAgICAgICAgY29uc3QgY29kZVJlc3BvbnNlID0gYXdhaXQgd2l0aEJyb3dzZXJBY3Rpb25UaW1lb3V0KGJyb3dzZXJBY3Rpb25UaW1lb3V0LCByZWNlaXZlRGF0YSkuY2F0Y2goKHJlamVjdGVkKSA9PiB7XG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWplY3RlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhdXRvcml6YXRpb25Db2RlUmVzcG9uc2VQYXJhbWV0ZXJzID0gcXVlcnlzdHJpbmcucGFyc2UoY29kZVJlc3BvbnNlLnN1YnN0cmluZyhjb2RlUmVzcG9uc2UuaW5kZXhPZignPycpICsgMSkpO1xuICAgICAgICBjb25zdCBjb2RlID0gYXV0b3JpemF0aW9uQ29kZVJlc3BvbnNlUGFyYW1ldGVyc1snY29kZSddO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGF1dG9yaXphdGlvbkNvZGVSZXNwb25zZVBhcmFtZXRlcnNbJ3N0YXRlJ10ucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcc0hUVFAvLionKSwgJycpO1xuICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgUmVjZWl2ZWQgbmV3IE9BdXRoIGF1dGhvcml6YXRpb24gY29kZSBmcm9tOiBIb3N0OiAke2F1dGhvcml6YXRpb25VcmwuaG9zdH0gUGF0aDogJHthdXRob3JpemF0aW9uVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICByZXR1cm4geyBjb2RlOiBjb2RlLCBzdGF0ZTogc3RhdGUgfTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gY29udmVydFRvUmVzcG9uc2VUeXBlKGh0dHBDbGllbnQsIHVybCwgb3B0aW9ucykge1xuICAgICAgICBmdW5jdGlvbiBhc1Jlc3BvbnNlVHlwZShyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZS5qc29uLCB7XG4gICAgICAgICAgICAgICAgc3RhdXM6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgIHJldHVybiBhc1Jlc3BvbnNlVHlwZShhd2FpdCBodHRwQ2xpZW50LnJlcXVlc3RBc3luYyhvcHRpb25zKSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RUb2tlbihhcywgdG9rZW5VcmwsIGNsaWVudCwgY2xpZW50QXV0aCwgcGFyYW1zLCByZWRpcmVjdFVyaSwgY29kZVZlcmlmaWVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBMb2dnZXIoKS50cmFjZShgUmVjZWl2aW5nIG5ldyBPQXV0aCBhY2Nlc3MgdG9rZW4gZnJvbTogSG9zdDogJHt0b2tlblVybC5ob3N0fSBQYXRoOiAke3Rva2VuVXJsLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgYXNbJ3Rva2VuX2VuZHBvaW50J10gPSB0b2tlblVybC5ocmVmO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aC5hdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjbGllbnRBdXRoLCBwYXJhbXMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIsIHtcbiAgICAgICAgICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aEh0dHBBbGxvd2VkKCksXG4gICAgICAgICAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogYXN5bmMgKHVybCwgb3B0aW9ucykgPT4gYXdhaXQgY29udmVydFRvUmVzcG9uc2VUeXBlKGh0dHBDbGllbnQsIHVybCwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IGNvbm5lY3Rpb25Db25maWcub2F1dGhFbmFibGVTaW5nbGVVc2VSZWZyZXNoVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlX3NpbmdsZV91c2VfcmVmcmVzaF90b2tlbnM6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb2F1dGgucHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvL2NhY2hlIGFjY2VzcyB0b2tlblxuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBSZWNlaXZlZCBuZXcgT0F1dGggYWNjZXNzIHRva2VuIGZyb206IEhvc3Q6ICR7dG9rZW5VcmwuaG9zdH0gUGF0aDogJHt0b2tlblVybC5wYXRobmFtZX1gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZVRvQ2FjaGUoYWNjZXNzVG9rZW5LZXksIHJlc3VsdC5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgIC8vY2FjaGUgcmVmcmVzaFRva2VuIGlmIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAvL2NhY2hlIHJlZnJlc2ggdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFJlY2VpdmVkIG5ldyBPQXV0aCByZWZyZXNoIHRva2VuIGZyb206IEhvc3Q6ICR7dG9rZW5VcmwuaG9zdH0gUGF0aDogJHt0b2tlblVybC5wYXRobmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVUb0NhY2hlKHJlZnJlc2hUb2tlbktleSwgcmVzdWx0LnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBSZXNwb25zZSBkb2Vzbid0IGNvbnRhaW4gT0F1dGggYWNjZXNzIHRva2VuLiBSZXF1ZXN0ZWQgVVJJOiBIb3N0OiAke3Rva2VuVXJsLmhvc3R9IFBhdGg6ICR7dG9rZW5VcmwucGF0aG5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmFjY2Vzc190b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ0Vycm9yIHdoaWxlIGdldHRpbmcgYWNjZXNzIHRva2VuLiBNZXNzYWdlOiAlcycsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRBdXRob3JpemF0aW9uVXJsKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXV0aENvZGVVcmwgPSBvcHRpb25zLmdldE9hdXRoQXV0aG9yaXphdGlvblVybCgpO1xuICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgVXJsIHVzZWQgZm9yIHJlY2VpdmluZyBhdXRob3JpemF0aW9uIGNvZGU6ICR7YXV0aENvZGVVcmx9YCk7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKGF1dGhDb2RlVXJsKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gYnVpbGRSZWRpcmVjdFVyaShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gb3B0aW9ucy5nZXRPYXV0aFJlZGlyZWN0VXJpKCkgfHwgKGF3YWl0IGNyZWF0ZURlZmF1bHRSZWRpcmVjdFVyaSgpKTtcbiAgICAgICAgTG9nZ2VyKCkuZGVidWcoYEF1dGhvcml6YXRpb24gY29kZSByZWRpcmVjdCBVUkw6ICR7cmVkaXJlY3RVcml9YCk7XG4gICAgICAgIHJldHVybiByZWRpcmVjdFVyaTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFJlZGlyZWN0VXJpKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdFBvcnQgPSBhd2FpdCBnZXRGcmVlUG9ydCgpO1xuICAgICAgICByZXR1cm4gYCR7REVGQVVMVF9SRURJUkVDVF9IT1NUfToke3JlZGlyZWN0UG9ydH1gO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBicm93c2VyQXV0aG9yaXphdGlvbkNvZGVQcm92aWRlcihhdXRob3JpemF0aW9uVXJsKSB7XG4gICAgICAgIExvZ2dlcigpLmRlYnVnKGBPcGVuaW5nIHlvdXIgYnJvd3NlciB0byBvYnRhaW4gdGhlIGF1dGhvcml6YXRpb24gY29kZTogJHthdXRob3JpemF0aW9uVXJsfWApO1xuICAgICAgICByZXR1cm4gb3BlbihhdXRob3JpemF0aW9uVXJsLmhyZWYpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aE9hdXRoQXV0aG9yaXphdGlvbkNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoX29hdXRoX2F1dGhvcml6YXRpb25fY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst authUtil = __importStar(__webpack_require__(/*! ../authentication/authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\"));\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst authentication_types_1 = __importDefault(__webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\"));\nclass AuthOauthClientCredentials {\n    connectionConfig;\n    httpClient;\n    _oauthImport;\n    token;\n    constructor(connectionConfig, httpClient) {\n        this.connectionConfig = connectionConfig;\n        this.httpClient = httpClient;\n    }\n    async getOauth4webapi() {\n        if (!this._oauthImport) {\n            this._oauthImport = await (0, util_1.dynamicImportESMInTypescriptWithCommonJS)('oauth4webapi');\n        }\n        return this._oauthImport;\n    }\n    updateBody(body) {\n        if (this.token) {\n            body.data.TOKEN = this.token;\n        }\n        body.data.AUTHENTICATOR = authentication_types_1.default.OAUTH_AUTHENTICATOR;\n        body.data.CLIENT_ENVIRONMENT.OAUTH_TYPE = authentication_types_1.default.OAUTH_CLIENT_CREDENTIALS;\n    }\n    async authenticate() {\n        const clientId = this.connectionConfig.getOauthClientId();\n        const clientSecret = this.connectionConfig.getOauthClientSecret();\n        const scope = await authUtil.prepareScope(this.connectionConfig);\n        const parameters = new URLSearchParams();\n        parameters.set('scope', scope);\n        this.token = await this.requestToken(clientId, clientSecret, parameters);\n    }\n    async requestToken(clientId, clientSecret, parameters) {\n        const oauth = await this.getOauth4webapi();\n        const tokenUrl = authUtil.getTokenUrl(this.connectionConfig);\n        const as = {\n            // An issuer is an obligatory parameter in validation processed by oauth4webapi library, even when it isn't used\n            issuer: 'UNKNOWN',\n            // eslint-disable-next-line camelcase\n            token_endpoint: tokenUrl.href,\n        };\n        const client = {\n            // eslint-disable-next-line camelcase\n            client_id: clientId,\n        };\n        try {\n            (0, logger_1.default)().debug(`Executing token request: ${tokenUrl.href}`);\n            const clientAuth = oauth.ClientSecretPost(clientSecret);\n            const response = await oauth.clientCredentialsGrantRequest(as, client, clientAuth, parameters, {\n                [oauth.allowInsecureRequests]: this.connectionConfig.getOauthHttpAllowed(),\n                [oauth.customFetch]: async (url, options) => {\n                    const response = await this.httpClient.requestAsync({ url, ...options });\n                    return new Response(response.json, {\n                        status: response.statusCode,\n                        statusText: response.statusText,\n                        headers: response.headers,\n                    });\n                },\n            });\n            const result = await oauth.processClientCredentialsResponse(as, client, response);\n            if (result.access_token) {\n                (0, logger_1.default)().debug(`Received new OAuth access token from: ${tokenUrl.href}`);\n            }\n            else {\n                throw Error(`Response doesn't contain OAuth access token. Requested URI: ${tokenUrl.href}`);\n            }\n            return result.access_token;\n        }\n        catch (error) {\n            throw new Error((0, util_1.format)('Error while getting access token. Message: %s', error.message));\n        }\n    }\n}\nexports[\"default\"] = AuthOauthClientCredentials;\n//# sourceMappingURL=auth_oauth_client_credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2NsaWVudF9jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLHdFQUFXO0FBQ3BELDhCQUE4QixtQkFBTyxDQUFDLGdJQUF1QztBQUM3RSxlQUFlLG1CQUFPLENBQUMsb0VBQVM7QUFDaEMsK0NBQStDLG1CQUFPLENBQUMsa0hBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBLDJGQUEyRixjQUFjO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX2NsaWVudF9jcmVkZW50aWFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xvZ2dlclwiKSk7XG5jb25zdCBhdXRoVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdXRpbFwiKSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGF1dGhlbnRpY2F0aW9uX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXV0aGVudGljYXRpb25fdHlwZXNcIikpO1xuY2xhc3MgQXV0aE9hdXRoQ2xpZW50Q3JlZGVudGlhbHMge1xuICAgIGNvbm5lY3Rpb25Db25maWc7XG4gICAgaHR0cENsaWVudDtcbiAgICBfb2F1dGhJbXBvcnQ7XG4gICAgdG9rZW47XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcgPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRPYXV0aDR3ZWJhcGkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb2F1dGhJbXBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX29hdXRoSW1wb3J0ID0gYXdhaXQgKDAsIHV0aWxfMS5keW5hbWljSW1wb3J0RVNNSW5UeXBlc2NyaXB0V2l0aENvbW1vbkpTKSgnb2F1dGg0d2ViYXBpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29hdXRoSW1wb3J0O1xuICAgIH1cbiAgICB1cGRhdGVCb2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgICAgIGJvZHkuZGF0YS5UT0tFTiA9IHRoaXMudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5kYXRhLkFVVEhFTlRJQ0FUT1IgPSBhdXRoZW50aWNhdGlvbl90eXBlc18xLmRlZmF1bHQuT0FVVEhfQVVUSEVOVElDQVRPUjtcbiAgICAgICAgYm9keS5kYXRhLkNMSUVOVF9FTlZJUk9OTUVOVC5PQVVUSF9UWVBFID0gYXV0aGVudGljYXRpb25fdHlwZXNfMS5kZWZhdWx0Lk9BVVRIX0NMSUVOVF9DUkVERU5USUFMUztcbiAgICB9XG4gICAgYXN5bmMgYXV0aGVudGljYXRlKCkge1xuICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aENsaWVudElkKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFNlY3JldCA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRPYXV0aENsaWVudFNlY3JldCgpO1xuICAgICAgICBjb25zdCBzY29wZSA9IGF3YWl0IGF1dGhVdGlsLnByZXBhcmVTY29wZSh0aGlzLmNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnc2NvcGUnLCBzY29wZSk7XG4gICAgICAgIHRoaXMudG9rZW4gPSBhd2FpdCB0aGlzLnJlcXVlc3RUb2tlbihjbGllbnRJZCwgY2xpZW50U2VjcmV0LCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdFRva2VuKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb2F1dGggPSBhd2FpdCB0aGlzLmdldE9hdXRoNHdlYmFwaSgpO1xuICAgICAgICBjb25zdCB0b2tlblVybCA9IGF1dGhVdGlsLmdldFRva2VuVXJsKHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGFzID0ge1xuICAgICAgICAgICAgLy8gQW4gaXNzdWVyIGlzIGFuIG9ibGlnYXRvcnkgcGFyYW1ldGVyIGluIHZhbGlkYXRpb24gcHJvY2Vzc2VkIGJ5IG9hdXRoNHdlYmFwaSBsaWJyYXJ5LCBldmVuIHdoZW4gaXQgaXNuJ3QgdXNlZFxuICAgICAgICAgICAgaXNzdWVyOiAnVU5LTk9XTicsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludDogdG9rZW5VcmwuaHJlZixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBFeGVjdXRpbmcgdG9rZW4gcmVxdWVzdDogJHt0b2tlblVybC5ocmVmfWApO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50QXV0aCA9IG9hdXRoLkNsaWVudFNlY3JldFBvc3QoY2xpZW50U2VjcmV0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGguY2xpZW50Q3JlZGVudGlhbHNHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgY2xpZW50QXV0aCwgcGFyYW1ldGVycywge1xuICAgICAgICAgICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0T2F1dGhIdHRwQWxsb3dlZCgpLFxuICAgICAgICAgICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGFzeW5jICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmh0dHBDbGllbnQucmVxdWVzdEFzeW5jKHsgdXJsLCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmpzb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvYXV0aC5wcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBSZWNlaXZlZCBuZXcgT0F1dGggYWNjZXNzIHRva2VuIGZyb206ICR7dG9rZW5VcmwuaHJlZn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBSZXNwb25zZSBkb2Vzbid0IGNvbnRhaW4gT0F1dGggYWNjZXNzIHRva2VuLiBSZXF1ZXN0ZWQgVVJJOiAke3Rva2VuVXJsLmhyZWZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmFjY2Vzc190b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoMCwgdXRpbF8xLmZvcm1hdCkoJ0Vycm9yIHdoaWxlIGdldHRpbmcgYWNjZXNzIHRva2VuLiBNZXNzYWdlOiAlcycsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGhPYXV0aENsaWVudENyZWRlbnRpYWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF9vYXV0aF9jbGllbnRfY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\n/**\n * Creates an oauth PAT  authenticator.\n *\n * @param {String} token\n * @param {String} password\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauthPAT(token, password) {\n    /**\n     * Update JSON body with token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        if (Util.exists(token)) {\n            body['data']['TOKEN'] = token;\n        }\n        else if (Util.exists(password)) {\n            body['data']['TOKEN'] = password;\n        }\n    };\n    this.authenticate = async function () { };\n}\nmodule.exports = AuthOauthPAT;\n//# sourceMappingURL=auth_oauth_pat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29hdXRoX3BhdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9vYXV0aF9wYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuLyoqXG4gKiBDcmVhdGVzIGFuIG9hdXRoIFBBVCAgYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aE9hdXRoUEFUKHRva2VuLCBwYXNzd29yZCkge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHRva2VuKSkge1xuICAgICAgICAgICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbC5leGlzdHMocGFzc3dvcmQpKSB7XG4gICAgICAgICAgICBib2R5WydkYXRhJ11bJ1RPS0VOJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7IH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhPYXV0aFBBVDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfb2F1dGhfcGF0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst rest = (__webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\").rest);\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * Creates an okta authenticator.\n *\n * @param {Object} connectionConfig\n * @param {HttpClient} httpClient\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOkta(connectionConfig, httpClient) {\n    const password = connectionConfig.password;\n    const region = connectionConfig.region;\n    const account = connectionConfig.account;\n    const clientAppId = connectionConfig.getClientType();\n    const clientAppVersion = connectionConfig.getClientVersion();\n    const host = util.constructHostname(region, account);\n    const port = rest.HTTPS_PORT;\n    const protocol = rest.HTTPS_PROTOCOL;\n    let user;\n    let ssoUrl;\n    let tokenUrl;\n    let samlResponse;\n    /**\n     * Update JSON body with saml response.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['RAW_SAML_RESPONSE'] = samlResponse;\n    };\n    /**\n     * Obtain saml response from Okta.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {null}\n     */\n    this.authenticate = async function (authenticator, serviceName, account, username) {\n        const response = await getAuthURLs(authenticator, serviceName, account, username);\n        const responseData = response['data'];\n        const success = responseData['success'];\n        const errorCode = responseData['code'];\n        const errorMessage = responseData['message'];\n        user = username;\n        if (typeof success === 'undefined' ||\n            errorCode === 'undefined' ||\n            errorMessage === 'undefined') {\n            throw new Error('Unable to use provided Okta address as an authenticator. Is the authenticator URL correct?');\n        }\n        if (success !== true) {\n            throw new Error(`Unable to use provided Okta address as an authenticator. Error code: ${errorCode}, error message: ${errorMessage}`);\n        }\n        ssoUrl = responseData['data']['ssoUrl'];\n        tokenUrl = responseData['data']['tokenUrl'];\n        this.validateURLs(authenticator, ssoUrl, tokenUrl);\n        const responseHtml = await getSAMLResponse(await createAccessToken(tokenUrl, username, password), ssoUrl);\n        validateSAML(responseHtml);\n    };\n    this.reauthenticate = async function (body, retryOption) {\n        const maxRetryTimeout = connectionConfig.getRetryTimeout();\n        const maxRetryCount = connectionConfig.getRetrySfMaxLoginRetries();\n        const remainingTimeout = (maxRetryTimeout - retryOption.totalElapsedTime) * 1000;\n        const startTime = Date.now();\n        const authRetryOption = {\n            maxRetryCount,\n            numRetries: retryOption.numRetries,\n            startTime,\n            remainingTimeout,\n            maxRetryTimeout,\n        };\n        let responseHtml;\n        while (util.shouldRetryOktaAuth(authRetryOption)) {\n            try {\n                responseHtml = await getSAMLResponse(await createAccessToken(tokenUrl, user, password), ssoUrl);\n                break;\n            }\n            catch (err) {\n                Logger.getInstance().debug('getSAMLResponse: refresh token for re-authentication');\n                authRetryOption.numRetries++;\n            }\n        }\n        if (remainingTimeout !== 0 && startTime + remainingTimeout < Date.now()) {\n            Logger.getInstance().warn(`getSAMLResponse: Fail to get SAML response, timeout reached: ${remainingTimeout} miliseconds`);\n            throw new Error('Reached out to the Login Timeout');\n        }\n        if (maxRetryCount < authRetryOption.numRetries) {\n            Logger.getInstance().warn(`getSAMLResponse: Fail to get SAML response, max retry reached: ${maxRetryCount} time`);\n            throw new Error('Reached out to the max retry count');\n        }\n        retryOption.totalElapsedTime += (Date.now() - startTime) / 1000;\n        retryOption.numRetries = authRetryOption.numRetries;\n        validateSAML(responseHtml);\n        this.updateBody(body);\n    };\n    /**\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {Object}\n     */\n    async function getAuthURLs(authenticator, serviceName, account, username) {\n        // Create URL to send POST request to\n        const url = protocol + '://' + host + '/session/authenticator-request';\n        let header;\n        if (serviceName) {\n            header = {\n                HTTP_HEADER_SERVICE_NAME: serviceName,\n            };\n        }\n        // JSON body to send with POST request\n        const body = {\n            data: {\n                ACCOUNT_NAME: account,\n                LOGIN_NAME: username,\n                PORT: port,\n                PROTOCOL: protocol,\n                AUTHENTICATOR: authenticator,\n                CLIENT_APP_ID: clientAppId,\n                CLIENT_APP_VERSION: clientAppVersion,\n            },\n        };\n        // POST request to get SSO URL and token URL\n        return await httpClient.post(url, body, {\n            headers: header,\n        });\n    }\n    /**\n     *\n     * @param {String} authenticator\n     * @param {String} ssoUrl\n     * @param {String} tokenUrl\n     *\n     * @returns {null}\n     */\n    this.validateURLs = function (authenticator, ssoUrl, tokenUrl) {\n        const compareUrlsByProtocolAndHost = (firstUrl, secondUrl) => firstUrl.protocol === secondUrl.protocol && firstUrl.host === secondUrl.host;\n        try {\n            const aUrl = new URL(authenticator);\n            const sUrl = new URL(ssoUrl);\n            const tUrl = new URL(tokenUrl);\n            if (!(compareUrlsByProtocolAndHost(aUrl, sUrl) && compareUrlsByProtocolAndHost(aUrl, tUrl))) {\n                throw new Error('The prefix of the SSO/token URL and the specified authenticator do not match.');\n            }\n        }\n        catch (err) {\n            // we did not get a valid URL to test\n            if (err instanceof TypeError) {\n                throw new Error('Authenticator, SSO, or token URL is invalid.');\n            }\n            else {\n                throw err;\n            }\n        }\n    };\n    /**\n     *\n     * @param {String} tokenUrl\n     * @param {String} username\n     * @param {String} password\n     *\n     * @returns {Object}\n     */\n    async function createAccessToken(tokenUrl, username, password) {\n        // JSON body to send with POST request\n        const body = {\n            username: username,\n            password: password,\n        };\n        // Query IDP token url to authenticate and retrieve access token\n        const response = await httpClient.post(tokenUrl, body);\n        const data = response['data'];\n        let oneTimeToken;\n        if (data['sessionToken']) {\n            oneTimeToken = data['sessionToken'];\n        }\n        else {\n            oneTimeToken = data['cookieToken'];\n        }\n        return oneTimeToken;\n    }\n    /**\n     *\n     * @param {String} oneTimeToken\n     * @param {String} ssoUrl\n     *\n     * @returns {Object}\n     */\n    async function getSAMLResponse(oneTimeToken, ssoUrl) {\n        // Query IDP URL to get SAML response\n        const response = await httpClient.get(ssoUrl, {\n            params: {\n                RelayState: '/some/deep/link',\n                onetimetoken: oneTimeToken,\n            },\n        });\n        return response['data'];\n    }\n    /**\n     *\n     * @param {String} responseHtml\n     *\n     * @returns {null}\n     */\n    function validateSAML(responseHtml) {\n        const postBackUrl = getPostBackUrlFromHtml(responseHtml);\n        const fullUrl = util.format('%s://%s:%s', protocol, host, port);\n        // Validate the post back url come back with the SAML response\n        // contains the same prefix as the Snowflake's server url, which is the\n        // intended destination url to Snowflake.\n        if (!connectionConfig.getDisableSamlURLCheck()) {\n            if (postBackUrl.substring(0, 20) !== fullUrl.substring(0, 20)) {\n                throw new Error(util.format('The specified authenticator and destination URL ' +\n                    'in the SAML assertion do not match: expected: %s postback: %s', fullUrl, postBackUrl));\n            }\n        }\n        samlResponse = responseHtml;\n    }\n    /**\n     * Extract the postback URL from the HTML response.\n     *\n     * @param {String} html\n     *\n     * @returns {String}\n     */\n    function getPostBackUrlFromHtml(html) {\n        const index = html.search('<form');\n        const startIndex = html.indexOf('action=\"', index);\n        const endIndex = html.indexOf('\"', startIndex + 8);\n        return unescapeHtml(html.substring(startIndex + 8, endIndex));\n    }\n    /**\n     * Unescape the HTML hex characters in the string.\n     *\n     * @param {String} html\n     *\n     * @returns {String}\n     */\n    function unescapeHtml(html) {\n        return html.replace(/&#x3a;/g, ':').replace(/&#x2f;/g, '/');\n    }\n}\nmodule.exports = AuthOkta;\n//# sourceMappingURL=auth_okta.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX29rdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsYUFBYSxrSEFBZ0M7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csVUFBVSxtQkFBbUIsYUFBYTtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxrQkFBa0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGVBQWU7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF9va3RhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IHJlc3QgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJykucmVzdDtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuLyoqXG4gKiBDcmVhdGVzIGFuIG9rdGEgYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBodHRwQ2xpZW50XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBdXRoT2t0YShjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50KSB7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBjb25uZWN0aW9uQ29uZmlnLnBhc3N3b3JkO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGNvbm5lY3Rpb25Db25maWcucmVnaW9uO1xuICAgIGNvbnN0IGFjY291bnQgPSBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQ7XG4gICAgY29uc3QgY2xpZW50QXBwSWQgPSBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFR5cGUoKTtcbiAgICBjb25zdCBjbGllbnRBcHBWZXJzaW9uID0gY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCk7XG4gICAgY29uc3QgaG9zdCA9IHV0aWwuY29uc3RydWN0SG9zdG5hbWUocmVnaW9uLCBhY2NvdW50KTtcbiAgICBjb25zdCBwb3J0ID0gcmVzdC5IVFRQU19QT1JUO1xuICAgIGNvbnN0IHByb3RvY29sID0gcmVzdC5IVFRQU19QUk9UT0NPTDtcbiAgICBsZXQgdXNlcjtcbiAgICBsZXQgc3NvVXJsO1xuICAgIGxldCB0b2tlblVybDtcbiAgICBsZXQgc2FtbFJlc3BvbnNlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCBzYW1sIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OfSBib2R5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBib2R5WydkYXRhJ11bJ1JBV19TQU1MX1JFU1BPTlNFJ10gPSBzYW1sUmVzcG9uc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPYnRhaW4gc2FtbCByZXNwb25zZSBmcm9tIE9rdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChhdXRoZW50aWNhdG9yLCBzZXJ2aWNlTmFtZSwgYWNjb3VudCwgdXNlcm5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRBdXRoVVJMcyhhdXRoZW50aWNhdG9yLCBzZXJ2aWNlTmFtZSwgYWNjb3VudCwgdXNlcm5hbWUpO1xuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gcmVzcG9uc2VEYXRhWydzdWNjZXNzJ107XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHJlc3BvbnNlRGF0YVsnY29kZSddO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZURhdGFbJ21lc3NhZ2UnXTtcbiAgICAgICAgdXNlciA9IHVzZXJuYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICBlcnJvckNvZGUgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byB1c2UgcHJvdmlkZWQgT2t0YSBhZGRyZXNzIGFzIGFuIGF1dGhlbnRpY2F0b3IuIElzIHRoZSBhdXRoZW50aWNhdG9yIFVSTCBjb3JyZWN0PycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1c2UgcHJvdmlkZWQgT2t0YSBhZGRyZXNzIGFzIGFuIGF1dGhlbnRpY2F0b3IuIEVycm9yIGNvZGU6ICR7ZXJyb3JDb2RlfSwgZXJyb3IgbWVzc2FnZTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3NvVXJsID0gcmVzcG9uc2VEYXRhWydkYXRhJ11bJ3Nzb1VybCddO1xuICAgICAgICB0b2tlblVybCA9IHJlc3BvbnNlRGF0YVsnZGF0YSddWyd0b2tlblVybCddO1xuICAgICAgICB0aGlzLnZhbGlkYXRlVVJMcyhhdXRoZW50aWNhdG9yLCBzc29VcmwsIHRva2VuVXJsKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIdG1sID0gYXdhaXQgZ2V0U0FNTFJlc3BvbnNlKGF3YWl0IGNyZWF0ZUFjY2Vzc1Rva2VuKHRva2VuVXJsLCB1c2VybmFtZSwgcGFzc3dvcmQpLCBzc29VcmwpO1xuICAgICAgICB2YWxpZGF0ZVNBTUwocmVzcG9uc2VIdG1sKTtcbiAgICB9O1xuICAgIHRoaXMucmVhdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoYm9keSwgcmV0cnlPcHRpb24pIHtcbiAgICAgICAgY29uc3QgbWF4UmV0cnlUaW1lb3V0ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVRpbWVvdXQoKTtcbiAgICAgICAgY29uc3QgbWF4UmV0cnlDb3VudCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heExvZ2luUmV0cmllcygpO1xuICAgICAgICBjb25zdCByZW1haW5pbmdUaW1lb3V0ID0gKG1heFJldHJ5VGltZW91dCAtIHJldHJ5T3B0aW9uLnRvdGFsRWxhcHNlZFRpbWUpICogMTAwMDtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgYXV0aFJldHJ5T3B0aW9uID0ge1xuICAgICAgICAgICAgbWF4UmV0cnlDb3VudCxcbiAgICAgICAgICAgIG51bVJldHJpZXM6IHJldHJ5T3B0aW9uLm51bVJldHJpZXMsXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICByZW1haW5pbmdUaW1lb3V0LFxuICAgICAgICAgICAgbWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2VIdG1sO1xuICAgICAgICB3aGlsZSAodXRpbC5zaG91bGRSZXRyeU9rdGFBdXRoKGF1dGhSZXRyeU9wdGlvbikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIdG1sID0gYXdhaXQgZ2V0U0FNTFJlc3BvbnNlKGF3YWl0IGNyZWF0ZUFjY2Vzc1Rva2VuKHRva2VuVXJsLCB1c2VyLCBwYXNzd29yZCksIHNzb1VybCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ2dldFNBTUxSZXNwb25zZTogcmVmcmVzaCB0b2tlbiBmb3IgcmUtYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgICAgICBhdXRoUmV0cnlPcHRpb24ubnVtUmV0cmllcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmdUaW1lb3V0ICE9PSAwICYmIHN0YXJ0VGltZSArIHJlbWFpbmluZ1RpbWVvdXQgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBnZXRTQU1MUmVzcG9uc2U6IEZhaWwgdG8gZ2V0IFNBTUwgcmVzcG9uc2UsIHRpbWVvdXQgcmVhY2hlZDogJHtyZW1haW5pbmdUaW1lb3V0fSBtaWxpc2Vjb25kc2ApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjaGVkIG91dCB0byB0aGUgTG9naW4gVGltZW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhSZXRyeUNvdW50IDwgYXV0aFJldHJ5T3B0aW9uLm51bVJldHJpZXMpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYGdldFNBTUxSZXNwb25zZTogRmFpbCB0byBnZXQgU0FNTCByZXNwb25zZSwgbWF4IHJldHJ5IHJlYWNoZWQ6ICR7bWF4UmV0cnlDb3VudH0gdGltZWApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjaGVkIG91dCB0byB0aGUgbWF4IHJldHJ5IGNvdW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnlPcHRpb24udG90YWxFbGFwc2VkVGltZSArPSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwO1xuICAgICAgICByZXRyeU9wdGlvbi5udW1SZXRyaWVzID0gYXV0aFJldHJ5T3B0aW9uLm51bVJldHJpZXM7XG4gICAgICAgIHZhbGlkYXRlU0FNTChyZXNwb25zZUh0bWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlcnZpY2VOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFVSTHMoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIHVzZXJuYW1lKSB7XG4gICAgICAgIC8vIENyZWF0ZSBVUkwgdG8gc2VuZCBQT1NUIHJlcXVlc3QgdG9cbiAgICAgICAgY29uc3QgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnL3Nlc3Npb24vYXV0aGVudGljYXRvci1yZXF1ZXN0JztcbiAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgaWYgKHNlcnZpY2VOYW1lKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgSFRUUF9IRUFERVJfU0VSVklDRV9OQU1FOiBzZXJ2aWNlTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlNPTiBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIHJlcXVlc3RcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBBQ0NPVU5UX05BTUU6IGFjY291bnQsXG4gICAgICAgICAgICAgICAgTE9HSU5fTkFNRTogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgUE9SVDogcG9ydCxcbiAgICAgICAgICAgICAgICBQUk9UT0NPTDogcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgQVVUSEVOVElDQVRPUjogYXV0aGVudGljYXRvcixcbiAgICAgICAgICAgICAgICBDTElFTlRfQVBQX0lEOiBjbGllbnRBcHBJZCxcbiAgICAgICAgICAgICAgICBDTElFTlRfQVBQX1ZFUlNJT046IGNsaWVudEFwcFZlcnNpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBQT1NUIHJlcXVlc3QgdG8gZ2V0IFNTTyBVUkwgYW5kIHRva2VuIFVSTFxuICAgICAgICByZXR1cm4gYXdhaXQgaHR0cENsaWVudC5wb3N0KHVybCwgYm9keSwge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzc29VcmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5VcmxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdGVVUkxzID0gZnVuY3Rpb24gKGF1dGhlbnRpY2F0b3IsIHNzb1VybCwgdG9rZW5VcmwpIHtcbiAgICAgICAgY29uc3QgY29tcGFyZVVybHNCeVByb3RvY29sQW5kSG9zdCA9IChmaXJzdFVybCwgc2Vjb25kVXJsKSA9PiBmaXJzdFVybC5wcm90b2NvbCA9PT0gc2Vjb25kVXJsLnByb3RvY29sICYmIGZpcnN0VXJsLmhvc3QgPT09IHNlY29uZFVybC5ob3N0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYVVybCA9IG5ldyBVUkwoYXV0aGVudGljYXRvcik7XG4gICAgICAgICAgICBjb25zdCBzVXJsID0gbmV3IFVSTChzc29VcmwpO1xuICAgICAgICAgICAgY29uc3QgdFVybCA9IG5ldyBVUkwodG9rZW5VcmwpO1xuICAgICAgICAgICAgaWYgKCEoY29tcGFyZVVybHNCeVByb3RvY29sQW5kSG9zdChhVXJsLCBzVXJsKSAmJiBjb21wYXJlVXJsc0J5UHJvdG9jb2xBbmRIb3N0KGFVcmwsIHRVcmwpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByZWZpeCBvZiB0aGUgU1NPL3Rva2VuIFVSTCBhbmQgdGhlIHNwZWNpZmllZCBhdXRoZW50aWNhdG9yIGRvIG5vdCBtYXRjaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyB3ZSBkaWQgbm90IGdldCBhIHZhbGlkIFVSTCB0byB0ZXN0XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdG9yLCBTU08sIG9yIHRva2VuIFVSTCBpcyBpbnZhbGlkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZFxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVBY2Nlc3NUb2tlbih0b2tlblVybCwgdXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIC8vIEpTT04gYm9keSB0byBzZW5kIHdpdGggUE9TVCByZXF1ZXN0XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFF1ZXJ5IElEUCB0b2tlbiB1cmwgdG8gYXV0aGVudGljYXRlIGFuZCByZXRyaWV2ZSBhY2Nlc3MgdG9rZW5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnBvc3QodG9rZW5VcmwsIGJvZHkpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IG9uZVRpbWVUb2tlbjtcbiAgICAgICAgaWYgKGRhdGFbJ3Nlc3Npb25Ub2tlbiddKSB7XG4gICAgICAgICAgICBvbmVUaW1lVG9rZW4gPSBkYXRhWydzZXNzaW9uVG9rZW4nXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uZVRpbWVUb2tlbiA9IGRhdGFbJ2Nvb2tpZVRva2VuJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uZVRpbWVUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb25lVGltZVRva2VuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNzb1VybFxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBnZXRTQU1MUmVzcG9uc2Uob25lVGltZVRva2VuLCBzc29VcmwpIHtcbiAgICAgICAgLy8gUXVlcnkgSURQIFVSTCB0byBnZXQgU0FNTCByZXNwb25zZVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KHNzb1VybCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgUmVsYXlTdGF0ZTogJy9zb21lL2RlZXAvbGluaycsXG4gICAgICAgICAgICAgICAgb25ldGltZXRva2VuOiBvbmVUaW1lVG9rZW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydkYXRhJ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc3BvbnNlSHRtbFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTQU1MKHJlc3BvbnNlSHRtbCkge1xuICAgICAgICBjb25zdCBwb3N0QmFja1VybCA9IGdldFBvc3RCYWNrVXJsRnJvbUh0bWwocmVzcG9uc2VIdG1sKTtcbiAgICAgICAgY29uc3QgZnVsbFVybCA9IHV0aWwuZm9ybWF0KCclczovLyVzOiVzJywgcHJvdG9jb2wsIGhvc3QsIHBvcnQpO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgcG9zdCBiYWNrIHVybCBjb21lIGJhY2sgd2l0aCB0aGUgU0FNTCByZXNwb25zZVxuICAgICAgICAvLyBjb250YWlucyB0aGUgc2FtZSBwcmVmaXggYXMgdGhlIFNub3dmbGFrZSdzIHNlcnZlciB1cmwsIHdoaWNoIGlzIHRoZVxuICAgICAgICAvLyBpbnRlbmRlZCBkZXN0aW5hdGlvbiB1cmwgdG8gU25vd2ZsYWtlLlxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25Db25maWcuZ2V0RGlzYWJsZVNhbWxVUkxDaGVjaygpKSB7XG4gICAgICAgICAgICBpZiAocG9zdEJhY2tVcmwuc3Vic3RyaW5nKDAsIDIwKSAhPT0gZnVsbFVybC5zdWJzdHJpbmcoMCwgMjApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdUaGUgc3BlY2lmaWVkIGF1dGhlbnRpY2F0b3IgYW5kIGRlc3RpbmF0aW9uIFVSTCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2luIHRoZSBTQU1MIGFzc2VydGlvbiBkbyBub3QgbWF0Y2g6IGV4cGVjdGVkOiAlcyBwb3N0YmFjazogJXMnLCBmdWxsVXJsLCBwb3N0QmFja1VybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNhbWxSZXNwb25zZSA9IHJlc3BvbnNlSHRtbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgcG9zdGJhY2sgVVJMIGZyb20gdGhlIEhUTUwgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQb3N0QmFja1VybEZyb21IdG1sKGh0bWwpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBodG1sLnNlYXJjaCgnPGZvcm0nKTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGh0bWwuaW5kZXhPZignYWN0aW9uPVwiJywgaW5kZXgpO1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGh0bWwuaW5kZXhPZignXCInLCBzdGFydEluZGV4ICsgOCk7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZUh0bWwoaHRtbC5zdWJzdHJpbmcoc3RhcnRJbmRleCArIDgsIGVuZEluZGV4KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlIHRoZSBIVE1MIGhleCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZUh0bWwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mI3gzYTsvZywgJzonKS5yZXBsYWNlKC8mI3gyZjsvZywgJy8nKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhPa3RhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF9va3RhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst URLUtil = __webpack_require__(/*! ./../../lib/url_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/url_util.js\");\nconst Util = __webpack_require__(/*! ./../../lib/util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst SsoUrlProvider = __webpack_require__(/*! ../authentication/sso_url_provider */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { rest } = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst { createServer } = __webpack_require__(/*! ./authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst { withBrowserActionTimeout } = __webpack_require__(/*! ./authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\n/**\n * Creates an external browser authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {module} webbrowser\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthWeb(connectionConfig, httpClient, webbrowser) {\n    const host = connectionConfig.host;\n    const browserActionTimeout = connectionConfig.getBrowserActionTimeout();\n    const ssoUrlProvider = new SsoUrlProvider(httpClient);\n    if (!Util.exists(host)) {\n        throw new Error(`Invalid value for host: ${host}`);\n    }\n    if (!Util.number.isPositiveInteger(browserActionTimeout)) {\n        throw new Error(`Invalid value for browser action timeout: ${browserActionTimeout}`);\n    }\n    const open = typeof webbrowser !== 'undefined' ? webbrowser : __webpack_require__(/*! open */ \"(rsc)/./node_modules/open/index.js\");\n    let proofKey;\n    let token;\n    /**\n     * Update JSON body with token and proof_key.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n    this.updateBody = function (body) {\n        body['data']['TOKEN'] = token;\n        body['data']['PROOF_KEY'] = proofKey;\n        body['data']['AUTHENTICATOR'] = 'EXTERNALBROWSER';\n    };\n    /**\n     * Obtain SAML token through SSO URL.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {String} username\n     *\n     * @returns {Promise<null>}\n     */\n    this.authenticate = async function (authenticator, serviceName, account, username) {\n        let server;\n        let loginUrl;\n        const receiveData = new Promise((resolve) => {\n            // Server to receive SAML token\n            server = createServer(resolve);\n        }).then((result) => {\n            return result;\n        });\n        // Use a free random port and set to no backlog\n        server.listen(0, 0);\n        if (connectionConfig.getDisableConsoleLogin()) {\n            // Step 1: query Snowflake to obtain SSO url\n            const ssoData = await ssoUrlProvider.getSSOURL(authenticator, serviceName, account, server.address().port, username, host);\n            proofKey = ssoData['proofKey'];\n            loginUrl = ssoData['ssoUrl'];\n        }\n        else {\n            proofKey = this.generateProofKey();\n            loginUrl = this.getLoginUrl(username, proofKey, server.address().port);\n        }\n        // Step 2: validate URL\n        if (!URLUtil.isValidURL(loginUrl)) {\n            throw new Error(util.format('Invalid SSO URL found - %s ', loginUrl));\n        }\n        // Step 3: open browser\n        open(loginUrl);\n        // Step 4: get SAML token\n        const tokenGetHttpLine = await withBrowserActionTimeout(browserActionTimeout, receiveData).catch((rejected) => {\n            server.close();\n            throw new Error(util.format('Error while getting SAML token: %s', rejected));\n        });\n        processGet(tokenGetHttpLine);\n    };\n    this.generateProofKey = function () {\n        const randomness = crypto.randomBytes(32);\n        return Buffer.from(randomness, 'utf8').toString('base64');\n    };\n    this.getLoginUrl = function (username, proofKey, port) {\n        const url = new URL(rest.HTTPS_PROTOCOL + '://' + host + '/console/login');\n        url.searchParams.append('login_name', username);\n        url.searchParams.append('proof_key', proofKey);\n        url.searchParams.append('browser_mode_redirect_port', port);\n        return url.toString();\n    };\n    /**\n     * Parse the GET request and get token parameter value.\n     *\n     * @param {String} tokenHttpGetLine\n     *\n     * @returns {null}\n     */\n    function processGet(tokenHttpGetLine) {\n        // Split the GET request line\n        const data = tokenHttpGetLine.split(' ');\n        // Get value of the \"token\" query parameter\n        token = querystring.parse(data[1])['/?token'];\n    }\n}\nmodule.exports = AuthWeb;\n//# sourceMappingURL=auth_web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dlYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLDZFQUFrQjtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQywwSEFBb0M7QUFDbkUsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzNDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsZ0hBQXVCO0FBQ3hELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxnSEFBdUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBLGtFQUFrRSxtQkFBTyxDQUFDLGdEQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dlYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBVUkxVdGlsID0gcmVxdWlyZSgnLi8uLi8uLi9saWIvdXJsX3V0aWwnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLy4uLy4uL2xpYi91dGlsJyk7XG5jb25zdCBTc29VcmxQcm92aWRlciA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL3Nzb191cmxfcHJvdmlkZXInKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyByZXN0IH0gPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCB7IGNyZWF0ZVNlcnZlciB9ID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl91dGlsJyk7XG5jb25zdCB7IHdpdGhCcm93c2VyQWN0aW9uVGltZW91dCB9ID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl91dGlsJyk7XG4vKipcbiAqIENyZWF0ZXMgYW4gZXh0ZXJuYWwgYnJvd3NlciBhdXRoZW50aWNhdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICogQHBhcmFtIHttb2R1bGV9IHdlYmJyb3dzZXJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhXZWIoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgd2ViYnJvd3Nlcikge1xuICAgIGNvbnN0IGhvc3QgPSBjb25uZWN0aW9uQ29uZmlnLmhvc3Q7XG4gICAgY29uc3QgYnJvd3NlckFjdGlvblRpbWVvdXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldEJyb3dzZXJBY3Rpb25UaW1lb3V0KCk7XG4gICAgY29uc3Qgc3NvVXJsUHJvdmlkZXIgPSBuZXcgU3NvVXJsUHJvdmlkZXIoaHR0cENsaWVudCk7XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhob3N0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIGhvc3Q6ICR7aG9zdH1gKTtcbiAgICB9XG4gICAgaWYgKCFVdGlsLm51bWJlci5pc1Bvc2l0aXZlSW50ZWdlcihicm93c2VyQWN0aW9uVGltZW91dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBicm93c2VyIGFjdGlvbiB0aW1lb3V0OiAke2Jyb3dzZXJBY3Rpb25UaW1lb3V0fWApO1xuICAgIH1cbiAgICBjb25zdCBvcGVuID0gdHlwZW9mIHdlYmJyb3dzZXIgIT09ICd1bmRlZmluZWQnID8gd2ViYnJvd3NlciA6IHJlcXVpcmUoJ29wZW4nKTtcbiAgICBsZXQgcHJvb2ZLZXk7XG4gICAgbGV0IHRva2VuO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0b2tlbiBhbmQgcHJvb2Zfa2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OfSBib2R5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBib2R5WydkYXRhJ11bJ1RPS0VOJ10gPSB0b2tlbjtcbiAgICAgICAgYm9keVsnZGF0YSddWydQUk9PRl9LRVknXSA9IHByb29mS2V5O1xuICAgICAgICBib2R5WydkYXRhJ11bJ0FVVEhFTlRJQ0FUT1InXSA9ICdFWFRFUk5BTEJST1dTRVInO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT2J0YWluIFNBTUwgdG9rZW4gdGhyb3VnaCBTU08gVVJMLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZU5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVsbD59XG4gICAgICovXG4gICAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIHVzZXJuYW1lKSB7XG4gICAgICAgIGxldCBzZXJ2ZXI7XG4gICAgICAgIGxldCBsb2dpblVybDtcbiAgICAgICAgY29uc3QgcmVjZWl2ZURhdGEgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2VydmVyIHRvIHJlY2VpdmUgU0FNTCB0b2tlblxuICAgICAgICAgICAgc2VydmVyID0gY3JlYXRlU2VydmVyKHJlc29sdmUpO1xuICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVc2UgYSBmcmVlIHJhbmRvbSBwb3J0IGFuZCBzZXQgdG8gbm8gYmFja2xvZ1xuICAgICAgICBzZXJ2ZXIubGlzdGVuKDAsIDApO1xuICAgICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXREaXNhYmxlQ29uc29sZUxvZ2luKCkpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMTogcXVlcnkgU25vd2ZsYWtlIHRvIG9idGFpbiBTU08gdXJsXG4gICAgICAgICAgICBjb25zdCBzc29EYXRhID0gYXdhaXQgc3NvVXJsUHJvdmlkZXIuZ2V0U1NPVVJMKGF1dGhlbnRpY2F0b3IsIHNlcnZpY2VOYW1lLCBhY2NvdW50LCBzZXJ2ZXIuYWRkcmVzcygpLnBvcnQsIHVzZXJuYW1lLCBob3N0KTtcbiAgICAgICAgICAgIHByb29mS2V5ID0gc3NvRGF0YVsncHJvb2ZLZXknXTtcbiAgICAgICAgICAgIGxvZ2luVXJsID0gc3NvRGF0YVsnc3NvVXJsJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9vZktleSA9IHRoaXMuZ2VuZXJhdGVQcm9vZktleSgpO1xuICAgICAgICAgICAgbG9naW5VcmwgPSB0aGlzLmdldExvZ2luVXJsKHVzZXJuYW1lLCBwcm9vZktleSwgc2VydmVyLmFkZHJlc3MoKS5wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDI6IHZhbGlkYXRlIFVSTFxuICAgICAgICBpZiAoIVVSTFV0aWwuaXNWYWxpZFVSTChsb2dpblVybCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnSW52YWxpZCBTU08gVVJMIGZvdW5kIC0gJXMgJywgbG9naW5VcmwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDM6IG9wZW4gYnJvd3NlclxuICAgICAgICBvcGVuKGxvZ2luVXJsKTtcbiAgICAgICAgLy8gU3RlcCA0OiBnZXQgU0FNTCB0b2tlblxuICAgICAgICBjb25zdCB0b2tlbkdldEh0dHBMaW5lID0gYXdhaXQgd2l0aEJyb3dzZXJBY3Rpb25UaW1lb3V0KGJyb3dzZXJBY3Rpb25UaW1lb3V0LCByZWNlaXZlRGF0YSkuY2F0Y2goKHJlamVjdGVkKSA9PiB7XG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnRXJyb3Igd2hpbGUgZ2V0dGluZyBTQU1MIHRva2VuOiAlcycsIHJlamVjdGVkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9jZXNzR2V0KHRva2VuR2V0SHR0cExpbmUpO1xuICAgIH07XG4gICAgdGhpcy5nZW5lcmF0ZVByb29mS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByYW5kb21uZXNzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJhbmRvbW5lc3MsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH07XG4gICAgdGhpcy5nZXRMb2dpblVybCA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcHJvb2ZLZXksIHBvcnQpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXN0LkhUVFBTX1BST1RPQ09MICsgJzovLycgKyBob3N0ICsgJy9jb25zb2xlL2xvZ2luJyk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdsb2dpbl9uYW1lJywgdXNlcm5hbWUpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncHJvb2Zfa2V5JywgcHJvb2ZLZXkpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnYnJvd3Nlcl9tb2RlX3JlZGlyZWN0X3BvcnQnLCBwb3J0KTtcbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIEdFVCByZXF1ZXN0IGFuZCBnZXQgdG9rZW4gcGFyYW1ldGVyIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuSHR0cEdldExpbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NHZXQodG9rZW5IdHRwR2V0TGluZSkge1xuICAgICAgICAvLyBTcGxpdCB0aGUgR0VUIHJlcXVlc3QgbGluZVxuICAgICAgICBjb25zdCBkYXRhID0gdG9rZW5IdHRwR2V0TGluZS5zcGxpdCgnICcpO1xuICAgICAgICAvLyBHZXQgdmFsdWUgb2YgdGhlIFwidG9rZW5cIiBxdWVyeSBwYXJhbWV0ZXJcbiAgICAgICAgdG9rZW4gPSBxdWVyeXN0cmluZy5wYXJzZShkYXRhWzFdKVsnLz90b2tlbiddO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQXV0aFdlYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhfd2ViLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAwsCredentials = getAwsCredentials;\nexports.getAwsRegion = getAwsRegion;\nexports.getStsHostname = getStsHostname;\nexports.getAwsAttestationToken = getAwsAttestationToken;\nconst credential_provider_node_1 = __webpack_require__(/*! @aws-sdk/credential-provider-node */ \"(rsc)/./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js\");\nconst ec2_metadata_service_1 = __webpack_require__(/*! @aws-sdk/ec2-metadata-service */ \"(rsc)/./node_modules/@aws-sdk/ec2-metadata-service/dist-es/index.js\");\nconst protocol_http_1 = __webpack_require__(/*! @smithy/protocol-http */ \"(rsc)/./node_modules/@smithy/protocol-http/dist-es/index.js\");\nconst signature_v4_1 = __webpack_require__(/*! @smithy/signature-v4 */ \"(rsc)/./node_modules/@smithy/signature-v4/dist-es/index.js\");\nconst sha256_js_1 = __webpack_require__(/*! @aws-crypto/sha256-js */ \"(rsc)/./node_modules/@aws-crypto/sha256-js/build/module/index.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nasync function getAwsCredentials() {\n    (0, logger_1.default)().debug('Getting AWS credentials from default provider');\n    return await (0, credential_provider_node_1.defaultProvider)()();\n}\nasync function getAwsRegion() {\n    if (process.env.AWS_REGION) {\n        (0, logger_1.default)().debug('Getting AWS region from AWS_REGION');\n        return process.env.AWS_REGION; // Lambda\n    }\n    else {\n        (0, logger_1.default)().debug('Getting AWS region from EC2 metadata service');\n        return new ec2_metadata_service_1.MetadataService().request('/latest/meta-data/placement/region', {}); // EC2\n    }\n}\nfunction getStsHostname(region) {\n    const domain = region.startsWith('cn-') ? 'amazonaws.com.cn' : 'amazonaws.com';\n    return `sts.${region}.${domain}`;\n}\nasync function getAwsAttestationToken() {\n    const credentials = await getAwsCredentials();\n    const region = await getAwsRegion();\n    const stsHostname = getStsHostname(region);\n    const request = new protocol_http_1.HttpRequest({\n        method: 'POST',\n        protocol: 'https',\n        hostname: stsHostname,\n        path: '/',\n        headers: {\n            host: stsHostname,\n            'x-snowflake-audience': 'snowflakecomputing.com',\n        },\n        query: {\n            Action: 'GetCallerIdentity',\n            Version: '2011-06-15',\n        },\n    });\n    const signedRequest = await new signature_v4_1.SignatureV4({\n        credentials,\n        applyChecksum: false,\n        region,\n        service: 'sts',\n        sha256: sha256_js_1.Sha256,\n    }).sign(request);\n    const token = {\n        url: `https://${stsHostname}/?Action=GetCallerIdentity&Version=2011-06-15`,\n        method: 'POST',\n        headers: signedRequest.headers,\n    };\n    return btoa(JSON.stringify(token));\n}\n//# sourceMappingURL=attestation_aws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F3cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLDhCQUE4QjtBQUM5QixtQ0FBbUMsbUJBQU8sQ0FBQyxrSEFBbUM7QUFDOUUsK0JBQStCLG1CQUFPLENBQUMsMEdBQStCO0FBQ3RFLHdCQUF3QixtQkFBTyxDQUFDLDBGQUF1QjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBc0I7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXVCO0FBQ25ELGlDQUFpQyxtQkFBTyxDQUFDLDJFQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxHQUFHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU8sR0FBRyxPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F3cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXdzQ3JlZGVudGlhbHMgPSBnZXRBd3NDcmVkZW50aWFscztcbmV4cG9ydHMuZ2V0QXdzUmVnaW9uID0gZ2V0QXdzUmVnaW9uO1xuZXhwb3J0cy5nZXRTdHNIb3N0bmFtZSA9IGdldFN0c0hvc3RuYW1lO1xuZXhwb3J0cy5nZXRBd3NBdHRlc3RhdGlvblRva2VuID0gZ2V0QXdzQXR0ZXN0YXRpb25Ub2tlbjtcbmNvbnN0IGNyZWRlbnRpYWxfcHJvdmlkZXJfbm9kZV8xID0gcmVxdWlyZShcIkBhd3Mtc2RrL2NyZWRlbnRpYWwtcHJvdmlkZXItbm9kZVwiKTtcbmNvbnN0IGVjMl9tZXRhZGF0YV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiQGF3cy1zZGsvZWMyLW1ldGFkYXRhLXNlcnZpY2VcIik7XG5jb25zdCBwcm90b2NvbF9odHRwXzEgPSByZXF1aXJlKFwiQHNtaXRoeS9wcm90b2NvbC1odHRwXCIpO1xuY29uc3Qgc2lnbmF0dXJlX3Y0XzEgPSByZXF1aXJlKFwiQHNtaXRoeS9zaWduYXR1cmUtdjRcIik7XG5jb25zdCBzaGEyNTZfanNfMSA9IHJlcXVpcmUoXCJAYXdzLWNyeXB0by9zaGEyNTYtanNcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEF3c0NyZWRlbnRpYWxzKCkge1xuICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdHZXR0aW5nIEFXUyBjcmVkZW50aWFscyBmcm9tIGRlZmF1bHQgcHJvdmlkZXInKTtcbiAgICByZXR1cm4gYXdhaXQgKDAsIGNyZWRlbnRpYWxfcHJvdmlkZXJfbm9kZV8xLmRlZmF1bHRQcm92aWRlcikoKSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QXdzUmVnaW9uKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5BV1NfUkVHSU9OKSB7XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdHZXR0aW5nIEFXUyByZWdpb24gZnJvbSBBV1NfUkVHSU9OJyk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5BV1NfUkVHSU9OOyAvLyBMYW1iZGFcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdHZXR0aW5nIEFXUyByZWdpb24gZnJvbSBFQzIgbWV0YWRhdGEgc2VydmljZScpO1xuICAgICAgICByZXR1cm4gbmV3IGVjMl9tZXRhZGF0YV9zZXJ2aWNlXzEuTWV0YWRhdGFTZXJ2aWNlKCkucmVxdWVzdCgnL2xhdGVzdC9tZXRhLWRhdGEvcGxhY2VtZW50L3JlZ2lvbicsIHt9KTsgLy8gRUMyXG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3RzSG9zdG5hbWUocmVnaW9uKSB7XG4gICAgY29uc3QgZG9tYWluID0gcmVnaW9uLnN0YXJ0c1dpdGgoJ2NuLScpID8gJ2FtYXpvbmF3cy5jb20uY24nIDogJ2FtYXpvbmF3cy5jb20nO1xuICAgIHJldHVybiBgc3RzLiR7cmVnaW9ufS4ke2RvbWFpbn1gO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QXdzQXR0ZXN0YXRpb25Ub2tlbigpIHtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IGdldEF3c0NyZWRlbnRpYWxzKCk7XG4gICAgY29uc3QgcmVnaW9uID0gYXdhaXQgZ2V0QXdzUmVnaW9uKCk7XG4gICAgY29uc3Qgc3RzSG9zdG5hbWUgPSBnZXRTdHNIb3N0bmFtZShyZWdpb24pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgcHJvdG9jb2xfaHR0cF8xLkh0dHBSZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHByb3RvY29sOiAnaHR0cHMnLFxuICAgICAgICBob3N0bmFtZTogc3RzSG9zdG5hbWUsXG4gICAgICAgIHBhdGg6ICcvJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgaG9zdDogc3RzSG9zdG5hbWUsXG4gICAgICAgICAgICAneC1zbm93Zmxha2UtYXVkaWVuY2UnOiAnc25vd2ZsYWtlY29tcHV0aW5nLmNvbScsXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICBBY3Rpb246ICdHZXRDYWxsZXJJZGVudGl0eScsXG4gICAgICAgICAgICBWZXJzaW9uOiAnMjAxMS0wNi0xNScsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbmVkUmVxdWVzdCA9IGF3YWl0IG5ldyBzaWduYXR1cmVfdjRfMS5TaWduYXR1cmVWNCh7XG4gICAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgICBhcHBseUNoZWNrc3VtOiBmYWxzZSxcbiAgICAgICAgcmVnaW9uLFxuICAgICAgICBzZXJ2aWNlOiAnc3RzJyxcbiAgICAgICAgc2hhMjU2OiBzaGEyNTZfanNfMS5TaGEyNTYsXG4gICAgfSkuc2lnbihyZXF1ZXN0KTtcbiAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly8ke3N0c0hvc3RuYW1lfS8/QWN0aW9uPUdldENhbGxlcklkZW50aXR5JlZlcnNpb249MjAxMS0wNi0xNWAsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBzaWduZWRSZXF1ZXN0LmhlYWRlcnMsXG4gICAgfTtcbiAgICByZXR1cm4gYnRvYShKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0ZXN0YXRpb25fYXdzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_AZURE_ENTRA_ID_RESOURCE = void 0;\nexports.getAzureAttestationToken = getAzureAttestationToken;\nconst identity_1 = __webpack_require__(/*! @azure/identity */ \"(rsc)/./node_modules/@azure/identity/dist/commonjs/index.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nexports.DEFAULT_AZURE_ENTRA_ID_RESOURCE = 'api://fd3f753b-eed3-462c-b6a7-a4b5bb650aad';\nasync function getAzureAttestationToken(entraIdResource = exports.DEFAULT_AZURE_ENTRA_ID_RESOURCE) {\n    const credential = new identity_1.DefaultAzureCredential();\n    (0, logger_1.default)().debug('Getting Azure auth token');\n    const token = await credential.getToken(entraIdResource);\n    return token.token;\n}\n//# sourceMappingURL=attestation_azure.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F6dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDO0FBQ3ZDLGdDQUFnQztBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDNUMsaUNBQWlDLG1CQUFPLENBQUMsMkVBQWM7QUFDdkQsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2F6dXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0FaVVJFX0VOVFJBX0lEX1JFU09VUkNFID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRBenVyZUF0dGVzdGF0aW9uVG9rZW4gPSBnZXRBenVyZUF0dGVzdGF0aW9uVG9rZW47XG5jb25zdCBpZGVudGl0eV8xID0gcmVxdWlyZShcIkBhenVyZS9pZGVudGl0eVwiKTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9sb2dnZXJcIikpO1xuZXhwb3J0cy5ERUZBVUxUX0FaVVJFX0VOVFJBX0lEX1JFU09VUkNFID0gJ2FwaTovL2ZkM2Y3NTNiLWVlZDMtNDYyYy1iNmE3LWE0YjViYjY1MGFhZCc7XG5hc3luYyBmdW5jdGlvbiBnZXRBenVyZUF0dGVzdGF0aW9uVG9rZW4oZW50cmFJZFJlc291cmNlID0gZXhwb3J0cy5ERUZBVUxUX0FaVVJFX0VOVFJBX0lEX1JFU09VUkNFKSB7XG4gICAgY29uc3QgY3JlZGVudGlhbCA9IG5ldyBpZGVudGl0eV8xLkRlZmF1bHRBenVyZUNyZWRlbnRpYWwoKTtcbiAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnR2V0dGluZyBBenVyZSBhdXRoIHRva2VuJyk7XG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjcmVkZW50aWFsLmdldFRva2VuKGVudHJhSWRSZXNvdXJjZSk7XG4gICAgcmV0dXJuIHRva2VuLnRva2VuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0ZXN0YXRpb25fYXp1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SNOWFLAKE_AUDIENCE = void 0;\nexports.getGcpAttestationToken = getGcpAttestationToken;\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nexports.SNOWFLAKE_AUDIENCE = 'snowflakecomputing.com';\nasync function getGcpAttestationToken() {\n    const auth = new google_auth_library_1.GoogleAuth();\n    (0, logger_1.default)().debug('Getting GCP auth token');\n    const client = await auth.getIdTokenClient(exports.SNOWFLAKE_AUDIENCE);\n    const idToken = await client.idTokenProvider.fetchIdToken(exports.SNOWFLAKE_AUDIENCE);\n    return idToken;\n}\n//# sourceMappingURL=attestation_gcp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2djcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsOEJBQThCLG1CQUFPLENBQUMsd0ZBQXFCO0FBQzNELGlDQUFpQyxtQkFBTyxDQUFDLDJFQUFjO0FBQ3ZELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F0dGVzdGF0aW9uX2djcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU05PV0ZMQUtFX0FVRElFTkNFID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRHY3BBdHRlc3RhdGlvblRva2VuID0gZ2V0R2NwQXR0ZXN0YXRpb25Ub2tlbjtcbmNvbnN0IGdvb2dsZV9hdXRoX2xpYnJhcnlfMSA9IHJlcXVpcmUoXCJnb29nbGUtYXV0aC1saWJyYXJ5XCIpO1xuY29uc3QgbG9nZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2xvZ2dlclwiKSk7XG5leHBvcnRzLlNOT1dGTEFLRV9BVURJRU5DRSA9ICdzbm93Zmxha2Vjb21wdXRpbmcuY29tJztcbmFzeW5jIGZ1bmN0aW9uIGdldEdjcEF0dGVzdGF0aW9uVG9rZW4oKSB7XG4gICAgY29uc3QgYXV0aCA9IG5ldyBnb29nbGVfYXV0aF9saWJyYXJ5XzEuR29vZ2xlQXV0aCgpO1xuICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKCdHZXR0aW5nIEdDUCBhdXRoIHRva2VuJyk7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgYXV0aC5nZXRJZFRva2VuQ2xpZW50KGV4cG9ydHMuU05PV0ZMQUtFX0FVRElFTkNFKTtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgY2xpZW50LmlkVG9rZW5Qcm92aWRlci5mZXRjaElkVG9rZW4oZXhwb3J0cy5TTk9XRkxBS0VfQVVESUVOQ0UpO1xuICAgIHJldHVybiBpZFRva2VuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0ZXN0YXRpb25fZ2NwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst attestation_aws_1 = __webpack_require__(/*! ./attestation_aws */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_aws.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js\");\nconst errors_1 = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst attestation_azure_1 = __webpack_require__(/*! ./attestation_azure */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_azure.js\");\nconst attestation_gcp_1 = __webpack_require__(/*! ./attestation_gcp */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/attestation_gcp.js\");\nconst authentication_types_1 = __importDefault(__webpack_require__(/*! ../authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\"));\nclass AuthWorkloadIdentity {\n    connectionConfig;\n    tokenProvider;\n    token;\n    constructor(connectionConfig) {\n        this.connectionConfig = connectionConfig;\n    }\n    updateBody(body) {\n        body.data['AUTHENTICATOR'] = authentication_types_1.default.WORKLOAD_IDENTITY;\n        body.data['PROVIDER'] = this.tokenProvider;\n        body.data['TOKEN'] = this.token;\n    }\n    async authenticate() {\n        let provider = this.connectionConfig.workloadIdentityProvider;\n        let token;\n        if (provider === types_1.WorkloadIdentityProvider.AWS) {\n            token = await (0, attestation_aws_1.getAwsAttestationToken)();\n        }\n        else if (provider === types_1.WorkloadIdentityProvider.AZURE) {\n            token = await (0, attestation_azure_1.getAzureAttestationToken)(this.connectionConfig.workloadIdentityAzureEntraIdResource);\n        }\n        else if (provider === types_1.WorkloadIdentityProvider.GCP) {\n            token = await (0, attestation_gcp_1.getGcpAttestationToken)();\n        }\n        else if (provider === types_1.WorkloadIdentityProvider.OIDC) {\n            if (this.connectionConfig.token) {\n                token = this.connectionConfig.token;\n            }\n            else {\n                throw (0, errors_1.createInvalidParameterError)(errors_1.ErrorCode.ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS, `workloadIdentityProvider: OIDC requires token in connection options`);\n            }\n        }\n        else {\n            throw (0, errors_1.createInvalidParameterError)(errors_1.ErrorCode.ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS, `workloadIdentityProvider must be one of: ${Object.values(types_1.WorkloadIdentityProvider).join(', ')}`);\n        }\n        (0, logger_1.default)().debug(`AuthWorkloadIdentity using provider=${provider}`);\n        this.tokenProvider = provider;\n        this.token = token;\n    }\n}\nexports[\"default\"] = AuthWorkloadIdentity;\n//# sourceMappingURL=auth_workload_identity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2F1dGhfd29ya2xvYWRfaWRlbnRpdHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQywrSEFBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsMkdBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWM7QUFDdkMsaUNBQWlDLG1CQUFPLENBQUMsMkVBQWM7QUFDdkQsNEJBQTRCLG1CQUFPLENBQUMsbUlBQXFCO0FBQ3pELDBCQUEwQixtQkFBTyxDQUFDLCtIQUFtQjtBQUNyRCwrQ0FBK0MsbUJBQU8sQ0FBQyxtSEFBeUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUxBQWlMLDJEQUEyRDtBQUM1TztBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF93b3JrbG9hZF9pZGVudGl0eS9hdXRoX3dvcmtsb2FkX2lkZW50aXR5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXR0ZXN0YXRpb25fYXdzXzEgPSByZXF1aXJlKFwiLi9hdHRlc3RhdGlvbl9hd3NcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGF0dGVzdGF0aW9uX2F6dXJlXzEgPSByZXF1aXJlKFwiLi9hdHRlc3RhdGlvbl9henVyZVwiKTtcbmNvbnN0IGF0dGVzdGF0aW9uX2djcF8xID0gcmVxdWlyZShcIi4vYXR0ZXN0YXRpb25fZ2NwXCIpO1xuY29uc3QgYXV0aGVudGljYXRpb25fdHlwZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXV0aGVudGljYXRpb25fdHlwZXNcIikpO1xuY2xhc3MgQXV0aFdvcmtsb2FkSWRlbnRpdHkge1xuICAgIGNvbm5lY3Rpb25Db25maWc7XG4gICAgdG9rZW5Qcm92aWRlcjtcbiAgICB0b2tlbjtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgfVxuICAgIHVwZGF0ZUJvZHkoYm9keSkge1xuICAgICAgICBib2R5LmRhdGFbJ0FVVEhFTlRJQ0FUT1InXSA9IGF1dGhlbnRpY2F0aW9uX3R5cGVzXzEuZGVmYXVsdC5XT1JLTE9BRF9JREVOVElUWTtcbiAgICAgICAgYm9keS5kYXRhWydQUk9WSURFUiddID0gdGhpcy50b2tlblByb3ZpZGVyO1xuICAgICAgICBib2R5LmRhdGFbJ1RPS0VOJ10gPSB0aGlzLnRva2VuO1xuICAgIH1cbiAgICBhc3luYyBhdXRoZW50aWNhdGUoKSB7XG4gICAgICAgIGxldCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy53b3JrbG9hZElkZW50aXR5UHJvdmlkZXI7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSB0eXBlc18xLldvcmtsb2FkSWRlbnRpdHlQcm92aWRlci5BV1MpIHtcbiAgICAgICAgICAgIHRva2VuID0gYXdhaXQgKDAsIGF0dGVzdGF0aW9uX2F3c18xLmdldEF3c0F0dGVzdGF0aW9uVG9rZW4pKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgPT09IHR5cGVzXzEuV29ya2xvYWRJZGVudGl0eVByb3ZpZGVyLkFaVVJFKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGF3YWl0ICgwLCBhdHRlc3RhdGlvbl9henVyZV8xLmdldEF6dXJlQXR0ZXN0YXRpb25Ub2tlbikodGhpcy5jb25uZWN0aW9uQ29uZmlnLndvcmtsb2FkSWRlbnRpdHlBenVyZUVudHJhSWRSZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgPT09IHR5cGVzXzEuV29ya2xvYWRJZGVudGl0eVByb3ZpZGVyLkdDUCkge1xuICAgICAgICAgICAgdG9rZW4gPSBhd2FpdCAoMCwgYXR0ZXN0YXRpb25fZ2NwXzEuZ2V0R2NwQXR0ZXN0YXRpb25Ub2tlbikoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlciA9PT0gdHlwZXNfMS5Xb3JrbG9hZElkZW50aXR5UHJvdmlkZXIuT0lEQykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkNvbmZpZy50b2tlbikge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLmNyZWF0ZUludmFsaWRQYXJhbWV0ZXJFcnJvcikoZXJyb3JzXzEuRXJyb3JDb2RlLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1dPUktMT0FEX0lERU5USVRZX1BBUkFNRVRFUlMsIGB3b3JrbG9hZElkZW50aXR5UHJvdmlkZXI6IE9JREMgcmVxdWlyZXMgdG9rZW4gaW4gY29ubmVjdGlvbiBvcHRpb25zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JzXzEuY3JlYXRlSW52YWxpZFBhcmFtZXRlckVycm9yKShlcnJvcnNfMS5FcnJvckNvZGUuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfV09SS0xPQURfSURFTlRJVFlfUEFSQU1FVEVSUywgYHdvcmtsb2FkSWRlbnRpdHlQcm92aWRlciBtdXN0IGJlIG9uZSBvZjogJHtPYmplY3QudmFsdWVzKHR5cGVzXzEuV29ya2xvYWRJZGVudGl0eVByb3ZpZGVyKS5qb2luKCcsICcpfWApO1xuICAgICAgICB9XG4gICAgICAgICgwLCBsb2dnZXJfMS5kZWZhdWx0KSgpLmRlYnVnKGBBdXRoV29ya2xvYWRJZGVudGl0eSB1c2luZyBwcm92aWRlcj0ke3Byb3ZpZGVyfWApO1xuICAgICAgICB0aGlzLnRva2VuUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGhXb3JrbG9hZElkZW50aXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aF93b3JrbG9hZF9pZGVudGl0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = void 0;\nvar auth_workload_identity_1 = __webpack_require__(/*! ./auth_workload_identity */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/auth_workload_identity.js\");\nObject.defineProperty(exports, \"default\", ({ enumerable: true, get: function () { return __importDefault(auth_workload_identity_1).default; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWU7QUFDZiwrQkFBK0IsbUJBQU8sQ0FBQyw2SUFBMEI7QUFDakUsMkNBQTBDLEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQy9JIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGF1dGhfd29ya2xvYWRfaWRlbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2F1dGhfd29ya2xvYWRfaWRlbnRpdHlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQoYXV0aF93b3JrbG9hZF9pZGVudGl0eV8xKS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorkloadIdentityProvider = void 0;\n// NOTE:\n// Intentionally not an enum as we want users to pass strings\nexports.WorkloadIdentityProvider = {\n    AWS: 'AWS',\n    AZURE: 'AZURE',\n    GCP: 'GCP',\n    OIDC: 'OIDC',\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dvcmtsb2FkX2lkZW50aXR5L3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aF93b3JrbG9hZF9pZGVudGl0eS90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29ya2xvYWRJZGVudGl0eVByb3ZpZGVyID0gdm9pZCAwO1xuLy8gTk9URTpcbi8vIEludGVudGlvbmFsbHkgbm90IGFuIGVudW0gYXMgd2Ugd2FudCB1c2VycyB0byBwYXNzIHN0cmluZ3NcbmV4cG9ydHMuV29ya2xvYWRJZGVudGl0eVByb3ZpZGVyID0ge1xuICAgIEFXUzogJ0FXUycsXG4gICAgQVpVUkU6ICdBWlVSRScsXG4gICAgR0NQOiAnR0NQJyxcbiAgICBPSURDOiAnT0lEQycsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst AuthDefault = __webpack_require__(/*! ./auth_default */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_default.js\");\nconst AuthWeb = __webpack_require__(/*! ./auth_web */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_web.js\");\nconst AuthKeypair = __webpack_require__(/*! ./auth_keypair */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js\");\nconst AuthOauth = __webpack_require__(/*! ./auth_oauth */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth.js\");\nconst AuthOauthPAT = __webpack_require__(/*! ./auth_oauth_pat */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_pat.js\");\nconst AuthOkta = __webpack_require__(/*! ./auth_okta */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js\");\nconst AuthIDToken = __webpack_require__(/*! ./auth_idtoken */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst AuthOauthAuthorizationCode = __webpack_require__(/*! ./auth_oauth_authorization_code */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js\");\nconst AuthOauthClientCredentials = (__webpack_require__(/*! ./auth_oauth_client_credentials */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_client_credentials.js\")[\"default\"]);\nconst AuthWorkloadIdentity = (__webpack_require__(/*! ./auth_workload_identity */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_workload_identity/index.js\")[\"default\"]);\n/**\n * TODO: Refactor\n * - StateConnecting.continue in sf.js and ConnectionConfig adds almost every param\n *   from this function (overwrites them)\n * - AUTHENTICATOR is implemented in almost every auth provider\n *\n * Refactor Plan:\n * - Have a single place to build CLIENT_ENVIRONMENT: ConnectionConfig or sf.js\n * - Have a single place to build common params by either:\n *  - Removing this method\n *  - Moving logic from StateConnecting.continue to this method.\n *    Options should be simplified to accept only ConnectionConfig\n * - Rename auth.updateBody to auth.buildData (as it only builds keys under body.data)\n * - Ensure AUTHENTICATOR is set in every auth provider\n * - Cleanup StateConnecting.continue so it's more clear how final body is built\n *\n * Returns the JSON body to be sent when connecting.\n *\n * @param {String} authenticator\n * @param {String} account\n * @param {String} username\n * @param {String} clientType\n * @param {String} clientVersion\n * @param {Object} clientEnv\n *\n * @returns {JSON}\n */\nexports.formAuthJSON = function formAuthJSON(authenticator, account, username, clientType, clientVersion, clientEnv) {\n    const body = {\n        data: {\n            ACCOUNT_NAME: account,\n            CLIENT_APP_ID: clientType,\n            CLIENT_APP_VERSION: clientVersion,\n            CLIENT_ENVIRONMENT: {\n                OS: clientEnv.OS,\n                OS_VERSION: clientEnv.OS_VERSION,\n                OCSP_MODE: clientEnv.OCSP_MODE,\n            },\n        },\n    };\n    if (!this.isOktaAuth(authenticator)) {\n        body['data']['AUTHENTICATOR'] = authenticator;\n        body['data']['LOGIN_NAME'] = username;\n    }\n    return body;\n};\n/**\n * Returns the authenticator to use base on the connection configuration.\n *\n * @param {Object} connectionConfig\n * @param httpClient\n *\n * @returns {Object} the authenticator.\n */\nexports.getAuthenticator = function getAuthenticator(connectionConfig, httpClient) {\n    const authType = connectionConfig.getAuthenticator();\n    const openExternalBrowserCallback = connectionConfig.openExternalBrowserCallback; // Important for SSO in the Snowflake VS Code extension\n    let auth;\n    if (authType === AuthenticationTypes.DEFAULT_AUTHENTICATOR ||\n        authType === AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR) {\n        auth = new AuthDefault(connectionConfig);\n    }\n    else if (authType === AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR) {\n        if (connectionConfig.getClientStoreTemporaryCredential() && !!connectionConfig.idToken) {\n            auth = new AuthIDToken(connectionConfig, httpClient, openExternalBrowserCallback);\n        }\n        else {\n            auth = new AuthWeb(connectionConfig, httpClient, openExternalBrowserCallback);\n        }\n    }\n    else if (authType === AuthenticationTypes.KEY_PAIR_AUTHENTICATOR) {\n        auth = new AuthKeypair(connectionConfig);\n    }\n    else if (authType === AuthenticationTypes.OAUTH_AUTHENTICATOR) {\n        auth = new AuthOauth(connectionConfig.getToken());\n    }\n    else if (authType === AuthenticationTypes.PROGRAMMATIC_ACCESS_TOKEN) {\n        auth = new AuthOauthPAT(connectionConfig.getToken(), connectionConfig.password);\n    }\n    else if (authType === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE) {\n        auth = new AuthOauthAuthorizationCode(connectionConfig, httpClient);\n    }\n    else if (authType === AuthenticationTypes.OAUTH_CLIENT_CREDENTIALS) {\n        auth = new AuthOauthClientCredentials(connectionConfig, httpClient);\n    }\n    else if (this.isOktaAuth(authType)) {\n        auth = new AuthOkta(connectionConfig, httpClient);\n    }\n    else if (authType === AuthenticationTypes.WORKLOAD_IDENTITY) {\n        auth = new AuthWorkloadIdentity(connectionConfig, httpClient);\n    }\n    else {\n        // Authenticator specified does not exist\n        Logger.getInstance().warn(`No authenticator found for '${authType}'. Using default authenticator as a fallback`);\n        auth = new AuthDefault(connectionConfig);\n    }\n    return auth;\n};\n/**\n * Returns the boolean describing if the provided authenticator is okta or not.\n *\n * @param {String} authenticator\n * @returns {boolean}\n */\nexports.isOktaAuth = function isOktaAuth(authenticator) {\n    return authenticator.toUpperCase().startsWith('HTTPS://');\n};\n//# sourceMappingURL=authentication.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLGtHQUFnQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBWTtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBZ0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQWM7QUFDeEMscUJBQXFCLG1CQUFPLENBQUMsc0dBQWtCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFhO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLGtHQUFnQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsa0hBQXdCO0FBQzVELG1DQUFtQyxtQkFBTyxDQUFDLG9JQUFpQztBQUM1RSxtQ0FBbUMsc0tBQWtEO0FBQ3JGLDZCQUE2Qiw4SkFBMkM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQXV0aERlZmF1bHQgPSByZXF1aXJlKCcuL2F1dGhfZGVmYXVsdCcpO1xuY29uc3QgQXV0aFdlYiA9IHJlcXVpcmUoJy4vYXV0aF93ZWInKTtcbmNvbnN0IEF1dGhLZXlwYWlyID0gcmVxdWlyZSgnLi9hdXRoX2tleXBhaXInKTtcbmNvbnN0IEF1dGhPYXV0aCA9IHJlcXVpcmUoJy4vYXV0aF9vYXV0aCcpO1xuY29uc3QgQXV0aE9hdXRoUEFUID0gcmVxdWlyZSgnLi9hdXRoX29hdXRoX3BhdCcpO1xuY29uc3QgQXV0aE9rdGEgPSByZXF1aXJlKCcuL2F1dGhfb2t0YScpO1xuY29uc3QgQXV0aElEVG9rZW4gPSByZXF1aXJlKCcuL2F1dGhfaWR0b2tlbicpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBBdXRoZW50aWNhdGlvblR5cGVzID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbl90eXBlcycpO1xuY29uc3QgQXV0aE9hdXRoQXV0aG9yaXphdGlvbkNvZGUgPSByZXF1aXJlKCcuL2F1dGhfb2F1dGhfYXV0aG9yaXphdGlvbl9jb2RlJyk7XG5jb25zdCBBdXRoT2F1dGhDbGllbnRDcmVkZW50aWFscyA9IHJlcXVpcmUoJy4vYXV0aF9vYXV0aF9jbGllbnRfY3JlZGVudGlhbHMnKS5kZWZhdWx0O1xuY29uc3QgQXV0aFdvcmtsb2FkSWRlbnRpdHkgPSByZXF1aXJlKCcuL2F1dGhfd29ya2xvYWRfaWRlbnRpdHknKS5kZWZhdWx0O1xuLyoqXG4gKiBUT0RPOiBSZWZhY3RvclxuICogLSBTdGF0ZUNvbm5lY3RpbmcuY29udGludWUgaW4gc2YuanMgYW5kIENvbm5lY3Rpb25Db25maWcgYWRkcyBhbG1vc3QgZXZlcnkgcGFyYW1cbiAqICAgZnJvbSB0aGlzIGZ1bmN0aW9uIChvdmVyd3JpdGVzIHRoZW0pXG4gKiAtIEFVVEhFTlRJQ0FUT1IgaXMgaW1wbGVtZW50ZWQgaW4gYWxtb3N0IGV2ZXJ5IGF1dGggcHJvdmlkZXJcbiAqXG4gKiBSZWZhY3RvciBQbGFuOlxuICogLSBIYXZlIGEgc2luZ2xlIHBsYWNlIHRvIGJ1aWxkIENMSUVOVF9FTlZJUk9OTUVOVDogQ29ubmVjdGlvbkNvbmZpZyBvciBzZi5qc1xuICogLSBIYXZlIGEgc2luZ2xlIHBsYWNlIHRvIGJ1aWxkIGNvbW1vbiBwYXJhbXMgYnkgZWl0aGVyOlxuICogIC0gUmVtb3ZpbmcgdGhpcyBtZXRob2RcbiAqICAtIE1vdmluZyBsb2dpYyBmcm9tIFN0YXRlQ29ubmVjdGluZy5jb250aW51ZSB0byB0aGlzIG1ldGhvZC5cbiAqICAgIE9wdGlvbnMgc2hvdWxkIGJlIHNpbXBsaWZpZWQgdG8gYWNjZXB0IG9ubHkgQ29ubmVjdGlvbkNvbmZpZ1xuICogLSBSZW5hbWUgYXV0aC51cGRhdGVCb2R5IHRvIGF1dGguYnVpbGREYXRhIChhcyBpdCBvbmx5IGJ1aWxkcyBrZXlzIHVuZGVyIGJvZHkuZGF0YSlcbiAqIC0gRW5zdXJlIEFVVEhFTlRJQ0FUT1IgaXMgc2V0IGluIGV2ZXJ5IGF1dGggcHJvdmlkZXJcbiAqIC0gQ2xlYW51cCBTdGF0ZUNvbm5lY3RpbmcuY29udGludWUgc28gaXQncyBtb3JlIGNsZWFyIGhvdyBmaW5hbCBib2R5IGlzIGJ1aWx0XG4gKlxuICogUmV0dXJucyB0aGUgSlNPTiBib2R5IHRvIGJlIHNlbnQgd2hlbiBjb25uZWN0aW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xpZW50VHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsaWVudFZlcnNpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnRFbnZcbiAqXG4gKiBAcmV0dXJucyB7SlNPTn1cbiAqL1xuZXhwb3J0cy5mb3JtQXV0aEpTT04gPSBmdW5jdGlvbiBmb3JtQXV0aEpTT04oYXV0aGVudGljYXRvciwgYWNjb3VudCwgdXNlcm5hbWUsIGNsaWVudFR5cGUsIGNsaWVudFZlcnNpb24sIGNsaWVudEVudikge1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIEFDQ09VTlRfTkFNRTogYWNjb3VudCxcbiAgICAgICAgICAgIENMSUVOVF9BUFBfSUQ6IGNsaWVudFR5cGUsXG4gICAgICAgICAgICBDTElFTlRfQVBQX1ZFUlNJT046IGNsaWVudFZlcnNpb24sXG4gICAgICAgICAgICBDTElFTlRfRU5WSVJPTk1FTlQ6IHtcbiAgICAgICAgICAgICAgICBPUzogY2xpZW50RW52Lk9TLFxuICAgICAgICAgICAgICAgIE9TX1ZFUlNJT046IGNsaWVudEVudi5PU19WRVJTSU9OLFxuICAgICAgICAgICAgICAgIE9DU1BfTU9ERTogY2xpZW50RW52Lk9DU1BfTU9ERSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuaXNPa3RhQXV0aChhdXRoZW50aWNhdG9yKSkge1xuICAgICAgICBib2R5WydkYXRhJ11bJ0FVVEhFTlRJQ0FUT1InXSA9IGF1dGhlbnRpY2F0b3I7XG4gICAgICAgIGJvZHlbJ2RhdGEnXVsnTE9HSU5fTkFNRSddID0gdXNlcm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYXV0aGVudGljYXRvciB0byB1c2UgYmFzZSBvbiB0aGUgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0gaHR0cENsaWVudFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBhdXRoZW50aWNhdG9yLlxuICovXG5leHBvcnRzLmdldEF1dGhlbnRpY2F0b3IgPSBmdW5jdGlvbiBnZXRBdXRoZW50aWNhdG9yKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpIHtcbiAgICBjb25zdCBhdXRoVHlwZSA9IGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpO1xuICAgIGNvbnN0IG9wZW5FeHRlcm5hbEJyb3dzZXJDYWxsYmFjayA9IGNvbm5lY3Rpb25Db25maWcub3BlbkV4dGVybmFsQnJvd3NlckNhbGxiYWNrOyAvLyBJbXBvcnRhbnQgZm9yIFNTTyBpbiB0aGUgU25vd2ZsYWtlIFZTIENvZGUgZXh0ZW5zaW9uXG4gICAgbGV0IGF1dGg7XG4gICAgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLkRFRkFVTFRfQVVUSEVOVElDQVRPUiB8fFxuICAgICAgICBhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5VU0VSX1BXRF9NRkFfQVVUSEVOVElDQVRPUikge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhEZWZhdWx0KGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5FWFRFUk5BTF9CUk9XU0VSX0FVVEhFTlRJQ0FUT1IpIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKCkgJiYgISFjb25uZWN0aW9uQ29uZmlnLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIGF1dGggPSBuZXcgQXV0aElEVG9rZW4oY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgb3BlbkV4dGVybmFsQnJvd3NlckNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF1dGggPSBuZXcgQXV0aFdlYihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBvcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLktFWV9QQUlSX0FVVEhFTlRJQ0FUT1IpIHtcbiAgICAgICAgYXV0aCA9IG5ldyBBdXRoS2V5cGFpcihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSEVOVElDQVRPUikge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhPYXV0aChjb25uZWN0aW9uQ29uZmlnLmdldFRva2VuKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5QUk9HUkFNTUFUSUNfQUNDRVNTX1RPS0VOKSB7XG4gICAgICAgIGF1dGggPSBuZXcgQXV0aE9hdXRoUEFUKGNvbm5lY3Rpb25Db25maWcuZ2V0VG9rZW4oKSwgY29ubmVjdGlvbkNvbmZpZy5wYXNzd29yZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSkge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhPYXV0aEF1dGhvcml6YXRpb25Db2RlKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9DTElFTlRfQ1JFREVOVElBTFMpIHtcbiAgICAgICAgYXV0aCA9IG5ldyBBdXRoT2F1dGhDbGllbnRDcmVkZW50aWFscyhjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc09rdGFBdXRoKGF1dGhUeXBlKSkge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhPa3RhKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5XT1JLTE9BRF9JREVOVElUWSkge1xuICAgICAgICBhdXRoID0gbmV3IEF1dGhXb3JrbG9hZElkZW50aXR5KGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQXV0aGVudGljYXRvciBzcGVjaWZpZWQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgTm8gYXV0aGVudGljYXRvciBmb3VuZCBmb3IgJyR7YXV0aFR5cGV9Jy4gVXNpbmcgZGVmYXVsdCBhdXRoZW50aWNhdG9yIGFzIGEgZmFsbGJhY2tgKTtcbiAgICAgICAgYXV0aCA9IG5ldyBBdXRoRGVmYXVsdChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGg7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBib29sZWFuIGRlc2NyaWJpbmcgaWYgdGhlIHByb3ZpZGVkIGF1dGhlbnRpY2F0b3IgaXMgb2t0YSBvciBub3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzT2t0YUF1dGggPSBmdW5jdGlvbiBpc09rdGFBdXRoKGF1dGhlbnRpY2F0b3IpIHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRvci50b1VwcGVyQ2FzZSgpLnN0YXJ0c1dpdGgoJ0hUVFBTOi8vJyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aGVudGljYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js":
/*!************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js ***!
  \************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AuthenticationTypes;\n(function (AuthenticationTypes) {\n    AuthenticationTypes[\"DEFAULT_AUTHENTICATOR\"] = \"SNOWFLAKE\";\n    AuthenticationTypes[\"EXTERNAL_BROWSER_AUTHENTICATOR\"] = \"EXTERNALBROWSER\";\n    AuthenticationTypes[\"KEY_PAIR_AUTHENTICATOR\"] = \"SNOWFLAKE_JWT\";\n    AuthenticationTypes[\"OAUTH_AUTHENTICATOR\"] = \"OAUTH\";\n    AuthenticationTypes[\"USER_PWD_MFA_AUTHENTICATOR\"] = \"USERNAME_PASSWORD_MFA\";\n    AuthenticationTypes[\"ID_TOKEN_AUTHENTICATOR\"] = \"ID_TOKEN\";\n    AuthenticationTypes[\"PROGRAMMATIC_ACCESS_TOKEN\"] = \"PROGRAMMATIC_ACCESS_TOKEN\";\n    AuthenticationTypes[\"OAUTH_AUTHORIZATION_CODE\"] = \"OAUTH_AUTHORIZATION_CODE\";\n    AuthenticationTypes[\"OAUTH_CLIENT_CREDENTIALS\"] = \"OAUTH_CLIENT_CREDENTIALS\";\n    AuthenticationTypes[\"WORKLOAD_IDENTITY\"] = \"WORKLOAD_IDENTITY\";\n})(AuthenticationTypes || (AuthenticationTypes = {}));\nmodule.exports = AuthenticationTypes;\nexports[\"default\"] = AuthenticationTypes;\n//# sourceMappingURL=authentication_types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEF1dGhlbnRpY2F0aW9uVHlwZXM7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0aW9uVHlwZXMpIHtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiREVGQVVMVF9BVVRIRU5USUNBVE9SXCJdID0gXCJTTk9XRkxBS0VcIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiRVhURVJOQUxfQlJPV1NFUl9BVVRIRU5USUNBVE9SXCJdID0gXCJFWFRFUk5BTEJST1dTRVJcIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiS0VZX1BBSVJfQVVUSEVOVElDQVRPUlwiXSA9IFwiU05PV0ZMQUtFX0pXVFwiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJPQVVUSF9BVVRIRU5USUNBVE9SXCJdID0gXCJPQVVUSFwiO1xuICAgIEF1dGhlbnRpY2F0aW9uVHlwZXNbXCJVU0VSX1BXRF9NRkFfQVVUSEVOVElDQVRPUlwiXSA9IFwiVVNFUk5BTUVfUEFTU1dPUkRfTUZBXCI7XG4gICAgQXV0aGVudGljYXRpb25UeXBlc1tcIklEX1RPS0VOX0FVVEhFTlRJQ0FUT1JcIl0gPSBcIklEX1RPS0VOXCI7XG4gICAgQXV0aGVudGljYXRpb25UeXBlc1tcIlBST0dSQU1NQVRJQ19BQ0NFU1NfVE9LRU5cIl0gPSBcIlBST0dSQU1NQVRJQ19BQ0NFU1NfVE9LRU5cIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiT0FVVEhfQVVUSE9SSVpBVElPTl9DT0RFXCJdID0gXCJPQVVUSF9BVVRIT1JJWkFUSU9OX0NPREVcIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiT0FVVEhfQ0xJRU5UX0NSRURFTlRJQUxTXCJdID0gXCJPQVVUSF9DTElFTlRfQ1JFREVOVElBTFNcIjtcbiAgICBBdXRoZW50aWNhdGlvblR5cGVzW1wiV09SS0xPQURfSURFTlRJVFlcIl0gPSBcIldPUktMT0FEX0lERU5USVRZXCI7XG59KShBdXRoZW50aWNhdGlvblR5cGVzIHx8IChBdXRoZW50aWNhdGlvblR5cGVzID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gQXV0aGVudGljYXRpb25UeXBlcztcbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGhlbnRpY2F0aW9uVHlwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoZW50aWNhdGlvbl90eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst net = __webpack_require__(/*! net */ \"net\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst { exists, format, escapeHTML, buildCredentialCacheKey } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst responseHeadersAsString = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nConnection: close\\r\\n\\r\\n';\nconst successResponse = 'Your identity was confirmed and propagated to Snowflake Node.js driver. You can close this window now and go back where you started from.';\nconst SNOWFLAKE_DOMAIN_REGEX = /(^|\\.)snowflakecomputing\\.(com|cn)/;\n/**\n * Create server to retrieve SAML token.\n *\n * @param {Function} resolve\n * @param {Function} reject\n *\n * @returns {Server}\n */\nfunction createServer(resolve, reject) {\n    const server = net.createServer(function (socket) {\n        socket.on('data', function (chunk) {\n            // Receive the data and split by line\n            const data = chunk.toString().split('\\r\\n');\n            if (data[0].includes('?error=')) {\n                // Error d credentials\n                const error = prepareError(data[0]);\n                socket.write(`${responseHeadersAsString} ${escapeHTML(error)}`, 'utf8');\n                socket.destroy();\n                server.close();\n                Logger.getInstance().trace(`Error during authorization: ${error}`);\n                reject(error);\n            }\n            else {\n                // User successfully entered credentials\n                socket.write(`${responseHeadersAsString} ${escapeHTML(successResponse)}`, 'utf8');\n                socket.destroy();\n                server.close();\n                Logger.getInstance().trace('User successfully entered authorization code');\n                resolve(data[0]);\n            }\n        });\n        socket.on('error', (socketErr) => {\n            if (socketErr['code'] === 'ECONNRESET') {\n                socket.end();\n            }\n            else {\n                throw socketErr;\n            }\n        });\n    });\n    return server;\n}\nconst withBrowserActionTimeout = (millis, promise) => {\n    let timeoutId;\n    const timeout = new Promise((resolve, reject) => (timeoutId = setTimeout(() => reject(`Browser action timed out after ${millis} ms.`), millis)));\n    return Promise.race([promise, timeout]).finally(() => {\n        clearTimeout(timeoutId);\n    });\n};\nfunction prepareError(rejected) {\n    const errorResponse = querystring.parse(rejected.substring(rejected.indexOf('?') + 1));\n    const error = errorResponse['error'];\n    const errorDescription = errorResponse['error_description'].replace(new RegExp('\\\\sHTTP/.*'), '');\n    return format('Error while getting oauth authorization code. ErrorCode %s. Message: %s', error, errorDescription);\n}\nfunction getTokenUrl(options) {\n    const tokenUrl = options.getOauthTokenRequestUrl();\n    Logger.getInstance().debug(`Url used for receiving token: ${tokenUrl}`);\n    return new URL(tokenUrl);\n}\nasync function prepareScope(options) {\n    const scope = exists(options.getOauthScope())\n        ? options.getOauthScope()\n        : `session:role:${options.getRole()}`;\n    Logger.getInstance().debug(`Prepared scope used for receiving authorization code: ${scope}`);\n    return scope;\n}\nconst readCache = async (key) => {\n    if (exists(GlobalConfig.getCredentialManager())) {\n        return GlobalConfig.getCredentialManager().read(key);\n    }\n    else {\n        return null;\n    }\n};\nconst writeToCache = async (key, value) => {\n    if (exists(GlobalConfig.getCredentialManager())) {\n        return GlobalConfig.getCredentialManager().write(key, value);\n    }\n};\nconst removeFromCache = async (key) => {\n    if (exists(GlobalConfig.getCredentialManager())) {\n        return GlobalConfig.getCredentialManager().remove(key);\n    }\n};\nconst buildOauthAccessTokenCacheKey = (host, username, authenticationType) => buildCredentialCacheKey(host, username, authenticationType + '_access_token');\nconst buildOauthRefreshTokenCacheKey = (host, username, authenticationType) => buildCredentialCacheKey(host, username, authenticationType + '_refresh_token');\nconst isSnowflakeHost = (url) => {\n    return SNOWFLAKE_DOMAIN_REGEX.test(url);\n};\nexports.createServer = createServer;\nexports.withBrowserActionTimeout = withBrowserActionTimeout;\nexports.getTokenUrl = getTokenUrl;\nexports.prepareScope = prepareScope;\nexports.readCache = readCache;\nexports.writeToCache = writeToCache;\nexports.removeFromCache = removeFromCache;\nexports.buildOauthAccessTokenCacheKey = buildOauthAccessTokenCacheKey;\nexports.buildOauthRefreshTokenCacheKey = buildOauthRefreshTokenCacheKey;\nexports.isSnowflakeHost = isSnowflakeHost;\n//# sourceMappingURL=authentication_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLFFBQVEsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyxvRUFBUztBQUNqRixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QixFQUFFLGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0EsMEVBQTBFLE1BQU07QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCLEVBQUUsNEJBQTRCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILFFBQVE7QUFDcEk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1Qyx3RkFBd0YsTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QixxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgeyBleGlzdHMsIGZvcm1hdCwgZXNjYXBlSFRNTCwgYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgcmVzcG9uc2VIZWFkZXJzQXNTdHJpbmcgPSAnSFRUUC8xLjEgMjAwIE9LXFxyXFxuQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluXFxyXFxuQ29ubmVjdGlvbjogY2xvc2VcXHJcXG5cXHJcXG4nO1xuY29uc3Qgc3VjY2Vzc1Jlc3BvbnNlID0gJ1lvdXIgaWRlbnRpdHkgd2FzIGNvbmZpcm1lZCBhbmQgcHJvcGFnYXRlZCB0byBTbm93Zmxha2UgTm9kZS5qcyBkcml2ZXIuIFlvdSBjYW4gY2xvc2UgdGhpcyB3aW5kb3cgbm93IGFuZCBnbyBiYWNrIHdoZXJlIHlvdSBzdGFydGVkIGZyb20uJztcbmNvbnN0IFNOT1dGTEFLRV9ET01BSU5fUkVHRVggPSAvKF58XFwuKXNub3dmbGFrZWNvbXB1dGluZ1xcLihjb218Y24pLztcbi8qKlxuICogQ3JlYXRlIHNlcnZlciB0byByZXRyaWV2ZSBTQU1MIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdFxuICpcbiAqIEByZXR1cm5zIHtTZXJ2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBuZXQuY3JlYXRlU2VydmVyKGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAvLyBSZWNlaXZlIHRoZSBkYXRhIGFuZCBzcGxpdCBieSBsaW5lXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2h1bmsudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXS5pbmNsdWRlcygnP2Vycm9yPScpKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3IgZCBjcmVkZW50aWFsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcHJlcGFyZUVycm9yKGRhdGFbMF0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC53cml0ZShgJHtyZXNwb25zZUhlYWRlcnNBc1N0cmluZ30gJHtlc2NhcGVIVE1MKGVycm9yKX1gLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYEVycm9yIGR1cmluZyBhdXRob3JpemF0aW9uOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHN1Y2Nlc3NmdWxseSBlbnRlcmVkIGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgc29ja2V0LndyaXRlKGAke3Jlc3BvbnNlSGVhZGVyc0FzU3RyaW5nfSAke2VzY2FwZUhUTUwoc3VjY2Vzc1Jlc3BvbnNlKX1gLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1VzZXIgc3VjY2Vzc2Z1bGx5IGVudGVyZWQgYXV0aG9yaXphdGlvbiBjb2RlJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoc29ja2V0RXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoc29ja2V0RXJyWydjb2RlJ10gPT09ICdFQ09OTlJFU0VUJykge1xuICAgICAgICAgICAgICAgIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHNvY2tldEVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcnZlcjtcbn1cbmNvbnN0IHdpdGhCcm93c2VyQWN0aW9uVGltZW91dCA9IChtaWxsaXMsIHByb21pc2UpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiAodGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QoYEJyb3dzZXIgYWN0aW9uIHRpbWVkIG91dCBhZnRlciAke21pbGxpc30gbXMuYCksIG1pbGxpcykpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lb3V0XSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIHByZXBhcmVFcnJvcihyZWplY3RlZCkge1xuICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBxdWVyeXN0cmluZy5wYXJzZShyZWplY3RlZC5zdWJzdHJpbmcocmVqZWN0ZWQuaW5kZXhPZignPycpICsgMSkpO1xuICAgIGNvbnN0IGVycm9yID0gZXJyb3JSZXNwb25zZVsnZXJyb3InXTtcbiAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gZXJyb3JSZXNwb25zZVsnZXJyb3JfZGVzY3JpcHRpb24nXS5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxzSFRUUC8uKicpLCAnJyk7XG4gICAgcmV0dXJuIGZvcm1hdCgnRXJyb3Igd2hpbGUgZ2V0dGluZyBvYXV0aCBhdXRob3JpemF0aW9uIGNvZGUuIEVycm9yQ29kZSAlcy4gTWVzc2FnZTogJXMnLCBlcnJvciwgZXJyb3JEZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiBnZXRUb2tlblVybChvcHRpb25zKSB7XG4gICAgY29uc3QgdG9rZW5VcmwgPSBvcHRpb25zLmdldE9hdXRoVG9rZW5SZXF1ZXN0VXJsKCk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFVybCB1c2VkIGZvciByZWNlaXZpbmcgdG9rZW46ICR7dG9rZW5Vcmx9YCk7XG4gICAgcmV0dXJuIG5ldyBVUkwodG9rZW5VcmwpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVNjb3BlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzY29wZSA9IGV4aXN0cyhvcHRpb25zLmdldE9hdXRoU2NvcGUoKSlcbiAgICAgICAgPyBvcHRpb25zLmdldE9hdXRoU2NvcGUoKVxuICAgICAgICA6IGBzZXNzaW9uOnJvbGU6JHtvcHRpb25zLmdldFJvbGUoKX1gO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBQcmVwYXJlZCBzY29wZSB1c2VkIGZvciByZWNlaXZpbmcgYXV0aG9yaXphdGlvbiBjb2RlOiAke3Njb3BlfWApO1xuICAgIHJldHVybiBzY29wZTtcbn1cbmNvbnN0IHJlYWRDYWNoZSA9IGFzeW5jIChrZXkpID0+IHtcbiAgICBpZiAoZXhpc3RzKEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpKSkge1xuICAgICAgICByZXR1cm4gR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkucmVhZChrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmNvbnN0IHdyaXRlVG9DYWNoZSA9IGFzeW5jIChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKGV4aXN0cyhHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKSkpIHtcbiAgICAgICAgcmV0dXJuIEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLndyaXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCByZW1vdmVGcm9tQ2FjaGUgPSBhc3luYyAoa2V5KSA9PiB7XG4gICAgaWYgKGV4aXN0cyhHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKSkpIHtcbiAgICAgICAgcmV0dXJuIEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLnJlbW92ZShrZXkpO1xuICAgIH1cbn07XG5jb25zdCBidWlsZE9hdXRoQWNjZXNzVG9rZW5DYWNoZUtleSA9IChob3N0LCB1c2VybmFtZSwgYXV0aGVudGljYXRpb25UeXBlKSA9PiBidWlsZENyZWRlbnRpYWxDYWNoZUtleShob3N0LCB1c2VybmFtZSwgYXV0aGVudGljYXRpb25UeXBlICsgJ19hY2Nlc3NfdG9rZW4nKTtcbmNvbnN0IGJ1aWxkT2F1dGhSZWZyZXNoVG9rZW5DYWNoZUtleSA9IChob3N0LCB1c2VybmFtZSwgYXV0aGVudGljYXRpb25UeXBlKSA9PiBidWlsZENyZWRlbnRpYWxDYWNoZUtleShob3N0LCB1c2VybmFtZSwgYXV0aGVudGljYXRpb25UeXBlICsgJ19yZWZyZXNoX3Rva2VuJyk7XG5jb25zdCBpc1Nub3dmbGFrZUhvc3QgPSAodXJsKSA9PiB7XG4gICAgcmV0dXJuIFNOT1dGTEFLRV9ET01BSU5fUkVHRVgudGVzdCh1cmwpO1xufTtcbmV4cG9ydHMuY3JlYXRlU2VydmVyID0gY3JlYXRlU2VydmVyO1xuZXhwb3J0cy53aXRoQnJvd3NlckFjdGlvblRpbWVvdXQgPSB3aXRoQnJvd3NlckFjdGlvblRpbWVvdXQ7XG5leHBvcnRzLmdldFRva2VuVXJsID0gZ2V0VG9rZW5Vcmw7XG5leHBvcnRzLnByZXBhcmVTY29wZSA9IHByZXBhcmVTY29wZTtcbmV4cG9ydHMucmVhZENhY2hlID0gcmVhZENhY2hlO1xuZXhwb3J0cy53cml0ZVRvQ2FjaGUgPSB3cml0ZVRvQ2FjaGU7XG5leHBvcnRzLnJlbW92ZUZyb21DYWNoZSA9IHJlbW92ZUZyb21DYWNoZTtcbmV4cG9ydHMuYnVpbGRPYXV0aEFjY2Vzc1Rva2VuQ2FjaGVLZXkgPSBidWlsZE9hdXRoQWNjZXNzVG9rZW5DYWNoZUtleTtcbmV4cG9ydHMuYnVpbGRPYXV0aFJlZnJlc2hUb2tlbkNhY2hlS2V5ID0gYnVpbGRPYXV0aFJlZnJlc2hUb2tlbkNhY2hlS2V5O1xuZXhwb3J0cy5pc1Nub3dmbGFrZUhvc3QgPSBpc1Nub3dmbGFrZUhvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoZW50aWNhdGlvbl91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst fs = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { getSecureHandle, closeHandle } = __webpack_require__(/*! ../../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst defaultJsonTokenCachePaths = {\n    win32: ['AppData', 'Local', 'Snowflake', 'Caches'],\n    linux: ['.cache', 'snowflake'],\n    darwin: ['Library', 'Caches', 'Snowflake'],\n};\nfunction JsonCredentialManager(credentialCacheDir, timeoutMs = 60000) {\n    const tokenMapKey = 'tokens';\n    const retryInterval = 100;\n    this.hashKey = function (key) {\n        return crypto.createHash('sha256').update(key).digest('hex');\n    };\n    this.getTokenDirCandidates = function () {\n        const candidates = [];\n        candidates.push({ folder: credentialCacheDir, subfolders: [] });\n        candidates.push({ folder: process.env.SF_TEMPORARY_CREDENTIAL_CACHE_DIR, subfolders: [] });\n        switch (process.platform) {\n            case 'win32':\n                candidates.push({ folder: os.homedir(), subfolders: defaultJsonTokenCachePaths['win32'] });\n                break;\n            case 'linux':\n                candidates.push({ folder: process.env.XDG_CACHE_HOME, subfolders: ['snowflake'] });\n                candidates.push({\n                    folder: process.env.HOME,\n                    subfolders: defaultJsonTokenCachePaths['linux'],\n                });\n                break;\n            case 'darwin':\n                candidates.push({\n                    folder: process.env.HOME,\n                    subfolders: defaultJsonTokenCachePaths['darwin'],\n                });\n        }\n        return candidates;\n    };\n    this.createCacheDir = async function (cacheDir) {\n        const options = { recursive: true };\n        if (process.platform !== 'win32') {\n            options.mode = 0o755;\n        }\n        await fs.mkdir(cacheDir, options);\n        if (process.platform !== 'win32') {\n            await fs.chmod(cacheDir, 0o700);\n        }\n    };\n    this.tryTokenDir = async function (dir, subDirs) {\n        if (!Util.exists(dir)) {\n            return false;\n        }\n        const cacheDir = path.join(dir, ...subDirs);\n        try {\n            const stat = await fs.stat(dir);\n            if (!stat.isDirectory()) {\n                Logger.getInstance().info(`Path ${dir} is not a directory`);\n                return false;\n            }\n            const cacheStat = await fs.stat(cacheDir).catch(async (err) => {\n                if (err.code !== 'ENOENT') {\n                    throw err;\n                }\n                await this.createCacheDir(cacheDir);\n                return await fs.stat(cacheDir);\n            });\n            if (!cacheStat.isDirectory()) {\n                return false;\n            }\n            if (process.platform === 'win32') {\n                return true;\n            }\n            if (cacheStat.uid !== os.userInfo().uid) {\n                Logger.getInstance().warn(`Token cache directory ${cacheDir} has insecure owner.`);\n            }\n            else if ((cacheStat.mode & 0o777) !== 0o700) {\n                Logger.getInstance().warn(`Token cache directory ${cacheDir} has insecure permissions.`);\n            }\n            return true;\n        }\n        catch (err) {\n            Logger.getInstance().warn(`The location ${cacheDir} is invalid. Please check this location is accessible or existing`);\n            return false;\n        }\n    };\n    this.getTokenDir = async function () {\n        const candidates = this.getTokenDirCandidates();\n        for (const candidate of candidates) {\n            const { folder: dir, subfolders: subDirs } = candidate;\n            if (await this.tryTokenDir(dir, subDirs)) {\n                return path.join(dir, ...subDirs);\n            }\n        }\n        return null;\n    };\n    this.getTokenFilePath = async function () {\n        const tokenDir = await this.getTokenDir();\n        if (!Util.exists(tokenDir)) {\n            throw new Error(`Temporary credential cache directory is invalid, and the driver is unable to use the default location. \n      Please set 'credentialCacheDir' connection configuration option to enable the default credential manager.`);\n        }\n        return path.join(tokenDir, 'credential_cache_v1.json');\n    };\n    this.readJsonCredentialFile = async function (fileHandle) {\n        if (!Util.exists(fileHandle)) {\n            return null;\n        }\n        try {\n            const cred = await fileHandle.readFile('utf8');\n            return JSON.parse(cred);\n        }\n        catch (err) {\n            Logger.getInstance().warn('Failed to read token data from the file. Err: %s', err.message);\n            return null;\n        }\n    };\n    this.removeStale = async function (file) {\n        const stat = await fs.stat(file).catch(() => {\n            return undefined;\n        });\n        if (!Util.exists(stat)) {\n            return;\n        }\n        if (new Date().getTime() - stat.birthtimeMs > timeoutMs) {\n            try {\n                await fs.rmdir(file);\n            }\n            catch (err) {\n                Logger.getInstance().warn('Failed to remove stale file. Error: %s', err.message);\n            }\n        }\n    };\n    this.lockFile = async function (filename) {\n        const lckFile = filename + '.lck';\n        await this.removeStale(lckFile);\n        let attempts = 1;\n        let locked = false;\n        const options = {};\n        if (process.platform !== 'win32') {\n            options.mode = 0o600;\n        }\n        while (attempts <= 10) {\n            Logger.getInstance().debug('Attempting to get a lock on file %s, attempt: %d', filename, attempts);\n            attempts++;\n            await fs.mkdir(lckFile, options).then(() => {\n                locked = true;\n            }, () => { });\n            if (locked) {\n                break;\n            }\n            await new Promise((resolve) => setTimeout(resolve, retryInterval));\n        }\n        if (!locked) {\n            Logger.getInstance().warn('Could not acquire lock on cache file %s', filename);\n        }\n        return locked;\n    };\n    this.unlockFile = async function (filename) {\n        const lckFile = filename + '.lck';\n        await fs.rmdir(lckFile);\n    };\n    this.withFileLocked = async function (fun) {\n        const filename = await this.getTokenFilePath();\n        if (await this.lockFile(filename)) {\n            const res = await fun(filename);\n            await this.unlockFile(filename);\n            return res;\n        }\n        return null;\n    };\n    this.write = async function (key, token) {\n        if (!validateTokenCacheOption(key)) {\n            return null;\n        }\n        const keyHash = this.hashKey(key);\n        await this.withFileLocked(async (filename) => {\n            const fileHandle = await getSecureHandle(filename, fs.constants.O_RDWR | fs.constants.O_CREAT, fs);\n            const jsonCredential = (await this.readJsonCredentialFile(fileHandle)) || {};\n            if (!Util.exists(jsonCredential[tokenMapKey])) {\n                jsonCredential[tokenMapKey] = {};\n            }\n            jsonCredential[tokenMapKey][keyHash] = token;\n            try {\n                await fileHandle.truncate();\n                await fileHandle.write(JSON.stringify(jsonCredential), 0);\n                await closeHandle(fileHandle);\n            }\n            catch (err) {\n                Logger.getInstance().warn(`Failed to write token data in ${filename}. Please check the permission or the file format of the token. ${err.message}`);\n            }\n        });\n    };\n    this.read = async function (key) {\n        if (!validateTokenCacheOption(key)) {\n            return null;\n        }\n        const keyHash = this.hashKey(key);\n        return await this.withFileLocked(async (filename) => {\n            const fileHandle = await getSecureHandle(filename, fs.constants.O_RDWR, fs);\n            const jsonCredential = await this.readJsonCredentialFile(fileHandle);\n            await closeHandle(fileHandle);\n            if (!!jsonCredential && jsonCredential[tokenMapKey] && jsonCredential[tokenMapKey][keyHash]) {\n                return jsonCredential[tokenMapKey][keyHash];\n            }\n            else {\n                return null;\n            }\n        });\n    };\n    this.remove = async function (key) {\n        if (!validateTokenCacheOption(key)) {\n            return null;\n        }\n        const keyHash = this.hashKey(key);\n        await this.withFileLocked(async (filename) => {\n            const fileHandle = await getSecureHandle(filename, fs.constants.O_RDWR, fs);\n            const jsonCredential = await this.readJsonCredentialFile(fileHandle);\n            if (jsonCredential && jsonCredential[tokenMapKey] && jsonCredential[tokenMapKey][keyHash]) {\n                try {\n                    jsonCredential[tokenMapKey][keyHash] = null;\n                    await fileHandle.truncate();\n                    await fileHandle.write(JSON.stringify(jsonCredential), 0);\n                    await closeHandle(fileHandle);\n                }\n                catch (err) {\n                    Logger.getInstance().warn(`Failed to remove token data from the file in ${filename}. Please check the permission or the file format of the token. ${err.message}`);\n                }\n            }\n        });\n    };\n    function validateTokenCacheOption(key) {\n        return Util.checkParametersDefined(key);\n    }\n}\nmodule.exports.defaultJsonTokenCachePaths = defaultJsonTokenCachePaths;\nmodule.exports.JsonCredentialManager = JsonCredentialManager;\n//# sourceMappingURL=json_credential_manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9zZWN1cmVfc3RvcmFnZS9qc29uX2NyZWRlbnRpYWxfbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsMkVBQWM7QUFDckMsV0FBVyxtQkFBTyxDQUFDLDBDQUFrQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDO0FBQ3RFLDBCQUEwQix1RUFBdUU7QUFDakc7QUFDQTtBQUNBLGtDQUFrQyx1RUFBdUU7QUFDekc7QUFDQTtBQUNBLGtDQUFrQywrREFBK0Q7QUFDakc7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFVBQVU7QUFDN0U7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFNBQVMsaUVBQWlFLFlBQVk7QUFDaks7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixTQUFTLGlFQUFpRSxZQUFZO0FBQ3BMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQ0FBb0M7QUFDcEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL3NlY3VyZV9zdG9yYWdlL2pzb25fY3JlZGVudGlhbF9tYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uLy4uL2xvZ2dlcicpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IGdldFNlY3VyZUhhbmRsZSwgY2xvc2VIYW5kbGUgfSA9IHJlcXVpcmUoJy4uLy4uL2ZpbGVfdXRpbCcpO1xuY29uc3QgZGVmYXVsdEpzb25Ub2tlbkNhY2hlUGF0aHMgPSB7XG4gICAgd2luMzI6IFsnQXBwRGF0YScsICdMb2NhbCcsICdTbm93Zmxha2UnLCAnQ2FjaGVzJ10sXG4gICAgbGludXg6IFsnLmNhY2hlJywgJ3Nub3dmbGFrZSddLFxuICAgIGRhcndpbjogWydMaWJyYXJ5JywgJ0NhY2hlcycsICdTbm93Zmxha2UnXSxcbn07XG5mdW5jdGlvbiBKc29uQ3JlZGVudGlhbE1hbmFnZXIoY3JlZGVudGlhbENhY2hlRGlyLCB0aW1lb3V0TXMgPSA2MDAwMCkge1xuICAgIGNvbnN0IHRva2VuTWFwS2V5ID0gJ3Rva2Vucyc7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDEwMDtcbiAgICB0aGlzLmhhc2hLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGtleSkuZGlnZXN0KCdoZXgnKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG9rZW5EaXJDYW5kaWRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7IGZvbGRlcjogY3JlZGVudGlhbENhY2hlRGlyLCBzdWJmb2xkZXJzOiBbXSB9KTtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHsgZm9sZGVyOiBwcm9jZXNzLmVudi5TRl9URU1QT1JBUllfQ1JFREVOVElBTF9DQUNIRV9ESVIsIHN1YmZvbGRlcnM6IFtdIH0pO1xuICAgICAgICBzd2l0Y2ggKHByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICAgICAgICAgIGNhc2UgJ3dpbjMyJzpcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goeyBmb2xkZXI6IG9zLmhvbWVkaXIoKSwgc3ViZm9sZGVyczogZGVmYXVsdEpzb25Ub2tlbkNhY2hlUGF0aHNbJ3dpbjMyJ10gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsaW51eCc6XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHsgZm9sZGVyOiBwcm9jZXNzLmVudi5YREdfQ0FDSEVfSE9NRSwgc3ViZm9sZGVyczogWydzbm93Zmxha2UnXSB9KTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmb2xkZXI6IHByb2Nlc3MuZW52LkhPTUUsXG4gICAgICAgICAgICAgICAgICAgIHN1YmZvbGRlcnM6IGRlZmF1bHRKc29uVG9rZW5DYWNoZVBhdGhzWydsaW51eCddLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGFyd2luJzpcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmb2xkZXI6IHByb2Nlc3MuZW52LkhPTUUsXG4gICAgICAgICAgICAgICAgICAgIHN1YmZvbGRlcnM6IGRlZmF1bHRKc29uVG9rZW5DYWNoZVBhdGhzWydkYXJ3aW4nXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlcztcbiAgICB9O1xuICAgIHRoaXMuY3JlYXRlQ2FjaGVEaXIgPSBhc3luYyBmdW5jdGlvbiAoY2FjaGVEaXIpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgcmVjdXJzaXZlOiB0cnVlIH07XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1vZGUgPSAwbzc1NTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmcy5ta2RpcihjYWNoZURpciwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5jaG1vZChjYWNoZURpciwgMG83MDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnRyeVRva2VuRGlyID0gYXN5bmMgZnVuY3Rpb24gKGRpciwgc3ViRGlycykge1xuICAgICAgICBpZiAoIVV0aWwuZXhpc3RzKGRpcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZURpciA9IHBhdGguam9pbihkaXIsIC4uLnN1YkRpcnMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzLnN0YXQoZGlyKTtcbiAgICAgICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbyhgUGF0aCAke2Rpcn0gaXMgbm90IGEgZGlyZWN0b3J5YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVTdGF0ID0gYXdhaXQgZnMuc3RhdChjYWNoZURpcikuY2F0Y2goYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUNhY2hlRGlyKGNhY2hlRGlyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZnMuc3RhdChjYWNoZURpcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2FjaGVTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhY2hlU3RhdC51aWQgIT09IG9zLnVzZXJJbmZvKCkudWlkKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgVG9rZW4gY2FjaGUgZGlyZWN0b3J5ICR7Y2FjaGVEaXJ9IGhhcyBpbnNlY3VyZSBvd25lci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChjYWNoZVN0YXQubW9kZSAmIDBvNzc3KSAhPT0gMG83MDApIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBUb2tlbiBjYWNoZSBkaXJlY3RvcnkgJHtjYWNoZURpcn0gaGFzIGluc2VjdXJlIHBlcm1pc3Npb25zLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgVGhlIGxvY2F0aW9uICR7Y2FjaGVEaXJ9IGlzIGludmFsaWQuIFBsZWFzZSBjaGVjayB0aGlzIGxvY2F0aW9uIGlzIGFjY2Vzc2libGUgb3IgZXhpc3RpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRUb2tlbkRpciA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuZ2V0VG9rZW5EaXJDYW5kaWRhdGVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9sZGVyOiBkaXIsIHN1YmZvbGRlcnM6IHN1YkRpcnMgfSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLnRyeVRva2VuRGlyKGRpciwgc3ViRGlycykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKGRpciwgLi4uc3ViRGlycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmdldFRva2VuRmlsZVBhdGggPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuRGlyID0gYXdhaXQgdGhpcy5nZXRUb2tlbkRpcigpO1xuICAgICAgICBpZiAoIVV0aWwuZXhpc3RzKHRva2VuRGlyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wb3JhcnkgY3JlZGVudGlhbCBjYWNoZSBkaXJlY3RvcnkgaXMgaW52YWxpZCwgYW5kIHRoZSBkcml2ZXIgaXMgdW5hYmxlIHRvIHVzZSB0aGUgZGVmYXVsdCBsb2NhdGlvbi4gXG4gICAgICBQbGVhc2Ugc2V0ICdjcmVkZW50aWFsQ2FjaGVEaXInIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiBvcHRpb24gdG8gZW5hYmxlIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWwgbWFuYWdlci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRva2VuRGlyLCAnY3JlZGVudGlhbF9jYWNoZV92MS5qc29uJyk7XG4gICAgfTtcbiAgICB0aGlzLnJlYWRKc29uQ3JlZGVudGlhbEZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZUhhbmRsZSkge1xuICAgICAgICBpZiAoIVV0aWwuZXhpc3RzKGZpbGVIYW5kbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3JlZCA9IGF3YWl0IGZpbGVIYW5kbGUucmVhZEZpbGUoJ3V0ZjgnKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0ZhaWxlZCB0byByZWFkIHRva2VuIGRhdGEgZnJvbSB0aGUgZmlsZS4gRXJyOiAlcycsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZVN0YWxlID0gYXN5bmMgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzLnN0YXQoZmlsZSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghVXRpbC5leGlzdHMoc3RhdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGF0LmJpcnRodGltZU1zID4gdGltZW91dE1zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZzLnJtZGlyKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0ZhaWxlZCB0byByZW1vdmUgc3RhbGUgZmlsZS4gRXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxvY2tGaWxlID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IGxja0ZpbGUgPSBmaWxlbmFtZSArICcubGNrJztcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVTdGFsZShsY2tGaWxlKTtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTtcbiAgICAgICAgbGV0IGxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1vZGUgPSAwbzYwMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXR0ZW1wdHMgPD0gMTApIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBdHRlbXB0aW5nIHRvIGdldCBhIGxvY2sgb24gZmlsZSAlcywgYXR0ZW1wdDogJWQnLCBmaWxlbmFtZSwgYXR0ZW1wdHMpO1xuICAgICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICAgIGF3YWl0IGZzLm1rZGlyKGxja0ZpbGUsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9LCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlJbnRlcnZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG9ja2VkKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDb3VsZCBub3QgYWNxdWlyZSBsb2NrIG9uIGNhY2hlIGZpbGUgJXMnLCBmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2tlZDtcbiAgICB9O1xuICAgIHRoaXMudW5sb2NrRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICBjb25zdCBsY2tGaWxlID0gZmlsZW5hbWUgKyAnLmxjayc7XG4gICAgICAgIGF3YWl0IGZzLnJtZGlyKGxja0ZpbGUpO1xuICAgIH07XG4gICAgdGhpcy53aXRoRmlsZUxvY2tlZCA9IGFzeW5jIGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBhd2FpdCB0aGlzLmdldFRva2VuRmlsZVBhdGgoKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMubG9ja0ZpbGUoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmdW4oZmlsZW5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51bmxvY2tGaWxlKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLndyaXRlID0gYXN5bmMgZnVuY3Rpb24gKGtleSwgdG9rZW4pIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZVRva2VuQ2FjaGVPcHRpb24oa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5SGFzaCA9IHRoaXMuaGFzaEtleShrZXkpO1xuICAgICAgICBhd2FpdCB0aGlzLndpdGhGaWxlTG9ja2VkKGFzeW5jIChmaWxlbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZUhhbmRsZSA9IGF3YWl0IGdldFNlY3VyZUhhbmRsZShmaWxlbmFtZSwgZnMuY29uc3RhbnRzLk9fUkRXUiB8IGZzLmNvbnN0YW50cy5PX0NSRUFULCBmcyk7XG4gICAgICAgICAgICBjb25zdCBqc29uQ3JlZGVudGlhbCA9IChhd2FpdCB0aGlzLnJlYWRKc29uQ3JlZGVudGlhbEZpbGUoZmlsZUhhbmRsZSkpIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV0pKSB7XG4gICAgICAgICAgICAgICAganNvbkNyZWRlbnRpYWxbdG9rZW5NYXBLZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV1ba2V5SGFzaF0gPSB0b2tlbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS50cnVuY2F0ZSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZpbGVIYW5kbGUud3JpdGUoSlNPTi5zdHJpbmdpZnkoanNvbkNyZWRlbnRpYWwpLCAwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbG9zZUhhbmRsZShmaWxlSGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBGYWlsZWQgdG8gd3JpdGUgdG9rZW4gZGF0YSBpbiAke2ZpbGVuYW1lfS4gUGxlYXNlIGNoZWNrIHRoZSBwZXJtaXNzaW9uIG9yIHRoZSBmaWxlIGZvcm1hdCBvZiB0aGUgdG9rZW4uICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZWFkID0gYXN5bmMgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIXZhbGlkYXRlVG9rZW5DYWNoZU9wdGlvbihrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlIYXNoID0gdGhpcy5oYXNoS2V5KGtleSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndpdGhGaWxlTG9ja2VkKGFzeW5jIChmaWxlbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZUhhbmRsZSA9IGF3YWl0IGdldFNlY3VyZUhhbmRsZShmaWxlbmFtZSwgZnMuY29uc3RhbnRzLk9fUkRXUiwgZnMpO1xuICAgICAgICAgICAgY29uc3QganNvbkNyZWRlbnRpYWwgPSBhd2FpdCB0aGlzLnJlYWRKc29uQ3JlZGVudGlhbEZpbGUoZmlsZUhhbmRsZSk7XG4gICAgICAgICAgICBhd2FpdCBjbG9zZUhhbmRsZShmaWxlSGFuZGxlKTtcbiAgICAgICAgICAgIGlmICghIWpzb25DcmVkZW50aWFsICYmIGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XSAmJiBqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV1ba2V5SGFzaF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbkNyZWRlbnRpYWxbdG9rZW5NYXBLZXldW2tleUhhc2hdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmUgPSBhc3luYyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdmFsaWRhdGVUb2tlbkNhY2hlT3B0aW9uKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUhhc2ggPSB0aGlzLmhhc2hLZXkoa2V5KTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXRoRmlsZUxvY2tlZChhc3luYyAoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVIYW5kbGUgPSBhd2FpdCBnZXRTZWN1cmVIYW5kbGUoZmlsZW5hbWUsIGZzLmNvbnN0YW50cy5PX1JEV1IsIGZzKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25DcmVkZW50aWFsID0gYXdhaXQgdGhpcy5yZWFkSnNvbkNyZWRlbnRpYWxGaWxlKGZpbGVIYW5kbGUpO1xuICAgICAgICAgICAgaWYgKGpzb25DcmVkZW50aWFsICYmIGpzb25DcmVkZW50aWFsW3Rva2VuTWFwS2V5XSAmJiBqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV1ba2V5SGFzaF0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBqc29uQ3JlZGVudGlhbFt0b2tlbk1hcEtleV1ba2V5SGFzaF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLnRydW5jYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZpbGVIYW5kbGUud3JpdGUoSlNPTi5zdHJpbmdpZnkoanNvbkNyZWRlbnRpYWwpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xvc2VIYW5kbGUoZmlsZUhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgRmFpbGVkIHRvIHJlbW92ZSB0b2tlbiBkYXRhIGZyb20gdGhlIGZpbGUgaW4gJHtmaWxlbmFtZX0uIFBsZWFzZSBjaGVjayB0aGUgcGVybWlzc2lvbiBvciB0aGUgZmlsZSBmb3JtYXQgb2YgdGhlIHRva2VuLiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVRva2VuQ2FjaGVPcHRpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBVdGlsLmNoZWNrUGFyYW1ldGVyc0RlZmluZWQoa2V5KTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0SnNvblRva2VuQ2FjaGVQYXRocyA9IGRlZmF1bHRKc29uVG9rZW5DYWNoZVBhdGhzO1xubW9kdWxlLmV4cG9ydHMuSnNvbkNyZWRlbnRpYWxNYW5hZ2VyID0gSnNvbkNyZWRlbnRpYWxNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbl9jcmVkZW50aWFsX21hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst { rest } = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\n/**\n * Creates a new instance of an SsoUrlProvider.\n *\n * @param {Object} httpClient\n * @constructor\n */\nfunction SsoUrlProvider(httpClient) {\n    Errors.assertInternal(Util.isObject(httpClient));\n    const port = rest.HTTPS_PORT;\n    const protocol = rest.HTTPS_PROTOCOL;\n    /**\n     * Get SSO URL through POST request.\n     *\n     * @param {String} authenticator\n     * @param {String} serviceName\n     * @param {String} account\n     * @param {Number} callbackPort\n     * @param {String} user\n     * @param {String} host\n     *\n     * @returns {Promise<String>} the SSO URL.\n     */\n    this.getSSOURL = async function (authenticator, serviceName, account, callbackPort, user, host) {\n        // Create URL to send POST request to\n        const url = protocol + '://' + host + '/session/authenticator-request';\n        let header;\n        if (serviceName) {\n            header = {\n                HTTP_HEADER_SERVICE_NAME: serviceName,\n            };\n        }\n        const body = {\n            data: {\n                ACCOUNT_NAME: account,\n                LOGIN_NAME: user,\n                PORT: port,\n                PROTOCOL: protocol,\n                AUTHENTICATOR: authenticator,\n                BROWSER_MODE_REDIRECT_PORT: callbackPort.toString(),\n            },\n        };\n        const requestOptions = {\n            method: 'post',\n            url: url,\n            headers: header,\n            data: body,\n            responseType: 'json',\n        };\n        // Post request to get the SSO URL\n        return httpClient\n            .requestAsync(requestOptions)\n            .then((response) => {\n            const data = response['data']['data'];\n            return data;\n        })\n            .catch((requestErr) => {\n            throw requestErr;\n        });\n    };\n}\nmodule.exports = SsoUrlProvider;\n//# sourceMappingURL=sso_url_provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9hdXRoZW50aWNhdGlvbi9zc29fdXJsX3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHNGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2F1dGhlbnRpY2F0aW9uL3Nzb191cmxfcHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCB7IHJlc3QgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBTc29VcmxQcm92aWRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFNzb1VybFByb3ZpZGVyKGh0dHBDbGllbnQpIHtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChodHRwQ2xpZW50KSk7XG4gICAgY29uc3QgcG9ydCA9IHJlc3QuSFRUUFNfUE9SVDtcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlc3QuSFRUUFNfUFJPVE9DT0w7XG4gICAgLyoqXG4gICAgICogR2V0IFNTTyBVUkwgdGhyb3VnaCBQT1NUIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNhbGxiYWNrUG9ydFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0cmluZz59IHRoZSBTU08gVVJMLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0U1NPVVJMID0gYXN5bmMgZnVuY3Rpb24gKGF1dGhlbnRpY2F0b3IsIHNlcnZpY2VOYW1lLCBhY2NvdW50LCBjYWxsYmFja1BvcnQsIHVzZXIsIGhvc3QpIHtcbiAgICAgICAgLy8gQ3JlYXRlIFVSTCB0byBzZW5kIFBPU1QgcmVxdWVzdCB0b1xuICAgICAgICBjb25zdCB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgaG9zdCArICcvc2Vzc2lvbi9hdXRoZW50aWNhdG9yLXJlcXVlc3QnO1xuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICBpZiAoc2VydmljZU5hbWUpIHtcbiAgICAgICAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgICAgICAgICBIVFRQX0hFQURFUl9TRVJWSUNFX05BTUU6IHNlcnZpY2VOYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIEFDQ09VTlRfTkFNRTogYWNjb3VudCxcbiAgICAgICAgICAgICAgICBMT0dJTl9OQU1FOiB1c2VyLFxuICAgICAgICAgICAgICAgIFBPUlQ6IHBvcnQsXG4gICAgICAgICAgICAgICAgUFJPVE9DT0w6IHByb3RvY29sLFxuICAgICAgICAgICAgICAgIEFVVEhFTlRJQ0FUT1I6IGF1dGhlbnRpY2F0b3IsXG4gICAgICAgICAgICAgICAgQlJPV1NFUl9NT0RFX1JFRElSRUNUX1BPUlQ6IGNhbGxiYWNrUG9ydC50b1N0cmluZygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyLFxuICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICAvLyBQb3N0IHJlcXVlc3QgdG8gZ2V0IHRoZSBTU08gVVJMXG4gICAgICAgIHJldHVybiBodHRwQ2xpZW50XG4gICAgICAgICAgICAucmVxdWVzdEFzeW5jKHJlcXVlc3RPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2VbJ2RhdGEnXVsnZGF0YSddO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKHJlcXVlc3RFcnIpID0+IHtcbiAgICAgICAgICAgIHRocm93IHJlcXVlc3RFcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNzb1VybFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3NvX3VybF9wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/sso_url_provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { isString, exists, getDriverDirectory, isWindows } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { IsFileExisted } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst clientConfigFileName = 'sf_client_config.json';\nconst Levels = Object.freeze({\n    Off: 'OFF',\n    Error: 'ERROR',\n    Warn: 'WARN',\n    Info: 'INFO',\n    Debug: 'DEBUG',\n    Trace: 'TRACE',\n});\nconst defaultDirectories = getDefaultDirectories();\nfunction getDefaultDirectories() {\n    const directories = [];\n    const driverDirectory = getDriverDirectory();\n    Logger.getInstance().debug(`Detected driver directory: ${driverDirectory}`);\n    if (driverDirectory) {\n        directories.push({\n            dir: driverDirectory,\n            dirDescription: 'driver',\n        });\n    }\n    else {\n        Logger.getInstance().warn('Driver directory is not defined');\n    }\n    const homedir = os.homedir();\n    Logger.getInstance().debug(`Detected home directory: ${homedir}`);\n    if (exists(homedir)) {\n        directories.push({\n            dir: homedir,\n            dirDescription: 'home',\n        });\n    }\n    else {\n        Logger.getInstance().warn('Home directory of the user is not defined');\n    }\n    Logger.getInstance().debug(`Detected default directories: ${driverDirectory}`);\n    return directories;\n}\nconst knownCommonEntries = ['log_level', 'log_path'];\nconst allLevels = Object.values(Levels);\nclass ClientConfig {\n    constructor(filePath, loggingConfig) {\n        this.configPath = filePath;\n        this.loggingConfig = loggingConfig;\n    }\n}\nclass ClientLoggingConfig {\n    constructor(logLevel, logPath) {\n        this.logLevel = logLevel;\n        this.logPath = logPath;\n    }\n}\nclass ConfigurationError extends Error {\n    name = 'ConfigurationError';\n    constructor(message, cause) {\n        super(message);\n        this.cause = cause;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    toString() {\n        return this.message + ': ' + this.cause.toString();\n    }\n}\n/**\n * @param value {String} Log level.\n * @return {String} normalized log level value.\n * @throws {Error} Error for unknown value.\n */\nfunction levelFromString(value) {\n    const level = value.toUpperCase();\n    if (!allLevels.includes(level)) {\n        Logger.getInstance().error(`Tried to create unsupported log level from string: ${value}`);\n        throw new Error('Unknown log level: ' + value);\n    }\n    return level;\n}\n/**\n * @param fsPromisesModule {module} filestream module\n * @param processModule {processModule} process module\n */\nfunction ConfigurationUtil(fsPromisesModule, processModule) {\n    const fsPromises = typeof fsPromisesModule !== 'undefined' ? fsPromisesModule : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n    const process = typeof processModule !== 'undefined' ? processModule : __webpack_require__(/*! process */ \"process\");\n    let configFileContents = null;\n    let fd = null;\n    /**\n     * @param configFilePath {String} A path to a client config file.\n     * @return {Promise<ClientConfig>} Client configuration.\n     */\n    this.getClientConfig = async function (configFilePath, mock = false, delay = 0) {\n        Logger.getInstance().debug('Retrieving client config');\n        const path = await findConfig(configFilePath);\n        if (!exists(path) || path === '') {\n            Logger.getInstance().info('No config file path found. Client config will not be used.');\n            return null;\n        }\n        const isFileExist = mock ? mock : IsFileExisted(path);\n        if (!isFileExist) {\n            Logger.getInstance().info(`No config file not found on ${path}. Client config will not be used.`);\n            return null;\n        }\n        try {\n            fd = await openFileSafely(path);\n            if (!isWindows()) {\n                const openStats = await fd.stat();\n                const mode = openStats.mode & 0o777;\n                if (!isFilePermissionValid(mode)) {\n                    Logger.getInstance().warn(`Config file path permissions are invalid. File: ${path} can be modified by group or others. Client config will not be used.`);\n                    throw new ConfigurationError(`Configuration file: ${path} can be modified by group or others`, 'IncorrectPerms');\n                }\n                if (!validateOwnership(openStats)) {\n                    Logger.getInstance().warn('This config file is not owned by the current user. Client config will not be used.');\n                    throw new ConfigurationError('Configuration file: not owned by the current user', 'Invalid Ownership');\n                }\n                Logger.getInstance().debug(`Config file path permissions are valid. Path: ${path}`);\n                if (mock) {\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                }\n                configFileContents = await readFileConfig(fd).catch((err) => {\n                    Logger.getInstance().debug(`Reading configuration from the file failed. Path: ${path}`);\n                    throw new ConfigurationError('Finding client configuration failed', err);\n                });\n                //Compare the modification time from the 'open' call with the modification time after reading to validate whether the file has been modified.\n                const currentStat = await fsPromises.stat(path);\n                if (!isFileModified(openStats, currentStat)) {\n                    Logger.getInstance().error('The file was modified after the driver opened the config file and can no longer be used.');\n                    throw new ConfigurationError('The config file has been modified', 'InvalidConfigFile');\n                }\n            }\n            else {\n                configFileContents = await readFileConfig(fd).catch((err) => {\n                    Logger.getInstance().debug(`Reading configuration from the file failed. Path: ${path}`);\n                    throw new ConfigurationError('Finding client configuration failed', err);\n                });\n            }\n            Logger.getInstance().info('Using client configuration from path: %s', path);\n        }\n        catch (err) {\n            if (err.syscall === 'open') {\n                Logger.getInstance().debug(`Fail to open the configuration file from. Path: ${path}. If the file is a symlink, please change the path to the real path`);\n                throw new ConfigurationError('Fail to open the configuration file', err);\n            }\n            else {\n                throw err;\n            }\n        }\n        finally {\n            await fd?.close();\n        }\n        return configFileContents == null ? null : parseConfigFile(path, configFileContents);\n    };\n    function isFilePermissionValid(mode) {\n        return (mode & (1 << 4)) === 0 && (mode & (1 << 1)) === 0;\n    }\n    function validateOwnership(stats) {\n        const currentUser = os.userInfo();\n        return stats.uid === currentUser.uid && stats.gid === currentUser.gid;\n    }\n    function isFileModified(openStat, newStat) {\n        const keys = ['uid', 'mtimeMs', 'mode', 'birthtimeMs', 'ctimeMs'];\n        return keys.every((key) => openStat[key] === newStat[key]);\n    }\n    async function openFileSafely(filePath) {\n        return fsPromises.open(filePath, fs.constants.O_NOFOLLOW | fs.constants.O_RDONLY);\n    }\n    async function readFileConfig(fd) {\n        return fd.readFile({ encoding: 'utf8' });\n    }\n    function parseConfigFile(path, configurationJson) {\n        Logger.getInstance().debug('Parsing config file: %s', path);\n        try {\n            const parsedConfiguration = JSON.parse(configurationJson);\n            Logger.getInstance().trace('Config file contains correct JSON structure. Validating the input.');\n            checkUnknownEntries(parsedConfiguration);\n            validate(parsedConfiguration);\n            Logger.getInstance().debug('Config file contains valid configuration input.');\n            const clientConfig = new ClientConfig(path, new ClientLoggingConfig(getLogLevel(parsedConfiguration), getLogPath(parsedConfiguration)));\n            Logger.getInstance().info('Client Configuration created with Log Level: %s and Log Path: %s', clientConfig.loggingConfig.logLevel, clientConfig.loggingConfig.logPath);\n            return clientConfig;\n        }\n        catch (err) {\n            Logger.getInstance().error('Parsing client configuration failed. Used config file from path: %s', path);\n            throw new ConfigurationError('Parsing client configuration failed', err);\n        }\n    }\n    function checkUnknownEntries(config) {\n        for (const key in config.common) {\n            if (!knownCommonEntries.includes(key.toLowerCase())) {\n                Logger.getInstance().warn('Unknown configuration entry: %s with value: %s', key, config.common[key]);\n            }\n        }\n    }\n    function validate(configuration) {\n        validateLogLevel(configuration);\n        validateLogPath(configuration);\n    }\n    function validateLogLevel(configuration) {\n        const logLevel = getLogLevel(configuration);\n        if (logLevel == null) {\n            Logger.getInstance().debug('Log level is not specified.');\n            return;\n        }\n        if (!isString(logLevel)) {\n            const errorMessage = 'Log level is not a string.';\n            Logger.getInstance().error(errorMessage);\n            throw new Error(errorMessage);\n        }\n        levelFromString(logLevel);\n    }\n    function validateLogPath(configuration) {\n        const logPath = getLogPath(configuration);\n        if (logPath == null) {\n            Logger.getInstance().debug('Log path is not specified');\n            return;\n        }\n        if (!isString(logPath)) {\n            const errorMessage = 'Log path is not a string.';\n            Logger.getInstance().error(errorMessage);\n            throw new Error(errorMessage);\n        }\n    }\n    function getLogLevel(configuration) {\n        return configuration.common.log_level;\n    }\n    function getLogPath(configuration) {\n        return configuration.common.log_path;\n    }\n    async function findConfig(filePathFromConnectionString) {\n        Logger.getInstance().trace(`findConfig() called with param: ${filePathFromConnectionString}`);\n        if (exists(filePathFromConnectionString)) {\n            Logger.getInstance().info('Found client configuration path in a connection string. Path: %s', filePathFromConnectionString);\n            return filePathFromConnectionString;\n        }\n        const filePathFromEnvVariable = await getFilePathFromEnvironmentVariable();\n        if (exists(filePathFromEnvVariable)) {\n            Logger.getInstance().info('Found client configuration path in an environment variable. Path: %s', filePathFromEnvVariable);\n            return filePathFromEnvVariable;\n        }\n        const fileFromDefDirs = await searchForConfigInDefaultDirectories();\n        if (exists(fileFromDefDirs)) {\n            Logger.getInstance().info('Found client configuration path in %s directory. Path: %s', fileFromDefDirs.dirDescription, fileFromDefDirs.configPath);\n            return fileFromDefDirs.configPath;\n        }\n        Logger.getInstance().info('No client config detected.');\n        return null;\n    }\n    async function verifyNotEmpty(filePath) {\n        return filePath ? filePath : null;\n    }\n    function getFilePathFromEnvironmentVariable() {\n        return verifyNotEmpty(process.env.SF_CLIENT_CONFIG_FILE);\n    }\n    async function searchForConfigInDefaultDirectories() {\n        Logger.getInstance().debug(`Searching for config in default directories: ${JSON.stringify(defaultDirectories)}`);\n        for (const directory of defaultDirectories) {\n            const configPath = await searchForConfigInDictionary(directory.dir, directory.dirDescription);\n            if (exists(configPath)) {\n                Logger.getInstance().debug(`Config found in the default directory: ${directory.dir}. Path: ${configPath}`);\n                return { configPath: configPath, dirDescription: directory.dirDescription };\n            }\n        }\n        Logger.getInstance().debug('Unable to find config in any default directory.');\n        return null;\n    }\n    async function searchForConfigInDictionary(directory, directoryDescription) {\n        try {\n            const filePath = path.join(directory, clientConfigFileName);\n            return await onlyIfFileExists(filePath);\n        }\n        catch (e) {\n            Logger.getInstance().error('Error while searching for the client config in %s directory: %s', directoryDescription, e);\n            return null;\n        }\n    }\n    async function onlyIfFileExists(filePath) {\n        return await fsPromises\n            .access(filePath, fs.constants.F_OK)\n            .then(() => filePath)\n            .catch(() => null);\n    }\n}\nexports.Levels = Levels;\nexports.levelFromString = levelFromString;\nexports.ConfigurationUtil = ConfigurationUtil;\n//# sourceMappingURL=client_configuration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25maWd1cmF0aW9uL2NsaWVudF9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsa0RBQWtELEVBQUUsbUJBQU8sQ0FBQyxvRUFBUztBQUM3RSxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDhFQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLE1BQU07QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQSxvRkFBb0YsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6RywyRUFBMkUsbUJBQU8sQ0FBQyx3QkFBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxNQUFNO0FBQ3ZHLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsS0FBSztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxLQUFLO0FBQ3pHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsS0FBSztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw2QkFBNkI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG1DQUFtQztBQUN0SDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsY0FBYyxVQUFVLFdBQVc7QUFDeEgseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbmZpZ3VyYXRpb24vY2xpZW50X2NvbmZpZ3VyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBpc1N0cmluZywgZXhpc3RzLCBnZXREcml2ZXJEaXJlY3RvcnksIGlzV2luZG93cyB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCB7IElzRmlsZUV4aXN0ZWQgfSA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpO1xuY29uc3QgY2xpZW50Q29uZmlnRmlsZU5hbWUgPSAnc2ZfY2xpZW50X2NvbmZpZy5qc29uJztcbmNvbnN0IExldmVscyA9IE9iamVjdC5mcmVlemUoe1xuICAgIE9mZjogJ09GRicsXG4gICAgRXJyb3I6ICdFUlJPUicsXG4gICAgV2FybjogJ1dBUk4nLFxuICAgIEluZm86ICdJTkZPJyxcbiAgICBEZWJ1ZzogJ0RFQlVHJyxcbiAgICBUcmFjZTogJ1RSQUNFJyxcbn0pO1xuY29uc3QgZGVmYXVsdERpcmVjdG9yaWVzID0gZ2V0RGVmYXVsdERpcmVjdG9yaWVzKCk7XG5mdW5jdGlvbiBnZXREZWZhdWx0RGlyZWN0b3JpZXMoKSB7XG4gICAgY29uc3QgZGlyZWN0b3JpZXMgPSBbXTtcbiAgICBjb25zdCBkcml2ZXJEaXJlY3RvcnkgPSBnZXREcml2ZXJEaXJlY3RvcnkoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgRGV0ZWN0ZWQgZHJpdmVyIGRpcmVjdG9yeTogJHtkcml2ZXJEaXJlY3Rvcnl9YCk7XG4gICAgaWYgKGRyaXZlckRpcmVjdG9yeSkge1xuICAgICAgICBkaXJlY3Rvcmllcy5wdXNoKHtcbiAgICAgICAgICAgIGRpcjogZHJpdmVyRGlyZWN0b3J5LFxuICAgICAgICAgICAgZGlyRGVzY3JpcHRpb246ICdkcml2ZXInLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0RyaXZlciBkaXJlY3RvcnkgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaG9tZWRpciA9IG9zLmhvbWVkaXIoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgRGV0ZWN0ZWQgaG9tZSBkaXJlY3Rvcnk6ICR7aG9tZWRpcn1gKTtcbiAgICBpZiAoZXhpc3RzKGhvbWVkaXIpKSB7XG4gICAgICAgIGRpcmVjdG9yaWVzLnB1c2goe1xuICAgICAgICAgICAgZGlyOiBob21lZGlyLFxuICAgICAgICAgICAgZGlyRGVzY3JpcHRpb246ICdob21lJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdIb21lIGRpcmVjdG9yeSBvZiB0aGUgdXNlciBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgRGV0ZWN0ZWQgZGVmYXVsdCBkaXJlY3RvcmllczogJHtkcml2ZXJEaXJlY3Rvcnl9YCk7XG4gICAgcmV0dXJuIGRpcmVjdG9yaWVzO1xufVxuY29uc3Qga25vd25Db21tb25FbnRyaWVzID0gWydsb2dfbGV2ZWwnLCAnbG9nX3BhdGgnXTtcbmNvbnN0IGFsbExldmVscyA9IE9iamVjdC52YWx1ZXMoTGV2ZWxzKTtcbmNsYXNzIENsaWVudENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoZmlsZVBhdGgsIGxvZ2dpbmdDb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWdQYXRoID0gZmlsZVBhdGg7XG4gICAgICAgIHRoaXMubG9nZ2luZ0NvbmZpZyA9IGxvZ2dpbmdDb25maWc7XG4gICAgfVxufVxuY2xhc3MgQ2xpZW50TG9nZ2luZ0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3IobG9nTGV2ZWwsIGxvZ1BhdGgpIHtcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICB0aGlzLmxvZ1BhdGggPSBsb2dQYXRoO1xuICAgIH1cbn1cbmNsYXNzIENvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBuYW1lID0gJ0NvbmZpZ3VyYXRpb25FcnJvcic7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgJzogJyArIHRoaXMuY2F1c2UudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB2YWx1ZSB7U3RyaW5nfSBMb2cgbGV2ZWwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbG9nIGxldmVsIHZhbHVlLlxuICogQHRocm93cyB7RXJyb3J9IEVycm9yIGZvciB1bmtub3duIHZhbHVlLlxuICovXG5mdW5jdGlvbiBsZXZlbEZyb21TdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBsZXZlbCA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFhbGxMZXZlbHMuaW5jbHVkZXMobGV2ZWwpKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGBUcmllZCB0byBjcmVhdGUgdW5zdXBwb3J0ZWQgbG9nIGxldmVsIGZyb20gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbG9nIGxldmVsOiAnICsgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWw7XG59XG4vKipcbiAqIEBwYXJhbSBmc1Byb21pc2VzTW9kdWxlIHttb2R1bGV9IGZpbGVzdHJlYW0gbW9kdWxlXG4gKiBAcGFyYW0gcHJvY2Vzc01vZHVsZSB7cHJvY2Vzc01vZHVsZX0gcHJvY2VzcyBtb2R1bGVcbiAqL1xuZnVuY3Rpb24gQ29uZmlndXJhdGlvblV0aWwoZnNQcm9taXNlc01vZHVsZSwgcHJvY2Vzc01vZHVsZSkge1xuICAgIGNvbnN0IGZzUHJvbWlzZXMgPSB0eXBlb2YgZnNQcm9taXNlc01vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmc1Byb21pc2VzTW9kdWxlIDogcmVxdWlyZSgnZnMvcHJvbWlzZXMnKTtcbiAgICBjb25zdCBwcm9jZXNzID0gdHlwZW9mIHByb2Nlc3NNb2R1bGUgIT09ICd1bmRlZmluZWQnID8gcHJvY2Vzc01vZHVsZSA6IHJlcXVpcmUoJ3Byb2Nlc3MnKTtcbiAgICBsZXQgY29uZmlnRmlsZUNvbnRlbnRzID0gbnVsbDtcbiAgICBsZXQgZmQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdGaWxlUGF0aCB7U3RyaW5nfSBBIHBhdGggdG8gYSBjbGllbnQgY29uZmlnIGZpbGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDbGllbnRDb25maWc+fSBDbGllbnQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudENvbmZpZyA9IGFzeW5jIGZ1bmN0aW9uIChjb25maWdGaWxlUGF0aCwgbW9jayA9IGZhbHNlLCBkZWxheSA9IDApIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JldHJpZXZpbmcgY2xpZW50IGNvbmZpZycpO1xuICAgICAgICBjb25zdCBwYXRoID0gYXdhaXQgZmluZENvbmZpZyhjb25maWdGaWxlUGF0aCk7XG4gICAgICAgIGlmICghZXhpc3RzKHBhdGgpIHx8IHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdObyBjb25maWcgZmlsZSBwYXRoIGZvdW5kLiBDbGllbnQgY29uZmlnIHdpbGwgbm90IGJlIHVzZWQuJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0ZpbGVFeGlzdCA9IG1vY2sgPyBtb2NrIDogSXNGaWxlRXhpc3RlZChwYXRoKTtcbiAgICAgICAgaWYgKCFpc0ZpbGVFeGlzdCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbyhgTm8gY29uZmlnIGZpbGUgbm90IGZvdW5kIG9uICR7cGF0aH0uIENsaWVudCBjb25maWcgd2lsbCBub3QgYmUgdXNlZC5gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmZCA9IGF3YWl0IG9wZW5GaWxlU2FmZWx5KHBhdGgpO1xuICAgICAgICAgICAgaWYgKCFpc1dpbmRvd3MoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5TdGF0cyA9IGF3YWl0IGZkLnN0YXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlID0gb3BlblN0YXRzLm1vZGUgJiAwbzc3NztcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmlsZVBlcm1pc3Npb25WYWxpZChtb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBDb25maWcgZmlsZSBwYXRoIHBlcm1pc3Npb25zIGFyZSBpbnZhbGlkLiBGaWxlOiAke3BhdGh9IGNhbiBiZSBtb2RpZmllZCBieSBncm91cCBvciBvdGhlcnMuIENsaWVudCBjb25maWcgd2lsbCBub3QgYmUgdXNlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcihgQ29uZmlndXJhdGlvbiBmaWxlOiAke3BhdGh9IGNhbiBiZSBtb2RpZmllZCBieSBncm91cCBvciBvdGhlcnNgLCAnSW5jb3JyZWN0UGVybXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZU93bmVyc2hpcChvcGVuU3RhdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ1RoaXMgY29uZmlnIGZpbGUgaXMgbm90IG93bmVkIGJ5IHRoZSBjdXJyZW50IHVzZXIuIENsaWVudCBjb25maWcgd2lsbCBub3QgYmUgdXNlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignQ29uZmlndXJhdGlvbiBmaWxlOiBub3Qgb3duZWQgYnkgdGhlIGN1cnJlbnQgdXNlcicsICdJbnZhbGlkIE93bmVyc2hpcCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgQ29uZmlnIGZpbGUgcGF0aCBwZXJtaXNzaW9ucyBhcmUgdmFsaWQuIFBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICBpZiAobW9jaykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWdGaWxlQ29udGVudHMgPSBhd2FpdCByZWFkRmlsZUNvbmZpZyhmZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUmVhZGluZyBjb25maWd1cmF0aW9uIGZyb20gdGhlIGZpbGUgZmFpbGVkLiBQYXRoOiAke3BhdGh9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ0ZpbmRpbmcgY2xpZW50IGNvbmZpZ3VyYXRpb24gZmFpbGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvL0NvbXBhcmUgdGhlIG1vZGlmaWNhdGlvbiB0aW1lIGZyb20gdGhlICdvcGVuJyBjYWxsIHdpdGggdGhlIG1vZGlmaWNhdGlvbiB0aW1lIGFmdGVyIHJlYWRpbmcgdG8gdmFsaWRhdGUgd2hldGhlciB0aGUgZmlsZSBoYXMgYmVlbiBtb2RpZmllZC5cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdCA9IGF3YWl0IGZzUHJvbWlzZXMuc3RhdChwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmlsZU1vZGlmaWVkKG9wZW5TdGF0cywgY3VycmVudFN0YXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdUaGUgZmlsZSB3YXMgbW9kaWZpZWQgYWZ0ZXIgdGhlIGRyaXZlciBvcGVuZWQgdGhlIGNvbmZpZyBmaWxlIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ1RoZSBjb25maWcgZmlsZSBoYXMgYmVlbiBtb2RpZmllZCcsICdJbnZhbGlkQ29uZmlnRmlsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGVDb250ZW50cyA9IGF3YWl0IHJlYWRGaWxlQ29uZmlnKGZkKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBSZWFkaW5nIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZmlsZSBmYWlsZWQuIFBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignRmluZGluZyBjbGllbnQgY29uZmlndXJhdGlvbiBmYWlsZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnVXNpbmcgY2xpZW50IGNvbmZpZ3VyYXRpb24gZnJvbSBwYXRoOiAlcycsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuc3lzY2FsbCA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYEZhaWwgdG8gb3BlbiB0aGUgY29uZmlndXJhdGlvbiBmaWxlIGZyb20uIFBhdGg6ICR7cGF0aH0uIElmIHRoZSBmaWxlIGlzIGEgc3ltbGluaywgcGxlYXNlIGNoYW5nZSB0aGUgcGF0aCB0byB0aGUgcmVhbCBwYXRoYCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignRmFpbCB0byBvcGVuIHRoZSBjb25maWd1cmF0aW9uIGZpbGUnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgZmQ/LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZ0ZpbGVDb250ZW50cyA9PSBudWxsID8gbnVsbCA6IHBhcnNlQ29uZmlnRmlsZShwYXRoLCBjb25maWdGaWxlQ29udGVudHMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNGaWxlUGVybWlzc2lvblZhbGlkKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgKDEgPDwgNCkpID09PSAwICYmIChtb2RlICYgKDEgPDwgMSkpID09PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU93bmVyc2hpcChzdGF0cykge1xuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IG9zLnVzZXJJbmZvKCk7XG4gICAgICAgIHJldHVybiBzdGF0cy51aWQgPT09IGN1cnJlbnRVc2VyLnVpZCAmJiBzdGF0cy5naWQgPT09IGN1cnJlbnRVc2VyLmdpZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGaWxlTW9kaWZpZWQob3BlblN0YXQsIG5ld1N0YXQpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFsndWlkJywgJ210aW1lTXMnLCAnbW9kZScsICdiaXJ0aHRpbWVNcycsICdjdGltZU1zJ107XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IG9wZW5TdGF0W2tleV0gPT09IG5ld1N0YXRba2V5XSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG9wZW5GaWxlU2FmZWx5KGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBmc1Byb21pc2VzLm9wZW4oZmlsZVBhdGgsIGZzLmNvbnN0YW50cy5PX05PRk9MTE9XIHwgZnMuY29uc3RhbnRzLk9fUkRPTkxZKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVDb25maWcoZmQpIHtcbiAgICAgICAgcmV0dXJuIGZkLnJlYWRGaWxlKHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDb25maWdGaWxlKHBhdGgsIGNvbmZpZ3VyYXRpb25Kc29uKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdQYXJzaW5nIGNvbmZpZyBmaWxlOiAlcycsIHBhdGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQ29uZmlndXJhdGlvbiA9IEpTT04ucGFyc2UoY29uZmlndXJhdGlvbkpzb24pO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0NvbmZpZyBmaWxlIGNvbnRhaW5zIGNvcnJlY3QgSlNPTiBzdHJ1Y3R1cmUuIFZhbGlkYXRpbmcgdGhlIGlucHV0LicpO1xuICAgICAgICAgICAgY2hlY2tVbmtub3duRW50cmllcyhwYXJzZWRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHZhbGlkYXRlKHBhcnNlZENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0NvbmZpZyBmaWxlIGNvbnRhaW5zIHZhbGlkIGNvbmZpZ3VyYXRpb24gaW5wdXQuJyk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRDb25maWcgPSBuZXcgQ2xpZW50Q29uZmlnKHBhdGgsIG5ldyBDbGllbnRMb2dnaW5nQ29uZmlnKGdldExvZ0xldmVsKHBhcnNlZENvbmZpZ3VyYXRpb24pLCBnZXRMb2dQYXRoKHBhcnNlZENvbmZpZ3VyYXRpb24pKSk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDbGllbnQgQ29uZmlndXJhdGlvbiBjcmVhdGVkIHdpdGggTG9nIExldmVsOiAlcyBhbmQgTG9nIFBhdGg6ICVzJywgY2xpZW50Q29uZmlnLmxvZ2dpbmdDb25maWcubG9nTGV2ZWwsIGNsaWVudENvbmZpZy5sb2dnaW5nQ29uZmlnLmxvZ1BhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignUGFyc2luZyBjbGllbnQgY29uZmlndXJhdGlvbiBmYWlsZWQuIFVzZWQgY29uZmlnIGZpbGUgZnJvbSBwYXRoOiAlcycsIHBhdGgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignUGFyc2luZyBjbGllbnQgY29uZmlndXJhdGlvbiBmYWlsZWQnLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVW5rbm93bkVudHJpZXMoY29uZmlnKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZy5jb21tb24pIHtcbiAgICAgICAgICAgIGlmICgha25vd25Db21tb25FbnRyaWVzLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ1Vua25vd24gY29uZmlndXJhdGlvbiBlbnRyeTogJXMgd2l0aCB2YWx1ZTogJXMnLCBrZXksIGNvbmZpZy5jb21tb25ba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoY29uZmlndXJhdGlvbikge1xuICAgICAgICB2YWxpZGF0ZUxvZ0xldmVsKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB2YWxpZGF0ZUxvZ1BhdGgoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTG9nTGV2ZWwoY29uZmlndXJhdGlvbikge1xuICAgICAgICBjb25zdCBsb2dMZXZlbCA9IGdldExvZ0xldmVsKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAobG9nTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0xvZyBsZXZlbCBpcyBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJpbmcobG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnTG9nIGxldmVsIGlzIG5vdCBhIHN0cmluZy4nO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldmVsRnJvbVN0cmluZyhsb2dMZXZlbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTG9nUGF0aChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxvZ1BhdGggPSBnZXRMb2dQYXRoKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAobG9nUGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnTG9nIHBhdGggaXMgbm90IHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJpbmcobG9nUGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdMb2cgcGF0aCBpcyBub3QgYSBzdHJpbmcuJztcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMb2dMZXZlbChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmNvbW1vbi5sb2dfbGV2ZWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExvZ1BhdGgoY29uZmlndXJhdGlvbikge1xuICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvbi5jb21tb24ubG9nX3BhdGg7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbmRDb25maWcoZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgZmluZENvbmZpZygpIGNhbGxlZCB3aXRoIHBhcmFtOiAke2ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmd9YCk7XG4gICAgICAgIGlmIChleGlzdHMoZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0ZvdW5kIGNsaWVudCBjb25maWd1cmF0aW9uIHBhdGggaW4gYSBjb25uZWN0aW9uIHN0cmluZy4gUGF0aDogJXMnLCBmaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoRnJvbUVudlZhcmlhYmxlID0gYXdhaXQgZ2V0RmlsZVBhdGhGcm9tRW52aXJvbm1lbnRWYXJpYWJsZSgpO1xuICAgICAgICBpZiAoZXhpc3RzKGZpbGVQYXRoRnJvbUVudlZhcmlhYmxlKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnRm91bmQgY2xpZW50IGNvbmZpZ3VyYXRpb24gcGF0aCBpbiBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS4gUGF0aDogJXMnLCBmaWxlUGF0aEZyb21FbnZWYXJpYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVBhdGhGcm9tRW52VmFyaWFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZUZyb21EZWZEaXJzID0gYXdhaXQgc2VhcmNoRm9yQ29uZmlnSW5EZWZhdWx0RGlyZWN0b3JpZXMoKTtcbiAgICAgICAgaWYgKGV4aXN0cyhmaWxlRnJvbURlZkRpcnMpKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdGb3VuZCBjbGllbnQgY29uZmlndXJhdGlvbiBwYXRoIGluICVzIGRpcmVjdG9yeS4gUGF0aDogJXMnLCBmaWxlRnJvbURlZkRpcnMuZGlyRGVzY3JpcHRpb24sIGZpbGVGcm9tRGVmRGlycy5jb25maWdQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlRnJvbURlZkRpcnMuY29uZmlnUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdObyBjbGllbnQgY29uZmlnIGRldGVjdGVkLicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Tm90RW1wdHkoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVQYXRoID8gZmlsZVBhdGggOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRGaWxlUGF0aEZyb21FbnZpcm9ubWVudFZhcmlhYmxlKCkge1xuICAgICAgICByZXR1cm4gdmVyaWZ5Tm90RW1wdHkocHJvY2Vzcy5lbnYuU0ZfQ0xJRU5UX0NPTkZJR19GSUxFKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VhcmNoRm9yQ29uZmlnSW5EZWZhdWx0RGlyZWN0b3JpZXMoKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBTZWFyY2hpbmcgZm9yIGNvbmZpZyBpbiBkZWZhdWx0IGRpcmVjdG9yaWVzOiAke0pTT04uc3RyaW5naWZ5KGRlZmF1bHREaXJlY3Rvcmllcyl9YCk7XG4gICAgICAgIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGRlZmF1bHREaXJlY3Rvcmllcykge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnUGF0aCA9IGF3YWl0IHNlYXJjaEZvckNvbmZpZ0luRGljdGlvbmFyeShkaXJlY3RvcnkuZGlyLCBkaXJlY3RvcnkuZGlyRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKGV4aXN0cyhjb25maWdQYXRoKSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBDb25maWcgZm91bmQgaW4gdGhlIGRlZmF1bHQgZGlyZWN0b3J5OiAke2RpcmVjdG9yeS5kaXJ9LiBQYXRoOiAke2NvbmZpZ1BhdGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29uZmlnUGF0aDogY29uZmlnUGF0aCwgZGlyRGVzY3JpcHRpb246IGRpcmVjdG9yeS5kaXJEZXNjcmlwdGlvbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdVbmFibGUgdG8gZmluZCBjb25maWcgaW4gYW55IGRlZmF1bHQgZGlyZWN0b3J5LicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VhcmNoRm9yQ29uZmlnSW5EaWN0aW9uYXJ5KGRpcmVjdG9yeSwgZGlyZWN0b3J5RGVzY3JpcHRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgY2xpZW50Q29uZmlnRmlsZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG9ubHlJZkZpbGVFeGlzdHMoZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignRXJyb3Igd2hpbGUgc2VhcmNoaW5nIGZvciB0aGUgY2xpZW50IGNvbmZpZyBpbiAlcyBkaXJlY3Rvcnk6ICVzJywgZGlyZWN0b3J5RGVzY3JpcHRpb24sIGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gb25seUlmRmlsZUV4aXN0cyhmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZnNQcm9taXNlc1xuICAgICAgICAgICAgLmFjY2VzcyhmaWxlUGF0aCwgZnMuY29uc3RhbnRzLkZfT0spXG4gICAgICAgICAgICAudGhlbigoKSA9PiBmaWxlUGF0aClcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkxldmVscyA9IExldmVscztcbmV4cG9ydHMubGV2ZWxGcm9tU3RyaW5nID0gbGV2ZWxGcm9tU3RyaW5nO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uVXRpbCA9IENvbmZpZ3VyYXRpb25VdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50X2NvbmZpZ3VyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst toml = __webpack_require__(/*! toml */ \"(rsc)/./node_modules/toml/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { validateNoExtraPermissionsForOthersSync, generateChecksum } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nfunction defaultIfNotSet(value, defaultValue) {\n    if (value === null || typeof value === 'undefined' || value === '') {\n        return defaultValue;\n    }\n    else {\n        return value;\n    }\n}\nfunction shouldReadTokenFromFile(fixedConfiguration) {\n    return (fixedConfiguration &&\n        fixedConfiguration.authenticator &&\n        fixedConfiguration.authenticator.toUpperCase() === AuthenticationTypes.OAUTH_AUTHENTICATOR &&\n        !Util.string.isNotNullOrEmpty(fixedConfiguration.token));\n}\nfunction readTokenFromFile(fixedConfiguration) {\n    const tokenFilePath = fixedConfiguration.token_file_path\n        ? fixedConfiguration.token_file_path\n        : '/snowflake/session/token';\n    const resolvedPath = fs.realpathSync(tokenFilePath);\n    Logger().trace('Token file path is : %s', tokenFilePath);\n    validateNoExtraPermissionsForOthersSync(resolvedPath);\n    fixedConfiguration.token = fs.readFileSync(resolvedPath, 'utf-8').trim();\n    if (!fixedConfiguration.token) {\n        Logger().error('The token does not exist or has empty value.');\n        throw new Error('The token does not exist or has empty value');\n    }\n    const tokenChecksum = generateChecksum(fixedConfiguration.token);\n    Logger().info('Token used in connection has been read from file: %s. Checksum: %s', resolvedPath, tokenChecksum);\n}\nfunction loadConnectionConfiguration() {\n    Logger().trace('Loading connection configuration from the local files...');\n    const snowflakeConfigDir = defaultIfNotSet(process.env.SNOWFLAKE_HOME, path.join(os.homedir(), '.snowflake'));\n    Logger().trace('Looking for connection file in directory %s', snowflakeConfigDir);\n    const filePath = path.join(snowflakeConfigDir, 'connections.toml');\n    const resolvedPath = fs.realpathSync(filePath);\n    Logger().trace('Connection configuration file found under the path %s. Validating file access.', resolvedPath);\n    validateNoExtraPermissionsForOthersSync(resolvedPath);\n    const str = fs.readFileSync(resolvedPath, { encoding: 'utf8' });\n    const configurationChecksum = generateChecksum(str);\n    Logger().info('Connection configuration file is read from path: %s. Checksum: %s', resolvedPath, configurationChecksum);\n    Logger().trace('Trying to parse the config file');\n    const parsingResult = toml.parse(str);\n    const configurationName = defaultIfNotSet(process.env.SNOWFLAKE_DEFAULT_CONNECTION_NAME, 'default');\n    if (parsingResult[configurationName] !== undefined) {\n        const fixedConfiguration = fixUserKey(parsingResult[configurationName]);\n        if (shouldReadTokenFromFile(fixedConfiguration)) {\n            Logger().info('Trying to read token from config file.');\n            readTokenFromFile(fixedConfiguration);\n        }\n        return fixedConfiguration;\n    }\n    else {\n        Logger().error('Connection configuration with name %s does not exist in the file %s', configurationName, resolvedPath);\n        throw new Error(`Connection configuration with name ${configurationName} does not exist`);\n    }\n}\nfunction fixUserKey(parsingResult) {\n    Logger().trace(\"Empty Username field will be filled with 'User' field value.\");\n    if (parsingResult['username'] === undefined && parsingResult['user'] !== undefined) {\n        parsingResult['username'] = parsingResult['user'];\n    }\n    return parsingResult;\n}\nexports.loadConnectionConfiguration = loadConnectionConfiguration;\n//# sourceMappingURL=connection_configuration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25maWd1cmF0aW9uL2Nvbm5lY3Rpb25fY29uZmlndXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxnREFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLDREQUE0RCxFQUFFLG1CQUFPLENBQUMsOEVBQWM7QUFDNUYsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsMEdBQTRCO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLGtJQUF3QztBQUM1RSxhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25maWd1cmF0aW9uL2Nvbm5lY3Rpb25fY29uZmlndXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRvbWwgPSByZXF1aXJlKCd0b21sJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IHZhbGlkYXRlTm9FeHRyYVBlcm1pc3Npb25zRm9yT3RoZXJzU3luYywgZ2VuZXJhdGVDaGVja3N1bSB9ID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl90eXBlcycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmZ1bmN0aW9uIGRlZmF1bHRJZk5vdFNldCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVhZFRva2VuRnJvbUZpbGUoZml4ZWRDb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIChmaXhlZENvbmZpZ3VyYXRpb24gJiZcbiAgICAgICAgZml4ZWRDb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0b3IgJiZcbiAgICAgICAgZml4ZWRDb25maWd1cmF0aW9uLmF1dGhlbnRpY2F0b3IudG9VcHBlckNhc2UoKSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9BVVRIRU5USUNBVE9SICYmXG4gICAgICAgICFVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbikpO1xufVxuZnVuY3Rpb24gcmVhZFRva2VuRnJvbUZpbGUoZml4ZWRDb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgdG9rZW5GaWxlUGF0aCA9IGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbl9maWxlX3BhdGhcbiAgICAgICAgPyBmaXhlZENvbmZpZ3VyYXRpb24udG9rZW5fZmlsZV9wYXRoXG4gICAgICAgIDogJy9zbm93Zmxha2Uvc2Vzc2lvbi90b2tlbic7XG4gICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gZnMucmVhbHBhdGhTeW5jKHRva2VuRmlsZVBhdGgpO1xuICAgIExvZ2dlcigpLnRyYWNlKCdUb2tlbiBmaWxlIHBhdGggaXMgOiAlcycsIHRva2VuRmlsZVBhdGgpO1xuICAgIHZhbGlkYXRlTm9FeHRyYVBlcm1pc3Npb25zRm9yT3RoZXJzU3luYyhyZXNvbHZlZFBhdGgpO1xuICAgIGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbiA9IGZzLnJlYWRGaWxlU3luYyhyZXNvbHZlZFBhdGgsICd1dGYtOCcpLnRyaW0oKTtcbiAgICBpZiAoIWZpeGVkQ29uZmlndXJhdGlvbi50b2tlbikge1xuICAgICAgICBMb2dnZXIoKS5lcnJvcignVGhlIHRva2VuIGRvZXMgbm90IGV4aXN0IG9yIGhhcyBlbXB0eSB2YWx1ZS4nKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdG9rZW4gZG9lcyBub3QgZXhpc3Qgb3IgaGFzIGVtcHR5IHZhbHVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuQ2hlY2tzdW0gPSBnZW5lcmF0ZUNoZWNrc3VtKGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbik7XG4gICAgTG9nZ2VyKCkuaW5mbygnVG9rZW4gdXNlZCBpbiBjb25uZWN0aW9uIGhhcyBiZWVuIHJlYWQgZnJvbSBmaWxlOiAlcy4gQ2hlY2tzdW06ICVzJywgcmVzb2x2ZWRQYXRoLCB0b2tlbkNoZWNrc3VtKTtcbn1cbmZ1bmN0aW9uIGxvYWRDb25uZWN0aW9uQ29uZmlndXJhdGlvbigpIHtcbiAgICBMb2dnZXIoKS50cmFjZSgnTG9hZGluZyBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgbG9jYWwgZmlsZXMuLi4nKTtcbiAgICBjb25zdCBzbm93Zmxha2VDb25maWdEaXIgPSBkZWZhdWx0SWZOb3RTZXQocHJvY2Vzcy5lbnYuU05PV0ZMQUtFX0hPTUUsIHBhdGguam9pbihvcy5ob21lZGlyKCksICcuc25vd2ZsYWtlJykpO1xuICAgIExvZ2dlcigpLnRyYWNlKCdMb29raW5nIGZvciBjb25uZWN0aW9uIGZpbGUgaW4gZGlyZWN0b3J5ICVzJywgc25vd2ZsYWtlQ29uZmlnRGlyKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihzbm93Zmxha2VDb25maWdEaXIsICdjb25uZWN0aW9ucy50b21sJyk7XG4gICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gZnMucmVhbHBhdGhTeW5jKGZpbGVQYXRoKTtcbiAgICBMb2dnZXIoKS50cmFjZSgnQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIGZpbGUgZm91bmQgdW5kZXIgdGhlIHBhdGggJXMuIFZhbGlkYXRpbmcgZmlsZSBhY2Nlc3MuJywgcmVzb2x2ZWRQYXRoKTtcbiAgICB2YWxpZGF0ZU5vRXh0cmFQZXJtaXNzaW9uc0Zvck90aGVyc1N5bmMocmVzb2x2ZWRQYXRoKTtcbiAgICBjb25zdCBzdHIgPSBmcy5yZWFkRmlsZVN5bmMocmVzb2x2ZWRQYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbkNoZWNrc3VtID0gZ2VuZXJhdGVDaGVja3N1bShzdHIpO1xuICAgIExvZ2dlcigpLmluZm8oJ0Nvbm5lY3Rpb24gY29uZmlndXJhdGlvbiBmaWxlIGlzIHJlYWQgZnJvbSBwYXRoOiAlcy4gQ2hlY2tzdW06ICVzJywgcmVzb2x2ZWRQYXRoLCBjb25maWd1cmF0aW9uQ2hlY2tzdW0pO1xuICAgIExvZ2dlcigpLnRyYWNlKCdUcnlpbmcgdG8gcGFyc2UgdGhlIGNvbmZpZyBmaWxlJyk7XG4gICAgY29uc3QgcGFyc2luZ1Jlc3VsdCA9IHRvbWwucGFyc2Uoc3RyKTtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uTmFtZSA9IGRlZmF1bHRJZk5vdFNldChwcm9jZXNzLmVudi5TTk9XRkxBS0VfREVGQVVMVF9DT05ORUNUSU9OX05BTUUsICdkZWZhdWx0Jyk7XG4gICAgaWYgKHBhcnNpbmdSZXN1bHRbY29uZmlndXJhdGlvbk5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZml4ZWRDb25maWd1cmF0aW9uID0gZml4VXNlcktleShwYXJzaW5nUmVzdWx0W2NvbmZpZ3VyYXRpb25OYW1lXSk7XG4gICAgICAgIGlmIChzaG91bGRSZWFkVG9rZW5Gcm9tRmlsZShmaXhlZENvbmZpZ3VyYXRpb24pKSB7XG4gICAgICAgICAgICBMb2dnZXIoKS5pbmZvKCdUcnlpbmcgdG8gcmVhZCB0b2tlbiBmcm9tIGNvbmZpZyBmaWxlLicpO1xuICAgICAgICAgICAgcmVhZFRva2VuRnJvbUZpbGUoZml4ZWRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4ZWRDb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTG9nZ2VyKCkuZXJyb3IoJ0Nvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB3aXRoIG5hbWUgJXMgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGZpbGUgJXMnLCBjb25maWd1cmF0aW9uTmFtZSwgcmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gd2l0aCBuYW1lICR7Y29uZmlndXJhdGlvbk5hbWV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZml4VXNlcktleShwYXJzaW5nUmVzdWx0KSB7XG4gICAgTG9nZ2VyKCkudHJhY2UoXCJFbXB0eSBVc2VybmFtZSBmaWVsZCB3aWxsIGJlIGZpbGxlZCB3aXRoICdVc2VyJyBmaWVsZCB2YWx1ZS5cIik7XG4gICAgaWYgKHBhcnNpbmdSZXN1bHRbJ3VzZXJuYW1lJ10gPT09IHVuZGVmaW5lZCAmJiBwYXJzaW5nUmVzdWx0Wyd1c2VyJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzaW5nUmVzdWx0Wyd1c2VybmFtZSddID0gcGFyc2luZ1Jlc3VsdFsndXNlciddO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2luZ1Jlc3VsdDtcbn1cbmV4cG9ydHMubG9hZENvbm5lY3Rpb25Db25maWd1cmF0aW9uID0gbG9hZENvbm5lY3Rpb25Db25maWd1cmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbl9jb25maWd1cmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Statement = __webpack_require__(/*! ./statement */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\");\nconst { isString } = __webpack_require__(/*! util */ \"util\");\nconst STAGE_NAME = 'SYSTEM$BIND';\nconst CREATE_STAGE_STMT = 'CREATE OR REPLACE TEMPORARY STAGE ' +\n    STAGE_NAME +\n    \" file_format=( type=csv field_optionally_enclosed_by='\\\"')\";\n/**\n * Creates a new BindUploader.\n *\n * @param {Object} options\n * @param {Object} services\n * @param {Object} connectionConfig\n * @param {*} requestId\n *\n * @constructor\n */\nfunction BindUploader(options, services, connectionConfig, requestId) {\n    const MAX_BUFFER_SIZE = 1024 * 1024 * 100;\n    Logger.getInstance().debug('BindUploaders');\n    this.options = options;\n    this.services = services;\n    this.connectionConfig = connectionConfig;\n    this.requestId = requestId;\n    this.stagePath = '@' + STAGE_NAME + '/' + requestId;\n    Logger.getInstance().debug('token = %s', connectionConfig.getToken());\n    this.createStage = async function () {\n        const createStageOptions = { sqlText: GetCreateStageStmt() };\n        const newContext = Statement.createContext(createStageOptions, this.services, this.connectionConfig);\n        if (this.connectionConfig.getForceStageBindError() === 0) {\n            throw new Error('Failed to create stage');\n        }\n        const ret = await Statement.sendRequest(newContext);\n        if (ret['status'] !== 200) {\n            throw new Error('Failed to create stage');\n        }\n    };\n    this.uploadFilestream = async function (fileName, fileData) {\n        Logger.getInstance().debug('BindUploaders::uploadFilestream');\n        const stageName = this.stagePath;\n        if (stageName == null) {\n            throw new Error('Stage name is null.');\n        }\n        if (fileName == null) {\n            throw new Error('File name is null.');\n        }\n        if (this.connectionConfig.getForceStageBindError() === 1) {\n            throw new Error('Failed to upload file');\n        }\n        await new Promise((resolve, reject) => {\n            const putStmt = 'PUT file://' +\n                fileName +\n                \"'\" +\n                stageName +\n                \"' overwrite=true auto_compress=false source_compression=gzip\";\n            const uploadFileOptions = {\n                sqlText: putStmt,\n                fileStream: fileData,\n                complete: function (err, stmt) {\n                    if (err) {\n                        Logger.getInstance().debug('err ' + err);\n                        reject(err);\n                    }\n                    Logger.getInstance().debug('uploadFiles done ');\n                    resolve(stmt.streamRows());\n                },\n            };\n            Statement.createStatementPreExec(uploadFileOptions, this.services, this.connectionConfig);\n        });\n    };\n    this.Upload = async function (bindings) {\n        Logger.getInstance().debug('BindUploaders::Upload');\n        if (bindings == null) {\n            return null;\n        }\n        if (!this.services.sf.isStageCreated) {\n            await this.createStage();\n            this.services.sf.isStageCreated = true;\n        }\n        let fileCount = 0;\n        let strbuffer = '';\n        for (let i = 0; i < bindings.length; i++) {\n            for (let j = 0; j < bindings[i].length; j++) {\n                if (j > 0) {\n                    strbuffer += ',';\n                }\n                const value = this.csvData(bindings[i][j]);\n                strbuffer += value;\n            }\n            strbuffer += '\\n';\n            if (strbuffer.length >= MAX_BUFFER_SIZE || i === bindings.length - 1) {\n                const fileName = (++fileCount).toString();\n                Logger.getInstance().debug('fileName=' + fileName);\n                await this.uploadFilestream(fileName, strbuffer);\n                strbuffer = '';\n            }\n        }\n    };\n    this.csvData = function (data) {\n        if (data === null) {\n            return '';\n        }\n        if (data.toString() === '') {\n            return '\"\"';\n        }\n        if (!isString(data)) {\n            if (data instanceof Date) {\n                data = data.toJSON();\n            }\n            else {\n                data = JSON.stringify(data);\n            }\n        }\n        if (data.toString().indexOf('\"') >= 0 ||\n            data.toString().indexOf(',') >= 0 ||\n            data.toString().indexOf('\\\\') >= 0 ||\n            data.toString().indexOf('\\n') >= 0 ||\n            data.toString().indexOf('\\t') >= 0) {\n            return '\"' + data.toString().replaceAll('\"', '\"\"') + '\"';\n        }\n        else {\n            return data;\n        }\n    };\n}\nfunction GetCreateStageStmt() {\n    return CREATE_STAGE_STMT;\n}\nfunction GetStageName(requestId) {\n    return '@' + STAGE_NAME + '/' + requestId;\n}\nfunction CleanFile(fileName) {\n    try {\n        if (fs.existsSync(fileName)) {\n            fs.unlinkSync(fileName);\n        }\n    }\n    catch (err) {\n        Logger.getInstance().debug('Delete file failed: %s', fileName);\n    }\n}\nmodule.exports = { BindUploader, GetCreateStageStmt, GetStageName, CleanFile };\n//# sourceMappingURL=bind_uploader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2JpbmRfdXBsb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQWE7QUFDdkMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3Qyw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2JpbmRfdXBsb2FkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IFN0YXRlbWVudCA9IHJlcXVpcmUoJy4vc3RhdGVtZW50Jyk7XG5jb25zdCB7IGlzU3RyaW5nIH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBTVEFHRV9OQU1FID0gJ1NZU1RFTSRCSU5EJztcbmNvbnN0IENSRUFURV9TVEFHRV9TVE1UID0gJ0NSRUFURSBPUiBSRVBMQUNFIFRFTVBPUkFSWSBTVEFHRSAnICtcbiAgICBTVEFHRV9OQU1FICtcbiAgICBcIiBmaWxlX2Zvcm1hdD0oIHR5cGU9Y3N2IGZpZWxkX29wdGlvbmFsbHlfZW5jbG9zZWRfYnk9J1xcXCInKVwiO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEJpbmRVcGxvYWRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHsqfSByZXF1ZXN0SWRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmluZFVwbG9hZGVyKG9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnLCByZXF1ZXN0SWQpIHtcbiAgICBjb25zdCBNQVhfQlVGRkVSX1NJWkUgPSAxMDI0ICogMTAyNCAqIDEwMDtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQmluZFVwbG9hZGVycycpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgdGhpcy5zdGFnZVBhdGggPSAnQCcgKyBTVEFHRV9OQU1FICsgJy8nICsgcmVxdWVzdElkO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCd0b2tlbiA9ICVzJywgY29ubmVjdGlvbkNvbmZpZy5nZXRUb2tlbigpKTtcbiAgICB0aGlzLmNyZWF0ZVN0YWdlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjcmVhdGVTdGFnZU9wdGlvbnMgPSB7IHNxbFRleHQ6IEdldENyZWF0ZVN0YWdlU3RtdCgpIH07XG4gICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBTdGF0ZW1lbnQuY3JlYXRlQ29udGV4dChjcmVhdGVTdGFnZU9wdGlvbnMsIHRoaXMuc2VydmljZXMsIHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Rm9yY2VTdGFnZUJpbmRFcnJvcigpID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc3RhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBTdGF0ZW1lbnQuc2VuZFJlcXVlc3QobmV3Q29udGV4dCk7XG4gICAgICAgIGlmIChyZXRbJ3N0YXR1cyddICE9PSAyMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzdGFnZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVwbG9hZEZpbGVzdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAoZmlsZU5hbWUsIGZpbGVEYXRhKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdCaW5kVXBsb2FkZXJzOjp1cGxvYWRGaWxlc3RyZWFtJyk7XG4gICAgICAgIGNvbnN0IHN0YWdlTmFtZSA9IHRoaXMuc3RhZ2VQYXRoO1xuICAgICAgICBpZiAoc3RhZ2VOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhZ2UgbmFtZSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgbmFtZSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Rm9yY2VTdGFnZUJpbmRFcnJvcigpID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZScpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHB1dFN0bXQgPSAnUFVUIGZpbGU6Ly8nICtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZSArXG4gICAgICAgICAgICAgICAgXCInXCIgK1xuICAgICAgICAgICAgICAgIHN0YWdlTmFtZSArXG4gICAgICAgICAgICAgICAgXCInIG92ZXJ3cml0ZT10cnVlIGF1dG9fY29tcHJlc3M9ZmFsc2Ugc291cmNlX2NvbXByZXNzaW9uPWd6aXBcIjtcbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZEZpbGVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHNxbFRleHQ6IHB1dFN0bXQsXG4gICAgICAgICAgICAgICAgZmlsZVN0cmVhbTogZmlsZURhdGEsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChlcnIsIHN0bXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ2VyciAnICsgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCd1cGxvYWRGaWxlcyBkb25lICcpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0bXQuc3RyZWFtUm93cygpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFN0YXRlbWVudC5jcmVhdGVTdGF0ZW1lbnRQcmVFeGVjKHVwbG9hZEZpbGVPcHRpb25zLCB0aGlzLnNlcnZpY2VzLCB0aGlzLmNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuVXBsb2FkID0gYXN5bmMgZnVuY3Rpb24gKGJpbmRpbmdzKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdCaW5kVXBsb2FkZXJzOjpVcGxvYWQnKTtcbiAgICAgICAgaWYgKGJpbmRpbmdzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZXJ2aWNlcy5zZi5pc1N0YWdlQ3JlYXRlZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVTdGFnZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlcy5zZi5pc1N0YWdlQ3JlYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbGVDb3VudCA9IDA7XG4gICAgICAgIGxldCBzdHJidWZmZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5kaW5nc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJidWZmZXIgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY3N2RGF0YShiaW5kaW5nc1tpXVtqXSk7XG4gICAgICAgICAgICAgICAgc3RyYnVmZmVyICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyYnVmZmVyICs9ICdcXG4nO1xuICAgICAgICAgICAgaWYgKHN0cmJ1ZmZlci5sZW5ndGggPj0gTUFYX0JVRkZFUl9TSVpFIHx8IGkgPT09IGJpbmRpbmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9ICgrK2ZpbGVDb3VudCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnZmlsZU5hbWU9JyArIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEZpbGVzdHJlYW0oZmlsZU5hbWUsIHN0cmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgc3RyYnVmZmVyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY3N2RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudG9TdHJpbmcoKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJcIic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9KU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudG9TdHJpbmcoKS5pbmRleE9mKCdcIicpID49IDAgfHxcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKS5pbmRleE9mKCcsJykgPj0gMCB8fFxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpLmluZGV4T2YoJ1xcXFwnKSA+PSAwIHx8XG4gICAgICAgICAgICBkYXRhLnRvU3RyaW5nKCkuaW5kZXhPZignXFxuJykgPj0gMCB8fFxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpLmluZGV4T2YoJ1xcdCcpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInICsgZGF0YS50b1N0cmluZygpLnJlcGxhY2VBbGwoJ1wiJywgJ1wiXCInKSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRDcmVhdGVTdGFnZVN0bXQoKSB7XG4gICAgcmV0dXJuIENSRUFURV9TVEFHRV9TVE1UO1xufVxuZnVuY3Rpb24gR2V0U3RhZ2VOYW1lKHJlcXVlc3RJZCkge1xuICAgIHJldHVybiAnQCcgKyBTVEFHRV9OQU1FICsgJy8nICsgcmVxdWVzdElkO1xufVxuZnVuY3Rpb24gQ2xlYW5GaWxlKGZpbGVOYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgICBmcy51bmxpbmtTeW5jKGZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdEZWxldGUgZmlsZSBmYWlsZWQ6ICVzJywgZmlsZU5hbWUpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0geyBCaW5kVXBsb2FkZXIsIEdldENyZWF0ZVN0YWdlU3RtdCwgR2V0U3RhZ2VOYW1lLCBDbGVhbkZpbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRfdXBsb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/connection.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/index.js\");\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst QueryStatus = __webpack_require__(/*! ../constants/query_status */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/query_status.js\");\nconst LoggingUtil = __webpack_require__(/*! ../logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Statement = __webpack_require__(/*! ./statement */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst Authenticator = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { isOktaAuth } = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\");\nconst { init: initEasyLogging } = __webpack_require__(/*! ../logger/easy_logging_starter */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst { JsonCredentialManager, } = __webpack_require__(/*! ../authentication/secure_storage/json_credential_manager */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/secure_storage/json_credential_manager.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\n/**\n * Creates a new Connection instance.\n *\n * @param {ConnectionContext} context\n *\n * @returns {Object}\n */\nfunction Connection(context) {\n    // validate input\n    Logger.getInstance().trace('Connection object is being constructed');\n    Errors.assertInternal(Util.isObject(context));\n    const services = context.getServices();\n    const connectionConfig = context.getConnectionConfig();\n    // generate an id for the connection\n    const id = uuidv4();\n    Logger.getInstance().trace('Generated connection id: %s', id);\n    Logger.getInstance().info('Creating Connection[id: %s] with %s, password is %s, region: %s, ' +\n        'authenticator: %s, ocsp mode: %s, os: %s, os version: %s', id, connectionConfig.describeIdentityAttributes(), LoggingUtil.describePresence(connectionConfig.password), connectionConfig.region, connectionConfig.getAuthenticator(), connectionConfig.getClientEnvironment().OCSP_MODE, connectionConfig.getClientEnvironment().OS, connectionConfig.getClientEnvironment().OS_VERSION);\n    // Log was split due to possibility of exceeding the max message length of the logger\n    Logger.getInstance().info('Connection[id: %s] additional details: ' +\n        'passcode in password is %s, passcode is %s, private key is %s, ' +\n        'application: %s, client name: %s, client version: %s, retry timeout: %s, ' +\n        'private key path: %s, private key pass is %s, ' +\n        'client store temporary credential: %s, browser response timeout: %s', id, LoggingUtil.describePresence(connectionConfig.getPasscodeInPassword()), LoggingUtil.describePresence(connectionConfig.getPasscode()), LoggingUtil.describePresence(connectionConfig.getPrivateKey()), connectionConfig.getClientApplication(), connectionConfig.getClientName(), connectionConfig.getClientVersion(), connectionConfig.getRetryTimeout(), connectionConfig.getPrivateKeyPath(), LoggingUtil.describePresence(connectionConfig.getPrivateKeyPass()), connectionConfig.getClientStoreTemporaryCredential(), connectionConfig.getBrowserActionTimeout());\n    // async max retry and retry pattern from python connector\n    const asyncNoDataMaxRetry = 24;\n    const asyncRetryPattern = [1, 1, 2, 3, 4, 8, 10];\n    const asyncRetryInMilliseconds = 500;\n    // Custom regex based on uuid validate\n    // Unable to directly use uuid validate because the queryId returned from the server doesn't match the regex\n    const queryIdRegex = new RegExp(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n    //Make session tokens available for testing\n    this.getTokens = function () {\n        if (connectionConfig._qaMode) {\n            return services.sf.getConfig() && services.sf.getConfig().tokenInfo;\n        }\n        return {};\n    };\n    /**\n     * Returns true if the connection is active otherwise false\n     *\n     * @returns {boolean}\n     */\n    this.isUp = function () {\n        const isUp = services.sf.isConnected();\n        Logger.getInstance().trace('Connection[id: %s] - isUp called. Returning: %s', this.getId(), isUp);\n        return isUp;\n    };\n    /**\n     * Returns true if the session token and master token are valid\n     *\n     * @returns {boolean}\n     */\n    this.isTokenValid = function () {\n        Logger.getInstance().trace('Connection[id: %s] - isTokenValid called', this.getId());\n        const tokenInfo = services.sf.getConfig().tokenInfo;\n        const sessionTokenExpirationTime = tokenInfo.sessionTokenExpirationTime;\n        const isSessionValid = sessionTokenExpirationTime > Date.now();\n        Logger.getInstance().trace('Connection[id: %s] - isSessionTokenValid: %s', this.getId(), isSessionValid);\n        const masterTokenExpirationTime = tokenInfo.masterTokenExpirationTime;\n        const isMasterValid = masterTokenExpirationTime > Date.now();\n        Logger.getInstance().trace('Connection[id: %s] - isMasterTokenValid: %s', this.getId(), isMasterValid);\n        const areTokensValid = isSessionValid && isMasterValid;\n        Logger.getInstance().trace('Connection[id: %s] - isTokenValid returned: %s', this.getId(), areTokensValid);\n        return areTokensValid;\n    };\n    this.getServiceName = function () {\n        return services.sf.getServiceName();\n    };\n    this.getClientSessionKeepAlive = function () {\n        return services.sf.getClientSessionKeepAlive();\n    };\n    this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n        return services.sf.getClientSessionKeepAliveHeartbeatFrequency();\n    };\n    this.getJsTreatIntegerAsBigInt = function () {\n        return services.sf.getJsTreatIntegerAsBigInt();\n    };\n    /**\n     * Returns the connection id.\n     *\n     * @returns {String}\n     */\n    this.getId = function () {\n        return id;\n    };\n    this.heartbeat = (callback) => {\n        Logger.getInstance().trace('Issuing heartbeat call');\n        const requestId = uuidv4();\n        services.sf.request({\n            method: 'POST',\n            url: Url.format({\n                pathname: '/session/heartbeat',\n                search: QueryString.stringify({\n                    requestId: requestId,\n                }),\n            }),\n            callback: Util.isFunction(callback)\n                ? callback\n                : function (err, body) {\n                    if (err) {\n                        Logger.getInstance().error('Error issuing heartbeat call: %s', err.message);\n                    }\n                    else {\n                        Logger.getInstance().trace('Heartbeat response %s', JSON.stringify(body));\n                    }\n                },\n        });\n    };\n    this.heartbeatAsync = () => {\n        return new Promise((resolve, reject) => {\n            // previous version of driver called `select 1;` which result in `[ { '1': 1 } ]`\n            Logger.getInstance().trace('Issuing async heartbeat call');\n            this.heartbeat((err) => (err ? reject(err) : resolve([{ 1: 1 }])));\n        });\n    };\n    /**\n     * @return {Promise<boolean>}\n     */\n    this.isValidAsync = async () => {\n        Logger.getInstance().trace('Connection[id: %s] - isValidAsync called', this.getId());\n        if (!this.isUp()) {\n            return false;\n        }\n        try {\n            await this.heartbeatAsync();\n            return true;\n        }\n        catch (e) {\n            Logger.getInstance().debug('Connection[id: %s] - heartbeat failed: %s', this.getId(), JSON.stringify(e, Object.getOwnPropertyNames(e)));\n            return false;\n        }\n    };\n    /**\n     * Set the private link as the OCSP cache server's URL.\n     *\n     * @param {String} host\n     *\n     * @returns {null}\n     */\n    this.setupOcspPrivateLink = function (host) {\n        process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL = Util.createOcspResponseCacheServerUrl(host);\n    };\n    /**\n     * Method returning callback function for connect() - used to establish a connection.\n     *\n     * @param self\n     * @param {Function} callback\n     *\n     * @returns {function}\n     */\n    function connectCallback(self, callback) {\n        return function (err) {\n            if (Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE)) {\n                const SECONDS_TO_MILLISECONDS_MULTIPLIER = 1000;\n                const KEEP_ALIVE_HEARTBEAT_FREQUENCY_IN_MS = Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY) *\n                    SECONDS_TO_MILLISECONDS_MULTIPLIER;\n                self.keepalive = setInterval(self.heartbeat, KEEP_ALIVE_HEARTBEAT_FREQUENCY_IN_MS, self);\n                Logger.getInstance().trace('Connection[id: %s] - keepAlive internal created', id);\n            }\n            if (Util.isFunction(callback)) {\n                callback(Errors.externalize(err), self);\n            }\n        };\n    }\n    this.determineConnectionDomain = () => connectionConfig.accessUrl && connectionConfig.accessUrl.includes('snowflakecomputing.cn')\n        ? 'CHINA'\n        : 'GLOBAL';\n    /**\n     * Establishes a connection if we aren't in a fatal state.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Object} the connection object.\n     */\n    this.connect = function (callback) {\n        const timer = new ExecutionTimer().start();\n        const connectionDomain = this.determineConnectionDomain();\n        Logger.getInstance().info('Connection[id: %s] - connecting. Associated Snowflake domain: %s', this.getId(), connectionDomain);\n        // invalid callback\n        Errors.checkArgumentValid(!Util.exists(callback) || Util.isFunction(callback), ErrorCodes.ERR_CONN_CONNECT_INVALID_CALLBACK);\n        if (Util.exists(connectionConfig.host) && Util.isPrivateLink(connectionConfig.host)) {\n            Logger.getInstance().info('Connection[id: %s] - setting up private link', this.getId());\n            this.setupOcspPrivateLink(connectionConfig.host);\n        }\n        // connect to the snowflake service and provide our own callback so that\n        // the connection can be passed in when invoking the connection.connect()\n        // callback\n        const self = this;\n        const authenticationType = connectionConfig.getAuthenticator();\n        Logger.getInstance().debug('Connection[id: %s] - using authentication type: %s', this.getId(), authenticationType);\n        // check if authentication type is compatible with connect()\n        // external browser and okta are not compatible with connect() due to their usage of async functions\n        if (authenticationType === AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR ||\n            isOktaAuth(authenticationType)) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - connecting failed after %s milliseconds.' +\n                'Error: External browser and Okta are not compatible with connection process', this.getId(), connectingDuration);\n            throw Errors.createClientError(ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_CONNECT);\n        }\n        // Get authenticator to use\n        Logger.getInstance().debug('Connection[id: %s] - retrieving authenticator', this.getId());\n        const auth = services.sf.getAuthenticator();\n        Logger.getInstance().debug('Connection[id: %s] - trying to authenticate', this.getId());\n        auth\n            .authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username)\n            .then(() => {\n            Logger.getInstance().info('Connection[id: %s] - authentication successful using: %s', this.getId(), connectionConfig.getAuthenticator());\n            // JSON for connection\n            const body = Authenticator.formAuthJSON(connectionConfig.getAuthenticator(), connectionConfig.account, connectionConfig.username, connectionConfig.getClientType(), connectionConfig.getClientVersion(), connectionConfig.getClientEnvironment());\n            // Update JSON body with the authentication values\n            auth.updateBody(body);\n            Logger.getInstance().debug('Connection[id: %s] - initializing easyLogging', this.getId());\n            initEasyLogging(connectionConfig.clientConfigFile).then(() => {\n                Logger.getInstance().debug('Connection[id: %s] - easyLogging initialized', this.getId());\n                try {\n                    Logger.getInstance().debug('Connection[id: %s] - connecting through service', this.getId());\n                    services.sf.connect({\n                        callback: connectCallback(self, callback),\n                        json: body,\n                    });\n                    const connectingDuration = timer.getDuration();\n                    Logger.getInstance().info('Connection[id: %s] - connected successfully after %s milliseconds', this.getId(), connectingDuration);\n                    return this;\n                }\n                catch (e) {\n                    // we don't expect an error here since callback method should be called\n                    const connectingDuration = timer.getDuration();\n                    Logger.getInstance().info('Connection[id: %s] - failed to connect after %s milliseconds. ' +\n                        'Error: Unexpected error from calling connectCallback function in snowflake service - %s', this.getId(), connectingDuration, e);\n                }\n            }, () => {\n                const connectingDuration = timer.getDuration();\n                Logger.getInstance().error('Connection[id: %s] - failed to initialize easyLogging. ' +\n                    'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n                callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG, true), self);\n            });\n        }, (err) => {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - authentication failed. Error: %s. ' +\n                'Connecting failed after %s milliseconds', this.getId(), err, connectingDuration);\n            callback(err, self);\n        });\n        return this;\n    };\n    /**\n     * Establishes a connection if we aren't in a fatal state.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Object} the connection object.\n     */\n    this.connectAsync = async function (callback) {\n        const timer = new ExecutionTimer().start();\n        const connectingDomain = this.determineConnectionDomain();\n        Logger.getInstance().info('Connection[id: %s] - async connecting. Associated Snowflake domain: %s', this.getId(), connectingDomain);\n        // invalid callback\n        Errors.checkArgumentValid(!Util.exists(callback) || Util.isFunction(callback), ErrorCodes.ERR_CONN_CONNECT_INVALID_CALLBACK);\n        if (Util.isPrivateLink(connectionConfig.host)) {\n            this.setupOcspPrivateLink(connectionConfig.host);\n            Logger.getInstance().info('Connection[id: %s] - setting up private link', this.getId());\n        }\n        // connect to the snowflake service and provide our own callback so that\n        // the connection can be passed in when invoking the connection.connect()\n        // callback\n        const self = this;\n        if (connectionConfig.getClientStoreTemporaryCredential()) {\n            Logger.getInstance().debug('Connection[id: %s] - storing temporary credential of client', this.getId());\n            const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n            if (GlobalConfig.getCredentialManager() === null) {\n                Logger.getInstance().debug('Connection[id: %s] - using default json credential manager', this.getId());\n                GlobalConfig.setCustomCredentialManager(new JsonCredentialManager(connectionConfig.getCredentialCacheDir()));\n            }\n            Logger.getInstance().debug('Connection[id: %s] - reading idToken using credential manager', this.getId());\n            connectionConfig.idToken = await GlobalConfig.getCredentialManager().read(key);\n        }\n        if (connectionConfig.getClientRequestMFAToken()) {\n            Logger.getInstance().debug('Connection[id: %s] - extracting mfaToken of client', this.getId());\n            const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR);\n            if (GlobalConfig.getCredentialManager() === null) {\n                Logger.getInstance().debug('Connection[id: %s] - using default json credential manager', this.getId());\n                GlobalConfig.setCustomCredentialManager(new JsonCredentialManager(connectionConfig.getCredentialCacheDir()));\n            }\n            Logger.getInstance().debug('Connection[id: %s] - reading mfaToken using credential manager', this.getId());\n            connectionConfig.mfaToken = await GlobalConfig.getCredentialManager().read(key);\n        }\n        // Get authenticator to use\n        let auth;\n        try {\n            Logger.getInstance().debug('Connection[id: %s] - retrieving authenticator', this.getId());\n            auth = Authenticator.getAuthenticator(connectionConfig, context.getHttpClient());\n            services.sf.authenticator = auth;\n        }\n        catch (error) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - failed to initialize authenticator. ' +\n                'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n            throw Errors.createClientError(ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED, true);\n        }\n        try {\n            Logger.getInstance().debug('Connection[id: %s] - initializing easyLogging', this.getId());\n            await initEasyLogging(connectionConfig.clientConfigFile);\n        }\n        catch (err) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().error('Connection[id: %s] - failed to initialize easyLogging. ' +\n                'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n            throw Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG, true);\n        }\n        let body = null;\n        try {\n            Logger.getInstance().debug('Connection[id: %s] - using authentication type: %s', this.getId(), connectionConfig.getAuthenticator());\n            Logger.getInstance().debug('Connection[id: %s] - trying to authenticate', this.getId());\n            await auth.authenticate(connectionConfig.getAuthenticator(), connectionConfig.getServiceName(), connectionConfig.account, connectionConfig.username);\n            Logger.getInstance().info('Connection[id: %s] - authentication successful using: %s', this.getId(), connectionConfig.getAuthenticator());\n            // JSON for connection\n            body = Authenticator.formAuthJSON(connectionConfig.getAuthenticator(), connectionConfig.account, connectionConfig.username, connectionConfig.getClientType(), connectionConfig.getClientVersion(), connectionConfig.getClientEnvironment());\n            // Update JSON body with the authentication values\n            auth.updateBody(body);\n        }\n        catch (authErr) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - failed to connect async after %s milliseconds.' +\n                'Failed during authentication. Error: %s', this.getId(), connectingDuration, authErr);\n            Logger.getInstance().error('Connection[id: %s] - failed during authentication. Error: %s', this.getId(), authErr);\n            callback(authErr);\n            return this;\n        }\n        try {\n            // Request connection\n            Logger.getInstance().debug('Connection[id: %s] - connecting through service', this.getId());\n            services.sf.connect({\n                callback: connectCallback(self, callback),\n                json: body,\n            });\n            // return the connection to facilitate chaining\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - connected successfully after %s milliseconds', this.getId(), connectingDuration);\n        }\n        catch (callbackErr) {\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - failed to connect async after %s milliseconds.' +\n                'Error: Unexpected error from calling connectCallback function in snowflake service - %s', this.getId(), connectingDuration, callbackErr);\n            callback(callbackErr);\n            return this;\n        }\n        return this;\n    };\n    /**\n     * Executes a statement.\n     *\n     * @param {Object} options\n     *\n     * @returns {Object}\n     */\n    this.execute = function (options) {\n        Logger.getInstance().trace('Connection[id: %s] - execute called with options.', this.getId());\n        return Statement.createStatementPreExec(options, services, connectionConfig);\n    };\n    /**\n     * Fetches the result of a previously issued statement.\n     *\n     * @param {Object} options\n     *\n     * @returns {Object}\n     */\n    this.fetchResult = function (options) {\n        Logger.getInstance().trace('Connection[id: %s] - fetchResult called with options', this.getId());\n        return Statement.createStatementPostExec(options, services, connectionConfig);\n    };\n    /**\n     * Immediately terminates the connection without waiting for currently\n     * executing statements to complete.\n     *\n     * @param {Function} callback\n     *\n     * @returns {Object} the connection object.\n     */\n    this.destroy = function (callback) {\n        // invalid callback\n        Logger.getInstance().trace('Connection[id: %s] - destroy called', this.getId());\n        Errors.checkArgumentValid(!Util.exists(callback) || Util.isFunction(callback), ErrorCodes.ERR_CONN_DESTROY_INVALID_CALLBACK);\n        // log out of the snowflake service and provide our own callback so that\n        // the connection can be passed in when invoking the connection.destroy()\n        // callback\n        Logger.getInstance().trace('Connection[id: %s] - destroying through service', this.getId());\n        const self = this;\n        services.sf.destroy({\n            callback: function (err) {\n                if (Util.exists(self.keepalive)) {\n                    clearInterval(self.keepalive);\n                    Logger.getInstance().trace('Connection[id: %s] - keepAlive interval cleared', self.getId());\n                }\n                if (Util.isFunction(callback)) {\n                    callback(Errors.externalize(err), self);\n                }\n            },\n        });\n        Logger.getInstance().trace('Connection[id: %s] - connection destroyed successfully', this.getId());\n        // return the connection to facilitate chaining\n        return this;\n    };\n    /**\n     * Gets the response containing the status of the query based on queryId.\n     *\n     * @param {String} queryId\n     *\n     * @returns {Object} the query response\n     */\n    async function getQueryResponse(queryId) {\n        Logger.getInstance().trace('Connection[id: %s] - requested query response for Query[id: %s]', id, queryId);\n        // Check if queryId exists and is valid uuid\n        Errors.checkArgumentExists(Util.exists(queryId), ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID);\n        Errors.checkArgumentValid(queryIdRegex.test(queryId), ErrorCodes.ERR_GET_RESPONSE_QUERY_INVALID_UUID, queryId);\n        Logger.getInstance().debug('Connection[id: %s] - Query[id: %s] is valid', id, queryId);\n        // Form the request options\n        const options = {\n            method: 'GET',\n            url: Url.format({\n                pathname: `/monitoring/queries/${queryId}`,\n            }),\n        };\n        Logger.getInstance().debug('Connection[id: %s] - fetching query response for Query[id: %s]', id, queryId);\n        const timer = new ExecutionTimer().start();\n        // Get the response containing the query status\n        const response = await services.sf.requestAsync(options);\n        const fetchingDuration = timer.getDuration();\n        Logger.getInstance().debug('Connection[id: %s] - query response for Query[id: %s] fetched successfully after: %s milliseconds', id, queryId, fetchingDuration);\n        return response['data'];\n    }\n    /**\n     * Extracts the status of the query from the query response.\n     *\n     * @param {Object} queryResponse\n     *\n     * @returns {String} the query status.\n     */\n    function extractQueryStatus(queryResponse) {\n        let status = QueryStatus.code.NO_QUERY_DATA; // default status\n        if (!queryResponse || !queryResponse['data'] || !queryResponse['data']['queries']) {\n            Logger.getInstance().trace('Connection[id: %s] - No query data found, returning NO_QUERY_DATA status', id);\n            return status;\n        }\n        const queries = queryResponse['data']['queries'];\n        if (queries.length > 0) {\n            status = queries[0]['status'];\n        }\n        Logger.getInstance().trace('Connection[id: %s] - Extracted query status: %s', id, status);\n        return status;\n    }\n    /**\n     * Gets the status of the query based on queryId.\n     *\n     * @param {String} queryId\n     *\n     * @returns {String} the query status.\n     */\n    this.getQueryStatus = async function (queryId) {\n        Logger.getInstance().trace('Connection[id: %s] - getQueryStatus called for Query[id: %s]', this.getId(), queryId);\n        return extractQueryStatus(await getQueryResponse(queryId));\n    };\n    /**\n     * Gets the status of the query based on queryId and throws if there's an error.\n     *\n     * @param {String} queryId\n     *\n     * @returns {String} the query status.\n     */\n    this.getQueryStatusThrowIfError = async function (queryId) {\n        Logger.getInstance().trace('Connection[id: %s] - getQueryStatusThrowIfError called for Query[id: %s]', this.getId(), queryId);\n        const response = await getQueryResponse(queryId); // returns response['data']\n        const status = extractQueryStatus(response);\n        let sqlState = null;\n        if (this.isAnError(status)) {\n            let message = response['message'] || '';\n            const code = response['code'] || -1;\n            if (response['data']) {\n                message +=\n                    response['data']['queries'].length > 0\n                        ? response['data']['queries'][0]['errorMessage']\n                        : '';\n                sqlState = response['data']['sqlState'];\n            }\n            Logger.getInstance().debug('Connection[id: %s] - query error for Query[id: %s]. Error: %s. SQLState: %s', this.getId(), queryId, message, sqlState);\n            throw Errors.createOperationFailedError(code, response, message, sqlState);\n        }\n        return status;\n    };\n    /**\n     * Gets the results from a previously ran query based on queryId\n     *\n     * @param {Object} options\n     *\n     * @returns {Object}\n     */\n    this.getResultsFromQueryId = async function (options) {\n        const queryId = options.queryId;\n        Logger.getInstance().trace('Connection[id: %s] - getResultsFromQueryId called for Query[id: %s].', this.getId(), queryId);\n        let status, noDataCounter = 0, retryPatternPos = 0;\n        // Wait until query has finished executing\n        let queryStillExecuting = true;\n        while (queryStillExecuting) {\n            Logger.getInstance().trace('Connection[id: %s] - checking if Query[id: %s] is still executing. Retries with no data count: %d', this.getId(), queryId, noDataCounter);\n            // Check if query is still running.\n            // Trigger exception if it failed or there is no query data in the server.\n            status = await this.getQueryStatusThrowIfError(queryId);\n            queryStillExecuting = this.isStillRunning(status);\n            if (!queryStillExecuting || status === QueryStatus.code.NO_QUERY_DATA) {\n                Logger.getInstance().trace('Connection[id: %s] - end of waiting for Query[id: %s] to finish executing. ' +\n                    queryStillExecuting\n                    ? 'Query is no longer executing. '\n                    : 0, this.getId(), queryId, status);\n                break;\n            }\n            // Timeout based on query status retry rules\n            await new Promise((resolve) => {\n                setTimeout(() => resolve(), asyncRetryInMilliseconds * asyncRetryPattern[retryPatternPos]);\n            });\n            // If no data, increment the no data counter\n            if (QueryStatus.code[status] === QueryStatus.code.NO_DATA) {\n                noDataCounter++;\n                Logger.getInstance().trace('Connection[id: %s] - no data returned for Query[id: %s]. Retries with no data count: %d', this.getId(), queryId, noDataCounter);\n                // Check if retry for no data is exceeded\n                if (noDataCounter > asyncNoDataMaxRetry) {\n                    Logger.getInstance().error('Connection[id: %s] - no data returned for Query[id: %s]. Retry limit: %s reached.', this.getId(), queryId, asyncNoDataMaxRetry);\n                    throw Errors.createClientError(ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA, true, queryId);\n                }\n            }\n            if (retryPatternPos < asyncRetryPattern.length - 1) {\n                retryPatternPos++;\n            }\n        }\n        if (QueryStatus.code[status] === QueryStatus.code.NO_QUERY_DATA) {\n            Logger.getInstance().error('Connection[id: %s] - Query[id: %s] did not succeed. Final status: %s', this.getId(), queryId, status);\n            throw Errors.createClientError(ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA, true, queryId, status);\n        }\n        if (QueryStatus.code[status] !== QueryStatus.code.SUCCESS) {\n            Logger.getInstance().error('Connection[id: %s] - Query[id: %s] did not succeed. Final status: %s', this.getId(), queryId, status);\n            throw Errors.createClientError(ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS, true, queryId, status);\n        }\n        Logger.getInstance().debug('Connection[id: %s] - Query[id: %s] succeeded. Fetching the result.', this.getId(), queryId);\n        return this.fetchResult(options);\n    };\n    /**\n     * Checks whether the given status is currently running.\n     *\n     * @param {String} status\n     *\n     * @returns {Boolean}\n     */\n    this.isStillRunning = function (status) {\n        Logger.getInstance().trace('Connection[id: %s] - checking if status %s is still running', this.getId(), status);\n        return QueryStatus.runningStatuses.includes(QueryStatus.code[status]);\n    };\n    /**\n     * Checks whether the given status means that there has been an error.\n     *\n     * @param {String} status\n     *\n     * @returns {Boolean}\n     */\n    this.isAnError = function (status) {\n        return QueryStatus.errorStatuses.includes(QueryStatus.code[status]);\n    };\n    /**\n     * Returns a serialized version of this connection.\n     *\n     * @returns {String}\n     */\n    this.serialize = function () {\n        Logger.getInstance().trace('Connection[id: %s] - serialize called', this.getId());\n        return JSON.stringify(context.getConfig());\n    };\n    EventEmitter.call(this);\n}\nUtil.inherits(Connection, EventEmitter);\nmodule.exports = Connection;\n//# sourceMappingURL=connection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlGQUFNO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsa0dBQXdCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQSxxQkFBcUIsMERBQThCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHdGQUFhO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHNIQUFrQztBQUNoRSw0QkFBNEIsbUJBQU8sQ0FBQyxrSUFBd0M7QUFDNUUsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsc0hBQWtDO0FBQ2pFLFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyxrSEFBZ0M7QUFDMUUscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxzS0FBMEQ7QUFDckcsdUJBQXVCLG1CQUFPLENBQUMsd0dBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsR0FBRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdUJBQXVCLFNBQVM7QUFDM0Y7QUFDQSxvRUFBb0UsTUFBTTtBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLENBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyB2NDogdXVpZHY0IH0gPSByZXF1aXJlKCd1dWlkJyk7XG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IFF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IFF1ZXJ5U3RhdHVzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL3F1ZXJ5X3N0YXR1cycpO1xuY29uc3QgTG9nZ2luZ1V0aWwgPSByZXF1aXJlKCcuLi9sb2dnZXIvbG9nZ2luZ191dGlsJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU3RhdGVtZW50ID0gcmVxdWlyZSgnLi9zdGF0ZW1lbnQnKTtcbmNvbnN0IFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuLi9wYXJhbWV0ZXJzJyk7XG5jb25zdCBBdXRoZW50aWNhdG9yID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24nKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbl90eXBlcycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCB7IGlzT2t0YUF1dGggfSA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uJyk7XG5jb25zdCB7IGluaXQ6IGluaXRFYXN5TG9nZ2luZyB9ID0gcmVxdWlyZSgnLi4vbG9nZ2VyL2Vhc3lfbG9nZ2luZ19zdGFydGVyJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCB7IEpzb25DcmVkZW50aWFsTWFuYWdlciwgfSA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL3NlY3VyZV9zdG9yYWdlL2pzb25fY3JlZGVudGlhbF9tYW5hZ2VyJyk7XG5jb25zdCBFeGVjdXRpb25UaW1lciA9IHJlcXVpcmUoJy4uL2xvZ2dlci9leGVjdXRpb25fdGltZXInKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDb25uZWN0aW9uIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbkNvbnRleHR9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBDb25uZWN0aW9uKGNvbnRleHQpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uIG9iamVjdCBpcyBiZWluZyBjb25zdHJ1Y3RlZCcpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbnRleHQpKTtcbiAgICBjb25zdCBzZXJ2aWNlcyA9IGNvbnRleHQuZ2V0U2VydmljZXMoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gY29udGV4dC5nZXRDb25uZWN0aW9uQ29uZmlnKCk7XG4gICAgLy8gZ2VuZXJhdGUgYW4gaWQgZm9yIHRoZSBjb25uZWN0aW9uXG4gICAgY29uc3QgaWQgPSB1dWlkdjQoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnR2VuZXJhdGVkIGNvbm5lY3Rpb24gaWQ6ICVzJywgaWQpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0NyZWF0aW5nIENvbm5lY3Rpb25baWQ6ICVzXSB3aXRoICVzLCBwYXNzd29yZCBpcyAlcywgcmVnaW9uOiAlcywgJyArXG4gICAgICAgICdhdXRoZW50aWNhdG9yOiAlcywgb2NzcCBtb2RlOiAlcywgb3M6ICVzLCBvcyB2ZXJzaW9uOiAlcycsIGlkLCBjb25uZWN0aW9uQ29uZmlnLmRlc2NyaWJlSWRlbnRpdHlBdHRyaWJ1dGVzKCksIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5wYXNzd29yZCksIGNvbm5lY3Rpb25Db25maWcucmVnaW9uLCBjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpLk9DU1BfTU9ERSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpLk9TLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEVudmlyb25tZW50KCkuT1NfVkVSU0lPTik7XG4gICAgLy8gTG9nIHdhcyBzcGxpdCBkdWUgdG8gcG9zc2liaWxpdHkgb2YgZXhjZWVkaW5nIHRoZSBtYXggbWVzc2FnZSBsZW5ndGggb2YgdGhlIGxvZ2dlclxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSBhZGRpdGlvbmFsIGRldGFpbHM6ICcgK1xuICAgICAgICAncGFzc2NvZGUgaW4gcGFzc3dvcmQgaXMgJXMsIHBhc3Njb2RlIGlzICVzLCBwcml2YXRlIGtleSBpcyAlcywgJyArXG4gICAgICAgICdhcHBsaWNhdGlvbjogJXMsIGNsaWVudCBuYW1lOiAlcywgY2xpZW50IHZlcnNpb246ICVzLCByZXRyeSB0aW1lb3V0OiAlcywgJyArXG4gICAgICAgICdwcml2YXRlIGtleSBwYXRoOiAlcywgcHJpdmF0ZSBrZXkgcGFzcyBpcyAlcywgJyArXG4gICAgICAgICdjbGllbnQgc3RvcmUgdGVtcG9yYXJ5IGNyZWRlbnRpYWw6ICVzLCBicm93c2VyIHJlc3BvbnNlIHRpbWVvdXQ6ICVzJywgaWQsIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5nZXRQYXNzY29kZUluUGFzc3dvcmQoKSksIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5nZXRQYXNzY29kZSgpKSwgTG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXkoKSksIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50QXBwbGljYXRpb24oKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnROYW1lKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VmVyc2lvbigpLCBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5VGltZW91dCgpLCBjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXlQYXRoKCksIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5UGFzcygpKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRCcm93c2VyQWN0aW9uVGltZW91dCgpKTtcbiAgICAvLyBhc3luYyBtYXggcmV0cnkgYW5kIHJldHJ5IHBhdHRlcm4gZnJvbSBweXRob24gY29ubmVjdG9yXG4gICAgY29uc3QgYXN5bmNOb0RhdGFNYXhSZXRyeSA9IDI0O1xuICAgIGNvbnN0IGFzeW5jUmV0cnlQYXR0ZXJuID0gWzEsIDEsIDIsIDMsIDQsIDgsIDEwXTtcbiAgICBjb25zdCBhc3luY1JldHJ5SW5NaWxsaXNlY29uZHMgPSA1MDA7XG4gICAgLy8gQ3VzdG9tIHJlZ2V4IGJhc2VkIG9uIHV1aWQgdmFsaWRhdGVcbiAgICAvLyBVbmFibGUgdG8gZGlyZWN0bHkgdXNlIHV1aWQgdmFsaWRhdGUgYmVjYXVzZSB0aGUgcXVlcnlJZCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgZG9lc24ndCBtYXRjaCB0aGUgcmVnZXhcbiAgICBjb25zdCBxdWVyeUlkUmVnZXggPSBuZXcgUmVnRXhwKC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2kpO1xuICAgIC8vTWFrZSBzZXNzaW9uIHRva2VucyBhdmFpbGFibGUgZm9yIHRlc3RpbmdcbiAgICB0aGlzLmdldFRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuX3FhTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VzLnNmLmdldENvbmZpZygpICYmIHNlcnZpY2VzLnNmLmdldENvbmZpZygpLnRva2VuSW5mbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gaXMgYWN0aXZlIG90aGVyd2lzZSBmYWxzZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBpc1VwID0gc2VydmljZXMuc2YuaXNDb25uZWN0ZWQoKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGlzVXAgY2FsbGVkLiBSZXR1cm5pbmc6ICVzJywgdGhpcy5nZXRJZCgpLCBpc1VwKTtcbiAgICAgICAgcmV0dXJuIGlzVXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNlc3Npb24gdG9rZW4gYW5kIG1hc3RlciB0b2tlbiBhcmUgdmFsaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNUb2tlblZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNUb2tlblZhbGlkIGNhbGxlZCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIGNvbnN0IHRva2VuSW5mbyA9IHNlcnZpY2VzLnNmLmdldENvbmZpZygpLnRva2VuSW5mbztcbiAgICAgICAgY29uc3Qgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPSB0b2tlbkluZm8uc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGNvbnN0IGlzU2Vzc2lvblZhbGlkID0gc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPiBEYXRlLm5vdygpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNTZXNzaW9uVG9rZW5WYWxpZDogJXMnLCB0aGlzLmdldElkKCksIGlzU2Vzc2lvblZhbGlkKTtcbiAgICAgICAgY29uc3QgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IHRva2VuSW5mby5tYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lO1xuICAgICAgICBjb25zdCBpc01hc3RlclZhbGlkID0gbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA+IERhdGUubm93KCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpc01hc3RlclRva2VuVmFsaWQ6ICVzJywgdGhpcy5nZXRJZCgpLCBpc01hc3RlclZhbGlkKTtcbiAgICAgICAgY29uc3QgYXJlVG9rZW5zVmFsaWQgPSBpc1Nlc3Npb25WYWxpZCAmJiBpc01hc3RlclZhbGlkO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNUb2tlblZhbGlkIHJldHVybmVkOiAlcycsIHRoaXMuZ2V0SWQoKSwgYXJlVG9rZW5zVmFsaWQpO1xuICAgICAgICByZXR1cm4gYXJlVG9rZW5zVmFsaWQ7XG4gICAgfTtcbiAgICB0aGlzLmdldFNlcnZpY2VOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0U2VydmljZU5hbWUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzLnNmLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzLnNmLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3koKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzLnNmLmdldEpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbm5lY3Rpb24gaWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIHRoaXMuaGVhcnRiZWF0ID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdJc3N1aW5nIGhlYXJ0YmVhdCBjYWxsJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWR2NCgpO1xuICAgICAgICBzZXJ2aWNlcy5zZi5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsOiBVcmwuZm9ybWF0KHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogJy9zZXNzaW9uL2hlYXJ0YmVhdCcsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2FsbGJhY2s6IFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICA/IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdFcnJvciBpc3N1aW5nIGhlYXJ0YmVhdCBjYWxsOiAlcycsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdIZWFydGJlYXQgcmVzcG9uc2UgJXMnLCBKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGVhcnRiZWF0QXN5bmMgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBwcmV2aW91cyB2ZXJzaW9uIG9mIGRyaXZlciBjYWxsZWQgYHNlbGVjdCAxO2Agd2hpY2ggcmVzdWx0IGluIGBbIHsgJzEnOiAxIH0gXWBcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdJc3N1aW5nIGFzeW5jIGhlYXJ0YmVhdCBjYWxsJyk7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdCgoZXJyKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKFt7IDE6IDEgfV0pKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLmlzVmFsaWRBc3luYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGlzVmFsaWRBc3luYyBjYWxsZWQnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICBpZiAoIXRoaXMuaXNVcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGVhcnRiZWF0QXN5bmMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gaGVhcnRiZWF0IGZhaWxlZDogJXMnLCB0aGlzLmdldElkKCksIEpTT04uc3RyaW5naWZ5KGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJpdmF0ZSBsaW5rIGFzIHRoZSBPQ1NQIGNhY2hlIHNlcnZlcidzIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnNldHVwT2NzcFByaXZhdGVMaW5rID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfVVJMID0gVXRpbC5jcmVhdGVPY3NwUmVzcG9uc2VDYWNoZVNlcnZlclVybChob3N0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGNvbm5lY3QoKSAtIHVzZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxmXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25uZWN0Q2FsbGJhY2soc2VsZiwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBTRUNPTkRTX1RPX01JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBLRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1lfSU5fTVMgPSBQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZKSAqXG4gICAgICAgICAgICAgICAgICAgIFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XG4gICAgICAgICAgICAgICAgc2VsZi5rZWVwYWxpdmUgPSBzZXRJbnRlcnZhbChzZWxmLmhlYXJ0YmVhdCwgS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZX0lOX01TLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0ga2VlcEFsaXZlIGludGVybmFsIGNyZWF0ZWQnLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9ycy5leHRlcm5hbGl6ZShlcnIpLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5kZXRlcm1pbmVDb25uZWN0aW9uRG9tYWluID0gKCkgPT4gY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwgJiYgY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwuaW5jbHVkZXMoJ3Nub3dmbGFrZWNvbXB1dGluZy5jbicpXG4gICAgICAgID8gJ0NISU5BJ1xuICAgICAgICA6ICdHTE9CQUwnO1xuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiBpZiB3ZSBhcmVuJ3QgaW4gYSBmYXRhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgY29ubmVjdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IEV4ZWN1dGlvblRpbWVyKCkuc3RhcnQoKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbkRvbWFpbiA9IHRoaXMuZGV0ZXJtaW5lQ29ubmVjdGlvbkRvbWFpbigpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0aW5nLiBBc3NvY2lhdGVkIFNub3dmbGFrZSBkb21haW46ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW9uRG9tYWluKTtcbiAgICAgICAgLy8gaW52YWxpZCBjYWxsYmFja1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKCFVdGlsLmV4aXN0cyhjYWxsYmFjaykgfHwgVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0FMTEJBQ0spO1xuICAgICAgICBpZiAoVXRpbC5leGlzdHMoY29ubmVjdGlvbkNvbmZpZy5ob3N0KSAmJiBVdGlsLmlzUHJpdmF0ZUxpbmsoY29ubmVjdGlvbkNvbmZpZy5ob3N0KSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gc2V0dGluZyB1cCBwcml2YXRlIGxpbmsnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgdGhpcy5zZXR1cE9jc3BQcml2YXRlTGluayhjb25uZWN0aW9uQ29uZmlnLmhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIHNub3dmbGFrZSBzZXJ2aWNlIGFuZCBwcm92aWRlIG91ciBvd24gY2FsbGJhY2sgc28gdGhhdFxuICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiBjYW4gYmUgcGFzc2VkIGluIHdoZW4gaW52b2tpbmcgdGhlIGNvbm5lY3Rpb24uY29ubmVjdCgpXG4gICAgICAgIC8vIGNhbGxiYWNrXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBhdXRoZW50aWNhdGlvblR5cGUgPSBjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHVzaW5nIGF1dGhlbnRpY2F0aW9uIHR5cGU6ICVzJywgdGhpcy5nZXRJZCgpLCBhdXRoZW50aWNhdGlvblR5cGUpO1xuICAgICAgICAvLyBjaGVjayBpZiBhdXRoZW50aWNhdGlvbiB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCBjb25uZWN0KClcbiAgICAgICAgLy8gZXh0ZXJuYWwgYnJvd3NlciBhbmQgb2t0YSBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCBjb25uZWN0KCkgZHVlIHRvIHRoZWlyIHVzYWdlIG9mIGFzeW5jIGZ1bmN0aW9uc1xuICAgICAgICBpZiAoYXV0aGVudGljYXRpb25UeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLkVYVEVSTkFMX0JST1dTRVJfQVVUSEVOVElDQVRPUiB8fFxuICAgICAgICAgICAgaXNPa3RhQXV0aChhdXRoZW50aWNhdGlvblR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcgZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nICtcbiAgICAgICAgICAgICAgICAnRXJyb3I6IEV4dGVybmFsIGJyb3dzZXIgYW5kIE9rdGEgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggY29ubmVjdGlvbiBwcm9jZXNzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24pO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVVUSF9DT05ORUNUKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYXV0aGVudGljYXRvciB0byB1c2VcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJldHJpZXZpbmcgYXV0aGVudGljYXRvcicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIGNvbnN0IGF1dGggPSBzZXJ2aWNlcy5zZi5nZXRBdXRoZW50aWNhdG9yKCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB0cnlpbmcgdG8gYXV0aGVudGljYXRlJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgYXV0aFxuICAgICAgICAgICAgLmF1dGhlbnRpY2F0ZShjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRTZXJ2aWNlTmFtZSgpLCBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBhdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsIHVzaW5nOiAlcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCkpO1xuICAgICAgICAgICAgLy8gSlNPTiBmb3IgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3QgYm9keSA9IEF1dGhlbnRpY2F0b3IuZm9ybUF1dGhKU09OKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLCBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFZlcnNpb24oKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gdmFsdWVzXG4gICAgICAgICAgICBhdXRoLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gaW5pdGlhbGl6aW5nIGVhc3lMb2dnaW5nJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGluaXRFYXN5TG9nZ2luZyhjb25uZWN0aW9uQ29uZmlnLmNsaWVudENvbmZpZ0ZpbGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBlYXN5TG9nZ2luZyBpbml0aWFsaXplZCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcgdGhyb3VnaCBzZXJ2aWNlJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZXMuc2YuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY29ubmVjdENhbGxiYWNrKHNlbGYsIGNhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5IGFmdGVyICVzIG1pbGxpc2Vjb25kcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGV4cGVjdCBhbiBlcnJvciBoZXJlIHNpbmNlIGNhbGxiYWNrIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBjb25uZWN0IGFmdGVyICVzIG1pbGxpc2Vjb25kcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRXJyb3I6IFVuZXhwZWN0ZWQgZXJyb3IgZnJvbSBjYWxsaW5nIGNvbm5lY3RDYWxsYmFjayBmdW5jdGlvbiBpbiBzbm93Zmxha2Ugc2VydmljZSAtICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgdG8gaW5pdGlhbGl6ZSBlYXN5TG9nZ2luZy4gJyArXG4gICAgICAgICAgICAgICAgICAgICdDb25uZWN0aW5nIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NMSUVOVF9DT05GSUcsIHRydWUpLCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGF1dGhlbnRpY2F0aW9uIGZhaWxlZC4gRXJyb3I6ICVzLiAnICtcbiAgICAgICAgICAgICAgICAnQ29ubmVjdGluZyBmYWlsZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzJywgdGhpcy5nZXRJZCgpLCBlcnIsIGNvbm5lY3RpbmdEdXJhdGlvbik7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNlbGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gaWYgd2UgYXJlbid0IGluIGEgZmF0YWwgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIGNvbm5lY3Rpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuY29ubmVjdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IEV4ZWN1dGlvblRpbWVyKCkuc3RhcnQoKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGluZ0RvbWFpbiA9IHRoaXMuZGV0ZXJtaW5lQ29ubmVjdGlvbkRvbWFpbigpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBhc3luYyBjb25uZWN0aW5nLiBBc3NvY2lhdGVkIFNub3dmbGFrZSBkb21haW46ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRG9tYWluKTtcbiAgICAgICAgLy8gaW52YWxpZCBjYWxsYmFja1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKCFVdGlsLmV4aXN0cyhjYWxsYmFjaykgfHwgVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0FMTEJBQ0spO1xuICAgICAgICBpZiAoVXRpbC5pc1ByaXZhdGVMaW5rKGNvbm5lY3Rpb25Db25maWcuaG9zdCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBPY3NwUHJpdmF0ZUxpbmsoY29ubmVjdGlvbkNvbmZpZy5ob3N0KTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHNldHRpbmcgdXAgcHJpdmF0ZSBsaW5rJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBzbm93Zmxha2Ugc2VydmljZSBhbmQgcHJvdmlkZSBvdXIgb3duIGNhbGxiYWNrIHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIGNvbm5lY3Rpb24gY2FuIGJlIHBhc3NlZCBpbiB3aGVuIGludm9raW5nIHRoZSBjb25uZWN0aW9uLmNvbm5lY3QoKVxuICAgICAgICAvLyBjYWxsYmFja1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBzdG9yaW5nIHRlbXBvcmFyeSBjcmVkZW50aWFsIG9mIGNsaWVudCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBVdGlsLmJ1aWxkQ3JlZGVudGlhbENhY2hlS2V5KGNvbm5lY3Rpb25Db25maWcuaG9zdCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgQXV0aGVudGljYXRpb25UeXBlcy5JRF9UT0tFTl9BVVRIRU5USUNBVE9SKTtcbiAgICAgICAgICAgIGlmIChHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB1c2luZyBkZWZhdWx0IGpzb24gY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxDb25maWcuc2V0Q3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIobmV3IEpzb25DcmVkZW50aWFsTWFuYWdlcihjb25uZWN0aW9uQ29uZmlnLmdldENyZWRlbnRpYWxDYWNoZURpcigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcmVhZGluZyBpZFRva2VuIHVzaW5nIGNyZWRlbnRpYWwgbWFuYWdlcicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmlkVG9rZW4gPSBhd2FpdCBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS5yZWFkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50UmVxdWVzdE1GQVRva2VuKCkpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBleHRyYWN0aW5nIG1mYVRva2VuIG9mIGNsaWVudCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBVdGlsLmJ1aWxkQ3JlZGVudGlhbENhY2hlS2V5KGNvbm5lY3Rpb25Db25maWcuaG9zdCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgQXV0aGVudGljYXRpb25UeXBlcy5VU0VSX1BXRF9NRkFfQVVUSEVOVElDQVRPUik7XG4gICAgICAgICAgICBpZiAoR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gdXNpbmcgZGVmYXVsdCBqc29uIGNyZWRlbnRpYWwgbWFuYWdlcicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKG5ldyBKc29uQ3JlZGVudGlhbE1hbmFnZXIoY29ubmVjdGlvbkNvbmZpZy5nZXRDcmVkZW50aWFsQ2FjaGVEaXIoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJlYWRpbmcgbWZhVG9rZW4gdXNpbmcgY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcubWZhVG9rZW4gPSBhd2FpdCBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS5yZWFkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGF1dGhlbnRpY2F0b3IgdG8gdXNlXG4gICAgICAgIGxldCBhdXRoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJldHJpZXZpbmcgYXV0aGVudGljYXRvcicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBhdXRoID0gQXV0aGVudGljYXRvci5nZXRBdXRoZW50aWNhdG9yKGNvbm5lY3Rpb25Db25maWcsIGNvbnRleHQuZ2V0SHR0cENsaWVudCgpKTtcbiAgICAgICAgICAgIHNlcnZpY2VzLnNmLmF1dGhlbnRpY2F0b3IgPSBhdXRoO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgdG8gaW5pdGlhbGl6ZSBhdXRoZW50aWNhdG9yLiAnICtcbiAgICAgICAgICAgICAgICAnQ29ubmVjdGluZyBmYWlsZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24pO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVVUSF9VTlNVUFBPUlRFRCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpbml0aWFsaXppbmcgZWFzeUxvZ2dpbmcnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgYXdhaXQgaW5pdEVhc3lMb2dnaW5nKGNvbm5lY3Rpb25Db25maWcuY2xpZW50Q29uZmlnRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgdG8gaW5pdGlhbGl6ZSBlYXN5TG9nZ2luZy4gJyArXG4gICAgICAgICAgICAgICAgJ0Nvbm5lY3RpbmcgZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uKTtcbiAgICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DTElFTlRfQ09ORklHLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gdXNpbmcgYXV0aGVudGljYXRpb24gdHlwZTogJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB0cnlpbmcgdG8gYXV0aGVudGljYXRlJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGF3YWl0IGF1dGguYXV0aGVudGljYXRlKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLCBjb25uZWN0aW9uQ29uZmlnLmdldFNlcnZpY2VOYW1lKCksIGNvbm5lY3Rpb25Db25maWcuYWNjb3VudCwgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBhdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsIHVzaW5nOiAlcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCkpO1xuICAgICAgICAgICAgLy8gSlNPTiBmb3IgY29ubmVjdGlvblxuICAgICAgICAgICAgYm9keSA9IEF1dGhlbnRpY2F0b3IuZm9ybUF1dGhKU09OKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLCBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLCBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFZlcnNpb24oKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gdmFsdWVzXG4gICAgICAgICAgICBhdXRoLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGF1dGhFcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgdG8gY29ubmVjdCBhc3luYyBhZnRlciAlcyBtaWxsaXNlY29uZHMuJyArXG4gICAgICAgICAgICAgICAgJ0ZhaWxlZCBkdXJpbmcgYXV0aGVudGljYXRpb24uIEVycm9yOiAlcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uLCBhdXRoRXJyKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgZHVyaW5nIGF1dGhlbnRpY2F0aW9uLiBFcnJvcjogJXMnLCB0aGlzLmdldElkKCksIGF1dGhFcnIpO1xuICAgICAgICAgICAgY2FsbGJhY2soYXV0aEVycik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb25uZWN0aW9uXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGluZyB0aHJvdWdoIHNlcnZpY2UnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgc2VydmljZXMuc2YuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNvbm5lY3RDYWxsYmFjayhzZWxmLCBjYWxsYmFjayksXG4gICAgICAgICAgICAgICAganNvbjogYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBjb25uZWN0aW9uIHRvIGZhY2lsaXRhdGUgY2hhaW5pbmdcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5IGFmdGVyICVzIG1pbGxpc2Vjb25kcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2FsbGJhY2tFcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgdG8gY29ubmVjdCBhc3luYyBhZnRlciAlcyBtaWxsaXNlY29uZHMuJyArXG4gICAgICAgICAgICAgICAgJ0Vycm9yOiBVbmV4cGVjdGVkIGVycm9yIGZyb20gY2FsbGluZyBjb25uZWN0Q2FsbGJhY2sgZnVuY3Rpb24gaW4gc25vd2ZsYWtlIHNlcnZpY2UgLSAlcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uLCBjYWxsYmFja0Vycik7XG4gICAgICAgICAgICBjYWxsYmFjayhjYWxsYmFja0Vycik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGV4ZWN1dGUgY2FsbGVkIHdpdGggb3B0aW9ucy4nLCB0aGlzLmdldElkKCkpO1xuICAgICAgICByZXR1cm4gU3RhdGVtZW50LmNyZWF0ZVN0YXRlbWVudFByZUV4ZWMob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcmVzdWx0IG9mIGEgcHJldmlvdXNseSBpc3N1ZWQgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5mZXRjaFJlc3VsdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmZXRjaFJlc3VsdCBjYWxsZWQgd2l0aCBvcHRpb25zJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgcmV0dXJuIFN0YXRlbWVudC5jcmVhdGVTdGF0ZW1lbnRQb3N0RXhlYyhvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSB0ZXJtaW5hdGVzIHRoZSBjb25uZWN0aW9uIHdpdGhvdXQgd2FpdGluZyBmb3IgY3VycmVudGx5XG4gICAgICogZXhlY3V0aW5nIHN0YXRlbWVudHMgdG8gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIGNvbm5lY3Rpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAvLyBpbnZhbGlkIGNhbGxiYWNrXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBkZXN0cm95IGNhbGxlZCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoIVV0aWwuZXhpc3RzKGNhbGxiYWNrKSB8fCBVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spLCBFcnJvckNvZGVzLkVSUl9DT05OX0RFU1RST1lfSU5WQUxJRF9DQUxMQkFDSyk7XG4gICAgICAgIC8vIGxvZyBvdXQgb2YgdGhlIHNub3dmbGFrZSBzZXJ2aWNlIGFuZCBwcm92aWRlIG91ciBvd24gY2FsbGJhY2sgc28gdGhhdFxuICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiBjYW4gYmUgcGFzc2VkIGluIHdoZW4gaW52b2tpbmcgdGhlIGNvbm5lY3Rpb24uZGVzdHJveSgpXG4gICAgICAgIC8vIGNhbGxiYWNrXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBkZXN0cm95aW5nIHRocm91Z2ggc2VydmljZScsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBzZXJ2aWNlcy5zZi5kZXN0cm95KHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHNlbGYua2VlcGFsaXZlKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHNlbGYua2VlcGFsaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGtlZXBBbGl2ZSBpbnRlcnZhbCBjbGVhcmVkJywgc2VsZi5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3JzLmV4dGVybmFsaXplKGVyciksIHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGlvbiBkZXN0cm95ZWQgc3VjY2Vzc2Z1bGx5JywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjb25uZWN0aW9uIHRvIGZhY2lsaXRhdGUgY2hhaW5pbmdcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGJhc2VkIG9uIHF1ZXJ5SWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlJZFxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHF1ZXJ5IHJlc3BvbnNlXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0UXVlcnlSZXNwb25zZShxdWVyeUlkKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSByZXF1ZXN0ZWQgcXVlcnkgcmVzcG9uc2UgZm9yIFF1ZXJ5W2lkOiAlc10nLCBpZCwgcXVlcnlJZCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHF1ZXJ5SWQgZXhpc3RzIGFuZCBpcyB2YWxpZCB1dWlkXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHF1ZXJ5SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX1FVRVJZX0lEKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChxdWVyeUlkUmVnZXgudGVzdChxdWVyeUlkKSwgRXJyb3JDb2Rlcy5FUlJfR0VUX1JFU1BPTlNFX1FVRVJZX0lOVkFMSURfVVVJRCwgcXVlcnlJZCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBRdWVyeVtpZDogJXNdIGlzIHZhbGlkJywgaWQsIHF1ZXJ5SWQpO1xuICAgICAgICAvLyBGb3JtIHRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB1cmw6IFVybC5mb3JtYXQoe1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBgL21vbml0b3JpbmcvcXVlcmllcy8ke3F1ZXJ5SWR9YCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gZmV0Y2hpbmcgcXVlcnkgcmVzcG9uc2UgZm9yIFF1ZXJ5W2lkOiAlc10nLCBpZCwgcXVlcnlJZCk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IEV4ZWN1dGlvblRpbWVyKCkuc3RhcnQoKTtcbiAgICAgICAgLy8gR2V0IHRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBxdWVyeSBzdGF0dXNcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXJ2aWNlcy5zZi5yZXF1ZXN0QXN5bmMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZldGNoaW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcXVlcnkgcmVzcG9uc2UgZm9yIFF1ZXJ5W2lkOiAlc10gZmV0Y2hlZCBzdWNjZXNzZnVsbHkgYWZ0ZXI6ICVzIG1pbGxpc2Vjb25kcycsIGlkLCBxdWVyeUlkLCBmZXRjaGluZ0R1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydkYXRhJ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGZyb20gdGhlIHF1ZXJ5IHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5UmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBxdWVyeSBzdGF0dXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5U3RhdHVzKHF1ZXJ5UmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmNvZGUuTk9fUVVFUllfREFUQTsgLy8gZGVmYXVsdCBzdGF0dXNcbiAgICAgICAgaWYgKCFxdWVyeVJlc3BvbnNlIHx8ICFxdWVyeVJlc3BvbnNlWydkYXRhJ10gfHwgIXF1ZXJ5UmVzcG9uc2VbJ2RhdGEnXVsncXVlcmllcyddKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gTm8gcXVlcnkgZGF0YSBmb3VuZCwgcmV0dXJuaW5nIE5PX1FVRVJZX0RBVEEgc3RhdHVzJywgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVzID0gcXVlcnlSZXNwb25zZVsnZGF0YSddWydxdWVyaWVzJ107XG4gICAgICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IHF1ZXJpZXNbMF1bJ3N0YXR1cyddO1xuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBFeHRyYWN0ZWQgcXVlcnkgc3RhdHVzOiAlcycsIGlkLCBzdGF0dXMpO1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGJhc2VkIG9uIHF1ZXJ5SWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlJZFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHF1ZXJ5IHN0YXR1cy5cbiAgICAgKi9cbiAgICB0aGlzLmdldFF1ZXJ5U3RhdHVzID0gYXN5bmMgZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGdldFF1ZXJ5U3RhdHVzIGNhbGxlZCBmb3IgUXVlcnlbaWQ6ICVzXScsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCk7XG4gICAgICAgIHJldHVybiBleHRyYWN0UXVlcnlTdGF0dXMoYXdhaXQgZ2V0UXVlcnlSZXNwb25zZShxdWVyeUlkKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGJhc2VkIG9uIHF1ZXJ5SWQgYW5kIHRocm93cyBpZiB0aGVyZSdzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5SWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBxdWVyeSBzdGF0dXMuXG4gICAgICovXG4gICAgdGhpcy5nZXRRdWVyeVN0YXR1c1Rocm93SWZFcnJvciA9IGFzeW5jIGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBnZXRRdWVyeVN0YXR1c1Rocm93SWZFcnJvciBjYWxsZWQgZm9yIFF1ZXJ5W2lkOiAlc10nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFF1ZXJ5UmVzcG9uc2UocXVlcnlJZCk7IC8vIHJldHVybnMgcmVzcG9uc2VbJ2RhdGEnXVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBleHRyYWN0UXVlcnlTdGF0dXMocmVzcG9uc2UpO1xuICAgICAgICBsZXQgc3FsU3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc0FuRXJyb3Ioc3RhdHVzKSkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSByZXNwb25zZVsnbWVzc2FnZSddIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHJlc3BvbnNlWydjb2RlJ10gfHwgLTE7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2RhdGEnXSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VbJ2RhdGEnXVsncXVlcmllcyddLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2VbJ2RhdGEnXVsncXVlcmllcyddWzBdWydlcnJvck1lc3NhZ2UnXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICBzcWxTdGF0ZSA9IHJlc3BvbnNlWydkYXRhJ11bJ3NxbFN0YXRlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcXVlcnkgZXJyb3IgZm9yIFF1ZXJ5W2lkOiAlc10uIEVycm9yOiAlcy4gU1FMU3RhdGU6ICVzJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBtZXNzYWdlLCBzcWxTdGF0ZSk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlT3BlcmF0aW9uRmFpbGVkRXJyb3IoY29kZSwgcmVzcG9uc2UsIG1lc3NhZ2UsIHNxbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmVzdWx0cyBmcm9tIGEgcHJldmlvdXNseSByYW4gcXVlcnkgYmFzZWQgb24gcXVlcnlJZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRSZXN1bHRzRnJvbVF1ZXJ5SWQgPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBxdWVyeUlkID0gb3B0aW9ucy5xdWVyeUlkO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZ2V0UmVzdWx0c0Zyb21RdWVyeUlkIGNhbGxlZCBmb3IgUXVlcnlbaWQ6ICVzXS4nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQpO1xuICAgICAgICBsZXQgc3RhdHVzLCBub0RhdGFDb3VudGVyID0gMCwgcmV0cnlQYXR0ZXJuUG9zID0gMDtcbiAgICAgICAgLy8gV2FpdCB1bnRpbCBxdWVyeSBoYXMgZmluaXNoZWQgZXhlY3V0aW5nXG4gICAgICAgIGxldCBxdWVyeVN0aWxsRXhlY3V0aW5nID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKHF1ZXJ5U3RpbGxFeGVjdXRpbmcpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjaGVja2luZyBpZiBRdWVyeVtpZDogJXNdIGlzIHN0aWxsIGV4ZWN1dGluZy4gUmV0cmllcyB3aXRoIG5vIGRhdGEgY291bnQ6ICVkJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBub0RhdGFDb3VudGVyKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHF1ZXJ5IGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGV4Y2VwdGlvbiBpZiBpdCBmYWlsZWQgb3IgdGhlcmUgaXMgbm8gcXVlcnkgZGF0YSBpbiB0aGUgc2VydmVyLlxuICAgICAgICAgICAgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRRdWVyeVN0YXR1c1Rocm93SWZFcnJvcihxdWVyeUlkKTtcbiAgICAgICAgICAgIHF1ZXJ5U3RpbGxFeGVjdXRpbmcgPSB0aGlzLmlzU3RpbGxSdW5uaW5nKHN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5U3RpbGxFeGVjdXRpbmcgfHwgc3RhdHVzID09PSBRdWVyeVN0YXR1cy5jb2RlLk5PX1FVRVJZX0RBVEEpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZW5kIG9mIHdhaXRpbmcgZm9yIFF1ZXJ5W2lkOiAlc10gdG8gZmluaXNoIGV4ZWN1dGluZy4gJyArXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RpbGxFeGVjdXRpbmdcbiAgICAgICAgICAgICAgICAgICAgPyAnUXVlcnkgaXMgbm8gbG9uZ2VyIGV4ZWN1dGluZy4gJ1xuICAgICAgICAgICAgICAgICAgICA6ICcnICsgJ1F1ZXJ5IHN0YXR1czogJXMuJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGltZW91dCBiYXNlZCBvbiBxdWVyeSBzdGF0dXMgcmV0cnkgcnVsZXNcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIGFzeW5jUmV0cnlJbk1pbGxpc2Vjb25kcyAqIGFzeW5jUmV0cnlQYXR0ZXJuW3JldHJ5UGF0dGVyblBvc10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiBubyBkYXRhLCBpbmNyZW1lbnQgdGhlIG5vIGRhdGEgY291bnRlclxuICAgICAgICAgICAgaWYgKFF1ZXJ5U3RhdHVzLmNvZGVbc3RhdHVzXSA9PT0gUXVlcnlTdGF0dXMuY29kZS5OT19EQVRBKSB7XG4gICAgICAgICAgICAgICAgbm9EYXRhQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBubyBkYXRhIHJldHVybmVkIGZvciBRdWVyeVtpZDogJXNdLiBSZXRyaWVzIHdpdGggbm8gZGF0YSBjb3VudDogJWQnLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIG5vRGF0YUNvdW50ZXIpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHJldHJ5IGZvciBubyBkYXRhIGlzIGV4Y2VlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG5vRGF0YUNvdW50ZXIgPiBhc3luY05vRGF0YU1heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBubyBkYXRhIHJldHVybmVkIGZvciBRdWVyeVtpZDogJXNdLiBSZXRyeSBsaW1pdDogJXMgcmVhY2hlZC4nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIGFzeW5jTm9EYXRhTWF4UmV0cnkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfR0VUX1JFU1VMVFNfUVVFUllfSURfTk9fREFUQSwgdHJ1ZSwgcXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHJ5UGF0dGVyblBvcyA8IGFzeW5jUmV0cnlQYXR0ZXJuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXRyeVBhdHRlcm5Qb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoUXVlcnlTdGF0dXMuY29kZVtzdGF0dXNdID09PSBRdWVyeVN0YXR1cy5jb2RlLk5PX1FVRVJZX0RBVEEpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBRdWVyeVtpZDogJXNdIGRpZCBub3Qgc3VjY2VlZC4gRmluYWwgc3RhdHVzOiAlcycsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCwgc3RhdHVzKTtcbiAgICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT19EQVRBLCB0cnVlLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChRdWVyeVN0YXR1cy5jb2RlW3N0YXR1c10gIT09IFF1ZXJ5U3RhdHVzLmNvZGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFF1ZXJ5W2lkOiAlc10gZGlkIG5vdCBzdWNjZWVkLiBGaW5hbCBzdGF0dXM6ICVzJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PVF9TVUNDRVNTX1NUQVRVUywgdHJ1ZSwgcXVlcnlJZCwgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gUXVlcnlbaWQ6ICVzXSBzdWNjZWVkZWQuIEZldGNoaW5nIHRoZSByZXN1bHQuJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hSZXN1bHQob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gc3RhdHVzIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1N0aWxsUnVubmluZyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNoZWNraW5nIGlmIHN0YXR1cyAlcyBpcyBzdGlsbCBydW5uaW5nJywgdGhpcy5nZXRJZCgpLCBzdGF0dXMpO1xuICAgICAgICByZXR1cm4gUXVlcnlTdGF0dXMucnVubmluZ1N0YXR1c2VzLmluY2x1ZGVzKFF1ZXJ5U3RhdHVzLmNvZGVbc3RhdHVzXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gc3RhdHVzIG1lYW5zIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdHVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQW5FcnJvciA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIFF1ZXJ5U3RhdHVzLmVycm9yU3RhdHVzZXMuaW5jbHVkZXMoUXVlcnlTdGF0dXMuY29kZVtzdGF0dXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHNlcmlhbGl6ZSBjYWxsZWQnLCB0aGlzLmdldElkKCkpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udGV4dC5nZXRDb25maWcoKSk7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblV0aWwuaW5oZXJpdHMoQ29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ConnectionConstants = __webpack_require__(/*! ../constants/connection_constants */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst ErrorCodes = Errors.codes;\nconst NativeTypes = (__webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\").NativeTypes);\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst levenshtein = __webpack_require__(/*! fastest-levenshtein */ \"(rsc)/./node_modules/fastest-levenshtein/esm/mod.js\");\nconst RowMode = __webpack_require__(/*! ./../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\nconst DataTypes = __webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { isSnowflakeHost } = __webpack_require__(/*! ../authentication/authentication_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_util.js\");\nconst WAIT_FOR_BROWSER_ACTION_TIMEOUT = 120000;\nconst SNOWFLAKE_AUTHORIZE_ENDPOINT = '/oauth/authorize';\nconst SNOWFLAKE_TOKEN_REQUEST_ENDPOINT = '/oauth/token-request';\nconst LOCAL_APPLICATION_CLIENT_CREDENTIAL = 'LOCAL_APPLICATION';\nconst DEFAULT_PARAMS = [\n    'account',\n    'application',\n    'region',\n    'host',\n    'accessUrl',\n    'username',\n    'password',\n    'authenticator',\n    'proxyHost',\n    'proxyPort',\n    'serviceName',\n    'privateKey',\n    'privateKeyPath',\n    'privateKeyPass',\n    'token',\n    'warehouse',\n    'database',\n    'schema',\n    'role',\n    'rowMode',\n    'streamResult',\n    'fetchAsString',\n    'clientSessionKeepAlive',\n    'clientSessionKeepAliveHeartbeatFrequency',\n    'jsTreatIntegerAsBigInt',\n    'sessionToken',\n    'masterToken',\n    'sessionTokenExpirationTime',\n    'masterTokenExpirationTime',\n    'agentClass',\n    'validateDefaultParameters',\n    'arrayBindingThreshold',\n    'gcsUseDownscopedCredential',\n    'forceStageBindError',\n    'includeRetryReason',\n    'disableQueryContextCache',\n    'retryTimeout',\n    'clientRequestMFAToken',\n    'clientStoreTemporaryCredential',\n    'disableConsoleLogin',\n    'forceGCPUseDownscopedCredential',\n    'representNullAsStringNull',\n    'disableSamlURLCheck',\n    'credentialCacheDir',\n    'passcodeInPassword',\n    'passcode',\n    'oauthClientId',\n    'oauthClientSecret',\n    'oauthRedirectUri',\n    'oauthAuthorizationUrl',\n    'oauthTokenRequestUrl',\n    'oauthScope',\n    'oauthChallengeMethod',\n    'oauthHttpAllowed', //only for tests\n    'workloadIdentityProvider',\n    'workloadIdentityAzureEntraIdResource',\n    'queryTag',\n    'certRevocationCheckMode',\n    'crlAllowCertificatesWithoutCrlURL',\n    'crlInMemoryCache',\n    'crlOnDiskCache',\n];\nfunction consolidateHostAndAccount(options) {\n    let dotPos = -1;\n    let realAccount = undefined;\n    let realRegion = undefined;\n    const protocol = options.protocol || 'https';\n    const port = Util.exists(options.port) ? Util.format(':%s', options.port) : '';\n    if (Util.exists(options.region)) {\n        Errors.checkArgumentValid(Util.isCorrectSubdomain(options.region), ErrorCodes.ERR_CONN_CREATE_INVALID_REGION_REGEX);\n        realRegion = options.region;\n    }\n    if (Util.exists(options.account)) {\n        Errors.checkArgumentValid(Util.isString(options.account), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCOUNT);\n        Errors.checkArgumentValid(Util.isCorrectSubdomain(options.account), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX);\n        dotPos = options.account.indexOf('.');\n        realAccount = options.account;\n        if (dotPos > 0) {\n            realRegion = realAccount.substring(dotPos + 1);\n            realAccount = realAccount.substring(0, dotPos);\n        }\n    }\n    if (Util.exists(options.accessUrl)) {\n        //accessUrl is set in configuration\n        try {\n            const parsedUrl = url.parse(options.accessUrl);\n            Errors.checkArgumentValid(Util.exists(parsedUrl.hostname), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCESS_URL);\n            if (!Util.exists(options.host)) {\n                options.host = parsedUrl.hostname;\n            }\n            const dotPos = parsedUrl.hostname.indexOf('.');\n            if (dotPos > 0 && !Util.exists(options.account)) {\n                realAccount = parsedUrl.hostname.substring(0, dotPos);\n            }\n        }\n        catch (e) {\n            Errors.checkArgumentValid(false, ErrorCodes.ERR_CONN_CREATE_MISSING_ACCOUNT);\n        }\n    }\n    else if (Util.exists(options.host)) {\n        //host is set in configuration\n        options.accessUrl = Util.format('%s://%s%s', protocol, options.host, port);\n        const dotPos = options.host.indexOf('.');\n        if (dotPos > 0 && !Util.exists(options.account)) {\n            realAccount = options.host.substring(0, dotPos);\n        }\n        else {\n            realAccount = options.account;\n        }\n    }\n    else if (Util.exists(options.account)) {\n        //only account() is set in configuration\n        if (options.region === 'us-west-2') {\n            options.region = '';\n        }\n        options.host = Util.constructHostname(realRegion, realAccount);\n        options.accessUrl = Util.format('%s://%s%s', protocol, options.host, port);\n    }\n    if (Util.exists(realAccount) && options.accessUrl.includes('global.snowflakecomputing')) {\n        const dashPos = realAccount.indexOf('-');\n        if (dashPos > 0) {\n            // global URL\n            realAccount = realAccount.substring(0, dashPos);\n        }\n    }\n    options.account = realAccount;\n    options.region = realRegion;\n    // check for missing accessURL\n    Errors.checkArgumentExists(Util.exists(options.account), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCOUNT);\n    // check for missing account\n    Errors.checkArgumentExists(Util.exists(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCESS_URL);\n}\n/**\n * A Connection configuration object that should be available to all stateful\n * objects in the driver.\n *\n * @param {Object} options\n * @param {Boolean} [validateCredentials]\n * @param {Boolean} [qaMode]\n * @param {Object} [clientInfo]\n *\n * @constructor\n */\nfunction ConnectionConfig(options, validateCredentials, qaMode, clientInfo) {\n    // if no value is specified for the validate credentials flag, default to true\n    if (!Util.exists(validateCredentials)) {\n        validateCredentials = true;\n    }\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(options), ErrorCodes.ERR_CONN_CREATE_MISSING_OPTIONS);\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(options), ErrorCodes.ERR_CONN_CREATE_INVALID_OPTIONS);\n    // only validate credentials if necessary\n    if (validateCredentials) {\n        const noUsernameRequiredFor = [\n            AuthenticationTypes.OAUTH_AUTHENTICATOR,\n            AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR,\n            AuthenticationTypes.PROGRAMMATIC_ACCESS_TOKEN,\n            AuthenticationTypes.OAUTH_CLIENT_CREDENTIALS,\n            AuthenticationTypes.OAUTH_AUTHORIZATION_CODE,\n            AuthenticationTypes.WORKLOAD_IDENTITY,\n        ];\n        if (!options.authenticator ||\n            !noUsernameRequiredFor.includes(options.authenticator.toUpperCase())) {\n            // check for missing username\n            Errors.checkArgumentExists(Util.exists(options.username), ErrorCodes.ERR_CONN_CREATE_MISSING_USERNAME);\n        }\n        if (Util.exists(options.username)) {\n            // check for invalid username\n            Errors.checkArgumentValid(Util.isString(options.username), ErrorCodes.ERR_CONN_CREATE_INVALID_USERNAME);\n        }\n        // password is only required for default authenticator\n        if (!Util.exists(options.authenticator) ||\n            options.authenticator === AuthenticationTypes.DEFAULT_AUTHENTICATOR) {\n            // check for missing password\n            Errors.checkArgumentExists(Util.exists(options.password), ErrorCodes.ERR_CONN_CREATE_MISSING_PASSWORD);\n            // check for invalid password\n            Errors.checkArgumentValid(Util.isString(options.password), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSWORD);\n        }\n        if (!Util.exists(options.authenticator) ||\n            options.authenticator === AuthenticationTypes.PROGRAMMATIC_ACCESS_TOKEN) {\n            // PASSWORD or TOKEN is needed\n            Errors.checkArgumentExists(Util.exists(options.password) || Util.exists(options.token), ErrorCodes.ERR_CONN_CREATE_MISSING_PASSWORD);\n            if (Util.exists(options.password)) {\n                // check for invalid password\n                Errors.checkArgumentValid(Util.isString(options.password), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSWORD);\n            }\n            if (Util.exists(options.token)) {\n                Errors.checkArgumentValid(Util.isString(options.token), ErrorCodes.ERR_CONN_CREATE_INVALID_OAUTH_TOKEN);\n            }\n        }\n        if (options.authenticator === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE) {\n            if (Util.exists(options.oauthAuthorizationUrl)) {\n                let parsedUrl;\n                try {\n                    parsedUrl = new URL(options.oauthAuthorizationUrl);\n                }\n                catch (error) {\n                    throw Errors.createInvalidParameterError(ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL);\n                }\n                Errors.checkArgumentValid(parsedUrl.protocol === 'https:' || parsedUrl.protocol === 'http:', ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL);\n            }\n            if ((options.oauthAuthorizationUrl && !isSnowflakeHost(options.oauthAuthorizationUrl)) ||\n                (options.oauthTokenRequestUrl && !isSnowflakeHost(options.oauthTokenRequestUrl))) {\n                Errors.checkArgumentValid(Util.isString(options.oauthClientId), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID);\n                Errors.checkArgumentValid(Util.isString(options.oauthClientSecret), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET);\n            }\n        }\n        if (options.authenticator === AuthenticationTypes.OAUTH_CLIENT_CREDENTIALS) {\n            if (Util.exists(options.oauthTokenRequestUrl)) {\n                let parsedUrl;\n                try {\n                    parsedUrl = new URL(options.oauthTokenRequestUrl);\n                }\n                catch (error) {\n                    throw Errors.createInvalidParameterError(ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL);\n                }\n                Errors.checkArgumentValid(parsedUrl.protocol === 'https:' || parsedUrl.protocol === 'http:', ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL);\n            }\n            Errors.checkArgumentValid(Util.isString(options.oauthClientId), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID);\n            Errors.checkArgumentValid(Util.isString(options.oauthClientSecret), ErrorCodes.ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET);\n        }\n        consolidateHostAndAccount(options);\n    }\n    // check for missing accessUrl\n    Errors.checkArgumentExists(Util.exists(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCESS_URL);\n    // check for invalid accessUrl\n    Errors.checkArgumentValid(Util.isString(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCESS_URL);\n    const proxyHost = options.proxyHost;\n    const proxyPort = options.proxyPort;\n    const proxyUser = options.proxyUser;\n    const proxyPassword = options.proxyPassword;\n    const proxyProtocol = options.proxyProtocol || 'http';\n    const noProxy = options.noProxy;\n    const useForOCSP = options.useConnectionConfigProxyForOCSP ?? false;\n    let oauthClientId = options.oauthClientId;\n    let oauthClientSecret = options.oauthClientSecret;\n    const oauthRedirectUri = options.oauthRedirectUri;\n    const oauthAuthorizationUrl = options.oauthAuthorizationUrl;\n    const oauthTokenRequestUrl = options.oauthTokenRequestUrl;\n    const oauthChallengeMethod = options.oauthChallengeMethod;\n    const oauthScope = options.oauthScope;\n    const oauthHttpAllowed = options.oauthHttpAllowed;\n    // if we're running in node and some proxy information is specified\n    let proxy;\n    if (Util.isNode() && (Util.exists(proxyHost) || Util.exists(proxyPort))) {\n        proxy = {\n            host: proxyHost,\n            port: proxyPort,\n            user: proxyUser,\n            password: proxyPassword,\n            protocol: proxyProtocol,\n            noProxy: noProxy,\n            useForOCSP: useForOCSP,\n        };\n        ProxyUtil.validateProxy(proxy);\n    }\n    const serviceName = options.serviceName;\n    let authenticator = options.authenticator;\n    // if no value is specified for authenticator, default to Snowflake\n    if (!Util.exists(authenticator)) {\n        authenticator = AuthenticationTypes.DEFAULT_AUTHENTICATOR;\n    }\n    else {\n        authenticator = authenticator.toUpperCase();\n    }\n    let browserActionTimeout = options.browserActionTimeout;\n    if (Util.exists(options.browserActionTimeout)) {\n        Errors.checkArgumentValid(Util.number.isPositiveInteger(browserActionTimeout), ErrorCodes.ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT);\n    }\n    else {\n        browserActionTimeout = WAIT_FOR_BROWSER_ACTION_TIMEOUT;\n    }\n    const privateKey = options.privateKey;\n    if (Util.exists(options.privateKey)) {\n        Errors.checkArgumentValid(Util.isString(privateKey) && Util.isPrivateKey(privateKey), ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY);\n    }\n    const privateKeyPath = options.privateKeyPath;\n    if (Util.exists(options.privateKeyPath)) {\n        Errors.checkArgumentValid(Util.isString(privateKeyPath), ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH);\n    }\n    const privateKeyPass = options.privateKeyPass;\n    if (Util.exists(options.privateKeyPass)) {\n        Errors.checkArgumentValid(Util.isString(privateKeyPass), ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS);\n    }\n    const token = options.token;\n    if (Util.exists(token)) {\n        Errors.checkArgumentValid(Util.isString(token), ErrorCodes.ERR_CONN_CREATE_INVALID_OAUTH_TOKEN);\n    }\n    const warehouse = options.warehouse;\n    const database = options.database;\n    const schema = options.schema;\n    const role = options.role;\n    // check for invalid warehouse\n    if (Util.exists(warehouse)) {\n        Errors.checkArgumentValid(Util.isString(warehouse), ErrorCodes.ERR_CONN_CREATE_INVALID_WAREHOUSE);\n    }\n    // check for invalid database\n    if (Util.exists(database)) {\n        Errors.checkArgumentValid(Util.isString(database), ErrorCodes.ERR_CONN_CREATE_INVALID_DATABASE);\n    }\n    // check for invalid schema\n    if (Util.exists(schema)) {\n        Errors.checkArgumentValid(Util.isString(schema), ErrorCodes.ERR_CONN_CREATE_INVALID_SCHEMA);\n    }\n    // check for invalid role\n    if (Util.exists(role)) {\n        Errors.checkArgumentValid(Util.isString(role), ErrorCodes.ERR_CONN_CREATE_INVALID_ROLE);\n    }\n    // check for invalid streamResult\n    const streamResult = options.streamResult;\n    if (Util.exists(streamResult)) {\n        Errors.checkArgumentValid(Util.isBoolean(streamResult), ErrorCodes.ERR_CONN_CREATE_INVALID_STREAM_RESULT);\n    }\n    // check for invalid fetchAsString\n    const fetchAsString = options.fetchAsString;\n    if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING);\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n    }\n    // Row mode is optional, can be undefined\n    const rowMode = options.rowMode;\n    if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n    }\n    // check for invalid clientSessionKeepAlive\n    const clientSessionKeepAlive = options.clientSessionKeepAlive;\n    if (Util.exists(clientSessionKeepAlive)) {\n        Errors.checkArgumentValid(Util.isBoolean(clientSessionKeepAlive), ErrorCodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE);\n    }\n    // check for invalid clientSessionKeepAliveHeartbeatFrequency\n    let clientSessionKeepAliveHeartbeatFrequency = options.clientSessionKeepAliveHeartbeatFrequency;\n    if (Util.exists(clientSessionKeepAliveHeartbeatFrequency)) {\n        Errors.checkArgumentValid(Util.isNumber(clientSessionKeepAliveHeartbeatFrequency), ErrorCodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ);\n        clientSessionKeepAliveHeartbeatFrequency =\n            Util.validateClientSessionKeepAliveHeartbeatFrequency(clientSessionKeepAliveHeartbeatFrequency, ConnectionConstants.HEARTBEAT_FREQUENCY_MASTER_VALIDITY);\n    }\n    const jsTreatIntegerAsBigInt = options.jsTreatIntegerAsBigInt;\n    if (Util.exists(jsTreatIntegerAsBigInt)) {\n        Errors.checkArgumentValid(Util.isBoolean(jsTreatIntegerAsBigInt), ErrorCodes.ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT);\n    }\n    const gcsUseDownscopedCredential = options.gcsUseDownscopedCredential;\n    if (Util.exists(gcsUseDownscopedCredential)) {\n        Errors.checkArgumentValid(Util.isBoolean(gcsUseDownscopedCredential), ErrorCodes.ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL);\n    }\n    const clientConfigFile = options.clientConfigFile;\n    if (Util.exists(clientConfigFile)) {\n        Errors.checkArgumentValid(Util.isString(clientConfigFile), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE);\n    }\n    // remember if we're in qa mode\n    this._qaMode = qaMode;\n    // if a client-info argument is specified, validate it\n    const clientType = 'JavaScript';\n    let clientName;\n    let clientVersion;\n    let clientEnvironment;\n    if (Util.exists(clientInfo)) {\n        Errors.assertInternal(Util.isObject(clientInfo));\n        Errors.assertInternal(Util.isString(clientInfo.version));\n        Errors.assertInternal(Util.isObject(clientInfo.environment));\n        clientName = clientInfo.name;\n        clientVersion = clientInfo.version;\n        clientEnvironment = clientInfo.environment;\n        clientEnvironment.OS = os.platform();\n        clientEnvironment.OS_VERSION = os.release();\n        clientEnvironment.OCSP_MODE = GlobalConfig.getOcspMode();\n    }\n    const clientApplication = options.application;\n    if (Util.exists(clientApplication)) {\n        Errors.checkArgumentValid(Util.isString(clientApplication), ErrorCodes.ERR_CONN_CREATE_INVALID_APPLICATION);\n        const APPLICATION_PATTERN = new RegExp(String.raw `^[A-Za-z]([A-Za-z0-9.\\-_]){1,50}$`, 'gi');\n        Errors.checkArgumentValid(APPLICATION_PATTERN.test(clientApplication), ErrorCodes.ERR_CONN_CREATE_INVALID_APPLICATION);\n    }\n    let validateDefaultParameters = false;\n    if (Util.exists(options.validateDefaultParameters)) {\n        // check for invalid validateDefaultParameters\n        Errors.checkArgumentValid(Util.isBoolean(options.validateDefaultParameters), ErrorCodes.ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS);\n        validateDefaultParameters = options.validateDefaultParameters;\n    }\n    let bindThreshold = null;\n    if (Util.exists(options.arrayBindingThreshold)) {\n        // check for invalid arrayBindingThreshold\n        Errors.checkArgumentValid(Util.isNumber(options.arrayBindingThreshold), ErrorCodes.ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD);\n        bindThreshold = options.arrayBindingThreshold;\n    }\n    let forceStageBindError = null;\n    if (Util.exists(options.forceStageBindError)) {\n        // check for invalid forceStageBindError\n        Errors.checkArgumentValid(Util.isNumber(options.forceStageBindError), ErrorCodes.ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR);\n        forceStageBindError = options.forceStageBindError;\n    }\n    let disableQueryContextCache = false;\n    if (Util.exists(options.disableQueryContextCache)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.disableQueryContextCache), ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE);\n        disableQueryContextCache = options.disableQueryContextCache;\n    }\n    let retryTimeout = 300;\n    if (Util.exists(options.retryTimeout)) {\n        Errors.checkArgumentValid(Util.isNumber(options.retryTimeout), ErrorCodes.ERR_CONN_CREATE_INVALID_MAX_RETRY_TIMEOUT);\n        retryTimeout = options.retryTimeout !== 0 ? Math.max(retryTimeout, options.retryTimeout) : 0;\n    }\n    let includeRetryReason = true;\n    if (Util.exists(options.includeRetryReason)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.includeRetryReason), ErrorCodes.ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON);\n        includeRetryReason = options.includeRetryReason;\n    }\n    let clientRequestMFAToken = false;\n    if (Util.exists(options.clientRequestMFAToken)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.clientRequestMFAToken), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN);\n        clientRequestMFAToken = options.clientRequestMFAToken;\n    }\n    let disableConsoleLogin = true;\n    if (Util.exists(options.disableConsoleLogin)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.disableConsoleLogin), ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN);\n        disableConsoleLogin = options.disableConsoleLogin;\n    }\n    if (Util.exists(options.forceGCPUseDownscopedCredential)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.forceGCPUseDownscopedCredential), ErrorCodes.ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL);\n        process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL =\n            options.forceGCPUseDownscopedCredential;\n    }\n    else {\n        process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL = false;\n    }\n    if (Util.exists(options.representNullAsStringNull)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.representNullAsStringNull), ErrorCodes.ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL);\n        DataTypes.setIsRepresentNullAsStringNull(options.representNullAsStringNull);\n    }\n    let disableSamlURLCheck = false;\n    if (Util.exists(options.disableSamlURLCheck)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.disableSamlURLCheck), ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK);\n        disableSamlURLCheck = options.disableSamlURLCheck;\n    }\n    let clientStoreTemporaryCredential = false;\n    if (Util.exists(options.clientStoreTemporaryCredential)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.clientStoreTemporaryCredential), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL);\n        clientStoreTemporaryCredential = options.clientStoreTemporaryCredential;\n    }\n    let credentialCacheDir = null;\n    if (Util.exists(options.credentialCacheDir)) {\n        const absolutePath = path.resolve(options.credentialCacheDir);\n        Errors.checkArgumentValid(Util.validatePath(absolutePath), ErrorCodes.ERR_CONN_CREATE_INVALID_CREDENTIAL_CACHE_DIR);\n        credentialCacheDir = absolutePath;\n    }\n    let passcodeInPassword = false;\n    if (Util.exists(options.passcodeInPassword)) {\n        Errors.checkArgumentValid(Util.isBoolean(options.passcodeInPassword), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD);\n        passcodeInPassword = options.passcodeInPassword;\n    }\n    let passcode = null;\n    if (Util.exists(options.passcode)) {\n        Errors.checkArgumentValid(Util.isString(options.passcode), ErrorCodes.ERR_CONN_CREATE_INVALID_PASSCODE);\n        passcode = options.passcode;\n    }\n    if (options.queryTag) {\n        Errors.checkArgumentValid(Util.isString(options.queryTag) && options.queryTag.length <= 2000, ErrorCodes.ERR_CONN_CREATE_INVALID_QUERY_TAG);\n        this.queryTag = options.queryTag;\n    }\n    if (validateDefaultParameters) {\n        for (const [key] of Object.entries(options)) {\n            if (!DEFAULT_PARAMS.includes(key)) {\n                const result = levenshtein.closest(key, DEFAULT_PARAMS);\n                Logger.getInstance().error(`'${key}' is an unknown connection parameter. Did you mean '${result}'?`);\n            }\n        }\n    }\n    /**\n     * Returns an object that contains information about the proxy hostname, port,\n     * etc. for when http requests are made.\n     *\n     * @returns {Object}\n     */\n    this.getProxy = function () {\n        return proxy;\n    };\n    /**\n     * Returns the warehouse to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getWarehouse = function () {\n        return warehouse;\n    };\n    /**\n     * Returns the database to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getDatabase = function () {\n        return database;\n    };\n    /**\n     * Returns the schema to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getSchema = function () {\n        return schema;\n    };\n    /**\n     * Returns the role to automatically use once a connection has been\n     * established.\n     *\n     * @returns {String}\n     */\n    this.getRole = function () {\n        return role;\n    };\n    /**\n     * Returns the service name.\n     *\n     * @returns {String}\n     */\n    this.getServiceName = function () {\n        return serviceName;\n    };\n    /**\n     * Returns the authenticator to use for establishing a connection.\n     *\n     * @returns {String}\n     */\n    this.getAuthenticator = function () {\n        return authenticator;\n    };\n    /**\n     * Returns the timeout in millis used for authentication by external browser.\n     *\n     * @returns {String}\n     */\n    this.getBrowserActionTimeout = function () {\n        return browserActionTimeout;\n    };\n    /**\n     * Returns the private key string.\n     *\n     * @returns {String}\n     */\n    this.getPrivateKey = function () {\n        return privateKey;\n    };\n    /**\n     * Returns the private key file location.\n     *\n     * @returns {String}\n     */\n    this.getPrivateKeyPath = function () {\n        return privateKeyPath;\n    };\n    /**\n     * Returns the private key passphrase.\n     *\n     * @returns {String}\n     */\n    this.getPrivateKeyPass = function () {\n        return privateKeyPass;\n    };\n    /**\n     * Returns the OAuth token.\n     *\n     * @returns {String}\n     */\n    this.getToken = function () {\n        return token;\n    };\n    /**\n     * Returns the streamResult flag.\n     *\n     * @returns {boolean}\n     */\n    this.getStreamResult = function () {\n        return streamResult;\n    };\n    /**\n     * Returns the fetchAsString array.\n     *\n     * @returns {String[]}\n     */\n    this.getFetchAsString = function () {\n        return fetchAsString;\n    };\n    /**\n     * Returns the rowMode string value ('array', 'object' or 'object_with_renamed_duplicated_columns'). Could be null or undefined.\n     *\n     * @returns  {String}\n     */\n    this.getRowMode = function () {\n        return rowMode;\n    };\n    /**\n     * Returns the client type.\n     *\n     * @returns {String}\n     */\n    this.getClientType = function () {\n        return clientType;\n    };\n    /**\n     * Returns the client name.\n     *\n     * @returns {String}\n     */\n    this.getClientName = function () {\n        return clientName;\n    };\n    /**\n     * Returns the client version.\n     *\n     * @returns {String}\n     */\n    this.getClientVersion = function () {\n        return clientVersion;\n    };\n    /**\n     * Returns the client application.\n     *\n     * @returns {String}\n     */\n    this.getClientApplication = function () {\n        return clientApplication;\n    };\n    /**\n     * Returns a JSON object containing version information for all the various\n     * components of the runtime, e.g. node, v8, openssl, etc.\n     *\n     * @returns {Object}\n     */\n    this.getClientEnvironment = function () {\n        return clientEnvironment;\n    };\n    /**\n     * Returns the client session keep alive setting.\n     *\n     * @returns {String}\n     */\n    this.getClientSessionKeepAlive = function () {\n        return clientSessionKeepAlive;\n    };\n    /**\n     * Returns the client session keep alive heartbeat frequency setting.\n     *\n     * @returns {String}\n     */\n    this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n        return clientSessionKeepAliveHeartbeatFrequency;\n    };\n    /**\n     * Returns the client treat integer as setting\n     *\n     * @returns {String}\n     */\n    this.getJsTreatIntegerAsBigInt = function () {\n        return jsTreatIntegerAsBigInt;\n    };\n    /**\n     * Returns the setting for the GCS_USE_DOWNSCOPED_CREDENTIAL session parameter\n     *\n     * @returns {String}\n     */\n    this.getGcsUseDownscopedCredential = function () {\n        return gcsUseDownscopedCredential;\n    };\n    /**\n     * Returns the bind threshold\n     *\n     * @returns {string}\n     */\n    this.getbindThreshold = function () {\n        return bindThreshold;\n    };\n    /**\n     * Returns the force stage bind error\n     *\n     * @returns {string}\n     */\n    this.getForceStageBindError = function () {\n        return forceStageBindError;\n    };\n    /**\n     * Returns whether the Retry reason is included or not in the retry url\n     *\n     * @returns {Boolean}\n     */\n    this.getIncludeRetryReason = function () {\n        return includeRetryReason;\n    };\n    /**\n     * Returns whether the Query Context Cache is enabled or not by the configuration\n     *\n     * @returns {Boolean}\n     */\n    this.getDisableQueryContextCache = function () {\n        return disableQueryContextCache;\n    };\n    /**\n     * Returns the client config file\n     *\n     * @returns {String}\n     */\n    this.getClientConfigFile = function () {\n        return clientConfigFile;\n    };\n    /**\n     * Returns the max login timeout\n     *\n     * @returns {Number}\n     */\n    this.getRetryTimeout = function () {\n        return retryTimeout;\n    };\n    this.getDisableConsoleLogin = function () {\n        return disableConsoleLogin;\n    };\n    /**\n     * Returns whether the SAML URL check is enabled or not.\n     *\n     * @returns {Boolean}\n     */\n    this.getDisableSamlURLCheck = function () {\n        return disableSamlURLCheck;\n    };\n    this.getCredentialCacheDir = function () {\n        return credentialCacheDir;\n    };\n    this.getClientRequestMFAToken = function () {\n        return clientRequestMFAToken;\n    };\n    /**\n     * Returns whether the auth token saves on the local machine or not.\n     *\n     * @returns {Boolean}\n     */\n    this.getClientStoreTemporaryCredential = function () {\n        return clientStoreTemporaryCredential;\n    };\n    this.getPasscodeInPassword = function () {\n        return passcodeInPassword;\n    };\n    this.getPasscode = function () {\n        return passcode;\n    };\n    this.getOauthClientId = function () {\n        if (!Util.isNotEmptyString(options.oauthClientId) &&\n            !Util.isNotEmptyString(options.oauthClientSecret) &&\n            authenticator === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE &&\n            isSnowflakeHost(this.getOauthAuthorizationUrl()) &&\n            isSnowflakeHost(this.getOauthTokenRequestUrl())) {\n            Logger.getInstance().debug(`Using default values for oauthClientId: ${LOCAL_APPLICATION_CLIENT_CREDENTIAL}`);\n            oauthClientId = LOCAL_APPLICATION_CLIENT_CREDENTIAL;\n        }\n        return oauthClientId;\n    };\n    this.getOauthClientSecret = function () {\n        if (!options.oauthClientId &&\n            !options.oauthClientSecret &&\n            authenticator === AuthenticationTypes.OAUTH_AUTHORIZATION_CODE &&\n            isSnowflakeHost(this.getOauthAuthorizationUrl()) &&\n            isSnowflakeHost(this.getOauthTokenRequestUrl())) {\n            Logger.getInstance().debug(`Using default values for oauthClientSecret: ${LOCAL_APPLICATION_CLIENT_CREDENTIAL}`);\n            oauthClientSecret = LOCAL_APPLICATION_CLIENT_CREDENTIAL;\n        }\n        return oauthClientSecret;\n    };\n    this.getOauthAuthorizationUrl = function () {\n        return oauthAuthorizationUrl ?? options.accessUrl + SNOWFLAKE_AUTHORIZE_ENDPOINT;\n    };\n    this.getOauthTokenRequestUrl = function () {\n        return oauthTokenRequestUrl ?? options.accessUrl + SNOWFLAKE_TOKEN_REQUEST_ENDPOINT;\n    };\n    this.getOauthRedirectUri = function () {\n        return oauthRedirectUri;\n    };\n    this.getOauthScope = function () {\n        return oauthScope;\n    };\n    this.getOauthChallengeMethod = function () {\n        return oauthChallengeMethod;\n    };\n    this.getOauthHttpAllowed = function () {\n        return oauthHttpAllowed || false;\n    };\n    /**\n     * Returns attributes of Connection Config object that can be used to identify\n     * the connection, when ID is not available in the scope. This is not sufficient set,\n     * since multiple connections can be instantiated for the same config, but can be treated as a hint.\n     *\n     * @returns {string}\n     */\n    this.describeIdentityAttributes = function () {\n        return (`host: ${this.host}, account: ${this.account}, accessUrl: ${this.accessUrl}, ` +\n            `user: ${this.username}, role: ${this.getRole()}, database: ${this.getDatabase()}, ` +\n            `schema: ${this.getSchema()}, warehouse: ${this.getWarehouse()}, ` +\n            ProxyUtil.describeProxy(this.getProxy()));\n    };\n    // NOTE:\n    // Don't add new get* methods when implementing new options. Use this.optionName instead.\n    // If you need advanced logic in getter, use JS object getters.\n    //\n    // Future plan is to reduce complexity of this file by merging 3 objects into one context:\n    // defaults+options+custom getters = ConnectionConfig\n    this.username = options.username;\n    this.password = options.password;\n    this.accessUrl = options.accessUrl;\n    this.region = options.region;\n    this.account = options.account;\n    this.token = options.token;\n    this.host = options.host;\n    this.sessionToken = options.sessionToken;\n    this.masterToken = options.masterToken;\n    this.masterTokenExpirationTime = options.masterTokenExpirationTime;\n    this.sessionTokenExpirationTime = options.sessionTokenExpirationTime;\n    this.clientConfigFile = options.clientConfigFile;\n    this.openExternalBrowserCallback = options.openExternalBrowserCallback;\n    this.oauthEnableSingleUseRefreshTokens = options.oauthEnableSingleUseRefreshTokens;\n    this.workloadIdentityProvider = options.workloadIdentityProvider;\n    this.workloadIdentityAzureEntraIdResource = options.workloadIdentityAzureEntraIdResource;\n    this.crlValidatorConfig = {\n        checkMode: options.certRevocationCheckMode ?? 'DISABLED',\n        allowCertificatesWithoutCrlURL: options.crlAllowCertificatesWithoutCrlURL ?? false,\n        inMemoryCache: options.crlInMemoryCache ?? true,\n        onDiskCache: options.crlOnDiskCache ?? true,\n    };\n    // create the parameters array\n    const parameters = createParameters();\n    // create a map in which the keys are the parameter names and the values are\n    // the corresponding parameters\n    const mapParameters = {};\n    let index, length, parameter;\n    for (index = 0, length = parameters.length; index < length; index++) {\n        parameter = parameters[index];\n        mapParameters[parameter.name] = parameter;\n        // initialize the value to the default\n        parameter.value = parameter.defaultValue;\n    }\n    // for each property in the options object that matches a known parameter name\n    let propertyName, propertyValue;\n    for (propertyName in options) {\n        if (Object.prototype.hasOwnProperty.call(options, propertyName) &&\n            Object.prototype.hasOwnProperty.call(mapParameters, propertyName)) {\n            // if the parameter matching the property is external and the specified\n            // value is valid for the parameter, update the parameter value\n            propertyValue = options[propertyName];\n            parameter = mapParameters[propertyName];\n            if (parameter.external && parameter.validate(propertyValue)) {\n                parameter.value = propertyValue;\n            }\n        }\n    }\n    // save the parameters map\n    this._mapParameters = mapParameters;\n    // custom agent class, test only\n    this.agentClass = options.agentClass;\n}\n/**\n * Determines if qa-mode is on.\n *\n * @returns {Boolean}\n */\nConnectionConfig.prototype.isQaMode = function () {\n    return this._qaMode;\n};\n/**\n * Clears all credential-related information.\n */\nConnectionConfig.prototype.clearCredentials = function () {\n    // clear the password\n    this.password = null;\n    // TODO: clear passcode and other credential-related information as well\n};\nconst PARAM_TIMEOUT = 'timeout';\nconst PARAM_RESULT_PREFETCH = 'resultPrefetch';\nconst PARAM_RESULT_STREAM_INTERRUPTS = 'resultStreamInterrupts';\nconst PARAM_RESULT_CHUNK_CACHE_SIZE = 'resultChunkCacheSize';\nconst PARAM_RESULT_PROCESSING_BATCH_SIZE = 'resultProcessingBatchSize';\nconst PARAM_RESULT_PROCESSING_BATCH_DURATION = 'resultProcessingBatchDuration';\nconst PARAM_ROW_STREAM_HIGH_WATER_MARK = 'rowStreamHighWaterMark';\nconst PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES = 'largeResultSetRetryMaxNumRetries';\nconst PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME = 'largeResultSetRetryMaxSleepTime';\nconst PARAM_RETRY_SF_MAX_LOGIN_RETRIES = 'sfRetryMaxLoginRetries';\nconst PARAM_RETRY_SF_MAX_NUM_RETRIES = 'sfRetryMaxNumRetries';\nconst PARAM_RETRY_SF_STARTING_SLEEP_TIME = 'sfRetryStartingSleepTime';\nconst PARAM_RETRY_SF_MAX_SLEEP_TIME = 'sfRetryMaxSleepTime';\n/**\n * Creates the list of known parameters. If a parameter is marked as external,\n * its value can be overridden by adding the appropriate name-value mapping to\n * the ConnectionConfig options.\n *\n * @returns {Object[]}\n */\nfunction createParameters() {\n    const isNonNegativeInteger = Util.number.isNonNegativeInteger.bind(Util.number);\n    const isPositiveInteger = Util.number.isPositiveInteger.bind(Util.number);\n    const isNonNegativeNumber = Util.number.isNonNegative.bind(Util.number);\n    return [\n        {\n            name: PARAM_TIMEOUT,\n            defaultValue: 90 * 1000,\n            external: true,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_PREFETCH,\n            defaultValue: 2,\n            external: true,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_STREAM_INTERRUPTS,\n            defaultValue: 3,\n            validate: isPositiveInteger,\n        },\n        // for now we set chunk cache size to 1, which is same as\n        // disabling the chunk cache. Otherwise, cache will explode\n        // memory when fetching large result set\n        {\n            name: PARAM_RESULT_CHUNK_CACHE_SIZE,\n            defaultValue: 1,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_PROCESSING_BATCH_SIZE,\n            defaultValue: 1000,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RESULT_PROCESSING_BATCH_DURATION,\n            defaultValue: 100,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_ROW_STREAM_HIGH_WATER_MARK,\n            defaultValue: 10,\n            validate: isPositiveInteger,\n        },\n        {\n            name: PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES,\n            defaultValue: 10,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME,\n            defaultValue: 16,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_SF_MAX_LOGIN_RETRIES,\n            defaultValue: 7,\n            external: true,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_SF_MAX_NUM_RETRIES,\n            defaultValue: 1000,\n            validate: isNonNegativeInteger,\n        },\n        {\n            name: PARAM_RETRY_SF_STARTING_SLEEP_TIME,\n            defaultValue: 1,\n            validate: isNonNegativeNumber,\n        },\n        {\n            name: PARAM_RETRY_SF_MAX_SLEEP_TIME,\n            defaultValue: 16,\n            validate: isNonNegativeNumber,\n        },\n    ];\n}\nConnectionConfig.prototype.getTimeout = function () {\n    return this._getParameterValue(PARAM_TIMEOUT);\n};\nConnectionConfig.prototype.getResultPrefetch = function () {\n    return this._getParameterValue(PARAM_RESULT_PREFETCH);\n};\nConnectionConfig.prototype.getResultStreamInterrupts = function () {\n    return this._getParameterValue(PARAM_RESULT_STREAM_INTERRUPTS);\n};\nConnectionConfig.prototype.getResultChunkCacheSize = function () {\n    return this._getParameterValue(PARAM_RESULT_CHUNK_CACHE_SIZE);\n};\nConnectionConfig.prototype.getResultProcessingBatchSize = function () {\n    return this._getParameterValue(PARAM_RESULT_PROCESSING_BATCH_SIZE);\n};\nConnectionConfig.prototype.getResultProcessingBatchDuration = function () {\n    return this._getParameterValue(PARAM_RESULT_PROCESSING_BATCH_DURATION);\n};\nConnectionConfig.prototype.getRowStreamHighWaterMark = function () {\n    return this._getParameterValue(PARAM_ROW_STREAM_HIGH_WATER_MARK);\n};\nConnectionConfig.prototype.getRetryLargeResultSetMaxNumRetries = function () {\n    return this._getParameterValue(PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES);\n};\nConnectionConfig.prototype.getRetryLargeResultSetMaxSleepTime = function () {\n    return this._getParameterValue(PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME);\n};\nConnectionConfig.prototype.getRetrySfMaxNumRetries = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_MAX_NUM_RETRIES);\n};\nConnectionConfig.prototype.getRetrySfMaxLoginRetries = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_MAX_LOGIN_RETRIES);\n};\nConnectionConfig.prototype.getRetrySfStartingSleepTime = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_STARTING_SLEEP_TIME);\n};\nConnectionConfig.prototype.getRetrySfMaxSleepTime = function () {\n    return this._getParameterValue(PARAM_RETRY_SF_MAX_SLEEP_TIME);\n};\n/**\n * Returns the value of a given connection config parameter.\n *\n * @param parameterName\n *\n * @returns {Object}\n * @private\n */\nConnectionConfig.prototype._getParameterValue = function (parameterName) {\n    const parameter = this._mapParameters[parameterName];\n    return parameter ? parameter.value : undefined;\n};\nmodule.exports = ConnectionConfig;\n//# sourceMappingURL=connection_config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsd0hBQW1DO0FBQ3ZFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQjtBQUNBLG9CQUFvQiwySUFBMEM7QUFDOUQscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLGtJQUF3QztBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQXlCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLHdHQUFxQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGdJQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixLQUFLO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUksc0RBQXNELE9BQU87QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLG9DQUFvQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixvQ0FBb0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSxhQUFhLGFBQWEsZUFBZSxlQUFlO0FBQzNGLHFCQUFxQixjQUFjLFVBQVUsZUFBZSxjQUFjLG1CQUFtQjtBQUM3Rix1QkFBdUIsaUJBQWlCLGVBQWUsb0JBQW9CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgUHJveHlVdGlsID0gcmVxdWlyZSgnLi4vcHJveHlfdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBDb25uZWN0aW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL2Nvbm5lY3Rpb25fY29uc3RhbnRzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IE5hdGl2ZVR5cGVzID0gcmVxdWlyZSgnLi9yZXN1bHQvZGF0YV90eXBlcycpLk5hdGl2ZVR5cGVzO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgQXV0aGVudGljYXRpb25UeXBlcyA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBsZXZlbnNodGVpbiA9IHJlcXVpcmUoJ2Zhc3Rlc3QtbGV2ZW5zaHRlaW4nKTtcbmNvbnN0IFJvd01vZGUgPSByZXF1aXJlKCcuLy4uL2NvbnN0YW50cy9yb3dfbW9kZScpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9yZXN1bHQvZGF0YV90eXBlcycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCB7IGlzU25vd2ZsYWtlSG9zdCB9ID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdXRpbCcpO1xuY29uc3QgV0FJVF9GT1JfQlJPV1NFUl9BQ1RJT05fVElNRU9VVCA9IDEyMDAwMDtcbmNvbnN0IFNOT1dGTEFLRV9BVVRIT1JJWkVfRU5EUE9JTlQgPSAnL29hdXRoL2F1dGhvcml6ZSc7XG5jb25zdCBTTk9XRkxBS0VfVE9LRU5fUkVRVUVTVF9FTkRQT0lOVCA9ICcvb2F1dGgvdG9rZW4tcmVxdWVzdCc7XG5jb25zdCBMT0NBTF9BUFBMSUNBVElPTl9DTElFTlRfQ1JFREVOVElBTCA9ICdMT0NBTF9BUFBMSUNBVElPTic7XG5jb25zdCBERUZBVUxUX1BBUkFNUyA9IFtcbiAgICAnYWNjb3VudCcsXG4gICAgJ2FwcGxpY2F0aW9uJyxcbiAgICAncmVnaW9uJyxcbiAgICAnaG9zdCcsXG4gICAgJ2FjY2Vzc1VybCcsXG4gICAgJ3VzZXJuYW1lJyxcbiAgICAncGFzc3dvcmQnLFxuICAgICdhdXRoZW50aWNhdG9yJyxcbiAgICAncHJveHlIb3N0JyxcbiAgICAncHJveHlQb3J0JyxcbiAgICAnc2VydmljZU5hbWUnLFxuICAgICdwcml2YXRlS2V5JyxcbiAgICAncHJpdmF0ZUtleVBhdGgnLFxuICAgICdwcml2YXRlS2V5UGFzcycsXG4gICAgJ3Rva2VuJyxcbiAgICAnd2FyZWhvdXNlJyxcbiAgICAnZGF0YWJhc2UnLFxuICAgICdzY2hlbWEnLFxuICAgICdyb2xlJyxcbiAgICAncm93TW9kZScsXG4gICAgJ3N0cmVhbVJlc3VsdCcsXG4gICAgJ2ZldGNoQXNTdHJpbmcnLFxuICAgICdjbGllbnRTZXNzaW9uS2VlcEFsaXZlJyxcbiAgICAnY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeScsXG4gICAgJ2pzVHJlYXRJbnRlZ2VyQXNCaWdJbnQnLFxuICAgICdzZXNzaW9uVG9rZW4nLFxuICAgICdtYXN0ZXJUb2tlbicsXG4gICAgJ3Nlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lJyxcbiAgICAnbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZScsXG4gICAgJ2FnZW50Q2xhc3MnLFxuICAgICd2YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzJyxcbiAgICAnYXJyYXlCaW5kaW5nVGhyZXNob2xkJyxcbiAgICAnZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWwnLFxuICAgICdmb3JjZVN0YWdlQmluZEVycm9yJyxcbiAgICAnaW5jbHVkZVJldHJ5UmVhc29uJyxcbiAgICAnZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlJyxcbiAgICAncmV0cnlUaW1lb3V0JyxcbiAgICAnY2xpZW50UmVxdWVzdE1GQVRva2VuJyxcbiAgICAnY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsJyxcbiAgICAnZGlzYWJsZUNvbnNvbGVMb2dpbicsXG4gICAgJ2ZvcmNlR0NQVXNlRG93bnNjb3BlZENyZWRlbnRpYWwnLFxuICAgICdyZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsJyxcbiAgICAnZGlzYWJsZVNhbWxVUkxDaGVjaycsXG4gICAgJ2NyZWRlbnRpYWxDYWNoZURpcicsXG4gICAgJ3Bhc3Njb2RlSW5QYXNzd29yZCcsXG4gICAgJ3Bhc3Njb2RlJyxcbiAgICAnb2F1dGhDbGllbnRJZCcsXG4gICAgJ29hdXRoQ2xpZW50U2VjcmV0JyxcbiAgICAnb2F1dGhSZWRpcmVjdFVyaScsXG4gICAgJ29hdXRoQXV0aG9yaXphdGlvblVybCcsXG4gICAgJ29hdXRoVG9rZW5SZXF1ZXN0VXJsJyxcbiAgICAnb2F1dGhTY29wZScsXG4gICAgJ29hdXRoQ2hhbGxlbmdlTWV0aG9kJyxcbiAgICAnb2F1dGhIdHRwQWxsb3dlZCcsIC8vb25seSBmb3IgdGVzdHNcbiAgICAnd29ya2xvYWRJZGVudGl0eVByb3ZpZGVyJyxcbiAgICAnd29ya2xvYWRJZGVudGl0eUF6dXJlRW50cmFJZFJlc291cmNlJyxcbiAgICAncXVlcnlUYWcnLFxuICAgICdjZXJ0UmV2b2NhdGlvbkNoZWNrTW9kZScsXG4gICAgJ2NybEFsbG93Q2VydGlmaWNhdGVzV2l0aG91dENybFVSTCcsXG4gICAgJ2NybEluTWVtb3J5Q2FjaGUnLFxuICAgICdjcmxPbkRpc2tDYWNoZScsXG5dO1xuZnVuY3Rpb24gY29uc29saWRhdGVIb3N0QW5kQWNjb3VudChvcHRpb25zKSB7XG4gICAgbGV0IGRvdFBvcyA9IC0xO1xuICAgIGxldCByZWFsQWNjb3VudCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVhbFJlZ2lvbiA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgJ2h0dHBzJztcbiAgICBjb25zdCBwb3J0ID0gVXRpbC5leGlzdHMob3B0aW9ucy5wb3J0KSA/IFV0aWwuZm9ybWF0KCc6JXMnLCBvcHRpb25zLnBvcnQpIDogJyc7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucmVnaW9uKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNDb3JyZWN0U3ViZG9tYWluKG9wdGlvbnMucmVnaW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRUdJT05fUkVHRVgpO1xuICAgICAgICByZWFsUmVnaW9uID0gb3B0aW9ucy5yZWdpb247XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLmFjY291bnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ09VTlQpO1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNDb3JyZWN0U3ViZG9tYWluKG9wdGlvbnMuYWNjb3VudCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDT1VOVF9SRUdFWCk7XG4gICAgICAgIGRvdFBvcyA9IG9wdGlvbnMuYWNjb3VudC5pbmRleE9mKCcuJyk7XG4gICAgICAgIHJlYWxBY2NvdW50ID0gb3B0aW9ucy5hY2NvdW50O1xuICAgICAgICBpZiAoZG90UG9zID4gMCkge1xuICAgICAgICAgICAgcmVhbFJlZ2lvbiA9IHJlYWxBY2NvdW50LnN1YnN0cmluZyhkb3RQb3MgKyAxKTtcbiAgICAgICAgICAgIHJlYWxBY2NvdW50ID0gcmVhbEFjY291bnQuc3Vic3RyaW5nKDAsIGRvdFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYWNjZXNzVXJsKSkge1xuICAgICAgICAvL2FjY2Vzc1VybCBpcyBzZXQgaW4gY29uZmlndXJhdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKG9wdGlvbnMuYWNjZXNzVXJsKTtcbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5leGlzdHMocGFyc2VkVXJsLmhvc3RuYW1lKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NFU1NfVVJMKTtcbiAgICAgICAgICAgIGlmICghVXRpbC5leGlzdHMob3B0aW9ucy5ob3N0KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRvdFBvcyA9IHBhcnNlZFVybC5ob3N0bmFtZS5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgICBpZiAoZG90UG9zID4gMCAmJiAhVXRpbC5leGlzdHMob3B0aW9ucy5hY2NvdW50KSkge1xuICAgICAgICAgICAgICAgIHJlYWxBY2NvdW50ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN1YnN0cmluZygwLCBkb3RQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGZhbHNlLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ09VTlQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuaG9zdCkpIHtcbiAgICAgICAgLy9ob3N0IGlzIHNldCBpbiBjb25maWd1cmF0aW9uXG4gICAgICAgIG9wdGlvbnMuYWNjZXNzVXJsID0gVXRpbC5mb3JtYXQoJyVzOi8vJXMlcycsIHByb3RvY29sLCBvcHRpb25zLmhvc3QsIHBvcnQpO1xuICAgICAgICBjb25zdCBkb3RQb3MgPSBvcHRpb25zLmhvc3QuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90UG9zID4gMCAmJiAhVXRpbC5leGlzdHMob3B0aW9ucy5hY2NvdW50KSkge1xuICAgICAgICAgICAgcmVhbEFjY291bnQgPSBvcHRpb25zLmhvc3Quc3Vic3RyaW5nKDAsIGRvdFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFsQWNjb3VudCA9IG9wdGlvbnMuYWNjb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpKSB7XG4gICAgICAgIC8vb25seSBhY2NvdW50KCkgaXMgc2V0IGluIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09PSAndXMtd2VzdC0yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5yZWdpb24gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmhvc3QgPSBVdGlsLmNvbnN0cnVjdEhvc3RuYW1lKHJlYWxSZWdpb24sIHJlYWxBY2NvdW50KTtcbiAgICAgICAgb3B0aW9ucy5hY2Nlc3NVcmwgPSBVdGlsLmZvcm1hdCgnJXM6Ly8lcyVzJywgcHJvdG9jb2wsIG9wdGlvbnMuaG9zdCwgcG9ydCk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhyZWFsQWNjb3VudCkgJiYgb3B0aW9ucy5hY2Nlc3NVcmwuaW5jbHVkZXMoJ2dsb2JhbC5zbm93Zmxha2Vjb21wdXRpbmcnKSkge1xuICAgICAgICBjb25zdCBkYXNoUG9zID0gcmVhbEFjY291bnQuaW5kZXhPZignLScpO1xuICAgICAgICBpZiAoZGFzaFBvcyA+IDApIHtcbiAgICAgICAgICAgIC8vIGdsb2JhbCBVUkxcbiAgICAgICAgICAgIHJlYWxBY2NvdW50ID0gcmVhbEFjY291bnQuc3Vic3RyaW5nKDAsIGRhc2hQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMuYWNjb3VudCA9IHJlYWxBY2NvdW50O1xuICAgIG9wdGlvbnMucmVnaW9uID0gcmVhbFJlZ2lvbjtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBhY2Nlc3NVUkxcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ09VTlQpO1xuICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIGFjY291bnRcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmFjY2Vzc1VybCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDRVNTX1VSTCk7XG59XG4vKipcbiAqIEEgQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgdG8gYWxsIHN0YXRlZnVsXG4gKiBvYmplY3RzIGluIHRoZSBkcml2ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbGlkYXRlQ3JlZGVudGlhbHNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtxYU1vZGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW2NsaWVudEluZm9dXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbm5lY3Rpb25Db25maWcob3B0aW9ucywgdmFsaWRhdGVDcmVkZW50aWFscywgcWFNb2RlLCBjbGllbnRJbmZvKSB7XG4gICAgLy8gaWYgbm8gdmFsdWUgaXMgc3BlY2lmaWVkIGZvciB0aGUgdmFsaWRhdGUgY3JlZGVudGlhbHMgZmxhZywgZGVmYXVsdCB0byB0cnVlXG4gICAgaWYgKCFVdGlsLmV4aXN0cyh2YWxpZGF0ZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICB2YWxpZGF0ZUNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKG9wdGlvbnMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX09QVElPTlMpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3Qob3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1BUSU9OUyk7XG4gICAgLy8gb25seSB2YWxpZGF0ZSBjcmVkZW50aWFscyBpZiBuZWNlc3NhcnlcbiAgICBpZiAodmFsaWRhdGVDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBub1VzZXJuYW1lUmVxdWlyZWRGb3IgPSBbXG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhFTlRJQ0FUT1IsXG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblR5cGVzLkVYVEVSTkFMX0JST1dTRVJfQVVUSEVOVElDQVRPUixcbiAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uVHlwZXMuUFJPR1JBTU1BVElDX0FDQ0VTU19UT0tFTixcbiAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQ0xJRU5UX0NSRURFTlRJQUxTLFxuICAgICAgICAgICAgQXV0aGVudGljYXRpb25UeXBlcy5PQVVUSF9BVVRIT1JJWkFUSU9OX0NPREUsXG4gICAgICAgICAgICBBdXRoZW50aWNhdGlvblR5cGVzLldPUktMT0FEX0lERU5USVRZLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXV0aGVudGljYXRvciB8fFxuICAgICAgICAgICAgIW5vVXNlcm5hbWVSZXF1aXJlZEZvci5pbmNsdWRlcyhvcHRpb25zLmF1dGhlbnRpY2F0b3IudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIHVzZXJuYW1lXG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLnVzZXJuYW1lKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19VU0VSTkFNRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMudXNlcm5hbWUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB1c2VybmFtZVxuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMudXNlcm5hbWUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1VTRVJOQU1FKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXNzd29yZCBpcyBvbmx5IHJlcXVpcmVkIGZvciBkZWZhdWx0IGF1dGhlbnRpY2F0b3JcbiAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhvcHRpb25zLmF1dGhlbnRpY2F0b3IpIHx8XG4gICAgICAgICAgICBvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuREVGQVVMVF9BVVRIRU5USUNBVE9SKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBwYXNzd29yZFxuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzd29yZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkQpO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcGFzc3dvcmRcbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLnBhc3N3b3JkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhvcHRpb25zLmF1dGhlbnRpY2F0b3IpIHx8XG4gICAgICAgICAgICBvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuUFJPR1JBTU1BVElDX0FDQ0VTU19UT0tFTikge1xuICAgICAgICAgICAgLy8gUEFTU1dPUkQgb3IgVE9LRU4gaXMgbmVlZGVkXG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLnBhc3N3b3JkKSB8fCBVdGlsLmV4aXN0cyhvcHRpb25zLnRva2VuKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QQVNTV09SRCk7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzd29yZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBwYXNzd29yZFxuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLnBhc3N3b3JkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy50b2tlbikpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy50b2tlbiksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT0FVVEhfVE9LRU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSE9SSVpBVElPTl9DT0RFKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5vYXV0aEF1dGhvcml6YXRpb25VcmwpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZFVybDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKG9wdGlvbnMub2F1dGhBdXRob3JpemF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVJbnZhbGlkUGFyYW1ldGVyRXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9BVVRIT1JJWkFUSU9OX1VSTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwOicsIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQVVUSE9SSVpBVElPTl9VUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvcHRpb25zLm9hdXRoQXV0aG9yaXphdGlvblVybCAmJiAhaXNTbm93Zmxha2VIb3N0KG9wdGlvbnMub2F1dGhBdXRob3JpemF0aW9uVXJsKSkgfHxcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybCAmJiAhaXNTbm93Zmxha2VIb3N0KG9wdGlvbnMub2F1dGhUb2tlblJlcXVlc3RVcmwpKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLm9hdXRoQ2xpZW50SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9JRCk7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMub2F1dGhDbGllbnRTZWNyZXQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9TRUNSRVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dGhlbnRpY2F0b3IgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQ0xJRU5UX0NSRURFTlRJQUxTKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkVXJsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwob3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlSW52YWxpZFBhcmFtZXRlckVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfVE9LRU5fUkVRVUVTVF9VUkwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cDonLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX1RPS0VOX1JFUVVFU1RfVVJMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLm9hdXRoQ2xpZW50SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9JRCk7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5vYXV0aENsaWVudFNlY3JldCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQ0xJRU5UX1NFQ1JFVCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29saWRhdGVIb3N0QW5kQWNjb3VudChvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgYWNjZXNzVXJsXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucy5hY2Nlc3NVcmwpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ0VTU19VUkwpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGFjY2Vzc1VybFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLmFjY2Vzc1VybCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDRVNTX1VSTCk7XG4gICAgY29uc3QgcHJveHlIb3N0ID0gb3B0aW9ucy5wcm94eUhvc3Q7XG4gICAgY29uc3QgcHJveHlQb3J0ID0gb3B0aW9ucy5wcm94eVBvcnQ7XG4gICAgY29uc3QgcHJveHlVc2VyID0gb3B0aW9ucy5wcm94eVVzZXI7XG4gICAgY29uc3QgcHJveHlQYXNzd29yZCA9IG9wdGlvbnMucHJveHlQYXNzd29yZDtcbiAgICBjb25zdCBwcm94eVByb3RvY29sID0gb3B0aW9ucy5wcm94eVByb3RvY29sIHx8ICdodHRwJztcbiAgICBjb25zdCBub1Byb3h5ID0gb3B0aW9ucy5ub1Byb3h5O1xuICAgIGNvbnN0IHVzZUZvck9DU1AgPSBvcHRpb25zLnVzZUNvbm5lY3Rpb25Db25maWdQcm94eUZvck9DU1AgPz8gZmFsc2U7XG4gICAgbGV0IG9hdXRoQ2xpZW50SWQgPSBvcHRpb25zLm9hdXRoQ2xpZW50SWQ7XG4gICAgbGV0IG9hdXRoQ2xpZW50U2VjcmV0ID0gb3B0aW9ucy5vYXV0aENsaWVudFNlY3JldDtcbiAgICBjb25zdCBvYXV0aFJlZGlyZWN0VXJpID0gb3B0aW9ucy5vYXV0aFJlZGlyZWN0VXJpO1xuICAgIGNvbnN0IG9hdXRoQXV0aG9yaXphdGlvblVybCA9IG9wdGlvbnMub2F1dGhBdXRob3JpemF0aW9uVXJsO1xuICAgIGNvbnN0IG9hdXRoVG9rZW5SZXF1ZXN0VXJsID0gb3B0aW9ucy5vYXV0aFRva2VuUmVxdWVzdFVybDtcbiAgICBjb25zdCBvYXV0aENoYWxsZW5nZU1ldGhvZCA9IG9wdGlvbnMub2F1dGhDaGFsbGVuZ2VNZXRob2Q7XG4gICAgY29uc3Qgb2F1dGhTY29wZSA9IG9wdGlvbnMub2F1dGhTY29wZTtcbiAgICBjb25zdCBvYXV0aEh0dHBBbGxvd2VkID0gb3B0aW9ucy5vYXV0aEh0dHBBbGxvd2VkO1xuICAgIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gbm9kZSBhbmQgc29tZSBwcm94eSBpbmZvcm1hdGlvbiBpcyBzcGVjaWZpZWRcbiAgICBsZXQgcHJveHk7XG4gICAgaWYgKFV0aWwuaXNOb2RlKCkgJiYgKFV0aWwuZXhpc3RzKHByb3h5SG9zdCkgfHwgVXRpbC5leGlzdHMocHJveHlQb3J0KSkpIHtcbiAgICAgICAgcHJveHkgPSB7XG4gICAgICAgICAgICBob3N0OiBwcm94eUhvc3QsXG4gICAgICAgICAgICBwb3J0OiBwcm94eVBvcnQsXG4gICAgICAgICAgICB1c2VyOiBwcm94eVVzZXIsXG4gICAgICAgICAgICBwYXNzd29yZDogcHJveHlQYXNzd29yZCxcbiAgICAgICAgICAgIHByb3RvY29sOiBwcm94eVByb3RvY29sLFxuICAgICAgICAgICAgbm9Qcm94eTogbm9Qcm94eSxcbiAgICAgICAgICAgIHVzZUZvck9DU1A6IHVzZUZvck9DU1AsXG4gICAgICAgIH07XG4gICAgICAgIFByb3h5VXRpbC52YWxpZGF0ZVByb3h5KHByb3h5KTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmljZU5hbWUgPSBvcHRpb25zLnNlcnZpY2VOYW1lO1xuICAgIGxldCBhdXRoZW50aWNhdG9yID0gb3B0aW9ucy5hdXRoZW50aWNhdG9yO1xuICAgIC8vIGlmIG5vIHZhbHVlIGlzIHNwZWNpZmllZCBmb3IgYXV0aGVudGljYXRvciwgZGVmYXVsdCB0byBTbm93Zmxha2VcbiAgICBpZiAoIVV0aWwuZXhpc3RzKGF1dGhlbnRpY2F0b3IpKSB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3IgPSBBdXRoZW50aWNhdGlvblR5cGVzLkRFRkFVTFRfQVVUSEVOVElDQVRPUjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3IgPSBhdXRoZW50aWNhdG9yLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGxldCBicm93c2VyQWN0aW9uVGltZW91dCA9IG9wdGlvbnMuYnJvd3NlckFjdGlvblRpbWVvdXQ7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYnJvd3NlckFjdGlvblRpbWVvdXQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIoYnJvd3NlckFjdGlvblRpbWVvdXQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0JST1dTRVJfVElNRU9VVCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBicm93c2VyQWN0aW9uVGltZW91dCA9IFdBSVRfRk9SX0JST1dTRVJfQUNUSU9OX1RJTUVPVVQ7XG4gICAgfVxuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBvcHRpb25zLnByaXZhdGVLZXk7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHByaXZhdGVLZXkpICYmIFV0aWwuaXNQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZKTtcbiAgICB9XG4gICAgY29uc3QgcHJpdmF0ZUtleVBhdGggPSBvcHRpb25zLnByaXZhdGVLZXlQYXRoO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnByaXZhdGVLZXlQYXRoKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcocHJpdmF0ZUtleVBhdGgpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZX1BBVEgpO1xuICAgIH1cbiAgICBjb25zdCBwcml2YXRlS2V5UGFzcyA9IG9wdGlvbnMucHJpdmF0ZUtleVBhc3M7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucHJpdmF0ZUtleVBhc3MpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhwcml2YXRlS2V5UGFzcyksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFTUyk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gb3B0aW9ucy50b2tlbjtcbiAgICBpZiAoVXRpbC5leGlzdHModG9rZW4pKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyh0b2tlbiksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT0FVVEhfVE9LRU4pO1xuICAgIH1cbiAgICBjb25zdCB3YXJlaG91c2UgPSBvcHRpb25zLndhcmVob3VzZTtcbiAgICBjb25zdCBkYXRhYmFzZSA9IG9wdGlvbnMuZGF0YWJhc2U7XG4gICAgY29uc3Qgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgY29uc3Qgcm9sZSA9IG9wdGlvbnMucm9sZTtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB3YXJlaG91c2VcbiAgICBpZiAoVXRpbC5leGlzdHMod2FyZWhvdXNlKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcod2FyZWhvdXNlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XQVJFSE9VU0UpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBkYXRhYmFzZVxuICAgIGlmIChVdGlsLmV4aXN0cyhkYXRhYmFzZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGRhdGFiYXNlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9EQVRBQkFTRSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHNjaGVtYVxuICAgIGlmIChVdGlsLmV4aXN0cyhzY2hlbWEpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhzY2hlbWEpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NDSEVNQSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHJvbGVcbiAgICBpZiAoVXRpbC5leGlzdHMocm9sZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHJvbGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JPTEUpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBzdHJlYW1SZXN1bHRcbiAgICBjb25zdCBzdHJlYW1SZXN1bHQgPSBvcHRpb25zLnN0cmVhbVJlc3VsdDtcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RyZWFtUmVzdWx0KSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0cmVhbVJlc3VsdCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfU1RSRUFNX1JFU1VMVCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZldGNoQXNTdHJpbmdcbiAgICBjb25zdCBmZXRjaEFzU3RyaW5nID0gb3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIGlmIChVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNBcnJheShmZXRjaEFzU3RyaW5nKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgICAgIGNvbnN0IGludmFsaWRWYWx1ZUluZGV4ID0gTmF0aXZlVHlwZXMuZmluZEludmFsaWRWYWx1ZShmZXRjaEFzU3RyaW5nKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChpbnZhbGlkVmFsdWVJbmRleCA9PT0gLTEsIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUywgSlNPTi5zdHJpbmdpZnkoZmV0Y2hBc1N0cmluZ1tpbnZhbGlkVmFsdWVJbmRleF0pKTtcbiAgICB9XG4gICAgLy8gUm93IG1vZGUgaXMgb3B0aW9uYWwsIGNhbiBiZSB1bmRlZmluZWRcbiAgICBjb25zdCByb3dNb2RlID0gb3B0aW9ucy5yb3dNb2RlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgICAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlXG4gICAgY29uc3QgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IG9wdGlvbnMuY2xpZW50U2Vzc2lvbktlZXBBbGl2ZTtcbiAgICBpZiAoVXRpbC5leGlzdHMoY2xpZW50U2Vzc2lvbktlZXBBbGl2ZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihjbGllbnRTZXNzaW9uS2VlcEFsaXZlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeVxuICAgIGxldCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5ID0gb3B0aW9ucy5jbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5O1xuICAgIGlmIChVdGlsLmV4aXN0cyhjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNOdW1iZXIoY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUSk7XG4gICAgICAgIGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kgPVxuICAgICAgICAgICAgVXRpbC52YWxpZGF0ZUNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3koY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSwgQ29ubmVjdGlvbkNvbnN0YW50cy5IRUFSVEJFQVRfRlJFUVVFTkNZX01BU1RFUl9WQUxJRElUWSk7XG4gICAgfVxuICAgIGNvbnN0IGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQgPSBvcHRpb25zLmpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQ7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oanNUcmVhdEludGVnZXJBc0JpZ0ludCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQpO1xuICAgIH1cbiAgICBjb25zdCBnY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCA9IG9wdGlvbnMuZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWw7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9HQ1NfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudENvbmZpZ0ZpbGUgPSBvcHRpb25zLmNsaWVudENvbmZpZ0ZpbGU7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNsaWVudENvbmZpZ0ZpbGUpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhjbGllbnRDb25maWdGaWxlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfQ09ORklHX0ZJTEUpO1xuICAgIH1cbiAgICAvLyByZW1lbWJlciBpZiB3ZSdyZSBpbiBxYSBtb2RlXG4gICAgdGhpcy5fcWFNb2RlID0gcWFNb2RlO1xuICAgIC8vIGlmIGEgY2xpZW50LWluZm8gYXJndW1lbnQgaXMgc3BlY2lmaWVkLCB2YWxpZGF0ZSBpdFxuICAgIGNvbnN0IGNsaWVudFR5cGUgPSAnSmF2YVNjcmlwdCc7XG4gICAgbGV0IGNsaWVudE5hbWU7XG4gICAgbGV0IGNsaWVudFZlcnNpb247XG4gICAgbGV0IGNsaWVudEVudmlyb25tZW50O1xuICAgIGlmIChVdGlsLmV4aXN0cyhjbGllbnRJbmZvKSkge1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjbGllbnRJbmZvKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKGNsaWVudEluZm8udmVyc2lvbikpO1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjbGllbnRJbmZvLmVudmlyb25tZW50KSk7XG4gICAgICAgIGNsaWVudE5hbWUgPSBjbGllbnRJbmZvLm5hbWU7XG4gICAgICAgIGNsaWVudFZlcnNpb24gPSBjbGllbnRJbmZvLnZlcnNpb247XG4gICAgICAgIGNsaWVudEVudmlyb25tZW50ID0gY2xpZW50SW5mby5lbnZpcm9ubWVudDtcbiAgICAgICAgY2xpZW50RW52aXJvbm1lbnQuT1MgPSBvcy5wbGF0Zm9ybSgpO1xuICAgICAgICBjbGllbnRFbnZpcm9ubWVudC5PU19WRVJTSU9OID0gb3MucmVsZWFzZSgpO1xuICAgICAgICBjbGllbnRFbnZpcm9ubWVudC5PQ1NQX01PREUgPSBHbG9iYWxDb25maWcuZ2V0T2NzcE1vZGUoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50QXBwbGljYXRpb24gPSBvcHRpb25zLmFwcGxpY2F0aW9uO1xuICAgIGlmIChVdGlsLmV4aXN0cyhjbGllbnRBcHBsaWNhdGlvbikpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGNsaWVudEFwcGxpY2F0aW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUFBMSUNBVElPTik7XG4gICAgICAgIGNvbnN0IEFQUExJQ0FUSU9OX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYF5bQS1aYS16XShbQS1aYS16MC05LlxcLV9dKXsxLDUwfSRgLCAnZ2knKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChBUFBMSUNBVElPTl9QQVRURVJOLnRlc3QoY2xpZW50QXBwbGljYXRpb24pLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FQUExJQ0FUSU9OKTtcbiAgICB9XG4gICAgbGV0IHZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy52YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB2YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy52YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9WQUxJREFURV9ERUZBVUxUX1BBUkFNRVRFUlMpO1xuICAgICAgICB2YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzID0gb3B0aW9ucy52YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICBsZXQgYmluZFRocmVzaG9sZCA9IG51bGw7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYXJyYXlCaW5kaW5nVGhyZXNob2xkKSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBhcnJheUJpbmRpbmdUaHJlc2hvbGRcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuYXJyYXlCaW5kaW5nVGhyZXNob2xkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCk7XG4gICAgICAgIGJpbmRUaHJlc2hvbGQgPSBvcHRpb25zLmFycmF5QmluZGluZ1RocmVzaG9sZDtcbiAgICB9XG4gICAgbGV0IGZvcmNlU3RhZ2VCaW5kRXJyb3IgPSBudWxsO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmZvcmNlU3RhZ2VCaW5kRXJyb3IpKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZvcmNlU3RhZ2VCaW5kRXJyb3JcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuZm9yY2VTdGFnZUJpbmRFcnJvciksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfU1RBR0VfQklORF9FUlJPUik7XG4gICAgICAgIGZvcmNlU3RhZ2VCaW5kRXJyb3IgPSBvcHRpb25zLmZvcmNlU3RhZ2VCaW5kRXJyb3I7XG4gICAgfVxuICAgIGxldCBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVEX1FVRVJZX0NPTlRFWFRfQ0FDSEUpO1xuICAgICAgICBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBvcHRpb25zLmRpc2FibGVRdWVyeUNvbnRleHRDYWNoZTtcbiAgICB9XG4gICAgbGV0IHJldHJ5VGltZW91dCA9IDMwMDtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5yZXRyeVRpbWVvdXQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihvcHRpb25zLnJldHJ5VGltZW91dCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfTUFYX1JFVFJZX1RJTUVPVVQpO1xuICAgICAgICByZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCAhPT0gMCA/IE1hdGgubWF4KHJldHJ5VGltZW91dCwgb3B0aW9ucy5yZXRyeVRpbWVvdXQpIDogMDtcbiAgICB9XG4gICAgbGV0IGluY2x1ZGVSZXRyeVJlYXNvbiA9IHRydWU7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9JTkNMVURFX1JFVFJZX1JFQVNPTik7XG4gICAgICAgIGluY2x1ZGVSZXRyeVJlYXNvbiA9IG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uO1xuICAgIH1cbiAgICBsZXQgY2xpZW50UmVxdWVzdE1GQVRva2VuID0gZmFsc2U7XG4gICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuY2xpZW50UmVxdWVzdE1GQVRva2VuKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuY2xpZW50UmVxdWVzdE1GQVRva2VuKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfUkVRVUVTVF9NRkFfVE9LRU4pO1xuICAgICAgICBjbGllbnRSZXF1ZXN0TUZBVG9rZW4gPSBvcHRpb25zLmNsaWVudFJlcXVlc3RNRkFUb2tlbjtcbiAgICB9XG4gICAgbGV0IGRpc2FibGVDb25zb2xlTG9naW4gPSB0cnVlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmRpc2FibGVDb25zb2xlTG9naW4pKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlQ29uc29sZUxvZ2luKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ESVNBQkxFX0NPTlNPTEVfTE9HSU4pO1xuICAgICAgICBkaXNhYmxlQ29uc29sZUxvZ2luID0gb3B0aW9ucy5kaXNhYmxlQ29uc29sZUxvZ2luO1xuICAgIH1cbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuZm9yY2VHQ1BVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwpO1xuICAgICAgICBwcm9jZXNzLmVudi5TTk9XRkxBS0VfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgPVxuICAgICAgICAgICAgb3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuU05PV0ZMQUtFX0ZPUkNFX0dDUF9VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnJlcHJlc2VudE51bGxBc1N0cmluZ051bGwpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5yZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRVBSRVNFTlRfTlVMTF9BU19TVFJJTkdfTlVMTCk7XG4gICAgICAgIERhdGFUeXBlcy5zZXRJc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwob3B0aW9ucy5yZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsKTtcbiAgICB9XG4gICAgbGV0IGRpc2FibGVTYW1sVVJMQ2hlY2sgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5kaXNhYmxlU2FtbFVSTENoZWNrKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZVNhbWxVUkxDaGVjayksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9TQU1MX1VSTF9DSEVDSyk7XG4gICAgICAgIGRpc2FibGVTYW1sVVJMQ2hlY2sgPSBvcHRpb25zLmRpc2FibGVTYW1sVVJMQ2hlY2s7XG4gICAgfVxuICAgIGxldCBjbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwgPSBmYWxzZTtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5jbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5jbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9TVE9SRV9URU1QT1JBUllfQ1JFREVOVElBTCk7XG4gICAgICAgIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCA9IG9wdGlvbnMuY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsO1xuICAgIH1cbiAgICBsZXQgY3JlZGVudGlhbENhY2hlRGlyID0gbnVsbDtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5jcmVkZW50aWFsQ2FjaGVEaXIpKSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmNyZWRlbnRpYWxDYWNoZURpcik7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC52YWxpZGF0ZVBhdGgoYWJzb2x1dGVQYXRoKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DUkVERU5USUFMX0NBQ0hFX0RJUik7XG4gICAgICAgIGNyZWRlbnRpYWxDYWNoZURpciA9IGFic29sdXRlUGF0aDtcbiAgICB9XG4gICAgbGV0IHBhc3Njb2RlSW5QYXNzd29yZCA9IGZhbHNlO1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREVfSU5fUEFTU1dPUkQpO1xuICAgICAgICBwYXNzY29kZUluUGFzc3dvcmQgPSBvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZDtcbiAgICB9XG4gICAgbGV0IHBhc3Njb2RlID0gbnVsbDtcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzY29kZSkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMucGFzc2NvZGUpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NDT0RFKTtcbiAgICAgICAgcGFzc2NvZGUgPSBvcHRpb25zLnBhc3Njb2RlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5xdWVyeVRhZykge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5xdWVyeVRhZykgJiYgb3B0aW9ucy5xdWVyeVRhZy5sZW5ndGggPD0gMjAwMCwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9RVUVSWV9UQUcpO1xuICAgICAgICB0aGlzLnF1ZXJ5VGFnID0gb3B0aW9ucy5xdWVyeVRhZztcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKCFERUZBVUxUX1BBUkFNUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbGV2ZW5zaHRlaW4uY2xvc2VzdChrZXksIERFRkFVTFRfUEFSQU1TKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgJyR7a2V5fScgaXMgYW4gdW5rbm93biBjb25uZWN0aW9uIHBhcmFtZXRlci4gRGlkIHlvdSBtZWFuICcke3Jlc3VsdH0nP2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3h5IGhvc3RuYW1lLCBwb3J0LFxuICAgICAqIGV0Yy4gZm9yIHdoZW4gaHR0cCByZXF1ZXN0cyBhcmUgbWFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FyZWhvdXNlIHRvIGF1dG9tYXRpY2FsbHkgdXNlIG9uY2UgYSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0V2FyZWhvdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2FyZWhvdXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YWJhc2UgdG8gYXV0b21hdGljYWxseSB1c2Ugb25jZSBhIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICAgKiBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXREYXRhYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFiYXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2NoZW1hIHRvIGF1dG9tYXRpY2FsbHkgdXNlIG9uY2UgYSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9sZSB0byBhdXRvbWF0aWNhbGx5IHVzZSBvbmNlIGEgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgICAqIGVzdGFibGlzaGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFJvbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByb2xlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2VydmljZSBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlcnZpY2VOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZU5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdXRoZW50aWNhdG9yIHRvIHVzZSBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRBdXRoZW50aWNhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWVvdXQgaW4gbWlsbGlzIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW9uIGJ5IGV4dGVybmFsIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QnJvd3NlckFjdGlvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBicm93c2VyQWN0aW9uVGltZW91dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IGZpbGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UHJpdmF0ZUtleVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5UGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IHBhc3NwaHJhc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UHJpdmF0ZUtleVBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5UGFzcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9BdXRoIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJlYW1SZXN1bHQgZmxhZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RyZWFtUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmV0Y2hBc1N0cmluZyBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLmdldEZldGNoQXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaEFzU3RyaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm93TW9kZSBzdHJpbmcgdmFsdWUgKCdhcnJheScsICdvYmplY3QnIG9yICdvYmplY3Rfd2l0aF9yZW5hbWVkX2R1cGxpY2F0ZWRfY29sdW1ucycpLiBDb3VsZCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zICB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Um93TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJvd01vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRDbGllbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xpZW50VHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNsaWVudCBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGllbnROYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50IHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFZlcnNpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgYXBwbGljYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50QXBwbGljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRBcHBsaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIG9iamVjdCBjb250YWluaW5nIHZlcnNpb24gaW5mb3JtYXRpb24gZm9yIGFsbCB0aGUgdmFyaW91c1xuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHJ1bnRpbWUsIGUuZy4gbm9kZSwgdjgsIG9wZW5zc2wsIGV0Yy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRDbGllbnRFbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudEVudmlyb25tZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50IHNlc3Npb24ga2VlcCBhbGl2ZSBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRTZXNzaW9uS2VlcEFsaXZlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2xpZW50IHNlc3Npb24ga2VlcCBhbGl2ZSBoZWFydGJlYXQgZnJlcXVlbmN5IHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgdHJlYXQgaW50ZWdlciBhcyBzZXR0aW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXR0aW5nIGZvciB0aGUgR0NTX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgc2Vzc2lvbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRHY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmluZCB0aHJlc2hvbGRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRiaW5kVGhyZXNob2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmluZFRocmVzaG9sZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZvcmNlIHN0YWdlIGJpbmQgZXJyb3JcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRGb3JjZVN0YWdlQmluZEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm9yY2VTdGFnZUJpbmRFcnJvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgUmV0cnkgcmVhc29uIGlzIGluY2x1ZGVkIG9yIG5vdCBpbiB0aGUgcmV0cnkgdXJsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldEluY2x1ZGVSZXRyeVJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVSZXRyeVJlYXNvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgUXVlcnkgQ29udGV4dCBDYWNoZSBpcyBlbmFibGVkIG9yIG5vdCBieSB0aGUgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5nZXREaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgY29uZmlnIGZpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRDbGllbnRDb25maWdGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2xpZW50Q29uZmlnRmlsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heCBsb2dpbiB0aW1lb3V0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UmV0cnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmV0cnlUaW1lb3V0O1xuICAgIH07XG4gICAgdGhpcy5nZXREaXNhYmxlQ29uc29sZUxvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGlzYWJsZUNvbnNvbGVMb2dpbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU0FNTCBVUkwgY2hlY2sgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldERpc2FibGVTYW1sVVJMQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkaXNhYmxlU2FtbFVSTENoZWNrO1xuICAgIH07XG4gICAgdGhpcy5nZXRDcmVkZW50aWFsQ2FjaGVEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsQ2FjaGVEaXI7XG4gICAgfTtcbiAgICB0aGlzLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFJlcXVlc3RNRkFUb2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgYXV0aCB0b2tlbiBzYXZlcyBvbiB0aGUgbG9jYWwgbWFjaGluZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UGFzc2NvZGVJblBhc3N3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFzc2NvZGVJblBhc3N3b3JkO1xuICAgIH07XG4gICAgdGhpcy5nZXRQYXNzY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhc3Njb2RlO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aENsaWVudElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIVV0aWwuaXNOb3RFbXB0eVN0cmluZyhvcHRpb25zLm9hdXRoQ2xpZW50SWQpICYmXG4gICAgICAgICAgICAhVXRpbC5pc05vdEVtcHR5U3RyaW5nKG9wdGlvbnMub2F1dGhDbGllbnRTZWNyZXQpICYmXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSAmJlxuICAgICAgICAgICAgaXNTbm93Zmxha2VIb3N0KHRoaXMuZ2V0T2F1dGhBdXRob3JpemF0aW9uVXJsKCkpICYmXG4gICAgICAgICAgICBpc1Nub3dmbGFrZUhvc3QodGhpcy5nZXRPYXV0aFRva2VuUmVxdWVzdFVybCgpKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBvYXV0aENsaWVudElkOiAke0xPQ0FMX0FQUExJQ0FUSU9OX0NMSUVOVF9DUkVERU5USUFMfWApO1xuICAgICAgICAgICAgb2F1dGhDbGllbnRJZCA9IExPQ0FMX0FQUExJQ0FUSU9OX0NMSUVOVF9DUkVERU5USUFMO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYXV0aENsaWVudElkO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aENsaWVudFNlY3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm9hdXRoQ2xpZW50SWQgJiZcbiAgICAgICAgICAgICFvcHRpb25zLm9hdXRoQ2xpZW50U2VjcmV0ICYmXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yID09PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhPUklaQVRJT05fQ09ERSAmJlxuICAgICAgICAgICAgaXNTbm93Zmxha2VIb3N0KHRoaXMuZ2V0T2F1dGhBdXRob3JpemF0aW9uVXJsKCkpICYmXG4gICAgICAgICAgICBpc1Nub3dmbGFrZUhvc3QodGhpcy5nZXRPYXV0aFRva2VuUmVxdWVzdFVybCgpKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBvYXV0aENsaWVudFNlY3JldDogJHtMT0NBTF9BUFBMSUNBVElPTl9DTElFTlRfQ1JFREVOVElBTH1gKTtcbiAgICAgICAgICAgIG9hdXRoQ2xpZW50U2VjcmV0ID0gTE9DQUxfQVBQTElDQVRJT05fQ0xJRU5UX0NSRURFTlRJQUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9hdXRoQ2xpZW50U2VjcmV0O1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aEF1dGhvcml6YXRpb25VcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYXV0aEF1dGhvcml6YXRpb25VcmwgPz8gb3B0aW9ucy5hY2Nlc3NVcmwgKyBTTk9XRkxBS0VfQVVUSE9SSVpFX0VORFBPSU5UO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aFRva2VuUmVxdWVzdFVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoVG9rZW5SZXF1ZXN0VXJsID8/IG9wdGlvbnMuYWNjZXNzVXJsICsgU05PV0ZMQUtFX1RPS0VOX1JFUVVFU1RfRU5EUE9JTlQ7XG4gICAgfTtcbiAgICB0aGlzLmdldE9hdXRoUmVkaXJlY3RVcmkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYXV0aFJlZGlyZWN0VXJpO1xuICAgIH07XG4gICAgdGhpcy5nZXRPYXV0aFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2F1dGhTY29wZTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2F1dGhDaGFsbGVuZ2VNZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYXV0aENoYWxsZW5nZU1ldGhvZDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2F1dGhIdHRwQWxsb3dlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoSHR0cEFsbG93ZWQgfHwgZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF0dHJpYnV0ZXMgb2YgQ29ubmVjdGlvbiBDb25maWcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnlcbiAgICAgKiB0aGUgY29ubmVjdGlvbiwgd2hlbiBJRCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBzY29wZS4gVGhpcyBpcyBub3Qgc3VmZmljaWVudCBzZXQsXG4gICAgICogc2luY2UgbXVsdGlwbGUgY29ubmVjdGlvbnMgY2FuIGJlIGluc3RhbnRpYXRlZCBmb3IgdGhlIHNhbWUgY29uZmlnLCBidXQgY2FuIGJlIHRyZWF0ZWQgYXMgYSBoaW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NyaWJlSWRlbnRpdHlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGBob3N0OiAke3RoaXMuaG9zdH0sIGFjY291bnQ6ICR7dGhpcy5hY2NvdW50fSwgYWNjZXNzVXJsOiAke3RoaXMuYWNjZXNzVXJsfSwgYCArXG4gICAgICAgICAgICBgdXNlcjogJHt0aGlzLnVzZXJuYW1lfSwgcm9sZTogJHt0aGlzLmdldFJvbGUoKX0sIGRhdGFiYXNlOiAke3RoaXMuZ2V0RGF0YWJhc2UoKX0sIGAgK1xuICAgICAgICAgICAgYHNjaGVtYTogJHt0aGlzLmdldFNjaGVtYSgpfSwgd2FyZWhvdXNlOiAke3RoaXMuZ2V0V2FyZWhvdXNlKCl9LCBgICtcbiAgICAgICAgICAgIFByb3h5VXRpbC5kZXNjcmliZVByb3h5KHRoaXMuZ2V0UHJveHkoKSkpO1xuICAgIH07XG4gICAgLy8gTk9URTpcbiAgICAvLyBEb24ndCBhZGQgbmV3IGdldCogbWV0aG9kcyB3aGVuIGltcGxlbWVudGluZyBuZXcgb3B0aW9ucy4gVXNlIHRoaXMub3B0aW9uTmFtZSBpbnN0ZWFkLlxuICAgIC8vIElmIHlvdSBuZWVkIGFkdmFuY2VkIGxvZ2ljIGluIGdldHRlciwgdXNlIEpTIG9iamVjdCBnZXR0ZXJzLlxuICAgIC8vXG4gICAgLy8gRnV0dXJlIHBsYW4gaXMgdG8gcmVkdWNlIGNvbXBsZXhpdHkgb2YgdGhpcyBmaWxlIGJ5IG1lcmdpbmcgMyBvYmplY3RzIGludG8gb25lIGNvbnRleHQ6XG4gICAgLy8gZGVmYXVsdHMrb3B0aW9ucytjdXN0b20gZ2V0dGVycyA9IENvbm5lY3Rpb25Db25maWdcbiAgICB0aGlzLnVzZXJuYW1lID0gb3B0aW9ucy51c2VybmFtZTtcbiAgICB0aGlzLnBhc3N3b3JkID0gb3B0aW9ucy5wYXNzd29yZDtcbiAgICB0aGlzLmFjY2Vzc1VybCA9IG9wdGlvbnMuYWNjZXNzVXJsO1xuICAgIHRoaXMucmVnaW9uID0gb3B0aW9ucy5yZWdpb247XG4gICAgdGhpcy5hY2NvdW50ID0gb3B0aW9ucy5hY2NvdW50O1xuICAgIHRoaXMudG9rZW4gPSBvcHRpb25zLnRva2VuO1xuICAgIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IG9wdGlvbnMuc2Vzc2lvblRva2VuO1xuICAgIHRoaXMubWFzdGVyVG9rZW4gPSBvcHRpb25zLm1hc3RlclRva2VuO1xuICAgIHRoaXMubWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IG9wdGlvbnMubWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lID0gb3B0aW9ucy5zZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICB0aGlzLmNsaWVudENvbmZpZ0ZpbGUgPSBvcHRpb25zLmNsaWVudENvbmZpZ0ZpbGU7XG4gICAgdGhpcy5vcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2sgPSBvcHRpb25zLm9wZW5FeHRlcm5hbEJyb3dzZXJDYWxsYmFjaztcbiAgICB0aGlzLm9hdXRoRW5hYmxlU2luZ2xlVXNlUmVmcmVzaFRva2VucyA9IG9wdGlvbnMub2F1dGhFbmFibGVTaW5nbGVVc2VSZWZyZXNoVG9rZW5zO1xuICAgIHRoaXMud29ya2xvYWRJZGVudGl0eVByb3ZpZGVyID0gb3B0aW9ucy53b3JrbG9hZElkZW50aXR5UHJvdmlkZXI7XG4gICAgdGhpcy53b3JrbG9hZElkZW50aXR5QXp1cmVFbnRyYUlkUmVzb3VyY2UgPSBvcHRpb25zLndvcmtsb2FkSWRlbnRpdHlBenVyZUVudHJhSWRSZXNvdXJjZTtcbiAgICB0aGlzLmNybFZhbGlkYXRvckNvbmZpZyA9IHtcbiAgICAgICAgY2hlY2tNb2RlOiBvcHRpb25zLmNlcnRSZXZvY2F0aW9uQ2hlY2tNb2RlID8/ICdESVNBQkxFRCcsXG4gICAgICAgIGFsbG93Q2VydGlmaWNhdGVzV2l0aG91dENybFVSTDogb3B0aW9ucy5jcmxBbGxvd0NlcnRpZmljYXRlc1dpdGhvdXRDcmxVUkwgPz8gZmFsc2UsXG4gICAgICAgIGluTWVtb3J5Q2FjaGU6IG9wdGlvbnMuY3JsSW5NZW1vcnlDYWNoZSA/PyB0cnVlLFxuICAgICAgICBvbkRpc2tDYWNoZTogb3B0aW9ucy5jcmxPbkRpc2tDYWNoZSA/PyB0cnVlLFxuICAgIH07XG4gICAgLy8gY3JlYXRlIHRoZSBwYXJhbWV0ZXJzIGFycmF5XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IGNyZWF0ZVBhcmFtZXRlcnMoKTtcbiAgICAvLyBjcmVhdGUgYSBtYXAgaW4gd2hpY2ggdGhlIGtleXMgYXJlIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlXG4gICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyc1xuICAgIGNvbnN0IG1hcFBhcmFtZXRlcnMgPSB7fTtcbiAgICBsZXQgaW5kZXgsIGxlbmd0aCwgcGFyYW1ldGVyO1xuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBwYXJhbWV0ZXJzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpbmRleF07XG4gICAgICAgIG1hcFBhcmFtZXRlcnNbcGFyYW1ldGVyLm5hbWVdID0gcGFyYW1ldGVyO1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB2YWx1ZSB0byB0aGUgZGVmYXVsdFxuICAgICAgICBwYXJhbWV0ZXIudmFsdWUgPSBwYXJhbWV0ZXIuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICAvLyBmb3IgZWFjaCBwcm9wZXJ0eSBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdGhhdCBtYXRjaGVzIGEga25vd24gcGFyYW1ldGVyIG5hbWVcbiAgICBsZXQgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlO1xuICAgIGZvciAocHJvcGVydHlOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBwcm9wZXJ0eU5hbWUpICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwUGFyYW1ldGVycywgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmFtZXRlciBtYXRjaGluZyB0aGUgcHJvcGVydHkgaXMgZXh0ZXJuYWwgYW5kIHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGZvciB0aGUgcGFyYW1ldGVyLCB1cGRhdGUgdGhlIHBhcmFtZXRlciB2YWx1ZVxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IG9wdGlvbnNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIHBhcmFtZXRlciA9IG1hcFBhcmFtZXRlcnNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXIuZXh0ZXJuYWwgJiYgcGFyYW1ldGVyLnZhbGlkYXRlKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyLnZhbHVlID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzYXZlIHRoZSBwYXJhbWV0ZXJzIG1hcFxuICAgIHRoaXMuX21hcFBhcmFtZXRlcnMgPSBtYXBQYXJhbWV0ZXJzO1xuICAgIC8vIGN1c3RvbSBhZ2VudCBjbGFzcywgdGVzdCBvbmx5XG4gICAgdGhpcy5hZ2VudENsYXNzID0gb3B0aW9ucy5hZ2VudENsYXNzO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHFhLW1vZGUgaXMgb24uXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmlzUWFNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9xYU1vZGU7XG59O1xuLyoqXG4gKiBDbGVhcnMgYWxsIGNyZWRlbnRpYWwtcmVsYXRlZCBpbmZvcm1hdGlvbi5cbiAqL1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuY2xlYXJDcmVkZW50aWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhciB0aGUgcGFzc3dvcmRcbiAgICB0aGlzLnBhc3N3b3JkID0gbnVsbDtcbiAgICAvLyBUT0RPOiBjbGVhciBwYXNzY29kZSBhbmQgb3RoZXIgY3JlZGVudGlhbC1yZWxhdGVkIGluZm9ybWF0aW9uIGFzIHdlbGxcbn07XG5jb25zdCBQQVJBTV9USU1FT1VUID0gJ3RpbWVvdXQnO1xuY29uc3QgUEFSQU1fUkVTVUxUX1BSRUZFVENIID0gJ3Jlc3VsdFByZWZldGNoJztcbmNvbnN0IFBBUkFNX1JFU1VMVF9TVFJFQU1fSU5URVJSVVBUUyA9ICdyZXN1bHRTdHJlYW1JbnRlcnJ1cHRzJztcbmNvbnN0IFBBUkFNX1JFU1VMVF9DSFVOS19DQUNIRV9TSVpFID0gJ3Jlc3VsdENodW5rQ2FjaGVTaXplJztcbmNvbnN0IFBBUkFNX1JFU1VMVF9QUk9DRVNTSU5HX0JBVENIX1NJWkUgPSAncmVzdWx0UHJvY2Vzc2luZ0JhdGNoU2l6ZSc7XG5jb25zdCBQQVJBTV9SRVNVTFRfUFJPQ0VTU0lOR19CQVRDSF9EVVJBVElPTiA9ICdyZXN1bHRQcm9jZXNzaW5nQmF0Y2hEdXJhdGlvbic7XG5jb25zdCBQQVJBTV9ST1dfU1RSRUFNX0hJR0hfV0FURVJfTUFSSyA9ICdyb3dTdHJlYW1IaWdoV2F0ZXJNYXJrJztcbmNvbnN0IFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX05VTV9SRVRSSUVTID0gJ2xhcmdlUmVzdWx0U2V0UmV0cnlNYXhOdW1SZXRyaWVzJztcbmNvbnN0IFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX1NMRUVQX1RJTUUgPSAnbGFyZ2VSZXN1bHRTZXRSZXRyeU1heFNsZWVwVGltZSc7XG5jb25zdCBQQVJBTV9SRVRSWV9TRl9NQVhfTE9HSU5fUkVUUklFUyA9ICdzZlJldHJ5TWF4TG9naW5SZXRyaWVzJztcbmNvbnN0IFBBUkFNX1JFVFJZX1NGX01BWF9OVU1fUkVUUklFUyA9ICdzZlJldHJ5TWF4TnVtUmV0cmllcyc7XG5jb25zdCBQQVJBTV9SRVRSWV9TRl9TVEFSVElOR19TTEVFUF9USU1FID0gJ3NmUmV0cnlTdGFydGluZ1NsZWVwVGltZSc7XG5jb25zdCBQQVJBTV9SRVRSWV9TRl9NQVhfU0xFRVBfVElNRSA9ICdzZlJldHJ5TWF4U2xlZXBUaW1lJztcbi8qKlxuICogQ3JlYXRlcyB0aGUgbGlzdCBvZiBrbm93biBwYXJhbWV0ZXJzLiBJZiBhIHBhcmFtZXRlciBpcyBtYXJrZWQgYXMgZXh0ZXJuYWwsXG4gKiBpdHMgdmFsdWUgY2FuIGJlIG92ZXJyaWRkZW4gYnkgYWRkaW5nIHRoZSBhcHByb3ByaWF0ZSBuYW1lLXZhbHVlIG1hcHBpbmcgdG9cbiAqIHRoZSBDb25uZWN0aW9uQ29uZmlnIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gVXRpbC5udW1iZXIuaXNOb25OZWdhdGl2ZUludGVnZXIuYmluZChVdGlsLm51bWJlcik7XG4gICAgY29uc3QgaXNQb3NpdGl2ZUludGVnZXIgPSBVdGlsLm51bWJlci5pc1Bvc2l0aXZlSW50ZWdlci5iaW5kKFV0aWwubnVtYmVyKTtcbiAgICBjb25zdCBpc05vbk5lZ2F0aXZlTnVtYmVyID0gVXRpbC5udW1iZXIuaXNOb25OZWdhdGl2ZS5iaW5kKFV0aWwubnVtYmVyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9USU1FT1VULFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiA5MCAqIDEwMDAsXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVTVUxUX1BSRUZFVENILFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAyLFxuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNQb3NpdGl2ZUludGVnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JFU1VMVF9TVFJFQU1fSU5URVJSVVBUUyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMyxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZm9yIG5vdyB3ZSBzZXQgY2h1bmsgY2FjaGUgc2l6ZSB0byAxLCB3aGljaCBpcyBzYW1lIGFzXG4gICAgICAgIC8vIGRpc2FibGluZyB0aGUgY2h1bmsgY2FjaGUuIE90aGVyd2lzZSwgY2FjaGUgd2lsbCBleHBsb2RlXG4gICAgICAgIC8vIG1lbW9yeSB3aGVuIGZldGNoaW5nIGxhcmdlIHJlc3VsdCBzZXRcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVTVUxUX0NIVU5LX0NBQ0hFX1NJWkUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNQb3NpdGl2ZUludGVnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JFU1VMVF9QUk9DRVNTSU5HX0JBVENIX1NJWkUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEwMDAsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNQb3NpdGl2ZUludGVnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JFU1VMVF9QUk9DRVNTSU5HX0JBVENIX0RVUkFUSU9OLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAxMDAsXG4gICAgICAgICAgICB2YWxpZGF0ZTogaXNQb3NpdGl2ZUludGVnZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JPV19TVFJFQU1fSElHSF9XQVRFUl9NQVJLLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAxMCxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVUUllfTEFSR0VfUkVTVUxUX1NFVF9NQVhfTlVNX1JFVFJJRVMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDEwLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVRSWV9MQVJHRV9SRVNVTFRfU0VUX01BWF9TTEVFUF9USU1FLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAxNixcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc05vbk5lZ2F0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVUUllfU0ZfTUFYX0xPR0lOX1JFVFJJRVMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDcsXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc05vbk5lZ2F0aXZlSW50ZWdlcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogUEFSQU1fUkVUUllfU0ZfTUFYX05VTV9SRVRSSUVTLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAxMDAwLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBQQVJBTV9SRVRSWV9TRl9TVEFSVElOR19TTEVFUF9USU1FLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAxLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGlzTm9uTmVnYXRpdmVOdW1iZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFBBUkFNX1JFVFJZX1NGX01BWF9TTEVFUF9USU1FLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAxNixcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpc05vbk5lZ2F0aXZlTnVtYmVyLFxuICAgICAgICB9LFxuICAgIF07XG59XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9USU1FT1VUKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXN1bHRQcmVmZXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVTVUxUX1BSRUZFVENIKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXN1bHRTdHJlYW1JbnRlcnJ1cHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVNVTFRfU1RSRUFNX0lOVEVSUlVQVFMpO1xufTtcbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJlc3VsdENodW5rQ2FjaGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVNVTFRfQ0hVTktfQ0FDSEVfU0laRSk7XG59O1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmVzdWx0UHJvY2Vzc2luZ0JhdGNoU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfU0laRSk7XG59O1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmVzdWx0UHJvY2Vzc2luZ0JhdGNoRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFU1VMVF9QUk9DRVNTSU5HX0JBVENIX0RVUkFUSU9OKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSb3dTdHJlYW1IaWdoV2F0ZXJNYXJrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9ST1dfU1RSRUFNX0hJR0hfV0FURVJfTUFSSyk7XG59O1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmV0cnlMYXJnZVJlc3VsdFNldE1heE51bVJldHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX05VTV9SRVRSSUVTKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXRyeUxhcmdlUmVzdWx0U2V0TWF4U2xlZXBUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVRSWV9MQVJHRV9SRVNVTFRfU0VUX01BWF9TTEVFUF9USU1FKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXRyeVNmTWF4TnVtUmV0cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVUUllfU0ZfTUFYX05VTV9SRVRSSUVTKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXRyeVNmTWF4TG9naW5SZXRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVRSWV9TRl9NQVhfTE9HSU5fUkVUUklFUyk7XG59O1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmV0cnlTZlN0YXJ0aW5nU2xlZXBUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVRSWV9TRl9TVEFSVElOR19TTEVFUF9USU1FKTtcbn07XG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXRyeVNmTWF4U2xlZXBUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVRSWV9TRl9NQVhfU0xFRVBfVElNRSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGNvbm5lY3Rpb24gY29uZmlnIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5fZ2V0UGFyYW1ldGVyVmFsdWUgPSBmdW5jdGlvbiAocGFyYW1ldGVyTmFtZSkge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHRoaXMuX21hcFBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV07XG4gICAgcmV0dXJuIHBhcmFtZXRlciA/IHBhcmFtZXRlci52YWx1ZSA6IHVuZGVmaW5lZDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25Db25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uX2NvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst SfService = __webpack_require__(/*! ../services/sf */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/services/sf.js\");\nconst LargeResultSetService = __webpack_require__(/*! ../services/large_result_set */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * Creates a new ConnectionContext.\n *\n * @param {ConnectionConfig} connectionConfig\n * @param {Object} httpClient\n * @param {Object} config\n *\n * @constructor\n */\nfunction ConnectionContext(connectionConfig, httpClient, config) {\n    // validate input\n    Logger.getInstance().trace('Creating ConnectionContext object.');\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    Errors.assertInternal(Util.isObject(httpClient));\n    // if a config object was specified, verify\n    // that it has all the information we need\n    let sfServiceConfig;\n    if (Util.exists(config)) {\n        Logger.getInstance().trace('ConnectionContext - validating received config.');\n        Errors.assertInternal(Util.isObject(config));\n        Errors.assertInternal(Util.isObject(config.services));\n        Errors.assertInternal(Util.isObject(config.services.sf));\n        sfServiceConfig = config.services.sf;\n    }\n    Logger.getInstance().debug('ConnectionContext - received data was validated.');\n    // create a map that contains all the services we'll be using\n    const services = {\n        sf: new SfService(connectionConfig, httpClient, sfServiceConfig),\n        largeResultSet: new LargeResultSetService(connectionConfig, httpClient),\n    };\n    Logger.getInstance().debug('ConnectionContext - services were instantiated.');\n    /**\n     * Returns the ConnectionConfig for use by the connection.\n     *\n     * @returns {ConnectionConfig}\n     */\n    this.getConnectionConfig = function () {\n        return connectionConfig;\n    };\n    /**\n     * Returns a map that contains all the available services.\n     *\n     * @returns {Object}\n     */\n    this.getServices = function () {\n        return services;\n    };\n    /**\n     * Returns a configuration object that can be passed as an optional argument\n     * to the ConnectionContext constructor to create a new object that has the\n     * same state as this ConnectionContext instance.\n     *\n     * @returns {Object}\n     */\n    this.getConfig = function () {\n        return {\n            services: {\n                sf: services.sf.getConfig(),\n            },\n        };\n    };\n    /**\n     * Returns instance of httpClient\n     *\n     * @returns {NodeHttpClient}\n     */\n    this.getHttpClient = function () {\n        return httpClient;\n    };\n}\nmodule.exports = ConnectionContext;\n//# sourceMappingURL=connection_context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzFDLDhCQUE4QixtQkFBTyxDQUFDLDhHQUE4QjtBQUNwRSxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFNmU2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL3NmJyk7XG5jb25zdCBMYXJnZVJlc3VsdFNldFNlcnZpY2UgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9sYXJnZV9yZXN1bHRfc2V0Jyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDb25uZWN0aW9uQ29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb25Db25maWd9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbm5lY3Rpb25Db250ZXh0KGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIGNvbmZpZykge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0NyZWF0aW5nIENvbm5lY3Rpb25Db250ZXh0IG9iamVjdC4nKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ29uZmlnKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoaHR0cENsaWVudCkpO1xuICAgIC8vIGlmIGEgY29uZmlnIG9iamVjdCB3YXMgc3BlY2lmaWVkLCB2ZXJpZnlcbiAgICAvLyB0aGF0IGl0IGhhcyBhbGwgdGhlIGluZm9ybWF0aW9uIHdlIG5lZWRcbiAgICBsZXQgc2ZTZXJ2aWNlQ29uZmlnO1xuICAgIGlmIChVdGlsLmV4aXN0cyhjb25maWcpKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uQ29udGV4dCAtIHZhbGlkYXRpbmcgcmVjZWl2ZWQgY29uZmlnLicpO1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25maWcpKTtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29uZmlnLnNlcnZpY2VzKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZy5zZXJ2aWNlcy5zZikpO1xuICAgICAgICBzZlNlcnZpY2VDb25maWcgPSBjb25maWcuc2VydmljZXMuc2Y7XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uQ29udGV4dCAtIHJlY2VpdmVkIGRhdGEgd2FzIHZhbGlkYXRlZC4nKTtcbiAgICAvLyBjcmVhdGUgYSBtYXAgdGhhdCBjb250YWlucyBhbGwgdGhlIHNlcnZpY2VzIHdlJ2xsIGJlIHVzaW5nXG4gICAgY29uc3Qgc2VydmljZXMgPSB7XG4gICAgICAgIHNmOiBuZXcgU2ZTZXJ2aWNlKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIHNmU2VydmljZUNvbmZpZyksXG4gICAgICAgIGxhcmdlUmVzdWx0U2V0OiBuZXcgTGFyZ2VSZXN1bHRTZXRTZXJ2aWNlKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpLFxuICAgIH07XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25Db250ZXh0IC0gc2VydmljZXMgd2VyZSBpbnN0YW50aWF0ZWQuJyk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ29ubmVjdGlvbkNvbmZpZyBmb3IgdXNlIGJ5IHRoZSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Nvbm5lY3Rpb25Db25maWd9XG4gICAgICovXG4gICAgdGhpcy5nZXRDb25uZWN0aW9uQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkNvbmZpZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgdGhhdCBjb250YWlucyBhbGwgdGhlIGF2YWlsYWJsZSBzZXJ2aWNlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRTZXJ2aWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCBhcyBhbiBvcHRpb25hbCBhcmd1bWVudFxuICAgICAqIHRvIHRoZSBDb25uZWN0aW9uQ29udGV4dCBjb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHRoYXQgaGFzIHRoZVxuICAgICAqIHNhbWUgc3RhdGUgYXMgdGhpcyBDb25uZWN0aW9uQ29udGV4dCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgICAgICAgIHNmOiBzZXJ2aWNlcy5zZi5nZXRDb25maWcoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIGh0dHBDbGllbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOb2RlSHR0cENsaWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmdldEh0dHBDbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBodHRwQ2xpZW50O1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25Db250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbl9jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n/**\n * Creates a new Chunk.\n *\n * @param options\n * @constructor\n */\nfunction Chunk(options) {\n    // make sure the options object contains all the necessary information\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isObject(options.statement));\n    Errors.assertInternal(Util.isObject(options.services));\n    Errors.assertInternal(Util.isNumber(options.startIndex));\n    Errors.assertInternal(Util.isArray(options.columns));\n    Errors.assertInternal(Util.isObject(options.mapColumnNameToIndices));\n    Errors.assertInternal(Util.isObject(options.statementParameters));\n    Errors.assertInternal(Util.isString(options.resultVersion));\n    Errors.assertInternal(Util.isNumber(options.rowCount));\n    // if the result is small (i.e. not persisted on S3/Blob), there's no\n    // compressed and uncompressed size, so default to -1\n    this._compressedSize = options.compressedSize || -1;\n    this._uncompressedSize = options.uncompressedSize || -1;\n    // copy out other information from the options object and save it\n    this._statement = options.statement;\n    this._services = options.services;\n    this._startIndex = options.startIndex;\n    this._url = options.url;\n    this._columns = options.columns;\n    this._mapColumnNameToIndices = options.mapColumnNameToIndices;\n    this._chunkHeaders = options.chunkHeaders;\n    this._rowset = options.rowset;\n    // use the start index and row count to compute the end index\n    this._endIndex = this._startIndex + options.rowCount - 1;\n    // use the start and end index to build an id for this chunk\n    this._id = buildId(this._startIndex, this._endIndex);\n}\nUtil.inherits(Chunk, EventEmitter);\n/**\n * Returns the compressed size of this chunk's contents on S3/Blob.\n * A value of -1 means the contents of this chunk are not stored on S3/Blob.\n *\n * @returns {Number}\n */\nChunk.prototype.getCompressedSize = function () {\n    return this._compressedSize;\n};\n/**\n * Returns the uncompressed size of this chunk's contents on S3/Blob.\n * A value of -1 means the contents of this chunk are not stored on S3/Blob.\n *\n * @returns {Number}\n */\nChunk.prototype.getUncompressedSize = function () {\n    return this._uncompressedSize;\n};\n/**\n * Returns the row index of the first row in this chunk.\n *\n * @returns {Number}\n */\nChunk.prototype.getStartIndex = function () {\n    return this._startIndex;\n};\n/**\n * Returns the row index of the last row in this chunk.\n *\n * @returns {Number}\n */\nChunk.prototype.getEndIndex = function () {\n    return this._endIndex;\n};\n/**\n * Returns the id of this chunk.\n *\n * @returns {String}\n */\nChunk.prototype.getId = function () {\n    return this._id;\n};\n/**\n * Determines if this chunk overlaps with a given window.\n *\n * @param {Number} start The start index of the window.\n * @param {Number} end The end index of the window.\n *\n * @returns {Boolean}\n */\nChunk.prototype.overlapsWithWindow = function (start, end) {\n    const chunkStart = this._startIndex, chunkEnd = this._endIndex;\n    // check if the window overlaps with the chunk from the left or\n    // from the right or from both sides\n    return ((end <= chunkEnd && end >= chunkStart) ||\n        (start >= chunkStart && start <= chunkEnd) ||\n        (start <= chunkStart && end >= chunkEnd));\n};\n/**\n * Returns the rows in this chunk.\n *\n * @returns {Object[]}\n */\nChunk.prototype.getRows = function () {\n    // if we don't already have a valid value for the rows\n    if (!Util.isArray(this._rows)) {\n        // if we have a string version of the rowset\n        if (Util.string.isNotNullOrEmpty(this._rowsetAsString)) {\n            // add square brackets on either side and do a json-parse to get the\n            // rowset\n            this._rowset = JSON.parse('[' + this._rowsetAsString + ']');\n            // we don't need the string version of the rowset anymore\n            this._rowsetAsString = undefined;\n        }\n        // if we have a valid value for the rowset\n        if (Util.isArray(this._rowset)) {\n            // convert the rowset to an array of rows\n            this._rows = convertRowsetToRows(this._statement, this._startIndex, this._rowset, this._columns, this._mapColumnNameToIndices);\n            // clear out the rowset because we don't need it anymore\n            this._rowset = undefined;\n        }\n    }\n    return this._rows;\n};\n/**\n * Clears out the rows in this chunk if it has a valid url or if the force flag\n * is true.\n *\n * @param force\n */\nChunk.prototype.clearRows = function (force) {\n    if (Util.string.isNotNullOrEmpty(this._url) || force) {\n        // clear out all row and rowset related fields\n        this._rowsetAsString = this._rowset = this._rows = undefined;\n    }\n};\n/**\n * Updates this chunk's url.\n *\n * @param url\n */\nChunk.prototype.setUrl = function (url) {\n    this._url = url;\n};\n/**\n * Returns true if this chunk's contents are loaded, false otherwise.\n *\n * @returns {Boolean}\n */\nChunk.prototype.isLoaded = function () {\n    // the chunk is considered loaded if we have valid values for\n    // _rowsetAsString, _rowset or _rows\n    return (Util.string.isNotNullOrEmpty(this._rowsetAsString) ||\n        Util.isArray(this._rowset) ||\n        Util.isArray(this._rows));\n};\n/**\n * Returns true if this chunk is currently in the process of loading its\n * contents, false otherwise.\n *\n * @returns {Boolean}\n */\nChunk.prototype.isLoading = function () {\n    return this._isLoading;\n};\n/**\n * Loads the contents of this chunk.\n *\n * @param callback\n */\nChunk.prototype.load = function (callback) {\n    // we've started loading\n    this._isLoading = true;\n    const self = this;\n    /**\n     * Completes the chunk load.\n     *\n     * @param err\n     */\n    const completeLoad = function (err) {\n        // we're done loading\n        self._isLoading = false;\n        // emit an event to notify subscribers\n        self.emit('loadcomplete', err, self);\n        // invoke the callback if one was specified\n        if (Util.isFunction(callback)) {\n            callback(err, self);\n        }\n    };\n    // If the chunk is already loaded, complete the load asynchronously.\n    // This ensure that we are streaming chunks the right order even if the data was received before\n    // another chunk.\n    if (this.isLoaded()) {\n        process.nextTick(completeLoad);\n    }\n    else {\n        // issue a request to load the chunk's contents from S3/Blob\n        this._services.largeResultSet.getObject({\n            url: this._url,\n            headers: this._chunkHeaders,\n            callback: function (err, body) {\n                // if the request succeeded, save the\n                // body as a string version of the rowset\n                if (!err) {\n                    self._rowsetAsString = body;\n                }\n                // complete the load\n                completeLoad(err);\n            },\n        });\n    }\n};\n/**\n * Builds an id for a chunk from its start and end index.\n *\n * @param startIndex The row index of the first chunk row.\n * @param endIndex The row index of the last chunk row.\n *\n * @returns {String}\n * @private\n */\nfunction buildId(startIndex, endIndex) {\n    return Util.format('s=%d, e=%d', startIndex, endIndex);\n}\n/**\n * Converts a rowset to an array of records.\n *\n * @param statement\n * @param startIndex the chunk start index.\n * @param rowset\n * @param columns\n * @param mapColumnNameToIndices\n *\n * @returns {Array}\n * @private\n */\nfunction convertRowsetToRows(statement, startIndex, rowset, columns, mapColumnNameToIndices) {\n    // assert that rowset and columns are arrays\n    Errors.assertInternal(Util.isArray(rowset));\n    Errors.assertInternal(Util.isArray(columns));\n    ///////////////////////////////////////////////////////////////////////////\n    ////     Create functions that will be used as row methods             ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * Returns the index of this row in the result.\n     *\n     * @returns {Number}\n     */\n    const getRowIndex = function () {\n        return this.rowIndex;\n    };\n    /**\n     * Returns the statement that produced this row.\n     *\n     * @returns {*}\n     */\n    const getStatement = function getStatement() {\n        return statement;\n    };\n    /**\n     * Returns the value of a column.\n     *\n     * @param {String | Number} columnIdentifier this can be either the column\n     *   name or the column index.\n     *\n     * @returns {*}\n     */\n    const getColumnValue = function getColumnValue(columnIdentifier) {\n        // resolve the column identifier to the correct column if possible\n        const column = resolveColumnIdentifierToColumn(columns, columnIdentifier, mapColumnNameToIndices);\n        return column ? column.getRowValue(this) : undefined;\n    };\n    /**\n     * Returns the value of a column as a String.\n     *\n     * @param {String | Number} columnIdentifier this can be either the column\n     *   name or the column index.\n     *\n     * @returns {*}\n     */\n    const getColumnValueAsString = function getColumnValueAsString(columnIdentifier) {\n        // resolve the column identifier to the correct column if possible\n        const column = resolveColumnIdentifierToColumn(columns, columnIdentifier, mapColumnNameToIndices);\n        return column ? column.getRowValueAsString(this) : undefined;\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////     Convert the rowset to an array of row objects                 ////\n    ///////////////////////////////////////////////////////////////////////////\n    // create a new array to store the processed rows\n    const length = rowset.length;\n    const rows = new Array(length);\n    for (let index = 0; index < length; index++) {\n        // add a new item to the rows array\n        rows[index] = {\n            _arrayProcessedColumns: [],\n            values: rowset[index],\n            rowIndex: startIndex + index,\n            getRowIndex: getRowIndex,\n            getStatement: getStatement,\n            getColumnValue: getColumnValue,\n            getColumnValueAsString: getColumnValueAsString,\n        };\n    }\n    return rows;\n}\n/**\n * Resolves a column identifier to the corresponding column if possible. The\n * column identifier can be a column name or a column index. If an invalid\n * column identifier is specified, we return undefined.\n *\n * @param {Object[]} columns\n * @param {String | Number} columnIdentifier\n * @param {Object} mapColumnNameToIndices\n *\n * @returns {*}\n */\nfunction resolveColumnIdentifierToColumn(columns, columnIdentifier, mapColumnNameToIndices) {\n    let columnIndex;\n    // if the column identifier is a string, treat it as a column\n    // name and use it to get the index of the specified column\n    if (Util.isString(columnIdentifier)) {\n        // if a valid column name was specified, get the index of the first column\n        // with the specified name\n        if (Object.prototype.hasOwnProperty.call(mapColumnNameToIndices, columnIdentifier)) {\n            columnIndex = mapColumnNameToIndices[columnIdentifier][0];\n        }\n    }\n    else if (Util.isNumber(columnIdentifier)) {\n        // if the column identifier is a number, treat it as a column index\n        columnIndex = columnIdentifier;\n    }\n    return columns[columnIndex];\n}\nmodule.exports = Chunk;\n//# sourceMappingURL=chunk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVuay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLHVFQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVuay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDaHVuay5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENodW5rKG9wdGlvbnMpIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uXG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMuc3RhdGVtZW50KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5zZXJ2aWNlcykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuc3RhcnRJbmRleCkpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQXJyYXkob3B0aW9ucy5jb2x1bW5zKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5tYXBDb2x1bW5OYW1lVG9JbmRpY2VzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5zdGF0ZW1lbnRQYXJhbWV0ZXJzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5yZXN1bHRWZXJzaW9uKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNOdW1iZXIob3B0aW9ucy5yb3dDb3VudCkpO1xuICAgIC8vIGlmIHRoZSByZXN1bHQgaXMgc21hbGwgKGkuZS4gbm90IHBlcnNpc3RlZCBvbiBTMy9CbG9iKSwgdGhlcmUncyBub1xuICAgIC8vIGNvbXByZXNzZWQgYW5kIHVuY29tcHJlc3NlZCBzaXplLCBzbyBkZWZhdWx0IHRvIC0xXG4gICAgdGhpcy5fY29tcHJlc3NlZFNpemUgPSBvcHRpb25zLmNvbXByZXNzZWRTaXplIHx8IC0xO1xuICAgIHRoaXMuX3VuY29tcHJlc3NlZFNpemUgPSBvcHRpb25zLnVuY29tcHJlc3NlZFNpemUgfHwgLTE7XG4gICAgLy8gY29weSBvdXQgb3RoZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgb3B0aW9ucyBvYmplY3QgYW5kIHNhdmUgaXRcbiAgICB0aGlzLl9zdGF0ZW1lbnQgPSBvcHRpb25zLnN0YXRlbWVudDtcbiAgICB0aGlzLl9zZXJ2aWNlcyA9IG9wdGlvbnMuc2VydmljZXM7XG4gICAgdGhpcy5fc3RhcnRJbmRleCA9IG9wdGlvbnMuc3RhcnRJbmRleDtcbiAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl9jb2x1bW5zID0gb3B0aW9ucy5jb2x1bW5zO1xuICAgIHRoaXMuX21hcENvbHVtbk5hbWVUb0luZGljZXMgPSBvcHRpb25zLm1hcENvbHVtbk5hbWVUb0luZGljZXM7XG4gICAgdGhpcy5fY2h1bmtIZWFkZXJzID0gb3B0aW9ucy5jaHVua0hlYWRlcnM7XG4gICAgdGhpcy5fcm93c2V0ID0gb3B0aW9ucy5yb3dzZXQ7XG4gICAgLy8gdXNlIHRoZSBzdGFydCBpbmRleCBhbmQgcm93IGNvdW50IHRvIGNvbXB1dGUgdGhlIGVuZCBpbmRleFxuICAgIHRoaXMuX2VuZEluZGV4ID0gdGhpcy5fc3RhcnRJbmRleCArIG9wdGlvbnMucm93Q291bnQgLSAxO1xuICAgIC8vIHVzZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCB0byBidWlsZCBhbiBpZCBmb3IgdGhpcyBjaHVua1xuICAgIHRoaXMuX2lkID0gYnVpbGRJZCh0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9lbmRJbmRleCk7XG59XG5VdGlsLmluaGVyaXRzKENodW5rLCBFdmVudEVtaXR0ZXIpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb21wcmVzc2VkIHNpemUgb2YgdGhpcyBjaHVuaydzIGNvbnRlbnRzIG9uIFMzL0Jsb2IuXG4gKiBBIHZhbHVlIG9mIC0xIG1lYW5zIHRoZSBjb250ZW50cyBvZiB0aGlzIGNodW5rIGFyZSBub3Qgc3RvcmVkIG9uIFMzL0Jsb2IuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmdldENvbXByZXNzZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wcmVzc2VkU2l6ZTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHVuY29tcHJlc3NlZCBzaXplIG9mIHRoaXMgY2h1bmsncyBjb250ZW50cyBvbiBTMy9CbG9iLlxuICogQSB2YWx1ZSBvZiAtMSBtZWFucyB0aGUgY29udGVudHMgb2YgdGhpcyBjaHVuayBhcmUgbm90IHN0b3JlZCBvbiBTMy9CbG9iLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbkNodW5rLnByb3RvdHlwZS5nZXRVbmNvbXByZXNzZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl91bmNvbXByZXNzZWRTaXplO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcm93IGluZGV4IG9mIHRoZSBmaXJzdCByb3cgaW4gdGhpcyBjaHVuay5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5DaHVuay5wcm90b3R5cGUuZ2V0U3RhcnRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRJbmRleDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHJvdyBpbmRleCBvZiB0aGUgbGFzdCByb3cgaW4gdGhpcyBjaHVuay5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5DaHVuay5wcm90b3R5cGUuZ2V0RW5kSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEluZGV4O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgaWQgb2YgdGhpcyBjaHVuay5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5DaHVuay5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGlzIGNodW5rIG92ZXJsYXBzIHdpdGggYSBnaXZlbiB3aW5kb3cuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgd2luZG93LlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4IG9mIHRoZSB3aW5kb3cuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkNodW5rLnByb3RvdHlwZS5vdmVybGFwc1dpdGhXaW5kb3cgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGNodW5rU3RhcnQgPSB0aGlzLl9zdGFydEluZGV4LCBjaHVua0VuZCA9IHRoaXMuX2VuZEluZGV4O1xuICAgIC8vIGNoZWNrIGlmIHRoZSB3aW5kb3cgb3ZlcmxhcHMgd2l0aCB0aGUgY2h1bmsgZnJvbSB0aGUgbGVmdCBvclxuICAgIC8vIGZyb20gdGhlIHJpZ2h0IG9yIGZyb20gYm90aCBzaWRlc1xuICAgIHJldHVybiAoKGVuZCA8PSBjaHVua0VuZCAmJiBlbmQgPj0gY2h1bmtTdGFydCkgfHxcbiAgICAgICAgKHN0YXJ0ID49IGNodW5rU3RhcnQgJiYgc3RhcnQgPD0gY2h1bmtFbmQpIHx8XG4gICAgICAgIChzdGFydCA8PSBjaHVua1N0YXJ0ICYmIGVuZCA+PSBjaHVua0VuZCkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgcm93cyBpbiB0aGlzIGNodW5rLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgdmFsaWQgdmFsdWUgZm9yIHRoZSByb3dzXG4gICAgaWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fcm93cykpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSByb3dzZXRcbiAgICAgICAgaWYgKFV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkodGhpcy5fcm93c2V0QXNTdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBhZGQgc3F1YXJlIGJyYWNrZXRzIG9uIGVpdGhlciBzaWRlIGFuZCBkbyBhIGpzb24tcGFyc2UgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgLy8gcm93c2V0XG4gICAgICAgICAgICB0aGlzLl9yb3dzZXQgPSBKU09OLnBhcnNlKCdbJyArIHRoaXMuX3Jvd3NldEFzU3RyaW5nICsgJ10nKTtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSByb3dzZXQgYW55bW9yZVxuICAgICAgICAgICAgdGhpcy5fcm93c2V0QXNTdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHZhbGlkIHZhbHVlIGZvciB0aGUgcm93c2V0XG4gICAgICAgIGlmIChVdGlsLmlzQXJyYXkodGhpcy5fcm93c2V0KSkge1xuICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcm93c2V0IHRvIGFuIGFycmF5IG9mIHJvd3NcbiAgICAgICAgICAgIHRoaXMuX3Jvd3MgPSBjb252ZXJ0Um93c2V0VG9Sb3dzKHRoaXMuX3N0YXRlbWVudCwgdGhpcy5fc3RhcnRJbmRleCwgdGhpcy5fcm93c2V0LCB0aGlzLl9jb2x1bW5zLCB0aGlzLl9tYXBDb2x1bW5OYW1lVG9JbmRpY2VzKTtcbiAgICAgICAgICAgIC8vIGNsZWFyIG91dCB0aGUgcm93c2V0IGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlXG4gICAgICAgICAgICB0aGlzLl9yb3dzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3M7XG59O1xuLyoqXG4gKiBDbGVhcnMgb3V0IHRoZSByb3dzIGluIHRoaXMgY2h1bmsgaWYgaXQgaGFzIGEgdmFsaWQgdXJsIG9yIGlmIHRoZSBmb3JjZSBmbGFnXG4gKiBpcyB0cnVlLlxuICpcbiAqIEBwYXJhbSBmb3JjZVxuICovXG5DaHVuay5wcm90b3R5cGUuY2xlYXJSb3dzID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgaWYgKFV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkodGhpcy5fdXJsKSB8fCBmb3JjZSkge1xuICAgICAgICAvLyBjbGVhciBvdXQgYWxsIHJvdyBhbmQgcm93c2V0IHJlbGF0ZWQgZmllbGRzXG4gICAgICAgIHRoaXMuX3Jvd3NldEFzU3RyaW5nID0gdGhpcy5fcm93c2V0ID0gdGhpcy5fcm93cyA9IHVuZGVmaW5lZDtcbiAgICB9XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoaXMgY2h1bmsncyB1cmwuXG4gKlxuICogQHBhcmFtIHVybFxuICovXG5DaHVuay5wcm90b3R5cGUuc2V0VXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHRoaXMuX3VybCA9IHVybDtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNodW5rJ3MgY29udGVudHMgYXJlIGxvYWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5DaHVuay5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdGhlIGNodW5rIGlzIGNvbnNpZGVyZWQgbG9hZGVkIGlmIHdlIGhhdmUgdmFsaWQgdmFsdWVzIGZvclxuICAgIC8vIF9yb3dzZXRBc1N0cmluZywgX3Jvd3NldCBvciBfcm93c1xuICAgIHJldHVybiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eSh0aGlzLl9yb3dzZXRBc1N0cmluZykgfHxcbiAgICAgICAgVXRpbC5pc0FycmF5KHRoaXMuX3Jvd3NldCkgfHxcbiAgICAgICAgVXRpbC5pc0FycmF5KHRoaXMuX3Jvd3MpKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNodW5rIGlzIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiBsb2FkaW5nIGl0c1xuICogY29udGVudHMsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmlzTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNMb2FkaW5nO1xufTtcbi8qKlxuICogTG9hZHMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgY2h1bmsuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkNodW5rLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gd2UndmUgc3RhcnRlZCBsb2FkaW5nXG4gICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdGhlIGNodW5rIGxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICovXG4gICAgY29uc3QgY29tcGxldGVMb2FkID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyB3ZSdyZSBkb25lIGxvYWRpbmdcbiAgICAgICAgc2VsZi5faXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGVtaXQgYW4gZXZlbnQgdG8gbm90aWZ5IHN1YnNjcmliZXJzXG4gICAgICAgIHNlbGYuZW1pdCgnbG9hZGNvbXBsZXRlJywgZXJyLCBzZWxmKTtcbiAgICAgICAgLy8gaW52b2tlIHRoZSBjYWxsYmFjayBpZiBvbmUgd2FzIHNwZWNpZmllZFxuICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzZWxmKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgdGhlIGNodW5rIGlzIGFscmVhZHkgbG9hZGVkLCBjb21wbGV0ZSB0aGUgbG9hZCBhc3luY2hyb25vdXNseS5cbiAgICAvLyBUaGlzIGVuc3VyZSB0aGF0IHdlIGFyZSBzdHJlYW1pbmcgY2h1bmtzIHRoZSByaWdodCBvcmRlciBldmVuIGlmIHRoZSBkYXRhIHdhcyByZWNlaXZlZCBiZWZvcmVcbiAgICAvLyBhbm90aGVyIGNodW5rLlxuICAgIGlmICh0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjb21wbGV0ZUxvYWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaXNzdWUgYSByZXF1ZXN0IHRvIGxvYWQgdGhlIGNodW5rJ3MgY29udGVudHMgZnJvbSBTMy9CbG9iXG4gICAgICAgIHRoaXMuX3NlcnZpY2VzLmxhcmdlUmVzdWx0U2V0LmdldE9iamVjdCh7XG4gICAgICAgICAgICB1cmw6IHRoaXMuX3VybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuX2NodW5rSGVhZGVycyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkLCBzYXZlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJvZHkgYXMgYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgcm93c2V0XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcm93c2V0QXNTdHJpbmcgPSBib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZSB0aGUgbG9hZFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlTG9hZChlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogQnVpbGRzIGFuIGlkIGZvciBhIGNodW5rIGZyb20gaXRzIHN0YXJ0IGFuZCBlbmQgaW5kZXguXG4gKlxuICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHJvdyBpbmRleCBvZiB0aGUgZmlyc3QgY2h1bmsgcm93LlxuICogQHBhcmFtIGVuZEluZGV4IFRoZSByb3cgaW5kZXggb2YgdGhlIGxhc3QgY2h1bmsgcm93LlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWlsZElkKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgcmV0dXJuIFV0aWwuZm9ybWF0KCdzPSVkLCBlPSVkJywgc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJvd3NldCB0byBhbiBhcnJheSBvZiByZWNvcmRzLlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSBzdGFydEluZGV4IHRoZSBjaHVuayBzdGFydCBpbmRleC5cbiAqIEBwYXJhbSByb3dzZXRcbiAqIEBwYXJhbSBjb2x1bW5zXG4gKiBAcGFyYW0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1xuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSb3dzZXRUb1Jvd3Moc3RhdGVtZW50LCBzdGFydEluZGV4LCByb3dzZXQsIGNvbHVtbnMsIG1hcENvbHVtbk5hbWVUb0luZGljZXMpIHtcbiAgICAvLyBhc3NlcnQgdGhhdCByb3dzZXQgYW5kIGNvbHVtbnMgYXJlIGFycmF5c1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQXJyYXkocm93c2V0KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShjb2x1bW5zKSk7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLyAgICAgQ3JlYXRlIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCBhcyByb3cgbWV0aG9kcyAgICAgICAgICAgICAvLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhpcyByb3cgaW4gdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgY29uc3QgZ2V0Um93SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0luZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGVtZW50IHRoYXQgcHJvZHVjZWQgdGhpcyByb3cuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjb25zdCBnZXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiBnZXRTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBjb2x1bW5JZGVudGlmaWVyIHRoaXMgY2FuIGJlIGVpdGhlciB0aGUgY29sdW1uXG4gICAgICogICBuYW1lIG9yIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjb25zdCBnZXRDb2x1bW5WYWx1ZSA9IGZ1bmN0aW9uIGdldENvbHVtblZhbHVlKGNvbHVtbklkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSB0aGUgY29sdW1uIGlkZW50aWZpZXIgdG8gdGhlIGNvcnJlY3QgY29sdW1uIGlmIHBvc3NpYmxlXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHJlc29sdmVDb2x1bW5JZGVudGlmaWVyVG9Db2x1bW4oY29sdW1ucywgY29sdW1uSWRlbnRpZmllciwgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gPyBjb2x1bW4uZ2V0Um93VmFsdWUodGhpcykgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGNvbHVtbiBhcyBhIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBjb2x1bW5JZGVudGlmaWVyIHRoaXMgY2FuIGJlIGVpdGhlciB0aGUgY29sdW1uXG4gICAgICogICBuYW1lIG9yIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjb25zdCBnZXRDb2x1bW5WYWx1ZUFzU3RyaW5nID0gZnVuY3Rpb24gZ2V0Q29sdW1uVmFsdWVBc1N0cmluZyhjb2x1bW5JZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIHJlc29sdmUgdGhlIGNvbHVtbiBpZGVudGlmaWVyIHRvIHRoZSBjb3JyZWN0IGNvbHVtbiBpZiBwb3NzaWJsZVxuICAgICAgICBjb25zdCBjb2x1bW4gPSByZXNvbHZlQ29sdW1uSWRlbnRpZmllclRvQ29sdW1uKGNvbHVtbnMsIGNvbHVtbklkZW50aWZpZXIsIG1hcENvbHVtbk5hbWVUb0luZGljZXMpO1xuICAgICAgICByZXR1cm4gY29sdW1uID8gY29sdW1uLmdldFJvd1ZhbHVlQXNTdHJpbmcodGhpcykgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vICAgICBDb252ZXJ0IHRoZSByb3dzZXQgdG8gYW4gYXJyYXkgb2Ygcm93IG9iamVjdHMgICAgICAgICAgICAgICAgIC8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgdG8gc3RvcmUgdGhlIHByb2Nlc3NlZCByb3dzXG4gICAgY29uc3QgbGVuZ3RoID0gcm93c2V0Lmxlbmd0aDtcbiAgICBjb25zdCByb3dzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAvLyBhZGQgYSBuZXcgaXRlbSB0byB0aGUgcm93cyBhcnJheVxuICAgICAgICByb3dzW2luZGV4XSA9IHtcbiAgICAgICAgICAgIF9hcnJheVByb2Nlc3NlZENvbHVtbnM6IFtdLFxuICAgICAgICAgICAgdmFsdWVzOiByb3dzZXRbaW5kZXhdLFxuICAgICAgICAgICAgcm93SW5kZXg6IHN0YXJ0SW5kZXggKyBpbmRleCxcbiAgICAgICAgICAgIGdldFJvd0luZGV4OiBnZXRSb3dJbmRleCxcbiAgICAgICAgICAgIGdldFN0YXRlbWVudDogZ2V0U3RhdGVtZW50LFxuICAgICAgICAgICAgZ2V0Q29sdW1uVmFsdWU6IGdldENvbHVtblZhbHVlLFxuICAgICAgICAgICAgZ2V0Q29sdW1uVmFsdWVBc1N0cmluZzogZ2V0Q29sdW1uVmFsdWVBc1N0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgY29sdW1uIGlkZW50aWZpZXIgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uIGlmIHBvc3NpYmxlLiBUaGVcbiAqIGNvbHVtbiBpZGVudGlmaWVyIGNhbiBiZSBhIGNvbHVtbiBuYW1lIG9yIGEgY29sdW1uIGluZGV4LiBJZiBhbiBpbnZhbGlkXG4gKiBjb2x1bW4gaWRlbnRpZmllciBpcyBzcGVjaWZpZWQsIHdlIHJldHVybiB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gY29sdW1uc1xuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb2x1bW5JZGVudGlmaWVyVG9Db2x1bW4oY29sdW1ucywgY29sdW1uSWRlbnRpZmllciwgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcykge1xuICAgIGxldCBjb2x1bW5JbmRleDtcbiAgICAvLyBpZiB0aGUgY29sdW1uIGlkZW50aWZpZXIgaXMgYSBzdHJpbmcsIHRyZWF0IGl0IGFzIGEgY29sdW1uXG4gICAgLy8gbmFtZSBhbmQgdXNlIGl0IHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjb2x1bW5cbiAgICBpZiAoVXRpbC5pc1N0cmluZyhjb2x1bW5JZGVudGlmaWVyKSkge1xuICAgICAgICAvLyBpZiBhIHZhbGlkIGNvbHVtbiBuYW1lIHdhcyBzcGVjaWZpZWQsIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICAvLyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcENvbHVtbk5hbWVUb0luZGljZXMsIGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCA9IG1hcENvbHVtbk5hbWVUb0luZGljZXNbY29sdW1uSWRlbnRpZmllcl1bMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5pc051bWJlcihjb2x1bW5JZGVudGlmaWVyKSkge1xuICAgICAgICAvLyBpZiB0aGUgY29sdW1uIGlkZW50aWZpZXIgaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGEgY29sdW1uIGluZGV4XG4gICAgICAgIGNvbHVtbkluZGV4ID0gY29sdW1uSWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbHVtbnNbY29sdW1uSW5kZXhdO1xufVxubW9kdWxlLmV4cG9ydHMgPSBDaHVuaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst DoublyLinkedList = __webpack_require__(/*! ./doubly_linked_list */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js\");\n/**\n * An LRU cache used to store chunks.\n *\n * !! This cache is not fully implemented and not used at this time !!\n *\n * @param capacity the cache size in terms of the number of chunks.\n * @constructor\n */\nfunction ChunkCache(capacity) {\n    this._capacity = capacity;\n    // create a map and a doubly linked list to track the cached chunks\n    this._map = {};\n    this._list = new DoublyLinkedList();\n}\n/**\n * Adds a chunk to the cache.\n *\n * @param chunk\n */\nChunkCache.prototype.put = function (chunk) {\n    let evictedNode;\n    let evictedChunk;\n    const map = this._map;\n    const list = this._list;\n    const chunkId = chunk.getId();\n    // if we already have the chunk in the cache, remove the corresponding node\n    // from the list\n    if (Object.prototype.hasOwnProperty.call(map, chunkId) && map[chunkId]) {\n        list.remove(map[chunkId]);\n    }\n    // append the chunk to the list and put the corresponding node in the map\n    map[chunkId] = list.insertEnd(chunk);\n    // if we've exceeded the cache capacity\n    if (list.getLength() > this._capacity) {\n        // remove the current head of the list\n        evictedNode = list.getHead();\n        list.remove(evictedNode);\n        // evict the chunk associated with the removed node\n        evictedChunk = evictedNode.getValue();\n        delete map[evictedChunk.getId()];\n        // clear the rows from the evicted chunk\n        // TODO: should the force flag be set to true here?\n        evictedChunk.clearRows();\n    }\n};\nmodule.exports = ChunkCache;\n//# sourceMappingURL=chunk_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVua19jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHlCQUF5QixtQkFBTyxDQUFDLGlIQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVua19jYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IERvdWJseUxpbmtlZExpc3QgPSByZXF1aXJlKCcuL2RvdWJseV9saW5rZWRfbGlzdCcpO1xuLyoqXG4gKiBBbiBMUlUgY2FjaGUgdXNlZCB0byBzdG9yZSBjaHVua3MuXG4gKlxuICogISEgVGhpcyBjYWNoZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgYW5kIG5vdCB1c2VkIGF0IHRoaXMgdGltZSAhIVxuICpcbiAqIEBwYXJhbSBjYXBhY2l0eSB0aGUgY2FjaGUgc2l6ZSBpbiB0ZXJtcyBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDaHVua0NhY2hlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAvLyBjcmVhdGUgYSBtYXAgYW5kIGEgZG91Ymx5IGxpbmtlZCBsaXN0IHRvIHRyYWNrIHRoZSBjYWNoZWQgY2h1bmtzXG4gICAgdGhpcy5fbWFwID0ge307XG4gICAgdGhpcy5fbGlzdCA9IG5ldyBEb3VibHlMaW5rZWRMaXN0KCk7XG59XG4vKipcbiAqIEFkZHMgYSBjaHVuayB0byB0aGUgY2FjaGUuXG4gKlxuICogQHBhcmFtIGNodW5rXG4gKi9cbkNodW5rQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGxldCBldmljdGVkTm9kZTtcbiAgICBsZXQgZXZpY3RlZENodW5rO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICBjb25zdCBjaHVua0lkID0gY2h1bmsuZ2V0SWQoKTtcbiAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIGNodW5rIGluIHRoZSBjYWNoZSwgcmVtb3ZlIHRoZSBjb3JyZXNwb25kaW5nIG5vZGVcbiAgICAvLyBmcm9tIHRoZSBsaXN0XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGNodW5rSWQpICYmIG1hcFtjaHVua0lkXSkge1xuICAgICAgICBsaXN0LnJlbW92ZShtYXBbY2h1bmtJZF0pO1xuICAgIH1cbiAgICAvLyBhcHBlbmQgdGhlIGNodW5rIHRvIHRoZSBsaXN0IGFuZCBwdXQgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBpbiB0aGUgbWFwXG4gICAgbWFwW2NodW5rSWRdID0gbGlzdC5pbnNlcnRFbmQoY2h1bmspO1xuICAgIC8vIGlmIHdlJ3ZlIGV4Y2VlZGVkIHRoZSBjYWNoZSBjYXBhY2l0eVxuICAgIGlmIChsaXN0LmdldExlbmd0aCgpID4gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIGxpc3RcbiAgICAgICAgZXZpY3RlZE5vZGUgPSBsaXN0LmdldEhlYWQoKTtcbiAgICAgICAgbGlzdC5yZW1vdmUoZXZpY3RlZE5vZGUpO1xuICAgICAgICAvLyBldmljdCB0aGUgY2h1bmsgYXNzb2NpYXRlZCB3aXRoIHRoZSByZW1vdmVkIG5vZGVcbiAgICAgICAgZXZpY3RlZENodW5rID0gZXZpY3RlZE5vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgZGVsZXRlIG1hcFtldmljdGVkQ2h1bmsuZ2V0SWQoKV07XG4gICAgICAgIC8vIGNsZWFyIHRoZSByb3dzIGZyb20gdGhlIGV2aWN0ZWQgY2h1bmtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHRoZSBmb3JjZSBmbGFnIGJlIHNldCB0byB0cnVlIGhlcmU/XG4gICAgICAgIGV2aWN0ZWRDaHVuay5jbGVhclJvd3MoKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDaHVua0NhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmtfY2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/column.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/column.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst BigNumber = __webpack_require__(/*! bignumber.js */ \"(rsc)/./node_modules/bignumber.js/bignumber.js\");\nconst GlobalConfig = __webpack_require__(/*! ../../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst SfTimestamp = __webpack_require__(/*! ./sf_timestamp */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js\");\nconst DataTypes = __webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst SqlTypes = (__webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\").SqlTypes);\nconst dateTimeFormatConverter = __webpack_require__(/*! ./datetime_format_converter */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(rsc)/./node_modules/big-integer/BigInteger.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst momentTimezone = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\n/**\n * Creates a new Column.\n *\n * @param {Object} options\n * @param {Number} index\n * @param {Object} statementParameters\n * @param {String} resultVersion\n *\n * @constructor\n */\nfunction Column(options, index, statementParameters, resultVersion) {\n    const name = options.overriddenName || options.name;\n    const nullable = options.nullable;\n    const scale = options.scale;\n    const type = options.type;\n    const precision = options.precision;\n    const fieldsMetadata = options.fields;\n    /**\n     * Returns the name of this column.\n     *\n     * @return {String}\n     */\n    this.getName = function () {\n        return name;\n    };\n    /**\n     * Returns the index of this column.\n     *\n     * @return {Number}\n     */\n    this.getIndex = function () {\n        return index;\n    };\n    /**\n     * Returns the id of this column.\n     *\n     * @return {Number}\n     */\n    this.getId = function () {\n        // use the index as the id for now\n        return index;\n    };\n    /**\n     * Determines if this column is nullable.\n     *\n     * @returns {Boolean}\n     */\n    this.isNullable = function () {\n        return nullable;\n    };\n    /**\n     * Returns the scale associated with this column.\n     *\n     * @returns {Number}\n     */\n    this.getScale = function () {\n        return scale;\n    };\n    /**\n     * Returns the type associated with this column.\n     *\n     * @returns {String}\n     */\n    this.getType = function () {\n        return type;\n    };\n    /**\n     * Returns the precision associated with this column\n     *\n     * @returns {Number}\n     */\n    this.getPrecision = function () {\n        return precision;\n    };\n    // add methods that make it easy to check if the column is of a specific type\n    this.isString = createFnIsColumnOfType(type, SqlTypes.isString, SqlTypes);\n    this.isBinary = createFnIsColumnOfType(type, SqlTypes.isBinary, SqlTypes);\n    this.isNumber = createFnIsColumnOfType(type, SqlTypes.isNumber, SqlTypes);\n    this.isBoolean = createFnIsColumnOfType(type, SqlTypes.isBoolean, SqlTypes);\n    this.isDate = createFnIsColumnOfType(type, SqlTypes.isDate, SqlTypes);\n    this.isTime = createFnIsColumnOfType(type, SqlTypes.isTime, SqlTypes);\n    this.isTimestamp = createFnIsColumnOfType(type, SqlTypes.isTimestamp, SqlTypes);\n    this.isTimestampLtz = createFnIsColumnOfType(type, SqlTypes.isTimestampLtz, SqlTypes);\n    this.isTimestampNtz = createFnIsColumnOfType(type, SqlTypes.isTimestampNtz, SqlTypes);\n    this.isTimestampTz = createFnIsColumnOfType(type, SqlTypes.isTimestampTz, SqlTypes);\n    this.isVariant = createFnIsColumnOfType(type, (type) => SqlTypes.isVariant(type, fieldsMetadata), SqlTypes);\n    this.isObject = createFnIsColumnOfType(type, (type) => SqlTypes.isObject(type, fieldsMetadata), SqlTypes);\n    this.isArray = createFnIsColumnOfType(type, (type) => SqlTypes.isArray(type, fieldsMetadata), SqlTypes);\n    this.isMap = createFnIsColumnOfType(type, (type) => SqlTypes.isMap(type, fieldsMetadata), SqlTypes);\n    let convert;\n    let toString;\n    let toValue;\n    let format;\n    if (this.isNumber()) {\n        const integerAs = statementParameters['JS_TREAT_INTEGER_AS_BIGINT'];\n        if (!integerAs) {\n            convert = convertRawNumber;\n        }\n        else {\n            if (this.getScale() > 0 || this.getType() === SqlTypes.values.REAL) {\n                convert = convertRawNumber;\n            }\n            else {\n                // This is an integer so represent it as a big int\n                convert = convertRawBigInt;\n            }\n        }\n        toValue = toValueFromNumber;\n        toString = toStringFromNumber;\n    }\n    else if (this.isTime()) {\n        convert = convertRawTime;\n        toValue = toValueFromTime;\n        toString = toStringFromTime;\n        format = statementParameters['TIME_OUTPUT_FORMAT'];\n    }\n    else {\n        toValue = noop;\n        if (this.isBoolean()) {\n            convert = convertRawBoolean;\n            toString = toStringFromBoolean;\n        }\n        else if (this.isDate()) {\n            convert = convertRawDate;\n            toString = toStringFromDate;\n            format = statementParameters['DATE_OUTPUT_FORMAT'];\n        }\n        else if (this.isTimestamp()) {\n            if (this.isTimestampLtz()) {\n                convert = convertRawTimestampLtz;\n                toString = toStringFromTimestamp;\n                format = statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'];\n            }\n            else if (this.isTimestampNtz()) {\n                convert = convertRawTimestampNtz;\n                toString = toStringFromTimestamp;\n                format = statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n            }\n            else if (this.isTimestampTz()) {\n                convert = convertRawTimestampTz;\n                toString = toStringFromTimestamp;\n                format = statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'];\n            }\n            // if we don't have a type-specific timezone, use the default format\n            if (!format) {\n                format = statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n            }\n        }\n        else if (this.isBinary()) {\n            convert = convertRawBinary;\n            toString = toStringFromBinary;\n            format = statementParameters['BINARY_OUTPUT_FORMAT'];\n        }\n        else if (this.isVariant()) {\n            convert = convertRawVariant;\n            toString = toStringFromRawValue;\n        }\n        else if (this.isObject()) {\n            convert = convertRawStructuredType(convertJsonObject);\n            toString = toStringFromRawValue;\n        }\n        else if (this.isArray()) {\n            convert = convertRawStructuredType(convertJsonArray);\n            toString = toStringFromRawValue;\n        }\n        else if (this.isMap()) {\n            convert = convertRawStructuredType(convertJsonMap);\n            toString = toStringFromRawValue;\n        }\n        else {\n            // column is of type string, so leave value as is\n            convert = noop;\n            toString = toStringFromString;\n        }\n    }\n    // create a private context to pass to the extract function\n    const context = {\n        convert: convert,\n        toValue: toValue,\n        toString: toString,\n        format: format,\n        resultVersion: resultVersion,\n        statementParameters: statementParameters,\n        fieldsMetadata: fieldsMetadata,\n    };\n    /**\n     * Returns the value of this column in a row.\n     *\n     * @param {Object} row\n     *\n     * @returns {*}\n     */\n    this.getRowValue = function (row) {\n        return extractFromRow.call(this, row, context, false);\n    };\n    /**\n     * Returns the value of this in a row as a String.\n     *\n     * @param {Object} row\n     *\n     * @returns {String}\n     */\n    this.getRowValueAsString = function (row) {\n        return extractFromRow.call(this, row, context, true);\n    };\n}\n/**\n * Returns a function that can be used to determine if a column is of a given\n * type.\n *\n * @param {String} columnType the column type.\n * @param {Function} columnComparisonFn the column comparison function.\n * @param {Object} scope the scope in which to invoke the column comparison\n *   function.\n *\n * @returns {Function}\n */\nfunction createFnIsColumnOfType(columnType, columnComparisonFn, scope) {\n    return function () {\n        return columnComparisonFn.call(scope, columnType);\n    };\n}\n/**\n * Converts a raw column value of type Number. The returned value is an object\n * that contains the raw string version of the value as well as the\n * post-processed version of the value obtained after casting to Number.\n *\n * @param {String} rawColumnValue\n *\n * @returns {Object}\n */\nfunction convertRawNumber(rawColumnValue) {\n    return {\n        raw: rawColumnValue,\n        processed: Number(rawColumnValue),\n    };\n}\n/**\n * Converts a raw column value that is an integer. The returned value is an object\n * that contains the raw string version of the value as well as the post-processed\n * version of the value obtained after casting to bigInt\n *\n * @param rawColumnValue\n * @returns {{processed: bigInt.BigInteger, raw: *}}\n */\nfunction convertRawBigInt(rawColumnValue) {\n    return {\n        raw: rawColumnValue,\n        processed: bigInt(rawColumnValue),\n    };\n}\n/**\n * Converts a raw column value of type Boolean to a boolean (true, false,\n * or null).\n *\n * @param {String} rawColumnValue\n *\n * @returns {Boolean}\n */\nfunction convertRawBoolean(rawColumnValue) {\n    let ret;\n    if (rawColumnValue === true ||\n        rawColumnValue === '1' ||\n        rawColumnValue.toUpperCase() === 'TRUE') {\n        ret = true;\n    }\n    else if (rawColumnValue === false ||\n        rawColumnValue === '0' ||\n        rawColumnValue.toUpperCase() === 'FALSE') {\n        ret = false;\n    }\n    else {\n        throw new Error(`Value could not be converted to boolean: ${rawColumnValue}`);\n    }\n    return ret;\n}\n/**\n * Converts a raw column value of structured type object to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonObject(json, context) {\n    if (context.fieldsMetadata) {\n        context.fieldsMetadata = context.fieldsMetadata.reduce(function (map, obj) {\n            map[obj.name] = obj;\n            return map;\n        }, {});\n        const result = {};\n        Object.keys(json).forEach(function (key) {\n            const fieldMetadata = context.fieldsMetadata[key];\n            result[key] = mapStructuredTypeValue(json[key], context, fieldMetadata);\n        });\n        return result;\n    }\n    else {\n        return json;\n    }\n}\n/**\n * Converts a raw column value of structured type array to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonArray(json, context) {\n    if (context.fieldsMetadata) {\n        const result = [];\n        json.forEach(function (value) {\n            result.push(mapStructuredTypeValue(value, context, context.fieldsMetadata[0]));\n        });\n        return result;\n    }\n    else {\n        return json;\n    }\n}\n/**\n * Converts a raw column value of structured type map to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonMap(json, context) {\n    if (Array.isArray(context.fieldsMetadata) && context.fieldsMetadata.length === 2) {\n        const result = new Map();\n        const keyMetadata = context.fieldsMetadata[0];\n        const valueMetadata = context.fieldsMetadata[1];\n        Object.keys(json).forEach(function (key) {\n            const convertedKey = mapStructuredTypeValue(key, context, keyMetadata);\n            const convertedValue = mapStructuredTypeValue(json[key], context, valueMetadata);\n            result.set(convertedKey, convertedValue);\n        });\n        return result;\n    }\n    else {\n        return json;\n    }\n}\n/**\n * Converts a raw column value of structured type OBJECT to javascript Object\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nconst convertRawStructuredType = (convertJsonFn) => (rawColumnValue, column, context) => {\n    if (Util.string.isNotNullOrEmpty(rawColumnValue)) {\n        try {\n            const json = JSON.parse(rawColumnValue);\n            return convertJsonFn(json, context);\n        }\n        catch (jsonParseError) {\n            Logger.getInstance().debug('Column %s raw value cannot be parsed as JSON: %s ', column.name, jsonParseError.message);\n            throw new Error(util.format('Column [%s] raw value cannot be parsed as JSON: %s ', column.name, jsonParseError.message));\n        }\n    }\n    else {\n        throw new Error(util.format('Column %s raw value is null or empty ', column.name));\n    }\n};\nfunction mapStructuredTypeValue(columnValue, context, metadataField) {\n    const formatLtz = context.statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'] ??\n        context.statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n    const formatTz = context.statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'] ??\n        context.statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n    const formatNtz = context.statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n    let value;\n    switch (metadataField.type) {\n        case 'text':\n            value = columnValue;\n            break;\n        case 'real':\n            value = toValueFromNumber(convertRawNumber(columnValue));\n            break;\n        case 'fixed':\n            value = toValueFromNumber(convertRawNumber(columnValue));\n            break;\n        case 'boolean':\n            value = convertRawBoolean(columnValue);\n            break;\n        case 'timestamp_ltz':\n            value = convertTimestampTzString(columnValue, formatLtz, context.statementParameters['TIMEZONE'], metadataField.scale).toSfDate();\n            break;\n        case 'timestamp_ntz':\n            value = convertTimestampNtzString(columnValue, formatNtz, moment.tz.zone('UTC'), metadataField.scale).toSfDate();\n            break;\n        case 'timestamp_tz':\n            value = convertTimestampTzString(columnValue, formatTz, context.statementParameters['TIMEZONE'], metadataField.scale).toSfDate();\n            break;\n        case 'date': {\n            context.format = context.statementParameters['DATE_OUTPUT_FORMAT'];\n            value = convertDateString(columnValue, context.format);\n            break;\n        }\n        case 'time':\n            context.format = context.statementParameters['TIME_OUTPUT_FORMAT'];\n            value = convertTimeString(columnValue, context.format, moment.tz.zone('UTC'), metadataField.scale).toSfTime();\n            break;\n        case 'binary':\n            context.format = context.statementParameters['BINARY_OUTPUT_FORMAT'];\n            value = convertRawBinary(columnValue, this, context).toJSON().data;\n            break;\n        case 'object': {\n            const internalContext = {\n                convert: convertRawStructuredType(convertJsonObject),\n                toValue: noop,\n                toString: toString,\n                format: toStringFromRawValue,\n                resultVersion: context.resultVersion,\n                statementParameters: context.statementParameters,\n                fieldsMetadata: metadataField.fields,\n            };\n            value = convertJsonObject(columnValue, internalContext);\n            break;\n        }\n        case 'array': {\n            const internalArrayContext = {\n                convert: convertRawStructuredType(convertJsonArray),\n                toValue: noop,\n                toString: toString,\n                format: toStringFromRawValue,\n                resultVersion: context.resultVersion,\n                statementParameters: context.statementParameters,\n                fieldsMetadata: metadataField.fields,\n            };\n            value = convertJsonArray(columnValue, internalArrayContext);\n            break;\n        }\n        case 'map': {\n            const internalMapContext = {\n                convert: convertRawStructuredType(convertJsonMap),\n                toValue: noop,\n                toString: toString,\n                format: toStringFromRawValue,\n                resultVersion: context.resultVersion,\n                statementParameters: context.statementParameters,\n                fieldsMetadata: metadataField.fields,\n            };\n            value = convertJsonMap(columnValue, internalMapContext);\n            break;\n        }\n        default:\n            Logger.getInstance().info(`Column type not supported: ${context.fieldsMetadata.type}`);\n            throw new Error(`Column type not supported: ${context.fieldsMetadata.type}`);\n    }\n    return value;\n}\nconst convertTimestampTzString = function (stringValue, formatSql, timezone, scale) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n    const epochSeconds = momentTimezone(stringValue, formatMoment).unix();\n    return new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n};\nconst convertTimestampNtzString = function (stringValue, formatSql, timezone, scale) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n    const epochSeconds = momentTimezone.utc(stringValue, formatMoment).unix();\n    return new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n};\nconst convertDateString = function (stringValue, formatSql) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, 0);\n    const epochSeconds = momentTimezone.utc(stringValue, formatMoment).unix();\n    const date = new SfTimestamp(epochSeconds, // convert to seconds\n    0, // no nano seconds\n    0, // no scale required\n    'UTC', // use utc as the timezone\n    context.format);\n    date._valueAsString = stringValue;\n    return date.toSfDate();\n};\nconst convertTimeString = function (stringValue, formatSql, timezone, scale) {\n    const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n    const moment = momentTimezone(stringValue, formatMoment);\n    const epochSeconds = moment.hours() * 3600 + moment.minutes() * 60 + moment.seconds();\n    const time = new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n    time._valueAsString = stringValue;\n    return time;\n};\n/**\n * Converts a raw column value of type Date to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawDate(rawColumnValue, column, context) {\n    return new SfTimestamp(Number(rawColumnValue) * 86400, // convert to seconds\n    0, // no nano seconds\n    0, // no scale required\n    'UTC', // use utc as the timezone\n    context.format).toSfDate();\n}\n/**\n * Converts a raw column value of type Time to a Snowflake Time.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawTime(rawColumnValue, column, context) {\n    const columnScale = column.getScale();\n    // the values might be big so use BigNumber to do arithmetic\n    const valFracSecsBig = new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, 'UTC', context.format).toSfTime();\n}\n/**\n * Converts a raw column value of type TIMESTAMP_LTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampLtz(rawColumnValue, column, context) {\n    const columnScale = column.getScale();\n    // the values might be big so use BigNumber to do arithmetic\n    const valFracSecsBig = new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n    // create a new snowflake date\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, context.statementParameters['TIMEZONE'], context.format).toSfDate();\n}\n/**\n * Converts a raw column value of type TIMESTAMP_NTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampNtz(rawColumnValue, column, context) {\n    const columnScale = column.getScale();\n    // the values might be big so use BigNumber to do arithmetic\n    const valFracSecsBig = new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n    // create a new snowflake date\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, 'UTC', // it's _ntz, so use UTC for timezone\n    context.format).toSfDate();\n}\n/**\n * Converts a raw column value of type TIMESTAMP_TZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampTz(rawColumnValue, column, context) {\n    let valFracSecsBig;\n    let valFracSecsWithTzBig;\n    let timezoneBig;\n    let timezone;\n    let timestampAndTZIndex;\n    // compute the scale factor\n    const columnScale = column.getScale();\n    const scaleFactor = Math.pow(10, columnScale);\n    const resultVersion = context.resultVersion;\n    if (resultVersion === '0' || resultVersion === undefined) {\n        // the values might be big so use BigNumber to do arithmetic\n        valFracSecsBig = new BigNumber(rawColumnValue).times(scaleFactor);\n        // for _tz, the timezone is baked into the value\n        valFracSecsWithTzBig = valFracSecsBig;\n        // extract everything but the lowest 14 bits to get the fractional seconds\n        valFracSecsBig = valFracSecsWithTzBig.dividedBy(16384).integerValue(BigNumber.ROUND_FLOOR);\n        // extract the lowest 14 bits to get the timezone\n        if (valFracSecsWithTzBig.isGreaterThanOrEqualTo(0)) {\n            timezoneBig = valFracSecsWithTzBig.modulo(16384);\n        }\n        else {\n            timezoneBig = valFracSecsWithTzBig.modulo(16384).plus(16384);\n        }\n    }\n    else {\n        // split the value into number of seconds and timezone index\n        timestampAndTZIndex = rawColumnValue.split(' ');\n        // the values might be big so use BigNumber to do arithmetic\n        valFracSecsBig = new BigNumber(timestampAndTZIndex[0]).times(scaleFactor);\n        timezoneBig = new BigNumber(timestampAndTZIndex[1]);\n    }\n    timezone = timezoneBig.toNumber();\n    // assert that timezone is valid\n    Errors.assertInternal(timezone >= 0 && timezone <= 2880);\n    // subtract 24 hours from the timezone to map [0, 48] to\n    // [-24, 24], and convert the result to a number\n    timezone = timezone - 1440;\n    // create a new snowflake date\n    return convertRawTimestampHelper(valFracSecsBig, columnScale, timezone, context.format).toSfDate();\n}\n/**\n * Helper function for the convertRawTimestamp*() functions.\n * Returns an instance of SfTimestamp.\n *\n * @param {Object} epochFracSecsBig\n * @param {Number} scale\n * @param {String | Number} timezone\n * @param {String} format\n *\n * @returns {Object}\n */\nfunction convertRawTimestampHelper(epochFracSecsBig, scale, timezone, format) {\n    // compute the scale factor\n    const scaleFactor = Math.pow(10, scale);\n    // split the value into epoch seconds + nanoseconds; for example,\n    // 1365148923.123456789 will be split into 1365148923 (epoch seconds)\n    // and 123456789 (nano seconds)\n    const valSecBig = epochFracSecsBig.dividedBy(scaleFactor).integerValue(BigNumber.ROUND_FLOOR);\n    const fractionsBig = epochFracSecsBig.minus(valSecBig.times(scaleFactor));\n    const valSecNanoBig = fractionsBig.times(Math.pow(10, 9 - scale));\n    // create a new snowflake date from the information\n    return new SfTimestamp(valSecBig.toNumber(), valSecNanoBig.toNumber(), scale, timezone, format);\n}\n/**\n * Converts a raw column value of type Variant to a JavaScript value.\n *\n * @param {String} rawColumnValue\n *\n * @returns {Object | Array}\n */\nfunction convertRawVariant(rawColumnValue) {\n    // if the input is a non-empty string, convert it to a json object\n    if (Util.string.isNotNullOrEmpty(rawColumnValue)) {\n        try {\n            return GlobalConfig.jsonColumnVariantParser(rawColumnValue);\n        }\n        catch (jsonParseError) {\n            try {\n                return GlobalConfig.xmlColumnVariantParser(rawColumnValue);\n            }\n            catch (xmlParseError) {\n                Logger.getInstance().debug('Variant cannot be parsed neither as JSON: %s nor as XML: %s', jsonParseError.message, xmlParseError.message);\n                throw new Errors.VariantParseError(jsonParseError, xmlParseError);\n            }\n        }\n    }\n}\n/**\n * Converts a raw column value of type Binary to a Buffer.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Buffer}\n */\nfunction convertRawBinary(rawColumnValue, column, context) {\n    // Ensure the format is valid.\n    const format = context.format.toUpperCase();\n    Errors.assertInternal(format === 'HEX' || format === 'BASE64');\n    // Decode hex string sent by GS.\n    const buffer = Buffer.from(rawColumnValue, 'HEX');\n    if (format === 'HEX') {\n        buffer.toStringSf = function () {\n            // The raw value is already an uppercase hex string, so just return it.\n            // Note that buffer.toString(\"HEX\") returns a lowercase hex string, but we\n            // want upper case.\n            return rawColumnValue;\n        };\n    }\n    else {\n        buffer.toStringSf = function () {\n            return this.toString('BASE64');\n        };\n    }\n    buffer.getFormat = function () {\n        return format;\n    };\n    return buffer;\n}\n/**\n * Returns the input value as is.\n *\n * @param {*} value\n *\n * @returns {*}\n */\nfunction noop(value) {\n    return value;\n}\n/**\n * The toValue() function for a column of type Number.\n *\n * @param {*} columnValue\n *\n * @returns {Number}\n */\nfunction toValueFromNumber(columnValue) {\n    return columnValue ? columnValue.processed : columnValue;\n}\n/**\n * The toValue() function for a column of type Time.\n *\n * @param {*} columnValue\n *\n * @returns {String}\n */\nfunction toValueFromTime(columnValue) {\n    // there's no native javascript type that can be used to represent time, so\n    // just convert to string\n    return toStringFromTime(columnValue);\n}\n/**\n * The toString() function for a column of type Number.\n *\n * @param {Number} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromNumber(columnValue) {\n    return columnValue !== null ? columnValue.raw : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Boolean.\n *\n * @param {Boolean} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBoolean(columnValue) {\n    return columnValue !== null ? String(columnValue).toUpperCase() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Date.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromDate(columnValue) {\n    return columnValue !== null ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Time.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTime(columnValue) {\n    return columnValue !== null ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Timestamp.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTimestamp(columnValue) {\n    return columnValue !== null ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Variant.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromRawValue(columnValue) {\n    return columnValue !== null ? JSON.stringify(columnValue) : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type String.\n *\n * @param {String} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromString(columnValue) {\n    return columnValue !== null ? columnValue : DataTypes.getNullValue();\n}\n/**\n * The toString() function for a column of type Binary.\n *\n * @param {Buffer} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBinary(columnValue) {\n    return columnValue !== null ? columnValue.toStringSf() : DataTypes.getNullValue();\n}\n/**\n * Extracts the value of a column from a given row.\n *\n * @param {Object} row\n * @param {Object} context\n * @param {Boolean} asString\n *\n * @returns {*}\n */\nfunction extractFromRow(row, context, asString) {\n    const map = row._arrayProcessedColumns;\n    const values = row.values;\n    // get the value\n    const columnIndex = this.getIndex();\n    let ret = values[columnIndex];\n    // if we want the value as a string, and the column is of type variant, and we\n    // haven't already processed the value before, we don't need to process the\n    // value, so only process if none of the aforementioned conditions are true\n    if (!(asString && this.isVariant() && !map[columnIndex])) {\n        // if the column value has not been processed yet, process it, put it back\n        // in the values array, and remember that the value has been processed\n        if (!map[columnIndex]) {\n            if (ret !== null) {\n                ret = values[columnIndex] = context.convert(values[columnIndex], this, context);\n            }\n            map[columnIndex] = true;\n        }\n        // use the appropriate extraction function depending on whether\n        // we want the value or a string representation of the value\n        const extractFn = !asString ? context.toValue : context.toString;\n        ret = extractFn(ret);\n    }\n    return ret;\n}\nmodule.exports = Column;\n//# sourceMappingURL=column.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jb2x1bW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDJFQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFjO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFxQjtBQUNsRCxlQUFlLG1CQUFPLENBQUMsMkVBQWM7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUdBQWdCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGlHQUFjO0FBQ3hDLGlCQUFpQixpSUFBZ0M7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMsK0hBQTZCO0FBQ3JFLGVBQWUsbUJBQU8sQ0FBQyxtRUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyx1RUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsNEJBQTRCO0FBQ2hHLDBEQUEwRCw0QkFBNEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L2NvbHVtbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vbG9nZ2VyJyk7XG5jb25zdCBTZlRpbWVzdGFtcCA9IHJlcXVpcmUoJy4vc2ZfdGltZXN0YW1wJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL2RhdGFfdHlwZXMnKTtcbmNvbnN0IFNxbFR5cGVzID0gcmVxdWlyZSgnLi9kYXRhX3R5cGVzJykuU3FsVHlwZXM7XG5jb25zdCBkYXRlVGltZUZvcm1hdENvbnZlcnRlciA9IHJlcXVpcmUoJy4vZGF0ZXRpbWVfZm9ybWF0X2NvbnZlcnRlcicpO1xuY29uc3QgYmlnSW50ID0gcmVxdWlyZSgnYmlnLWludGVnZXInKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuY29uc3QgbW9tZW50VGltZXpvbmUgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQ29sdW1uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzdWx0VmVyc2lvblxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb2x1bW4ob3B0aW9ucywgaW5kZXgsIHN0YXRlbWVudFBhcmFtZXRlcnMsIHJlc3VsdFZlcnNpb24pIHtcbiAgICBjb25zdCBuYW1lID0gb3B0aW9ucy5vdmVycmlkZGVuTmFtZSB8fCBvcHRpb25zLm5hbWU7XG4gICAgY29uc3QgbnVsbGFibGUgPSBvcHRpb25zLm51bGxhYmxlO1xuICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIGNvbnN0IHByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIGNvbnN0IGZpZWxkc01ldGFkYXRhID0gb3B0aW9ucy5maWVsZHM7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGlzIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhpcyBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhpcyBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBpbmRleCBhcyB0aGUgaWQgZm9yIG5vd1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgY29sdW1uIGlzIG51bGxhYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc051bGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbGFibGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29sdW1uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJlY2lzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbHVtblxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgICB9O1xuICAgIC8vIGFkZCBtZXRob2RzIHRoYXQgbWFrZSBpdCBlYXN5IHRvIGNoZWNrIGlmIHRoZSBjb2x1bW4gaXMgb2YgYSBzcGVjaWZpYyB0eXBlXG4gICAgdGhpcy5pc1N0cmluZyA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNTdHJpbmcsIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzQmluYXJ5ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc0JpbmFyeSwgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNOdW1iZXIgPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzTnVtYmVyLCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc0Jvb2xlYW4gPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzQm9vbGVhbiwgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNEYXRlID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc0RhdGUsIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzVGltZSA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNUaW1lLCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc1RpbWVzdGFtcCA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNUaW1lc3RhbXAsIFNxbFR5cGVzKTtcbiAgICB0aGlzLmlzVGltZXN0YW1wTHR6ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1RpbWVzdGFtcEx0eiwgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNUaW1lc3RhbXBOdHogPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzVGltZXN0YW1wTnR6LCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc1RpbWVzdGFtcFR6ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1RpbWVzdGFtcFR6LCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc1ZhcmlhbnQgPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsICh0eXBlKSA9PiBTcWxUeXBlcy5pc1ZhcmlhbnQodHlwZSwgZmllbGRzTWV0YWRhdGEpLCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc09iamVjdCA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgKHR5cGUpID0+IFNxbFR5cGVzLmlzT2JqZWN0KHR5cGUsIGZpZWxkc01ldGFkYXRhKSwgU3FsVHlwZXMpO1xuICAgIHRoaXMuaXNBcnJheSA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgKHR5cGUpID0+IFNxbFR5cGVzLmlzQXJyYXkodHlwZSwgZmllbGRzTWV0YWRhdGEpLCBTcWxUeXBlcyk7XG4gICAgdGhpcy5pc01hcCA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgKHR5cGUpID0+IFNxbFR5cGVzLmlzTWFwKHR5cGUsIGZpZWxkc01ldGFkYXRhKSwgU3FsVHlwZXMpO1xuICAgIGxldCBjb252ZXJ0O1xuICAgIGxldCB0b1N0cmluZztcbiAgICBsZXQgdG9WYWx1ZTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmICh0aGlzLmlzTnVtYmVyKCkpIHtcbiAgICAgICAgY29uc3QgaW50ZWdlckFzID0gc3RhdGVtZW50UGFyYW1ldGVyc1snSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQnXTtcbiAgICAgICAgaWYgKCFpbnRlZ2VyQXMpIHtcbiAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0U2NhbGUoKSA+IDAgfHwgdGhpcy5nZXRUeXBlKCkgPT09IFNxbFR5cGVzLnZhbHVlcy5SRUFMKSB7XG4gICAgICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVnZXIgc28gcmVwcmVzZW50IGl0IGFzIGEgYmlnIGludFxuICAgICAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3QmlnSW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvVmFsdWUgPSB0b1ZhbHVlRnJvbU51bWJlcjtcbiAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21OdW1iZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNUaW1lKCkpIHtcbiAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdUaW1lO1xuICAgICAgICB0b1ZhbHVlID0gdG9WYWx1ZUZyb21UaW1lO1xuICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVRpbWU7XG4gICAgICAgIGZvcm1hdCA9IHN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVfT1VUUFVUX0ZPUk1BVCddO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdG9WYWx1ZSA9IG5vb3A7XG4gICAgICAgIGlmICh0aGlzLmlzQm9vbGVhbigpKSB7XG4gICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd0Jvb2xlYW47XG4gICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbUJvb2xlYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0RhdGUoKSkge1xuICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdEYXRlO1xuICAgICAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21EYXRlO1xuICAgICAgICAgICAgZm9ybWF0ID0gc3RhdGVtZW50UGFyYW1ldGVyc1snREFURV9PVVRQVVRfRk9STUFUJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1RpbWVzdGFtcCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RpbWVzdGFtcEx0eigpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdUaW1lc3RhbXBMdHo7XG4gICAgICAgICAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21UaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVNUQU1QX0xUWl9PVVRQVVRfRk9STUFUJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzVGltZXN0YW1wTnR6KCkpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1RpbWVzdGFtcE50ejtcbiAgICAgICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTlRaX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUaW1lc3RhbXBUeigpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdUaW1lc3RhbXBUejtcbiAgICAgICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfVFpfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhIHR5cGUtc3BlY2lmaWMgdGltZXpvbmUsIHVzZSB0aGUgZGVmYXVsdCBmb3JtYXRcbiAgICAgICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVNUQU1QX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQmluYXJ5KCkpIHtcbiAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3QmluYXJ5O1xuICAgICAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21CaW5hcnk7XG4gICAgICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydCSU5BUllfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNWYXJpYW50KCkpIHtcbiAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3VmFyaWFudDtcbiAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tUmF3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc09iamVjdCgpKSB7XG4gICAgICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uT2JqZWN0KTtcbiAgICAgICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tUmF3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3U3RydWN0dXJlZFR5cGUoY29udmVydEpzb25BcnJheSk7XG4gICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVJhd1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNNYXAoKSkge1xuICAgICAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbk1hcCk7XG4gICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVJhd1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY29sdW1uIGlzIG9mIHR5cGUgc3RyaW5nLCBzbyBsZWF2ZSB2YWx1ZSBhcyBpc1xuICAgICAgICAgICAgY29udmVydCA9IG5vb3A7XG4gICAgICAgICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgYSBwcml2YXRlIGNvbnRleHQgdG8gcGFzcyB0byB0aGUgZXh0cmFjdCBmdW5jdGlvblxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIGNvbnZlcnQ6IGNvbnZlcnQsXG4gICAgICAgIHRvVmFsdWU6IHRvVmFsdWUsXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIHJlc3VsdFZlcnNpb246IHJlc3VsdFZlcnNpb24sXG4gICAgICAgIHN0YXRlbWVudFBhcmFtZXRlcnM6IHN0YXRlbWVudFBhcmFtZXRlcnMsXG4gICAgICAgIGZpZWxkc01ldGFkYXRhOiBmaWVsZHNNZXRhZGF0YSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgY29sdW1uIGluIGEgcm93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvd1xuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdGhpcy5nZXRSb3dWYWx1ZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RGcm9tUm93LmNhbGwodGhpcywgcm93LCBjb250ZXh0LCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGluIGEgcm93IGFzIGEgU3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJvd1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFJvd1ZhbHVlQXNTdHJpbmcgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0RnJvbVJvdy5jYWxsKHRoaXMsIHJvdywgY29udGV4dCwgdHJ1ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY29sdW1uIGlzIG9mIGEgZ2l2ZW5cbiAqIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtblR5cGUgdGhlIGNvbHVtbiB0eXBlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29sdW1uQ29tcGFyaXNvbkZuIHRoZSBjb2x1bW4gY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gaW52b2tlIHRoZSBjb2x1bW4gY29tcGFyaXNvblxuICogICBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUoY29sdW1uVHlwZSwgY29sdW1uQ29tcGFyaXNvbkZuLCBzY29wZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5Db21wYXJpc29uRm4uY2FsbChzY29wZSwgY29sdW1uVHlwZSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgTnVtYmVyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG4gKiB0aGF0IGNvbnRhaW5zIHRoZSByYXcgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHZhbHVlIGFzIHdlbGwgYXMgdGhlXG4gKiBwb3N0LXByb2Nlc3NlZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSBvYnRhaW5lZCBhZnRlciBjYXN0aW5nIHRvIE51bWJlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3TnVtYmVyKHJhd0NvbHVtblZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmF3OiByYXdDb2x1bW5WYWx1ZSxcbiAgICAgICAgcHJvY2Vzc2VkOiBOdW1iZXIocmF3Q29sdW1uVmFsdWUpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSB0aGF0IGlzIGFuIGludGVnZXIuIFRoZSByZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3RcbiAqIHRoYXQgY29udGFpbnMgdGhlIHJhdyBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgdmFsdWUgYXMgd2VsbCBhcyB0aGUgcG9zdC1wcm9jZXNzZWRcbiAqIHZlcnNpb24gb2YgdGhlIHZhbHVlIG9idGFpbmVkIGFmdGVyIGNhc3RpbmcgdG8gYmlnSW50XG4gKlxuICogQHBhcmFtIHJhd0NvbHVtblZhbHVlXG4gKiBAcmV0dXJucyB7e3Byb2Nlc3NlZDogYmlnSW50LkJpZ0ludGVnZXIsIHJhdzogKn19XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdCaWdJbnQocmF3Q29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByYXc6IHJhd0NvbHVtblZhbHVlLFxuICAgICAgICBwcm9jZXNzZWQ6IGJpZ0ludChyYXdDb2x1bW5WYWx1ZSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgQm9vbGVhbiB0byBhIGJvb2xlYW4gKHRydWUsIGZhbHNlLFxuICogb3IgbnVsbCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdCb29sZWFuKHJhd0NvbHVtblZhbHVlKSB7XG4gICAgbGV0IHJldDtcbiAgICBpZiAocmF3Q29sdW1uVmFsdWUgPT09IHRydWUgfHxcbiAgICAgICAgcmF3Q29sdW1uVmFsdWUgPT09ICcxJyB8fFxuICAgICAgICByYXdDb2x1bW5WYWx1ZS50b1VwcGVyQ2FzZSgpID09PSAnVFJVRScpIHtcbiAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmF3Q29sdW1uVmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIHJhd0NvbHVtblZhbHVlID09PSAnMCcgfHxcbiAgICAgICAgcmF3Q29sdW1uVmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ0ZBTFNFJykge1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCB0byBib29sZWFuOiAke3Jhd0NvbHVtblZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2Ygc3RydWN0dXJlZCB0eXBlIG9iamVjdCB0byBqYXZhc2NyaXB0IE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRKc29uT2JqZWN0KGpzb24sIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5maWVsZHNNZXRhZGF0YSkge1xuICAgICAgICBjb250ZXh0LmZpZWxkc01ldGFkYXRhID0gY29udGV4dC5maWVsZHNNZXRhZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgb2JqKSB7XG4gICAgICAgICAgICBtYXBbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE1ldGFkYXRhID0gY29udGV4dC5maWVsZHNNZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtYXBTdHJ1Y3R1cmVkVHlwZVZhbHVlKGpzb25ba2V5XSwgY29udGV4dCwgZmllbGRNZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2Ygc3RydWN0dXJlZCB0eXBlIGFycmF5IHRvIGphdmFzY3JpcHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydEpzb25BcnJheShqc29uLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuZmllbGRzTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGpzb24uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcFN0cnVjdHVyZWRUeXBlVmFsdWUodmFsdWUsIGNvbnRleHQsIGNvbnRleHQuZmllbGRzTWV0YWRhdGFbMF0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiBzdHJ1Y3R1cmVkIHR5cGUgbWFwIHRvIGphdmFzY3JpcHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydEpzb25NYXAoanNvbiwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRleHQuZmllbGRzTWV0YWRhdGEpICYmIGNvbnRleHQuZmllbGRzTWV0YWRhdGEubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qga2V5TWV0YWRhdGEgPSBjb250ZXh0LmZpZWxkc01ldGFkYXRhWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZU1ldGFkYXRhID0gY29udGV4dC5maWVsZHNNZXRhZGF0YVsxXTtcbiAgICAgICAgT2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRLZXkgPSBtYXBTdHJ1Y3R1cmVkVHlwZVZhbHVlKGtleSwgY29udGV4dCwga2V5TWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBtYXBTdHJ1Y3R1cmVkVHlwZVZhbHVlKGpzb25ba2V5XSwgY29udGV4dCwgdmFsdWVNZXRhZGF0YSk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGNvbnZlcnRlZEtleSwgY29udmVydGVkVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHN0cnVjdHVyZWQgdHlwZSBPQkpFQ1QgdG8gamF2YXNjcmlwdCBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgY29udmVydFJhd1N0cnVjdHVyZWRUeXBlID0gKGNvbnZlcnRKc29uRm4pID0+IChyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKFV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkocmF3Q29sdW1uVmFsdWUpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyYXdDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydEpzb25Gbihqc29uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoanNvblBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb2x1bW4gJXMgcmF3IHZhbHVlIGNhbm5vdCBiZSBwYXJzZWQgYXMgSlNPTjogJXMgJywgY29sdW1uLm5hbWUsIGpzb25QYXJzZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdDb2x1bW4gWyVzXSByYXcgdmFsdWUgY2Fubm90IGJlIHBhcnNlZCBhcyBKU09OOiAlcyAnLCBjb2x1bW4ubmFtZSwganNvblBhcnNlRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ0NvbHVtbiAlcyByYXcgdmFsdWUgaXMgbnVsbCBvciBlbXB0eSAnLCBjb2x1bW4ubmFtZSkpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBtYXBTdHJ1Y3R1cmVkVHlwZVZhbHVlKGNvbHVtblZhbHVlLCBjb250ZXh0LCBtZXRhZGF0YUZpZWxkKSB7XG4gICAgY29uc3QgZm9ybWF0THR6ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTFRaX09VVFBVVF9GT1JNQVQnXSA/P1xuICAgICAgICBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9PVVRQVVRfRk9STUFUJ107XG4gICAgY29uc3QgZm9ybWF0VHogPSBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9UWl9PVVRQVVRfRk9STUFUJ10gPz9cbiAgICAgICAgY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfT1VUUFVUX0ZPUk1BVCddO1xuICAgIGNvbnN0IGZvcm1hdE50eiA9IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVNUQU1QX05UWl9PVVRQVVRfRk9STUFUJ107XG4gICAgbGV0IHZhbHVlO1xuICAgIHN3aXRjaCAobWV0YWRhdGFGaWVsZC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgdmFsdWUgPSBjb2x1bW5WYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZWFsJzpcbiAgICAgICAgICAgIHZhbHVlID0gdG9WYWx1ZUZyb21OdW1iZXIoY29udmVydFJhd051bWJlcihjb2x1bW5WYWx1ZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZpeGVkJzpcbiAgICAgICAgICAgIHZhbHVlID0gdG9WYWx1ZUZyb21OdW1iZXIoY29udmVydFJhd051bWJlcihjb2x1bW5WYWx1ZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0UmF3Qm9vbGVhbihjb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGltZXN0YW1wX2x0eic6XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRUaW1lc3RhbXBUelN0cmluZyhjb2x1bW5WYWx1ZSwgZm9ybWF0THR6LCBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVaT05FJ10sIG1ldGFkYXRhRmllbGQuc2NhbGUpLnRvU2ZEYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGltZXN0YW1wX250eic6XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRUaW1lc3RhbXBOdHpTdHJpbmcoY29sdW1uVmFsdWUsIGZvcm1hdE50eiwgbW9tZW50LnR6LnpvbmUoJ1VUQycpLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmRGF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcF90eic6XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRUaW1lc3RhbXBUelN0cmluZyhjb2x1bW5WYWx1ZSwgZm9ybWF0VHosIGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVpPTkUnXSwgbWV0YWRhdGFGaWVsZC5zY2FsZSkudG9TZkRhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkYXRlJzoge1xuICAgICAgICAgICAgY29udGV4dC5mb3JtYXQgPSBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ0RBVEVfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0RGF0ZVN0cmluZyhjb2x1bW5WYWx1ZSwgY29udGV4dC5mb3JtYXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICBjb250ZXh0LmZvcm1hdCA9IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRV9PVVRQVVRfRk9STUFUJ107XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRUaW1lU3RyaW5nKGNvbHVtblZhbHVlLCBjb250ZXh0LmZvcm1hdCwgbW9tZW50LnR6LnpvbmUoJ1VUQycpLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmVGltZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICBjb250ZXh0LmZvcm1hdCA9IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snQklOQVJZX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydFJhd0JpbmFyeShjb2x1bW5WYWx1ZSwgdGhpcywgY29udGV4dCkudG9KU09OKCkuZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY29udmVydDogY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uT2JqZWN0KSxcbiAgICAgICAgICAgICAgICB0b1ZhbHVlOiBub29wLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRvU3RyaW5nRnJvbVJhd1ZhbHVlLFxuICAgICAgICAgICAgICAgIHJlc3VsdFZlcnNpb246IGNvbnRleHQucmVzdWx0VmVyc2lvbixcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRQYXJhbWV0ZXJzOiBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgZmllbGRzTWV0YWRhdGE6IG1ldGFkYXRhRmllbGQuZmllbGRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydEpzb25PYmplY3QoY29sdW1uVmFsdWUsIGludGVybmFsQ29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsQXJyYXlDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNvbnZlcnQ6IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbkFycmF5KSxcbiAgICAgICAgICAgICAgICB0b1ZhbHVlOiBub29wLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRvU3RyaW5nRnJvbVJhd1ZhbHVlLFxuICAgICAgICAgICAgICAgIHJlc3VsdFZlcnNpb246IGNvbnRleHQucmVzdWx0VmVyc2lvbixcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRQYXJhbWV0ZXJzOiBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgZmllbGRzTWV0YWRhdGE6IG1ldGFkYXRhRmllbGQuZmllbGRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydEpzb25BcnJheShjb2x1bW5WYWx1ZSwgaW50ZXJuYWxBcnJheUNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWFwJzoge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxNYXBDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNvbnZlcnQ6IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbk1hcCksXG4gICAgICAgICAgICAgICAgdG9WYWx1ZTogbm9vcCxcbiAgICAgICAgICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0b1N0cmluZ0Zyb21SYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICByZXN1bHRWZXJzaW9uOiBjb250ZXh0LnJlc3VsdFZlcnNpb24sXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50UGFyYW1ldGVyczogY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGZpZWxkc01ldGFkYXRhOiBtZXRhZGF0YUZpZWxkLmZpZWxkcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnRKc29uTWFwKGNvbHVtblZhbHVlLCBpbnRlcm5hbE1hcENvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oYENvbHVtbiB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICR7Y29udGV4dC5maWVsZHNNZXRhZGF0YS50eXBlfWApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2x1bW4gdHlwZSBub3Qgc3VwcG9ydGVkOiAke2NvbnRleHQuZmllbGRzTWV0YWRhdGEudHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgY29udmVydFRpbWVzdGFtcFR6U3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZ1ZhbHVlLCBmb3JtYXRTcWwsIHRpbWV6b25lLCBzY2FsZSkge1xuICAgIGNvbnN0IGZvcm1hdE1vbWVudCA9IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyLmNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIHNjYWxlKTtcbiAgICBjb25zdCBlcG9jaFNlY29uZHMgPSBtb21lbnRUaW1lem9uZShzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KS51bml4KCk7XG4gICAgcmV0dXJuIG5ldyBTZlRpbWVzdGFtcChlcG9jaFNlY29uZHMsIDAsIHNjYWxlLCB0aW1lem9uZSwgZm9ybWF0U3FsKTtcbn07XG5jb25zdCBjb252ZXJ0VGltZXN0YW1wTnR6U3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZ1ZhbHVlLCBmb3JtYXRTcWwsIHRpbWV6b25lLCBzY2FsZSkge1xuICAgIGNvbnN0IGZvcm1hdE1vbWVudCA9IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyLmNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIHNjYWxlKTtcbiAgICBjb25zdCBlcG9jaFNlY29uZHMgPSBtb21lbnRUaW1lem9uZS51dGMoc3RyaW5nVmFsdWUsIGZvcm1hdE1vbWVudCkudW5peCgpO1xuICAgIHJldHVybiBuZXcgU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCAwLCBzY2FsZSwgdGltZXpvbmUsIGZvcm1hdFNxbCk7XG59O1xuY29uc3QgY29udmVydERhdGVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nVmFsdWUsIGZvcm1hdFNxbCkge1xuICAgIGNvbnN0IGZvcm1hdE1vbWVudCA9IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyLmNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIDApO1xuICAgIGNvbnN0IGVwb2NoU2Vjb25kcyA9IG1vbWVudFRpbWV6b25lLnV0YyhzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KS51bml4KCk7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBTZlRpbWVzdGFtcChlcG9jaFNlY29uZHMsIC8vIGNvbnZlcnQgdG8gc2Vjb25kc1xuICAgIDAsIC8vIG5vIG5hbm8gc2Vjb25kc1xuICAgIDAsIC8vIG5vIHNjYWxlIHJlcXVpcmVkXG4gICAgJ1VUQycsIC8vIHVzZSB1dGMgYXMgdGhlIHRpbWV6b25lXG4gICAgY29udGV4dC5mb3JtYXQpO1xuICAgIGRhdGUuX3ZhbHVlQXNTdHJpbmcgPSBzdHJpbmdWYWx1ZTtcbiAgICByZXR1cm4gZGF0ZS50b1NmRGF0ZSgpO1xufTtcbmNvbnN0IGNvbnZlcnRUaW1lU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZ1ZhbHVlLCBmb3JtYXRTcWwsIHRpbWV6b25lLCBzY2FsZSkge1xuICAgIGNvbnN0IGZvcm1hdE1vbWVudCA9IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyLmNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIHNjYWxlKTtcbiAgICBjb25zdCBtb21lbnQgPSBtb21lbnRUaW1lem9uZShzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KTtcbiAgICBjb25zdCBlcG9jaFNlY29uZHMgPSBtb21lbnQuaG91cnMoKSAqIDM2MDAgKyBtb21lbnQubWludXRlcygpICogNjAgKyBtb21lbnQuc2Vjb25kcygpO1xuICAgIGNvbnN0IHRpbWUgPSBuZXcgU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCAwLCBzY2FsZSwgdGltZXpvbmUsIGZvcm1hdFNxbCk7XG4gICAgdGltZS5fdmFsdWVBc1N0cmluZyA9IHN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0aW1lO1xufTtcbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgRGF0ZSB0byBhIFNub3dmbGFrZSBEYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd0RhdGUocmF3Q29sdW1uVmFsdWUsIGNvbHVtbiwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgU2ZUaW1lc3RhbXAoTnVtYmVyKHJhd0NvbHVtblZhbHVlKSAqIDg2NDAwLCAvLyBjb252ZXJ0IHRvIHNlY29uZHNcbiAgICAwLCAvLyBubyBuYW5vIHNlY29uZHNcbiAgICAwLCAvLyBubyBzY2FsZSByZXF1aXJlZFxuICAgICdVVEMnLCAvLyB1c2UgdXRjIGFzIHRoZSB0aW1lem9uZVxuICAgIGNvbnRleHQuZm9ybWF0KS50b1NmRGF0ZSgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBUaW1lIHRvIGEgU25vd2ZsYWtlIFRpbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lKHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpIHtcbiAgICBjb25zdCBjb2x1bW5TY2FsZSA9IGNvbHVtbi5nZXRTY2FsZSgpO1xuICAgIC8vIHRoZSB2YWx1ZXMgbWlnaHQgYmUgYmlnIHNvIHVzZSBCaWdOdW1iZXIgdG8gZG8gYXJpdGhtZXRpY1xuICAgIGNvbnN0IHZhbEZyYWNTZWNzQmlnID0gbmV3IEJpZ051bWJlcihyYXdDb2x1bW5WYWx1ZSkudGltZXMoTWF0aC5wb3coMTAsIGNvbHVtblNjYWxlKSk7XG4gICAgcmV0dXJuIGNvbnZlcnRSYXdUaW1lc3RhbXBIZWxwZXIodmFsRnJhY1NlY3NCaWcsIGNvbHVtblNjYWxlLCAnVVRDJywgY29udGV4dC5mb3JtYXQpLnRvU2ZUaW1lKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIFRJTUVTVEFNUF9MVFogdG8gYSBTbm93Zmxha2UgRGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lc3RhbXBMdHoocmF3Q29sdW1uVmFsdWUsIGNvbHVtbiwgY29udGV4dCkge1xuICAgIGNvbnN0IGNvbHVtblNjYWxlID0gY29sdW1uLmdldFNjYWxlKCk7XG4gICAgLy8gdGhlIHZhbHVlcyBtaWdodCBiZSBiaWcgc28gdXNlIEJpZ051bWJlciB0byBkbyBhcml0aG1ldGljXG4gICAgY29uc3QgdmFsRnJhY1NlY3NCaWcgPSBuZXcgQmlnTnVtYmVyKHJhd0NvbHVtblZhbHVlKS50aW1lcyhNYXRoLnBvdygxMCwgY29sdW1uU2NhbGUpKTtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc25vd2ZsYWtlIGRhdGVcbiAgICByZXR1cm4gY29udmVydFJhd1RpbWVzdGFtcEhlbHBlcih2YWxGcmFjU2Vjc0JpZywgY29sdW1uU2NhbGUsIGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVpPTkUnXSwgY29udGV4dC5mb3JtYXQpLnRvU2ZEYXRlKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIFRJTUVTVEFNUF9OVFogdG8gYSBTbm93Zmxha2UgRGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lc3RhbXBOdHoocmF3Q29sdW1uVmFsdWUsIGNvbHVtbiwgY29udGV4dCkge1xuICAgIGNvbnN0IGNvbHVtblNjYWxlID0gY29sdW1uLmdldFNjYWxlKCk7XG4gICAgLy8gdGhlIHZhbHVlcyBtaWdodCBiZSBiaWcgc28gdXNlIEJpZ051bWJlciB0byBkbyBhcml0aG1ldGljXG4gICAgY29uc3QgdmFsRnJhY1NlY3NCaWcgPSBuZXcgQmlnTnVtYmVyKHJhd0NvbHVtblZhbHVlKS50aW1lcyhNYXRoLnBvdygxMCwgY29sdW1uU2NhbGUpKTtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc25vd2ZsYWtlIGRhdGVcbiAgICByZXR1cm4gY29udmVydFJhd1RpbWVzdGFtcEhlbHBlcih2YWxGcmFjU2Vjc0JpZywgY29sdW1uU2NhbGUsICdVVEMnLCAvLyBpdCdzIF9udHosIHNvIHVzZSBVVEMgZm9yIHRpbWV6b25lXG4gICAgY29udGV4dC5mb3JtYXQpLnRvU2ZEYXRlKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIFRJTUVTVEFNUF9UWiB0byBhIFNub3dmbGFrZSBEYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb2x1bW5WYWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd1RpbWVzdGFtcFR6KHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpIHtcbiAgICBsZXQgdmFsRnJhY1NlY3NCaWc7XG4gICAgbGV0IHZhbEZyYWNTZWNzV2l0aFR6QmlnO1xuICAgIGxldCB0aW1lem9uZUJpZztcbiAgICBsZXQgdGltZXpvbmU7XG4gICAgbGV0IHRpbWVzdGFtcEFuZFRaSW5kZXg7XG4gICAgLy8gY29tcHV0ZSB0aGUgc2NhbGUgZmFjdG9yXG4gICAgY29uc3QgY29sdW1uU2NhbGUgPSBjb2x1bW4uZ2V0U2NhbGUoKTtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IE1hdGgucG93KDEwLCBjb2x1bW5TY2FsZSk7XG4gICAgY29uc3QgcmVzdWx0VmVyc2lvbiA9IGNvbnRleHQucmVzdWx0VmVyc2lvbjtcbiAgICBpZiAocmVzdWx0VmVyc2lvbiA9PT0gJzAnIHx8IHJlc3VsdFZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGUgdmFsdWVzIG1pZ2h0IGJlIGJpZyBzbyB1c2UgQmlnTnVtYmVyIHRvIGRvIGFyaXRobWV0aWNcbiAgICAgICAgdmFsRnJhY1NlY3NCaWcgPSBuZXcgQmlnTnVtYmVyKHJhd0NvbHVtblZhbHVlKS50aW1lcyhzY2FsZUZhY3Rvcik7XG4gICAgICAgIC8vIGZvciBfdHosIHRoZSB0aW1lem9uZSBpcyBiYWtlZCBpbnRvIHRoZSB2YWx1ZVxuICAgICAgICB2YWxGcmFjU2Vjc1dpdGhUekJpZyA9IHZhbEZyYWNTZWNzQmlnO1xuICAgICAgICAvLyBleHRyYWN0IGV2ZXJ5dGhpbmcgYnV0IHRoZSBsb3dlc3QgMTQgYml0cyB0byBnZXQgdGhlIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgICAgICB2YWxGcmFjU2Vjc0JpZyA9IHZhbEZyYWNTZWNzV2l0aFR6QmlnLmRpdmlkZWRCeSgxNjM4NCkuaW50ZWdlclZhbHVlKEJpZ051bWJlci5ST1VORF9GTE9PUik7XG4gICAgICAgIC8vIGV4dHJhY3QgdGhlIGxvd2VzdCAxNCBiaXRzIHRvIGdldCB0aGUgdGltZXpvbmVcbiAgICAgICAgaWYgKHZhbEZyYWNTZWNzV2l0aFR6QmlnLmlzR3JlYXRlclRoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgICAgICAgIHRpbWV6b25lQmlnID0gdmFsRnJhY1NlY3NXaXRoVHpCaWcubW9kdWxvKDE2Mzg0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWV6b25lQmlnID0gdmFsRnJhY1NlY3NXaXRoVHpCaWcubW9kdWxvKDE2Mzg0KS5wbHVzKDE2Mzg0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3BsaXQgdGhlIHZhbHVlIGludG8gbnVtYmVyIG9mIHNlY29uZHMgYW5kIHRpbWV6b25lIGluZGV4XG4gICAgICAgIHRpbWVzdGFtcEFuZFRaSW5kZXggPSByYXdDb2x1bW5WYWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAvLyB0aGUgdmFsdWVzIG1pZ2h0IGJlIGJpZyBzbyB1c2UgQmlnTnVtYmVyIHRvIGRvIGFyaXRobWV0aWNcbiAgICAgICAgdmFsRnJhY1NlY3NCaWcgPSBuZXcgQmlnTnVtYmVyKHRpbWVzdGFtcEFuZFRaSW5kZXhbMF0pLnRpbWVzKHNjYWxlRmFjdG9yKTtcbiAgICAgICAgdGltZXpvbmVCaWcgPSBuZXcgQmlnTnVtYmVyKHRpbWVzdGFtcEFuZFRaSW5kZXhbMV0pO1xuICAgIH1cbiAgICB0aW1lem9uZSA9IHRpbWV6b25lQmlnLnRvTnVtYmVyKCk7XG4gICAgLy8gYXNzZXJ0IHRoYXQgdGltZXpvbmUgaXMgdmFsaWRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwodGltZXpvbmUgPj0gMCAmJiB0aW1lem9uZSA8PSAyODgwKTtcbiAgICAvLyBzdWJ0cmFjdCAyNCBob3VycyBmcm9tIHRoZSB0aW1lem9uZSB0byBtYXAgWzAsIDQ4XSB0b1xuICAgIC8vIFstMjQsIDI0XSwgYW5kIGNvbnZlcnQgdGhlIHJlc3VsdCB0byBhIG51bWJlclxuICAgIHRpbWV6b25lID0gdGltZXpvbmUgLSAxNDQwO1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzbm93Zmxha2UgZGF0ZVxuICAgIHJldHVybiBjb252ZXJ0UmF3VGltZXN0YW1wSGVscGVyKHZhbEZyYWNTZWNzQmlnLCBjb2x1bW5TY2FsZSwgdGltZXpvbmUsIGNvbnRleHQuZm9ybWF0KS50b1NmRGF0ZSgpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHRoZSBjb252ZXJ0UmF3VGltZXN0YW1wKigpIGZ1bmN0aW9ucy5cbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgU2ZUaW1lc3RhbXAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVwb2NoRnJhY1NlY3NCaWdcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IHRpbWV6b25lXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd1RpbWVzdGFtcEhlbHBlcihlcG9jaEZyYWNTZWNzQmlnLCBzY2FsZSwgdGltZXpvbmUsIGZvcm1hdCkge1xuICAgIC8vIGNvbXB1dGUgdGhlIHNjYWxlIGZhY3RvclxuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gTWF0aC5wb3coMTAsIHNjYWxlKTtcbiAgICAvLyBzcGxpdCB0aGUgdmFsdWUgaW50byBlcG9jaCBzZWNvbmRzICsgbmFub3NlY29uZHM7IGZvciBleGFtcGxlLFxuICAgIC8vIDEzNjUxNDg5MjMuMTIzNDU2Nzg5IHdpbGwgYmUgc3BsaXQgaW50byAxMzY1MTQ4OTIzIChlcG9jaCBzZWNvbmRzKVxuICAgIC8vIGFuZCAxMjM0NTY3ODkgKG5hbm8gc2Vjb25kcylcbiAgICBjb25zdCB2YWxTZWNCaWcgPSBlcG9jaEZyYWNTZWNzQmlnLmRpdmlkZWRCeShzY2FsZUZhY3RvcikuaW50ZWdlclZhbHVlKEJpZ051bWJlci5ST1VORF9GTE9PUik7XG4gICAgY29uc3QgZnJhY3Rpb25zQmlnID0gZXBvY2hGcmFjU2Vjc0JpZy5taW51cyh2YWxTZWNCaWcudGltZXMoc2NhbGVGYWN0b3IpKTtcbiAgICBjb25zdCB2YWxTZWNOYW5vQmlnID0gZnJhY3Rpb25zQmlnLnRpbWVzKE1hdGgucG93KDEwLCA5IC0gc2NhbGUpKTtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc25vd2ZsYWtlIGRhdGUgZnJvbSB0aGUgaW5mb3JtYXRpb25cbiAgICByZXR1cm4gbmV3IFNmVGltZXN0YW1wKHZhbFNlY0JpZy50b051bWJlcigpLCB2YWxTZWNOYW5vQmlnLnRvTnVtYmVyKCksIHNjYWxlLCB0aW1lem9uZSwgZm9ybWF0KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgVmFyaWFudCB0byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge09iamVjdCB8IEFycmF5fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3VmFyaWFudChyYXdDb2x1bW5WYWx1ZSkge1xuICAgIC8vIGlmIHRoZSBpbnB1dCBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gYSBqc29uIG9iamVjdFxuICAgIGlmIChVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KHJhd0NvbHVtblZhbHVlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEdsb2JhbENvbmZpZy5qc29uQ29sdW1uVmFyaWFudFBhcnNlcihyYXdDb2x1bW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGpzb25QYXJzZUVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHbG9iYWxDb25maWcueG1sQ29sdW1uVmFyaWFudFBhcnNlcihyYXdDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoeG1sUGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdWYXJpYW50IGNhbm5vdCBiZSBwYXJzZWQgbmVpdGhlciBhcyBKU09OOiAlcyBub3IgYXMgWE1MOiAlcycsIGpzb25QYXJzZUVycm9yLm1lc3NhZ2UsIHhtbFBhcnNlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5WYXJpYW50UGFyc2VFcnJvcihqc29uUGFyc2VFcnJvciwgeG1sUGFyc2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIEJpbmFyeSB0byBhIEJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd0JpbmFyeShyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSB7XG4gICAgLy8gRW5zdXJlIHRoZSBmb3JtYXQgaXMgdmFsaWQuXG4gICAgY29uc3QgZm9ybWF0ID0gY29udGV4dC5mb3JtYXQudG9VcHBlckNhc2UoKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoZm9ybWF0ID09PSAnSEVYJyB8fCBmb3JtYXQgPT09ICdCQVNFNjQnKTtcbiAgICAvLyBEZWNvZGUgaGV4IHN0cmluZyBzZW50IGJ5IEdTLlxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHJhd0NvbHVtblZhbHVlLCAnSEVYJyk7XG4gICAgaWYgKGZvcm1hdCA9PT0gJ0hFWCcpIHtcbiAgICAgICAgYnVmZmVyLnRvU3RyaW5nU2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGUgcmF3IHZhbHVlIGlzIGFscmVhZHkgYW4gdXBwZXJjYXNlIGhleCBzdHJpbmcsIHNvIGp1c3QgcmV0dXJuIGl0LlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGJ1ZmZlci50b1N0cmluZyhcIkhFWFwiKSByZXR1cm5zIGEgbG93ZXJjYXNlIGhleCBzdHJpbmcsIGJ1dCB3ZVxuICAgICAgICAgICAgLy8gd2FudCB1cHBlciBjYXNlLlxuICAgICAgICAgICAgcmV0dXJuIHJhd0NvbHVtblZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnRvU3RyaW5nU2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygnQkFTRTY0Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1ZmZlci5nZXRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnB1dCB2YWx1ZSBhcyBpcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIG5vb3AodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFRoZSB0b1ZhbHVlKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgTnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7Kn0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiB0b1ZhbHVlRnJvbU51bWJlcihjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSA/IGNvbHVtblZhbHVlLnByb2Nlc3NlZCA6IGNvbHVtblZhbHVlO1xufVxuLyoqXG4gKiBUaGUgdG9WYWx1ZSgpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIFRpbWUuXG4gKlxuICogQHBhcmFtIHsqfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWVGcm9tVGltZShjb2x1bW5WYWx1ZSkge1xuICAgIC8vIHRoZXJlJ3Mgbm8gbmF0aXZlIGphdmFzY3JpcHQgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aW1lLCBzb1xuICAgIC8vIGp1c3QgY29udmVydCB0byBzdHJpbmdcbiAgICByZXR1cm4gdG9TdHJpbmdGcm9tVGltZShjb2x1bW5WYWx1ZSk7XG59XG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIE51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21OdW1iZXIoY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBjb2x1bW5WYWx1ZS5yYXcgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIEJvb2xlYW4uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbUJvb2xlYW4oY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBTdHJpbmcoY29sdW1uVmFsdWUpLnRvVXBwZXJDYXNlKCkgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIERhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbURhdGUoY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBjb2x1bW5WYWx1ZS50b0pTT04oKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21UaW1lKGNvbHVtblZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbHVtblZhbHVlICE9PSBudWxsID8gY29sdW1uVmFsdWUudG9KU09OKCkgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIFRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tVGltZXN0YW1wKGNvbHVtblZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbHVtblZhbHVlICE9PSBudWxsID8gY29sdW1uVmFsdWUudG9KU09OKCkgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIFZhcmlhbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tUmF3VmFsdWUoY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBKU09OLnN0cmluZ2lmeShjb2x1bW5WYWx1ZSkgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIFN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21TdHJpbmcoY29sdW1uVmFsdWUpIHtcbiAgICByZXR1cm4gY29sdW1uVmFsdWUgIT09IG51bGwgPyBjb2x1bW5WYWx1ZSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgQmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbUJpbmFyeShjb2x1bW5WYWx1ZSkge1xuICAgIHJldHVybiBjb2x1bW5WYWx1ZSAhPT0gbnVsbCA/IGNvbHVtblZhbHVlLnRvU3RyaW5nU2YoKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgdGhlIHZhbHVlIG9mIGEgY29sdW1uIGZyb20gYSBnaXZlbiByb3cuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJvd1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNTdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEZyb21Sb3cocm93LCBjb250ZXh0LCBhc1N0cmluZykge1xuICAgIGNvbnN0IG1hcCA9IHJvdy5fYXJyYXlQcm9jZXNzZWRDb2x1bW5zO1xuICAgIGNvbnN0IHZhbHVlcyA9IHJvdy52YWx1ZXM7XG4gICAgLy8gZ2V0IHRoZSB2YWx1ZVxuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgIGxldCByZXQgPSB2YWx1ZXNbY29sdW1uSW5kZXhdO1xuICAgIC8vIGlmIHdlIHdhbnQgdGhlIHZhbHVlIGFzIGEgc3RyaW5nLCBhbmQgdGhlIGNvbHVtbiBpcyBvZiB0eXBlIHZhcmlhbnQsIGFuZCB3ZVxuICAgIC8vIGhhdmVuJ3QgYWxyZWFkeSBwcm9jZXNzZWQgdGhlIHZhbHVlIGJlZm9yZSwgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZXNzIHRoZVxuICAgIC8vIHZhbHVlLCBzbyBvbmx5IHByb2Nlc3MgaWYgbm9uZSBvZiB0aGUgYWZvcmVtZW50aW9uZWQgY29uZGl0aW9ucyBhcmUgdHJ1ZVxuICAgIGlmICghKGFzU3RyaW5nICYmIHRoaXMuaXNWYXJpYW50KCkgJiYgIW1hcFtjb2x1bW5JbmRleF0pKSB7XG4gICAgICAgIC8vIGlmIHRoZSBjb2x1bW4gdmFsdWUgaGFzIG5vdCBiZWVuIHByb2Nlc3NlZCB5ZXQsIHByb2Nlc3MgaXQsIHB1dCBpdCBiYWNrXG4gICAgICAgIC8vIGluIHRoZSB2YWx1ZXMgYXJyYXksIGFuZCByZW1lbWJlciB0aGF0IHRoZSB2YWx1ZSBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgICAgaWYgKCFtYXBbY29sdW1uSW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAocmV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gdmFsdWVzW2NvbHVtbkluZGV4XSA9IGNvbnRleHQuY29udmVydCh2YWx1ZXNbY29sdW1uSW5kZXhdLCB0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFtjb2x1bW5JbmRleF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSB0aGUgYXBwcm9wcmlhdGUgZXh0cmFjdGlvbiBmdW5jdGlvbiBkZXBlbmRpbmcgb24gd2hldGhlclxuICAgICAgICAvLyB3ZSB3YW50IHRoZSB2YWx1ZSBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWVcbiAgICAgICAgY29uc3QgZXh0cmFjdEZuID0gIWFzU3RyaW5nID8gY29udGV4dC50b1ZhbHVlIDogY29udGV4dC50b1N0cmluZztcbiAgICAgICAgcmV0ID0gZXh0cmFjdEZuKHJldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbHVtbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/column.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst sqlTypes = {\n    values: {\n        TEXT: 'text',\n        BINARY: 'binary',\n        BOOLEAN: 'boolean',\n        FIXED: 'fixed',\n        REAL: 'real',\n        DATE: 'date',\n        TIME: 'time',\n        TIMESTAMP_LTZ: 'timestamp_ltz',\n        TIMESTAMP_NTZ: 'timestamp_ntz',\n        TIMESTAMP_TZ: 'timestamp_tz',\n        VARIANT: 'variant',\n        OBJECT: 'object',\n        ARRAY: 'array',\n        MAP: 'map',\n    },\n    /**\n     * Determines if a column's SQL type is String.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isString: function (sqlType) {\n        return sqlType === this.values.TEXT;\n    },\n    /**\n     * Determines if a column's SQL type is Binary.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isBinary: function (sqlType) {\n        return sqlType === this.values.BINARY;\n    },\n    /**\n     * Determines if a column's SQL type is Boolean.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isBoolean: function (sqlType) {\n        return sqlType === this.values.BOOLEAN;\n    },\n    /**\n     * Determines if a column's SQL type is Number.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isNumber: function (sqlType) {\n        return sqlType === this.values.FIXED || sqlType === this.values.REAL;\n    },\n    /**\n     * Determines if a column's SQL type is Date.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isDate: function (sqlType) {\n        return sqlType === this.values.DATE;\n    },\n    /**\n     * Determines if a column's SQL type is Time.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTime: function (sqlType) {\n        return sqlType === this.values.TIME;\n    },\n    /**\n     * Determines if a column's SQL type is Timestamp.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestamp: function (sqlType) {\n        return (sqlType === this.values.TIMESTAMP_LTZ ||\n            sqlType === this.values.TIMESTAMP_NTZ ||\n            sqlType === this.values.TIMESTAMP_TZ);\n    },\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_LTZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampLtz: function (sqlType) {\n        return sqlType === this.values.TIMESTAMP_LTZ;\n    },\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_NTZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampNtz: function (sqlType) {\n        return sqlType === this.values.TIMESTAMP_NTZ;\n    },\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_TZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampTz: function (sqlType) {\n        return sqlType === this.values.TIMESTAMP_TZ;\n    },\n    /**\n     * Determines if a column's SQL type is Variant.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isVariant: function (sqlType, fieldsMetadata) {\n        return (sqlType === this.values.VARIANT ||\n            (sqlType === this.values.OBJECT && fieldsMetadata == null) ||\n            (sqlType === this.values.ARRAY && fieldsMetadata == null) ||\n            (sqlType === this.values.MAP && fieldsMetadata == null));\n    },\n    /**\n     * Determines if a column's SQL type is Object.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isObject: function (sqlType, fieldsMetadata) {\n        return sqlType === this.values.OBJECT && fieldsMetadata != null;\n    },\n    /**\n     * Determines if a column's SQL type is Array.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isArray: function (sqlType, fieldsMetadata) {\n        return sqlType === this.values.ARRAY && fieldsMetadata != null;\n    },\n    /**\n     * Determines if a column's SQL type is Map.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isMap: function (sqlType, fieldsMetadata) {\n        return sqlType === this.values.MAP && fieldsMetadata != null;\n    },\n};\nconst nativeTypes = {\n    values: {\n        STRING: 'STRING',\n        BOOLEAN: 'BOOLEAN',\n        NUMBER: 'NUMBER',\n        DATE: 'DATE',\n        JSON: 'JSON',\n        BUFFER: 'BUFFER',\n        OBJECT: 'OBJECT',\n        ARRAY: 'ARRAY',\n        MAP: 'MAP',\n    },\n    /**\n     * Determines if a given value is a valid native type.\n     *\n     * @param {*} value\n     *\n     * @returns {boolean}\n     */\n    isValidValue: function (value) {\n        return !!this.values[Util.isString(value) ? value.toUpperCase() : value];\n    },\n    /**\n     * Given an array of strings, returns the index of the first element that\n     * represents an invalid native type. If the values are all valid, a value of\n     * -1 is returned.\n     *\n     * @param {String[]} nativeTypes\n     *\n     * @returns {Number}\n     */\n    findInvalidValue: function (nativeTypes) {\n        // validate input\n        Errors.assertInternal(Util.isArray(nativeTypes));\n        // find the index of the first invalid value\n        let invalidValueIndex = -1;\n        for (let index = 0, length = nativeTypes.length; index < length; index++) {\n            if (!this.isValidValue(nativeTypes[index])) {\n                invalidValueIndex = index;\n                break;\n            }\n        }\n        return invalidValueIndex;\n    },\n};\nlet isRepresentNullAsStringNull = true;\nexports.setIsRepresentNullAsStringNull = function (option) {\n    isRepresentNullAsStringNull = option;\n};\nexports.getNullValue = function () {\n    return isRepresentNullAsStringNull ? 'NULL' : null;\n};\nconst sqlTypeValues = sqlTypes.values;\nconst nativeTypeValues = nativeTypes.values;\nconst MAP_SQL_TO_NATIVE = {};\nMAP_SQL_TO_NATIVE[sqlTypeValues.TEXT] = nativeTypeValues.STRING;\nMAP_SQL_TO_NATIVE[sqlTypeValues.BINARY] = nativeTypeValues.BUFFER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.BOOLEAN] = nativeTypeValues.BOOLEAN;\nMAP_SQL_TO_NATIVE[sqlTypeValues.FIXED] = nativeTypeValues.NUMBER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.REAL] = nativeTypeValues.NUMBER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.DATE] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIME] = nativeTypeValues.STRING;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_LTZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_NTZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_TZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.VARIANT] = nativeTypeValues.JSON;\nMAP_SQL_TO_NATIVE[sqlTypeValues.OBJECT] = nativeTypeValues.OBJECT;\nMAP_SQL_TO_NATIVE[sqlTypeValues.ARRAY] = nativeTypeValues.ARRAY;\nMAP_SQL_TO_NATIVE[sqlTypeValues.MAP] = nativeTypeValues.MAP;\nexports.SqlTypes = sqlTypes;\nexports.NativeTypes = nativeTypes;\n/**\n * Given a SQL type, returns the corresponding native type.\n *\n * @param {String} sqlType\n *\n * @returns {String}\n */\nexports.toNativeType = function (sqlType) {\n    return MAP_SQL_TO_NATIVE[sqlType];\n};\n//# sourceMappingURL=data_types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRhX3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLHVFQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRhX3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3Qgc3FsVHlwZXMgPSB7XG4gICAgdmFsdWVzOiB7XG4gICAgICAgIFRFWFQ6ICd0ZXh0JyxcbiAgICAgICAgQklOQVJZOiAnYmluYXJ5JyxcbiAgICAgICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgICAgICBGSVhFRDogJ2ZpeGVkJyxcbiAgICAgICAgUkVBTDogJ3JlYWwnLFxuICAgICAgICBEQVRFOiAnZGF0ZScsXG4gICAgICAgIFRJTUU6ICd0aW1lJyxcbiAgICAgICAgVElNRVNUQU1QX0xUWjogJ3RpbWVzdGFtcF9sdHonLFxuICAgICAgICBUSU1FU1RBTVBfTlRaOiAndGltZXN0YW1wX250eicsXG4gICAgICAgIFRJTUVTVEFNUF9UWjogJ3RpbWVzdGFtcF90eicsXG4gICAgICAgIFZBUklBTlQ6ICd2YXJpYW50JyxcbiAgICAgICAgT0JKRUNUOiAnb2JqZWN0JyxcbiAgICAgICAgQVJSQVk6ICdhcnJheScsXG4gICAgICAgIE1BUDogJ21hcCcsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgU3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzU3RyaW5nOiBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVEVYVDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBCaW5hcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCaW5hcnk6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5CSU5BUlk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgQm9vbGVhbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5CT09MRUFOO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIE51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc051bWJlcjogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkZJWEVEIHx8IHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLlJFQUw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgRGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RhdGU6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5EQVRFO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lOiBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUaW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXA6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX0xUWiB8fFxuICAgICAgICAgICAgc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX05UWiB8fFxuICAgICAgICAgICAgc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX1RaKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUSU1FU1RBTVBfTFRaLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGltZXN0YW1wTHR6OiBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX0xUWjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUSU1FU1RBTVBfTlRaLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGltZXN0YW1wTnR6OiBmdW5jdGlvbiAoc3FsVHlwZSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX05UWjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUSU1FU1RBTVBfVFouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXBUejogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLlRJTUVTVEFNUF9UWjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBWYXJpYW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFyaWFudDogZnVuY3Rpb24gKHNxbFR5cGUsIGZpZWxkc01ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVkFSSUFOVCB8fFxuICAgICAgICAgICAgKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLk9CSkVDVCAmJiBmaWVsZHNNZXRhZGF0YSA9PSBudWxsKSB8fFxuICAgICAgICAgICAgKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkFSUkFZICYmIGZpZWxkc01ldGFkYXRhID09IG51bGwpIHx8XG4gICAgICAgICAgICAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuTUFQICYmIGZpZWxkc01ldGFkYXRhID09IG51bGwpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBPYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uIChzcWxUeXBlLCBmaWVsZHNNZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuT0JKRUNUICYmIGZpZWxkc01ldGFkYXRhICE9IG51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgQXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBcnJheTogZnVuY3Rpb24gKHNxbFR5cGUsIGZpZWxkc01ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5BUlJBWSAmJiBmaWVsZHNNZXRhZGF0YSAhPSBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIE1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc01hcDogZnVuY3Rpb24gKHNxbFR5cGUsIGZpZWxkc01ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5NQVAgJiYgZmllbGRzTWV0YWRhdGEgIT0gbnVsbDtcbiAgICB9LFxufTtcbmNvbnN0IG5hdGl2ZVR5cGVzID0ge1xuICAgIHZhbHVlczoge1xuICAgICAgICBTVFJJTkc6ICdTVFJJTkcnLFxuICAgICAgICBCT09MRUFOOiAnQk9PTEVBTicsXG4gICAgICAgIE5VTUJFUjogJ05VTUJFUicsXG4gICAgICAgIERBVEU6ICdEQVRFJyxcbiAgICAgICAgSlNPTjogJ0pTT04nLFxuICAgICAgICBCVUZGRVI6ICdCVUZGRVInLFxuICAgICAgICBPQkpFQ1Q6ICdPQkpFQ1QnLFxuICAgICAgICBBUlJBWTogJ0FSUkFZJyxcbiAgICAgICAgTUFQOiAnTUFQJyxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIG5hdGl2ZSB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy52YWx1ZXNbVXRpbC5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsdWVdO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdFxuICAgICAqIHJlcHJlc2VudHMgYW4gaW52YWxpZCBuYXRpdmUgdHlwZS4gSWYgdGhlIHZhbHVlcyBhcmUgYWxsIHZhbGlkLCBhIHZhbHVlIG9mXG4gICAgICogLTEgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBuYXRpdmVUeXBlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmaW5kSW52YWxpZFZhbHVlOiBmdW5jdGlvbiAobmF0aXZlVHlwZXMpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShuYXRpdmVUeXBlcykpO1xuICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaW52YWxpZCB2YWx1ZVxuICAgICAgICBsZXQgaW52YWxpZFZhbHVlSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBuYXRpdmVUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFZhbHVlKG5hdGl2ZVR5cGVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkVmFsdWVJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnZhbGlkVmFsdWVJbmRleDtcbiAgICB9LFxufTtcbmxldCBpc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwgPSB0cnVlO1xuZXhwb3J0cy5zZXRJc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgaXNSZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsID0gb3B0aW9uO1xufTtcbmV4cG9ydHMuZ2V0TnVsbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwgPyAnTlVMTCcgOiBudWxsO1xufTtcbmNvbnN0IHNxbFR5cGVWYWx1ZXMgPSBzcWxUeXBlcy52YWx1ZXM7XG5jb25zdCBuYXRpdmVUeXBlVmFsdWVzID0gbmF0aXZlVHlwZXMudmFsdWVzO1xuY29uc3QgTUFQX1NRTF9UT19OQVRJVkUgPSB7fTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuVEVYVF0gPSBuYXRpdmVUeXBlVmFsdWVzLlNUUklORztcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuQklOQVJZXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuQlVGRkVSO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5CT09MRUFOXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuQk9PTEVBTjtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuRklYRURdID0gbmF0aXZlVHlwZVZhbHVlcy5OVU1CRVI7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlJFQUxdID0gbmF0aXZlVHlwZVZhbHVlcy5OVU1CRVI7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLkRBVEVdID0gbmF0aXZlVHlwZVZhbHVlcy5EQVRFO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5USU1FXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuU1RSSU5HO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5USU1FU1RBTVBfTFRaXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuREFURTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuVElNRVNUQU1QX05UWl0gPSBuYXRpdmVUeXBlVmFsdWVzLkRBVEU7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlRJTUVTVEFNUF9UWl0gPSBuYXRpdmVUeXBlVmFsdWVzLkRBVEU7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlZBUklBTlRdID0gbmF0aXZlVHlwZVZhbHVlcy5KU09OO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5PQkpFQ1RdID0gbmF0aXZlVHlwZVZhbHVlcy5PQkpFQ1Q7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLkFSUkFZXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuQVJSQVk7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLk1BUF0gPSBuYXRpdmVUeXBlVmFsdWVzLk1BUDtcbmV4cG9ydHMuU3FsVHlwZXMgPSBzcWxUeXBlcztcbmV4cG9ydHMuTmF0aXZlVHlwZXMgPSBuYXRpdmVUeXBlcztcbi8qKlxuICogR2l2ZW4gYSBTUUwgdHlwZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBuYXRpdmUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3FsVHlwZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9OYXRpdmVUeXBlID0gZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICByZXR1cm4gTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZV07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YV90eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * The map of symbols for datatime representation in Snowflake and in Moment.js formatting.\n * The order of tags is important Please don't change it\n */\nfunction formatTagsMap() {\n    return [\n        // proper mappings\n        ['YYYY', 'YYYY'],\n        ['YY', 'YY'],\n        ['MM', 'MM'],\n        ['MON', 'MMM'],\n        ['DD', 'DD'],\n        ['DY', 'ddd'],\n        ['HH24', 'HH'],\n        ['HH12', 'hh'],\n        ['HH', 'HH'],\n        ['AM', 'A'],\n        ['PM', 'A'],\n        ['MI', 'mm'],\n        ['SS', 'ss'],\n        ['TZH:TZM', 'Z'],\n        ['TZHTZM', 'ZZ'],\n        // special code needed\n        ['TZH', ''],\n        ['TZM', ''],\n        ['FF', ''],\n    ];\n}\nfunction convertSnowflakeFormatToMomentFormat(formatSql, scale) {\n    const tags = formatTagsMap();\n    // get an upper-case version of the input sql format\n    const formatSqlUpper = formatSql.toUpperCase();\n    // iterate over the format string\n    const length = formatSql.length;\n    let formatMoment = '';\n    for (let pos = 0; pos < length;) {\n        let tag = null;\n        let out = null;\n        // at each position, check if there's a tag at that position; if so, use\n        // 'out' as the replacement\n        for (let index = 0; index < tags.length; index++) {\n            if (formatSqlUpper.substr(pos).indexOf(tags[index][0]) === 0) {\n                tag = tags[index][0];\n                out = tags[index][1];\n                break;\n            }\n        }\n        // if we didn't find a match, just insert the character after escaping it\n        // (by wrapping it in square brackets)\n        if (out === null) {\n            formatMoment += formatSql[pos];\n            pos++;\n        }\n        else {\n            // we found one of our special tags\n            if (out === '') {\n                if (tag === 'TZH') {\n                    out = 'Z';\n                }\n                else if (tag === 'FF') {\n                    // if 'FF' is followed by a digit, use the digit as the scale\n                    let digit = null;\n                    if (pos + tag.length < length) {\n                        const matches = formatSql[pos + tag.length].match(/[0-9]/);\n                        if (matches) {\n                            digit = matches[0];\n                        }\n                    }\n                    if (digit !== null) {\n                        pos++; // skip the digit as well\n                    }\n                    // if we need to include fractional seconds\n                    if (scale > 0) {\n                        // divide the nanoSeconds to get the requested number of\n                        // meaningful digits\n                        // pad with the appropriate number of leading zeros\n                        out = new Array(9).join('S').substr(-scale);\n                    }\n                }\n            }\n            // append the 'out' text to the moment format and update the position\n            formatMoment += out;\n            pos += tag.length;\n        }\n    }\n    return formatMoment;\n}\nmodule.exports.formatTagsMap = formatTagsMap;\nmodule.exports.convertSnowflakeFormatToMomentFormat = convertSnowflakeFormatToMomentFormat;\n//# sourceMappingURL=datetime_format_converter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRldGltZV9mb3JtYXRfY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbURBQW1EO0FBQ25EIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRldGltZV9mb3JtYXRfY29udmVydGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGUgbWFwIG9mIHN5bWJvbHMgZm9yIGRhdGF0aW1lIHJlcHJlc2VudGF0aW9uIGluIFNub3dmbGFrZSBhbmQgaW4gTW9tZW50LmpzIGZvcm1hdHRpbmcuXG4gKiBUaGUgb3JkZXIgb2YgdGFncyBpcyBpbXBvcnRhbnQgUGxlYXNlIGRvbid0IGNoYW5nZSBpdFxuICovXG5mdW5jdGlvbiBmb3JtYXRUYWdzTWFwKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIC8vIHByb3BlciBtYXBwaW5nc1xuICAgICAgICBbJ1lZWVknLCAnWVlZWSddLFxuICAgICAgICBbJ1lZJywgJ1lZJ10sXG4gICAgICAgIFsnTU0nLCAnTU0nXSxcbiAgICAgICAgWydNT04nLCAnTU1NJ10sXG4gICAgICAgIFsnREQnLCAnREQnXSxcbiAgICAgICAgWydEWScsICdkZGQnXSxcbiAgICAgICAgWydISDI0JywgJ0hIJ10sXG4gICAgICAgIFsnSEgxMicsICdoaCddLFxuICAgICAgICBbJ0hIJywgJ0hIJ10sXG4gICAgICAgIFsnQU0nLCAnQSddLFxuICAgICAgICBbJ1BNJywgJ0EnXSxcbiAgICAgICAgWydNSScsICdtbSddLFxuICAgICAgICBbJ1NTJywgJ3NzJ10sXG4gICAgICAgIFsnVFpIOlRaTScsICdaJ10sXG4gICAgICAgIFsnVFpIVFpNJywgJ1paJ10sXG4gICAgICAgIC8vIHNwZWNpYWwgY29kZSBuZWVkZWRcbiAgICAgICAgWydUWkgnLCAnJ10sXG4gICAgICAgIFsnVFpNJywgJyddLFxuICAgICAgICBbJ0ZGJywgJyddLFxuICAgIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0U25vd2ZsYWtlRm9ybWF0VG9Nb21lbnRGb3JtYXQoZm9ybWF0U3FsLCBzY2FsZSkge1xuICAgIGNvbnN0IHRhZ3MgPSBmb3JtYXRUYWdzTWFwKCk7XG4gICAgLy8gZ2V0IGFuIHVwcGVyLWNhc2UgdmVyc2lvbiBvZiB0aGUgaW5wdXQgc3FsIGZvcm1hdFxuICAgIGNvbnN0IGZvcm1hdFNxbFVwcGVyID0gZm9ybWF0U3FsLnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAgY29uc3QgbGVuZ3RoID0gZm9ybWF0U3FsLmxlbmd0aDtcbiAgICBsZXQgZm9ybWF0TW9tZW50ID0gJyc7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuZ3RoOykge1xuICAgICAgICBsZXQgdGFnID0gbnVsbDtcbiAgICAgICAgbGV0IG91dCA9IG51bGw7XG4gICAgICAgIC8vIGF0IGVhY2ggcG9zaXRpb24sIGNoZWNrIGlmIHRoZXJlJ3MgYSB0YWcgYXQgdGhhdCBwb3NpdGlvbjsgaWYgc28sIHVzZVxuICAgICAgICAvLyAnb3V0JyBhcyB0aGUgcmVwbGFjZW1lbnRcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0U3FsVXBwZXIuc3Vic3RyKHBvcykuaW5kZXhPZih0YWdzW2luZGV4XVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YWcgPSB0YWdzW2luZGV4XVswXTtcbiAgICAgICAgICAgICAgICBvdXQgPSB0YWdzW2luZGV4XVsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1hdGNoLCBqdXN0IGluc2VydCB0aGUgY2hhcmFjdGVyIGFmdGVyIGVzY2FwaW5nIGl0XG4gICAgICAgIC8vIChieSB3cmFwcGluZyBpdCBpbiBzcXVhcmUgYnJhY2tldHMpXG4gICAgICAgIGlmIChvdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdE1vbWVudCArPSBmb3JtYXRTcWxbcG9zXTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgZm91bmQgb25lIG9mIG91ciBzcGVjaWFsIHRhZ3NcbiAgICAgICAgICAgIGlmIChvdXQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ1RaSCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWcgPT09ICdGRicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgJ0ZGJyBpcyBmb2xsb3dlZCBieSBhIGRpZ2l0LCB1c2UgdGhlIGRpZ2l0IGFzIHRoZSBzY2FsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlnaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICsgdGFnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGZvcm1hdFNxbFtwb3MgKyB0YWcubGVuZ3RoXS5tYXRjaCgvWzAtOV0vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQgPSBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7IC8vIHNraXAgdGhlIGRpZ2l0IGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZWVkIHRvIGluY2x1ZGUgZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdmlkZSB0aGUgbmFub1NlY29uZHMgdG8gZ2V0IHRoZSByZXF1ZXN0ZWQgbnVtYmVyIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFkIHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBuZXcgQXJyYXkoOSkuam9pbignUycpLnN1YnN0cigtc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSAnb3V0JyB0ZXh0IHRvIHRoZSBtb21lbnQgZm9ybWF0IGFuZCB1cGRhdGUgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICBmb3JtYXRNb21lbnQgKz0gb3V0O1xuICAgICAgICAgICAgcG9zICs9IHRhZy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdE1vbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzLmZvcm1hdFRhZ3NNYXAgPSBmb3JtYXRUYWdzTWFwO1xubW9kdWxlLmV4cG9ydHMuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0ID0gY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZXRpbWVfZm9ybWF0X2NvbnZlcnRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction DoublyLinkedList() {\n    this._length = 0;\n    this._head = null;\n    this._tail = null;\n}\n/**\n * Returns the length of the list.\n *\n * @returns {number}\n */\nDoublyLinkedList.prototype.getLength = function () {\n    return this._length;\n};\n/**\n * Returns the first element in the list.\n *\n * @returns {Object}\n */\nDoublyLinkedList.prototype.getHead = function () {\n    return this._head;\n};\n/**\n * Returns the last element in the list.\n *\n * @returns {Object}\n */\nDoublyLinkedList.prototype.getTail = function () {\n    return this._tail;\n};\n/**\n * Inserts a value at the end of the list.\n *\n * @param value\n *\n * @returns {Object} the node that was inserted into the list.\n */\nDoublyLinkedList.prototype.insertEnd = function (value) {\n    // create a node from the specified value\n    const node = new Node(value, null, null);\n    // if there are no element in the list yet\n    if (this._length === 0) {\n        this._head = node;\n        this._tail = node;\n    }\n    else {\n        // add the node to the end\n        this._tail.setNext(node);\n        node.setPrev(this._tail);\n        this._tail = node;\n    }\n    // increment the length\n    this._length++;\n    // return the node that was created\n    return node;\n};\n/**\n * Removes a given node from the list.\n *\n * @param node\n */\nDoublyLinkedList.prototype.remove = function (node) {\n    // if no node was specified, we have nothing to do\n    if (!node) {\n        return;\n    }\n    // if we're removing the first element in the list, adjust the head,\n    // otherwise connect the node's previous to its next\n    if (node.getPrev() === null) {\n        this._head = node.getNext();\n    }\n    else {\n        node.getPrev().setNext(node.getNext());\n    }\n    // if we're removing the last element in the list, adjust the tail,\n    // otherwise connect the node's next to its previous\n    if (node.getNext() === null) {\n        this._tail = node.getPrev();\n    }\n    else {\n        node.getNext().setPrev(node.getPrev());\n    }\n    // decrement the length\n    this._length--;\n};\nfunction Node(value, prev, next) {\n    this._value = value;\n    this._prev = prev;\n    this._next = next;\n}\nNode.prototype.getValue = function () {\n    return this._value;\n};\nNode.prototype.getPrev = function () {\n    return this._prev;\n};\nNode.prototype.setPrev = function (prev) {\n    this._prev = prev;\n};\nNode.prototype.getNext = function () {\n    return this._next;\n};\nNode.prototype.setNext = function (next) {\n    this._next = next;\n};\nmodule.exports = DoublyLinkedList;\n//# sourceMappingURL=doubly_linked_list.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kb3VibHlfbGlua2VkX2xpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kb3VibHlfbGlua2VkX2xpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBEb3VibHlMaW5rZWRMaXN0KCkge1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGlzdC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpc3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuZ2V0SGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90YWlsO1xufTtcbi8qKlxuICogSW5zZXJ0cyBhIHZhbHVlIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQHJldHVybnMge09iamVjdH0gdGhlIG5vZGUgdGhhdCB3YXMgaW5zZXJ0ZWQgaW50byB0aGUgbGlzdC5cbiAqL1xuRG91Ymx5TGlua2VkTGlzdC5wcm90b3R5cGUuaW5zZXJ0RW5kID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gY3JlYXRlIGEgbm9kZSBmcm9tIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICBjb25zdCBub2RlID0gbmV3IE5vZGUodmFsdWUsIG51bGwsIG51bGwpO1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50IGluIHRoZSBsaXN0IHlldFxuICAgIGlmICh0aGlzLl9sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5faGVhZCA9IG5vZGU7XG4gICAgICAgIHRoaXMuX3RhaWwgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHRoZSBub2RlIHRvIHRoZSBlbmRcbiAgICAgICAgdGhpcy5fdGFpbC5zZXROZXh0KG5vZGUpO1xuICAgICAgICBub2RlLnNldFByZXYodGhpcy5fdGFpbCk7XG4gICAgICAgIHRoaXMuX3RhaWwgPSBub2RlO1xuICAgIH1cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGxlbmd0aFxuICAgIHRoaXMuX2xlbmd0aCsrO1xuICAgIC8vIHJldHVybiB0aGUgbm9kZSB0aGF0IHdhcyBjcmVhdGVkXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBSZW1vdmVzIGEgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBsaXN0LlxuICpcbiAqIEBwYXJhbSBub2RlXG4gKi9cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gaWYgbm8gbm9kZSB3YXMgc3BlY2lmaWVkLCB3ZSBoYXZlIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB3ZSdyZSByZW1vdmluZyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGlzdCwgYWRqdXN0IHRoZSBoZWFkLFxuICAgIC8vIG90aGVyd2lzZSBjb25uZWN0IHRoZSBub2RlJ3MgcHJldmlvdXMgdG8gaXRzIG5leHRcbiAgICBpZiAobm9kZS5nZXRQcmV2KCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faGVhZCA9IG5vZGUuZ2V0TmV4dCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5nZXRQcmV2KCkuc2V0TmV4dChub2RlLmdldE5leHQoKSk7XG4gICAgfVxuICAgIC8vIGlmIHdlJ3JlIHJlbW92aW5nIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGxpc3QsIGFkanVzdCB0aGUgdGFpbCxcbiAgICAvLyBvdGhlcndpc2UgY29ubmVjdCB0aGUgbm9kZSdzIG5leHQgdG8gaXRzIHByZXZpb3VzXG4gICAgaWYgKG5vZGUuZ2V0TmV4dCgpID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RhaWwgPSBub2RlLmdldFByZXYoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuZ2V0TmV4dCgpLnNldFByZXYobm9kZS5nZXRQcmV2KCkpO1xuICAgIH1cbiAgICAvLyBkZWNyZW1lbnQgdGhlIGxlbmd0aFxuICAgIHRoaXMuX2xlbmd0aC0tO1xufTtcbmZ1bmN0aW9uIE5vZGUodmFsdWUsIHByZXYsIG5leHQpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3ByZXYgPSBwcmV2O1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xufVxuTm9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xufTtcbk5vZGUucHJvdG90eXBlLmdldFByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXY7XG59O1xuTm9kZS5wcm90b3R5cGUuc2V0UHJldiA9IGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgdGhpcy5fcHJldiA9IHByZXY7XG59O1xuTm9kZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dDtcbn07XG5Ob2RlLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERvdWJseUxpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3VibHlfbGlua2VkX2xpc3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/doubly_linked_list.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/result.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst Chunk = __webpack_require__(/*! ./chunk */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk.js\");\nconst ResultStream = __webpack_require__(/*! ./result_stream */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js\");\nconst ChunkCache = __webpack_require__(/*! ./chunk_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/chunk_cache.js\");\nconst Column = __webpack_require__(/*! ./column */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/column.js\");\nconst StatementType = __webpack_require__(/*! ./statement_type */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js\");\nconst ColumnNamesCreator = __webpack_require__(/*! ./unique_column_name_creator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js\");\nconst RowMode = __webpack_require__(/*! ../../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\nconst Logger = (__webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst ExecutionTimer = __webpack_require__(/*! ../../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\n/**\n * Creates a new Result.\n *\n * @param {Object} options\n * @constructor\n */\nfunction Result(options) {\n    let chunkHeaders;\n    let length;\n    let index;\n    let parameter;\n    let mapColumnNameToIndices;\n    let columns;\n    let column;\n    let version;\n    // assert that options is a valid object that contains a response, statement,\n    // services and connection config\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isObject(options.response));\n    Errors.assertInternal(Util.isObject(options.statement));\n    Errors.assertInternal(Util.isObject(options.services));\n    Errors.assertInternal(Util.isObject(options.connectionConfig));\n    // save the statement, services and connection config\n    this._statement = options.statement;\n    this._services = options.services;\n    this._connectionConfig = options.connectionConfig;\n    const data = options.response.data;\n    this._queryId = data.queryId;\n    this._version = version = String(data.version); // don't rely on the version being a number\n    this._returnedRows = data.returned;\n    this._totalRows = data.total;\n    this._statementTypeId = data.statementTypeId;\n    this._queryContext = data.queryContext;\n    // if no chunk headers were specified, but a query-result-master-key (qrmk)\n    // was specified, build the chunk headers from the qrmk\n    chunkHeaders = data.chunkHeaders;\n    if (!Util.isObject(chunkHeaders) && Util.isString(data.qrmk)) {\n        chunkHeaders = {\n            'x-amz-server-side-encryption-customer-algorithm': 'AES256',\n            'x-amz-server-side-encryption-customer-key': data.qrmk,\n        };\n    }\n    this._chunkHeaders = chunkHeaders;\n    // build a session state object from the response data; this can be used to\n    // get the values of the current role, current warehouse, current database,\n    // etc.\n    this._sessionState = createSessionState(data);\n    // convert the parameters array to a map\n    const parametersMap = {};\n    const parametersArray = data.parameters || [];\n    for (index = 0, length = parametersArray.length; index < length; index++) {\n        parameter = parametersArray[index];\n        parametersMap[parameter.name] = parameter.value;\n    }\n    // save the parameters array\n    this._parametersArray = parametersArray;\n    // TODO: add timezone related information to columns\n    // create columns from the rowtype array returned in the result\n    const rowtype = data.rowtype;\n    const numColumns = rowtype.length;\n    this._columns = columns = new Array(numColumns);\n    // convert the rowtype array to an array of columns and build an inverted\n    // index map in which the keys are the column names and the values are the\n    // indices of the columns with the corresponding names\n    this._mapColumnNameToIndices = mapColumnNameToIndices = {};\n    const rowMode = options.rowMode;\n    if (rowMode === RowMode.OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS) {\n        ColumnNamesCreator.addOverridenNamesForDuplicatedColumns(rowtype);\n    }\n    Logger().trace(`Mapping columns in resultset (total: ${numColumns})`);\n    for (let index = 0; index < numColumns; index++) {\n        // create a new column and add it to the columns array\n        columns[index] = column = new Column(rowtype[index], index, parametersMap, version);\n        // if we don't already have an index array for a column with this name,\n        // create a new one, otherwise just append to the existing array of indices\n        mapColumnNameToIndices[column.getName()] = mapColumnNameToIndices[column.getName()] || [];\n        mapColumnNameToIndices[column.getName()].push(index);\n    }\n    Logger().trace('Finished mapping columns.');\n    // create chunks\n    //TODO SNOW-2090883 chunks or rowset should verified on containing data\n    this._chunks = createChunks(data.chunks, data.rowset, this._columns, this._mapColumnNameToIndices, this._chunkHeaders, parametersMap, this._version, this._statement, this._services);\n    this.getQueryContext = function () {\n        return this._queryContext;\n    };\n    /* Disable the ChunkCache until the implementation is complete.\n     *\n     *   // create a chunk cache and save a reference to it in case we need to\n     *   // TODO: should we be clearing the cache at some point, e.g. when the result\n     *   // is destroyed?\n     *   this._chunkCache = createChunkCache(\n     *   this._chunks,\n     *   this._connectionConfig.getResultChunkCacheSize());\n     */\n}\nUtil.inherits(Result, EventEmitter);\n/**\n * Refreshes the result by updating the chunk urls.\n *\n * @param response\n */\nResult.prototype.refresh = function (response) {\n    const chunks = this._chunks;\n    const chunkCfgs = response.data.chunks;\n    for (let index = 0, length = chunks.length; index < length; index++) {\n        chunks[index].setUrl(chunkCfgs[index].url);\n    }\n};\n/**\n * TODO\n *\n * @param chunks\n * @param capacity\n *\n * @returns {ChunkCache}\n */\n// eslint-disable-next-line no-unused-vars\nfunction createChunkCache(chunks, capacity) {\n    let index;\n    let length;\n    // create a chunk cache\n    const chunkCache = new ChunkCache(capacity);\n    // every time a chunk is loaded, add it to the cache\n    // TODO: should the caching be based on most recently 'used' or most recently\n    // 'loaded'?\n    const onLoadComplete = function (err, chunk) {\n        if (!err) {\n            chunkCache.put(chunk);\n        }\n    };\n    // subscribe to the 'loadcomplete' event on all the chunks\n    for (index = 0, length = chunks.length; index < length; index++) {\n        chunks[index].on('loadcomplete', onLoadComplete);\n    }\n    // TODO: do we need to unsubscribe from the loadcomplete event at some point?\n    return chunkCache;\n}\n/**\n * Creates a session state object from the values of the current role, current\n * warehouse, etc., returned in the result response.\n *\n * @param responseData\n *\n * @returns {Object}\n */\nfunction createSessionState(responseData) {\n    const currentRole = responseData.finalRoleName;\n    const currentWarehouse = responseData.finalWarehouseName;\n    const currentDatabaseProvider = responseData.databaseProvider;\n    const currentDatabase = responseData.finalDatabaseName;\n    const currentSchema = responseData.finalSchemaName;\n    return {\n        getCurrentRole: function () {\n            return currentRole;\n        },\n        getCurrentWarehouse: function () {\n            return currentWarehouse;\n        },\n        getCurrentDatabaseProvider: function () {\n            return currentDatabaseProvider;\n        },\n        getCurrentDatabase: function () {\n            return currentDatabase;\n        },\n        getCurrentSchema: function () {\n            return currentSchema;\n        },\n    };\n}\n/**\n * Creates an array of Chunk instances from the chunk-related information in the\n * result response.\n *\n * @param chunkCfgs\n * @param rowset\n * @param columns\n * @param mapColumnNameToIndices\n * @param chunkHeaders\n * @param statementParameters\n * @param resultVersion\n * @param statement\n * @param services\n *\n * @returns {Chunk}\n */\nfunction createChunks(chunkCfgs, rowset, columns, mapColumnNameToIndices, chunkHeaders, statementParameters, resultVersion, statement, services) {\n    let startIndex;\n    let index;\n    let chunkCfg;\n    // if we don't have any chunks, or if some records were returned inline,\n    // fabricate a config object for the first chunk\n    chunkCfgs = chunkCfgs || [];\n    if (!chunkCfgs || rowset.length > 0) {\n        chunkCfgs.unshift({\n            rowCount: rowset.length,\n            url: null,\n            rowset: rowset,\n        });\n    }\n    const chunks = new Array(chunkCfgs.length);\n    Logger().trace(`Downloading ${chunkCfgs.length} chunks`);\n    // loop over the chunk config objects and build Chunk instances out of them\n    startIndex = 0;\n    const length = chunkCfgs.length;\n    for (index = 0; index < length; index++) {\n        chunkCfg = chunkCfgs[index];\n        // augment the chunk config object with additional information\n        chunkCfg.statement = statement;\n        chunkCfg.services = services;\n        chunkCfg.startIndex = startIndex;\n        chunkCfg.columns = columns;\n        chunkCfg.mapColumnNameToIndices = mapColumnNameToIndices;\n        chunkCfg.chunkHeaders = chunkHeaders;\n        chunkCfg.statementParameters = statementParameters;\n        chunkCfg.resultVersion = resultVersion;\n        // increment the start index for the next chunk\n        startIndex += chunkCfg.rowCount;\n        // create a new Chunk from the config object, and add it to the chunks array\n        chunks[index] = new Chunk(chunkCfg);\n    }\n    return chunks;\n}\n/**\n * Returns the chunks in this result that overlap with a specified window.\n *\n * @param {Number} start the start index of the window.\n * @param {Number} end the end index of the window.\n *\n * @returns {Chunk[]}\n */\nResult.prototype.findOverlappingChunks = function (start, end) {\n    return findOverlappingChunks(this._chunks, start, end);\n};\n/**\n * Fetches the rows from the result.\n *\n * @param {Object} options\n *\n * @returns {EventEmitter}\n */\nResult.prototype.fetchRows = function (options) {\n    // validate options\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isFunction(options.each));\n    // if no value was specified for the start index or if the specified start\n    // index is negative, default to 0, otherwise truncate the fractional part\n    let start = options.startIndex;\n    start = !Util.isNumber(start) || start < 0 ? 0 : Math.floor(start);\n    // if no value was specified for the end index or if the end index is larger\n    // than the row index of the last row, default to the index of the last row,\n    // otherwise truncate the fractional part\n    const returnedRows = this.getReturnedRows();\n    let end = options.endIndex;\n    end = !Util.isNumber(end) || end >= returnedRows ? returnedRows - 1 : Math.floor(end);\n    // create an EventEmitter that will be returned to the\n    // caller to track progress of the fetch-rows operation\n    const operation = new EventEmitter();\n    // define a function to asynchronously complete the operation\n    const asyncComplete = function (err, continueCallback) {\n        process.nextTick(function () {\n            operation.emit('complete', err, continueCallback);\n        });\n    };\n    // if the start index is greater than the end index, asynchronously\n    // complete the operation and return the operation\n    if (start > end) {\n        // the operation is now complete\n        asyncComplete();\n        return operation;\n    }\n    const connectionConfig = this._connectionConfig;\n    // create a context object to store the state of the operation; we could store\n    // the state in the operation itself, but it would be good to keep this state\n    // private\n    const context = {\n        maxNumRowsToProcess: end - start + 1,\n        numRowsProcessed: 0,\n        rowBatchSize: connectionConfig.getResultProcessingBatchSize(),\n        rowBatchDuration: connectionConfig.getResultProcessingBatchDuration(),\n    };\n    // identify the chunks needed to get the requested rows, and create a stream\n    // to read their contents\n    const resultStream = new ResultStream({\n        chunks: findOverlappingChunks(this._chunks, start, end),\n        prefetchSize: connectionConfig.getResultPrefetch(),\n    });\n    // subscribe to the stream's 'close' event\n    resultStream.on('close', function (err, continueCallback) {\n        // the operation is now complete\n        asyncComplete(err, continueCallback);\n    });\n    // subscribe to the stream's 'data' event\n    resultStream.on('data', function (chunk) {\n        // start processing the chunk rows\n        processChunk(chunk);\n    });\n    /**\n     * Processes the rows in a given chunk.\n     *\n     * @param {Object} chunk\n     */\n    const processChunk = function (chunk) {\n        // get all the rows in the current chunk that overlap with the requested\n        // window\n        Logger().debug(`Start Processing chunks`);\n        const timer = new ExecutionTimer().start();\n        const chunkStart = chunk.getStartIndex();\n        const chunkEnd = chunk.getEndIndex();\n        const rows = chunk\n            .getRows()\n            .slice(Math.max(chunkStart, start) - chunkStart, Math.min(chunkEnd, end) + 1 - chunkStart);\n        let rowIndex = 0;\n        const rowsLength = rows.length;\n        // create a function that can be called to batch-process rows\n        const processRows = function () {\n            // get the start position and start time\n            const startIndex = rowIndex;\n            const startTime = Date.now();\n            const each = options.each;\n            let stoppedProcessingRows;\n            while (rowIndex < rowsLength) {\n                // invoke the each() callback on the current row\n                const ret = each(rows[rowIndex++]);\n                context.numRowsProcessed++;\n                // if the callback returned false, stop processing rows\n                if (ret === false) {\n                    stoppedProcessingRows = true;\n                    break;\n                }\n                // use the current position and current time to check if we've been\n                // processing rows for too long; if so, leave the rest for the next\n                // tick of the event loop\n                if (rowIndex - startIndex >= context.rowBatchSize &&\n                    Date.now() - startTime > context.rowBatchDuration) {\n                    process.nextTick(processRows);\n                    break;\n                }\n            }\n            // if there are no more rows for us to process in this chunk\n            if (!(rowIndex < rowsLength) || stoppedProcessingRows) {\n                // if we exhausted all the rows in this chunk and we haven't yet\n                // processed all the rows we want to process, ask the result stream to\n                // do another read\n                if (!(rowIndex < rowsLength) && context.numRowsProcessed !== context.maxNumRowsToProcess) {\n                    resultStream.read();\n                }\n                else {\n                    // we've either processed all the rows we wanted to process or we\n                    // were told to stop processing rows by the each() callback; either\n                    // way, close the result stream to complete the operation\n                    resultStream.asyncClose();\n                }\n            }\n        };\n        // start processing rows\n        processRows();\n        timer.stop();\n        Logger().debug(`Finished processing Chunks: Processed ${rowsLength} rows in ${timer.getDuration()} ms`);\n    };\n    // start reading from the stream in the next tick of the event loop\n    process.nextTick(function () {\n        resultStream.read();\n    });\n    return operation;\n};\n/**\n * Given a sorted array of chunks, returns a sub-array that overlaps with a\n * specified window.\n *\n * @param chunks\n * @param windowStart\n * @param windowEnd\n *\n * @returns {Array}\n */\nfunction findOverlappingChunks(chunks, windowStart, windowEnd) {\n    const overlappingChunks = [];\n    if (chunks.length !== 0) {\n        // get the index of the first chunk that overlaps with the specified window\n        let index = findFirstOverlappingChunk(chunks, windowStart, windowEnd);\n        // iterate over the chunks starting with the first overlapping chunk and\n        // keep going until there's no overlap\n        for (let length = chunks.length; index < length; index++) {\n            const chunk = chunks[index];\n            if (chunk.overlapsWithWindow(windowStart, windowEnd)) {\n                overlappingChunks.push(chunk);\n            }\n            else {\n                // no future chunks will overlap because the chunks array is sorted\n                break;\n            }\n        }\n    }\n    return overlappingChunks;\n}\n/**\n * Given a sorted array of chunks, returns the index of the first chunk in the\n * array that overlaps with a specified window.\n *\n * @param chunks\n * @param windowStartIndex\n * @param windowEndIndex\n *\n * @returns {number}\n */\nfunction findFirstOverlappingChunk(chunks, windowStartIndex, windowEndIndex) {\n    const helper = function (chunks, chunkIndexLeft, chunkIndexRight, windowStartIndex, windowEndIndex) {\n        let result;\n        let middleChunkEndIndex;\n        // initialize the return value to -1\n        result = -1;\n        // compute the index of the middle chunk and get the middle chunk\n        const chunkIndexMiddle = Math.floor((chunkIndexLeft + chunkIndexRight) / 2);\n        const middleChunk = chunks[chunkIndexMiddle];\n        // if we have two or fewer chunks\n        if (chunkIndexMiddle === chunkIndexLeft || chunkIndexMiddle === chunkIndexRight) {\n            // if we have just one chunk, and it overlaps with the specified window,\n            // we've found the chunk we were looking for\n            if (chunkIndexLeft === chunkIndexRight) {\n                if (middleChunk.overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                    result = chunkIndexLeft;\n                }\n            }\n            else {\n                // we just have two chunks left to check\n                // if the first chunk overlaps with the specified window, that's the\n                // chunk we were looking for\n                if (chunks[chunkIndexLeft].overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                    result = chunkIndexLeft;\n                }\n                else if (chunks[chunkIndexRight].overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                    // otherwise, if the second chunk overlaps with the specified window,\n                    // that's the chunk we were looking for\n                    result = chunkIndexRight;\n                }\n            }\n            return result;\n        }\n        // if the middle chunk does not overlap with the specified window\n        if (!middleChunk.overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n            middleChunkEndIndex = middleChunk.getEndIndex();\n            // if the window is to the right of the middle chunk,\n            // recurse on the right half\n            if (windowStartIndex > middleChunkEndIndex) {\n                return helper(chunks, chunkIndexMiddle, chunkIndexRight, windowStartIndex, windowEndIndex);\n            }\n            else {\n                // recurse on the left half\n                return helper(chunks, chunkIndexLeft, chunkIndexMiddle, windowStartIndex, windowEndIndex);\n            }\n        }\n        else {\n            // if the middle chunk overlaps but the chunk before it does not, the\n            // middle chunk is the one we were looking\n            if (chunkIndexMiddle === 0 ||\n                !chunks[chunkIndexMiddle - 1].overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n                return chunkIndexMiddle;\n            }\n            else {\n                // recurse on the left half\n                return helper(chunks, chunkIndexLeft, chunkIndexMiddle, windowStartIndex, windowEndIndex);\n            }\n        }\n    };\n    return helper(chunks, 0, chunks.length - 1, windowStartIndex, windowEndIndex);\n}\n/**\n * Returns the columns in this result.\n *\n * @returns {Object[]}\n */\nResult.prototype.getColumns = function () {\n    return this._columns;\n};\n/**\n * Given a column identifier, returns the corresponding column. The column\n * identifier can be either the column name (String) or the column index\n * (Number). If a column name is specified and there is more than one column\n * with that name, the first column with the specified name will be returned.\n *\n * @param {String | Number} columnIdentifier\n *\n * @returns {Object}\n */\nResult.prototype.getColumn = function (columnIdentifier) {\n    let columnIndex;\n    // if the column identifier is a string, treat it as a column\n    // name and use it to get the index of the specified column\n    if (Util.isString(columnIdentifier)) {\n        // if a valid column name was specified, get the index of the first column\n        // with the specified name\n        if (Object.prototype.hasOwnProperty.call(this._mapColumnNameToIndices, columnIdentifier)) {\n            columnIndex = this._mapColumnNameToIndices[columnIdentifier][0];\n        }\n    }\n    else if (Util.isNumber(columnIdentifier)) {\n        // if the column identifier is a number, treat it as a column index\n        columnIndex = columnIdentifier;\n    }\n    return this._columns[columnIndex];\n};\n/**\n * Returns the statement id generated by the server for the statement that\n * produced this result.\n *\n * Should use getQueryId instead.\n * @deprecated\n * @returns {string}\n */\nResult.prototype.getStatementId = function () {\n    return this._queryId;\n};\n/**\n * Returns the query id generated by the server for the statement that\n * produced this result.\n *\n * @returns {string}\n */\nResult.prototype.getQueryId = function () {\n    return this._queryId;\n};\n/**\n * Returns the number of rows in this result.\n *\n * @returns {number}\n */\nResult.prototype.getReturnedRows = function () {\n    return this._returnedRows;\n};\n/**\n * Returns the number of rows updated by the statement that produced this\n * result. If the statement isn't a DML, we return -1.\n *\n * @returns {Number}\n */\nResult.prototype.getNumUpdatedRows = function () {\n    // initialize if necessary\n    if (!this._numUpdatedRows) {\n        let numUpdatedRows = -1;\n        // the updated-rows metric only applies to dml's\n        const statementTypeId = this._statementTypeId;\n        if (StatementType.isDml(statementTypeId)) {\n            if (StatementType.isInsert(statementTypeId) ||\n                StatementType.isUpdate(statementTypeId) ||\n                StatementType.isDelete(statementTypeId) ||\n                StatementType.isMerge(statementTypeId) ||\n                StatementType.isMultiTableInsert(statementTypeId)) {\n                const chunks = this._chunks;\n                const columns = this._columns;\n                // if the statement is a dml, the result should be small,\n                // meaning we only have one chunk\n                Errors.assertInternal(Util.isArray(chunks) && chunks.length === 1);\n                // add up the values in all the columns\n                numUpdatedRows = 0;\n                const rows = chunks[0].getRows();\n                for (let rowIndex = 0, rowsLength = rows.length; rowIndex < rowsLength; rowIndex++) {\n                    const row = rows[rowIndex];\n                    for (let colIndex = 0, colsLength = columns.length; colIndex < colsLength; colIndex++) {\n                        numUpdatedRows += Number(row.getColumnValue(columns[colIndex].getId()));\n                    }\n                }\n            }\n            // TODO: handle 'copy' and 'unload'\n        }\n        this._numUpdatedRows = numUpdatedRows;\n    }\n    return this._numUpdatedRows;\n};\n/**\n * Returns the number of rows we would have had in this result if the value of\n * the ROWS_PER_RESULTSET parameter was 0 at the time this statement was\n * executed.\n *\n * @returns {number}\n */\nResult.prototype.getTotalRows = function () {\n    return this._totalRows;\n};\n/**\n * Returns the parameters associated with this result. These parameters contain\n * directives about how to consume and present the result.\n *\n * @returns {Object[]}\n */\nResult.prototype.getParametersArray = function () {\n    return this._parametersArray;\n};\n/**\n * Returns an object that contains information about the values of the current\n * warehouse, current database, and any other session-related state when the\n * statement that produced this result finished executing.\n *\n * @returns {Object}\n */\nResult.prototype.getSessionState = function () {\n    return this._sessionState;\n};\n/**\n * Returns the version associated with this result.\n *\n * @returns {string}\n */\nResult.prototype.getVersion = function () {\n    return this._version;\n};\nmodule.exports = Result;\n//# sourceMappingURL=result.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9yZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyx1RUFBWTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsMkVBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLHVGQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFpQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBZTtBQUMxQyxlQUFlLG1CQUFPLENBQUMseUZBQVU7QUFDakMsc0JBQXNCLG1CQUFPLENBQUMseUdBQWtCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLGlJQUE4QjtBQUNqRSxnQkFBZ0IsbUJBQU8sQ0FBQyxtR0FBMEI7QUFDbEQsZUFBZSw2R0FBK0I7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMsMkdBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZLFVBQVUscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RjtBQUNBLHdFQUF3RSx1QkFBdUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9yZXN1bHQvcmVzdWx0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgQ2h1bmsgPSByZXF1aXJlKCcuL2NodW5rJyk7XG5jb25zdCBSZXN1bHRTdHJlYW0gPSByZXF1aXJlKCcuL3Jlc3VsdF9zdHJlYW0nKTtcbmNvbnN0IENodW5rQ2FjaGUgPSByZXF1aXJlKCcuL2NodW5rX2NhY2hlJyk7XG5jb25zdCBDb2x1bW4gPSByZXF1aXJlKCcuL2NvbHVtbicpO1xuY29uc3QgU3RhdGVtZW50VHlwZSA9IHJlcXVpcmUoJy4vc3RhdGVtZW50X3R5cGUnKTtcbmNvbnN0IENvbHVtbk5hbWVzQ3JlYXRvciA9IHJlcXVpcmUoJy4vdW5pcXVlX2NvbHVtbl9uYW1lX2NyZWF0b3InKTtcbmNvbnN0IFJvd01vZGUgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvcm93X21vZGUnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uLy4uL2xvZ2dlcicpLmRlZmF1bHQ7XG5jb25zdCBFeGVjdXRpb25UaW1lciA9IHJlcXVpcmUoJy4uLy4uL2xvZ2dlci9leGVjdXRpb25fdGltZXInKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZXN1bHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZXN1bHQob3B0aW9ucykge1xuICAgIGxldCBjaHVua0hlYWRlcnM7XG4gICAgbGV0IGxlbmd0aDtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IHBhcmFtZXRlcjtcbiAgICBsZXQgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcztcbiAgICBsZXQgY29sdW1ucztcbiAgICBsZXQgY29sdW1uO1xuICAgIGxldCB2ZXJzaW9uO1xuICAgIC8vIGFzc2VydCB0aGF0IG9wdGlvbnMgaXMgYSB2YWxpZCBvYmplY3QgdGhhdCBjb250YWlucyBhIHJlc3BvbnNlLCBzdGF0ZW1lbnQsXG4gICAgLy8gc2VydmljZXMgYW5kIGNvbm5lY3Rpb24gY29uZmlnXG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMucmVzcG9uc2UpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnN0YXRlbWVudCkpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMuc2VydmljZXMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLmNvbm5lY3Rpb25Db25maWcpKTtcbiAgICAvLyBzYXZlIHRoZSBzdGF0ZW1lbnQsIHNlcnZpY2VzIGFuZCBjb25uZWN0aW9uIGNvbmZpZ1xuICAgIHRoaXMuX3N0YXRlbWVudCA9IG9wdGlvbnMuc3RhdGVtZW50O1xuICAgIHRoaXMuX3NlcnZpY2VzID0gb3B0aW9ucy5zZXJ2aWNlcztcbiAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlnID0gb3B0aW9ucy5jb25uZWN0aW9uQ29uZmlnO1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLnJlc3BvbnNlLmRhdGE7XG4gICAgdGhpcy5fcXVlcnlJZCA9IGRhdGEucXVlcnlJZDtcbiAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbiA9IFN0cmluZyhkYXRhLnZlcnNpb24pOyAvLyBkb24ndCByZWx5IG9uIHRoZSB2ZXJzaW9uIGJlaW5nIGEgbnVtYmVyXG4gICAgdGhpcy5fcmV0dXJuZWRSb3dzID0gZGF0YS5yZXR1cm5lZDtcbiAgICB0aGlzLl90b3RhbFJvd3MgPSBkYXRhLnRvdGFsO1xuICAgIHRoaXMuX3N0YXRlbWVudFR5cGVJZCA9IGRhdGEuc3RhdGVtZW50VHlwZUlkO1xuICAgIHRoaXMuX3F1ZXJ5Q29udGV4dCA9IGRhdGEucXVlcnlDb250ZXh0O1xuICAgIC8vIGlmIG5vIGNodW5rIGhlYWRlcnMgd2VyZSBzcGVjaWZpZWQsIGJ1dCBhIHF1ZXJ5LXJlc3VsdC1tYXN0ZXIta2V5IChxcm1rKVxuICAgIC8vIHdhcyBzcGVjaWZpZWQsIGJ1aWxkIHRoZSBjaHVuayBoZWFkZXJzIGZyb20gdGhlIHFybWtcbiAgICBjaHVua0hlYWRlcnMgPSBkYXRhLmNodW5rSGVhZGVycztcbiAgICBpZiAoIVV0aWwuaXNPYmplY3QoY2h1bmtIZWFkZXJzKSAmJiBVdGlsLmlzU3RyaW5nKGRhdGEucXJtaykpIHtcbiAgICAgICAgY2h1bmtIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ3gtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtJzogJ0FFUzI1NicsXG4gICAgICAgICAgICAneC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXknOiBkYXRhLnFybWssXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2NodW5rSGVhZGVycyA9IGNodW5rSGVhZGVycztcbiAgICAvLyBidWlsZCBhIHNlc3Npb24gc3RhdGUgb2JqZWN0IGZyb20gdGhlIHJlc3BvbnNlIGRhdGE7IHRoaXMgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBnZXQgdGhlIHZhbHVlcyBvZiB0aGUgY3VycmVudCByb2xlLCBjdXJyZW50IHdhcmVob3VzZSwgY3VycmVudCBkYXRhYmFzZSxcbiAgICAvLyBldGMuXG4gICAgdGhpcy5fc2Vzc2lvblN0YXRlID0gY3JlYXRlU2Vzc2lvblN0YXRlKGRhdGEpO1xuICAgIC8vIGNvbnZlcnQgdGhlIHBhcmFtZXRlcnMgYXJyYXkgdG8gYSBtYXBcbiAgICBjb25zdCBwYXJhbWV0ZXJzTWFwID0ge307XG4gICAgY29uc3QgcGFyYW1ldGVyc0FycmF5ID0gZGF0YS5wYXJhbWV0ZXJzIHx8IFtdO1xuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBwYXJhbWV0ZXJzQXJyYXkubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzQXJyYXlbaW5kZXhdO1xuICAgICAgICBwYXJhbWV0ZXJzTWFwW3BhcmFtZXRlci5uYW1lXSA9IHBhcmFtZXRlci52YWx1ZTtcbiAgICB9XG4gICAgLy8gc2F2ZSB0aGUgcGFyYW1ldGVycyBhcnJheVxuICAgIHRoaXMuX3BhcmFtZXRlcnNBcnJheSA9IHBhcmFtZXRlcnNBcnJheTtcbiAgICAvLyBUT0RPOiBhZGQgdGltZXpvbmUgcmVsYXRlZCBpbmZvcm1hdGlvbiB0byBjb2x1bW5zXG4gICAgLy8gY3JlYXRlIGNvbHVtbnMgZnJvbSB0aGUgcm93dHlwZSBhcnJheSByZXR1cm5lZCBpbiB0aGUgcmVzdWx0XG4gICAgY29uc3Qgcm93dHlwZSA9IGRhdGEucm93dHlwZTtcbiAgICBjb25zdCBudW1Db2x1bW5zID0gcm93dHlwZS5sZW5ndGg7XG4gICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnMgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG4gICAgLy8gY29udmVydCB0aGUgcm93dHlwZSBhcnJheSB0byBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBidWlsZCBhbiBpbnZlcnRlZFxuICAgIC8vIGluZGV4IG1hcCBpbiB3aGljaCB0aGUga2V5cyBhcmUgdGhlIGNvbHVtbiBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlXG4gICAgLy8gaW5kaWNlcyBvZiB0aGUgY29sdW1ucyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG5hbWVzXG4gICAgdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IG1hcENvbHVtbk5hbWVUb0luZGljZXMgPSB7fTtcbiAgICBjb25zdCByb3dNb2RlID0gb3B0aW9ucy5yb3dNb2RlO1xuICAgIGlmIChyb3dNb2RlID09PSBSb3dNb2RlLk9CSkVDVF9XSVRIX1JFTkFNRURfRFVQTElDQVRFRF9DT0xVTU5TKSB7XG4gICAgICAgIENvbHVtbk5hbWVzQ3JlYXRvci5hZGRPdmVycmlkZW5OYW1lc0ZvckR1cGxpY2F0ZWRDb2x1bW5zKHJvd3R5cGUpO1xuICAgIH1cbiAgICBMb2dnZXIoKS50cmFjZShgTWFwcGluZyBjb2x1bW5zIGluIHJlc3VsdHNldCAodG90YWw6ICR7bnVtQ29sdW1uc30pYCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bUNvbHVtbnM7IGluZGV4KyspIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGNvbHVtbiBhbmQgYWRkIGl0IHRvIHRoZSBjb2x1bW5zIGFycmF5XG4gICAgICAgIGNvbHVtbnNbaW5kZXhdID0gY29sdW1uID0gbmV3IENvbHVtbihyb3d0eXBlW2luZGV4XSwgaW5kZXgsIHBhcmFtZXRlcnNNYXAsIHZlcnNpb24pO1xuICAgICAgICAvLyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gaW5kZXggYXJyYXkgZm9yIGEgY29sdW1uIHdpdGggdGhpcyBuYW1lLFxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgb25lLCBvdGhlcndpc2UganVzdCBhcHBlbmQgdG8gdGhlIGV4aXN0aW5nIGFycmF5IG9mIGluZGljZXNcbiAgICAgICAgbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW4uZ2V0TmFtZSgpXSA9IG1hcENvbHVtbk5hbWVUb0luZGljZXNbY29sdW1uLmdldE5hbWUoKV0gfHwgW107XG4gICAgICAgIG1hcENvbHVtbk5hbWVUb0luZGljZXNbY29sdW1uLmdldE5hbWUoKV0ucHVzaChpbmRleCk7XG4gICAgfVxuICAgIExvZ2dlcigpLnRyYWNlKCdGaW5pc2hlZCBtYXBwaW5nIGNvbHVtbnMuJyk7XG4gICAgLy8gY3JlYXRlIGNodW5rc1xuICAgIC8vVE9ETyBTTk9XLTIwOTA4ODMgY2h1bmtzIG9yIHJvd3NldCBzaG91bGQgdmVyaWZpZWQgb24gY29udGFpbmluZyBkYXRhXG4gICAgdGhpcy5fY2h1bmtzID0gY3JlYXRlQ2h1bmtzKGRhdGEuY2h1bmtzLCBkYXRhLnJvd3NldCwgdGhpcy5fY29sdW1ucywgdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcywgdGhpcy5fY2h1bmtIZWFkZXJzLCBwYXJhbWV0ZXJzTWFwLCB0aGlzLl92ZXJzaW9uLCB0aGlzLl9zdGF0ZW1lbnQsIHRoaXMuX3NlcnZpY2VzKTtcbiAgICB0aGlzLmdldFF1ZXJ5Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29udGV4dDtcbiAgICB9O1xuICAgIC8qIERpc2FibGUgdGhlIENodW5rQ2FjaGUgdW50aWwgdGhlIGltcGxlbWVudGF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogICAvLyBjcmVhdGUgYSBjaHVuayBjYWNoZSBhbmQgc2F2ZSBhIHJlZmVyZW5jZSB0byBpdCBpbiBjYXNlIHdlIG5lZWQgdG9cbiAgICAgKiAgIC8vIFRPRE86IHNob3VsZCB3ZSBiZSBjbGVhcmluZyB0aGUgY2FjaGUgYXQgc29tZSBwb2ludCwgZS5nLiB3aGVuIHRoZSByZXN1bHRcbiAgICAgKiAgIC8vIGlzIGRlc3Ryb3llZD9cbiAgICAgKiAgIHRoaXMuX2NodW5rQ2FjaGUgPSBjcmVhdGVDaHVua0NhY2hlKFxuICAgICAqICAgdGhpcy5fY2h1bmtzLFxuICAgICAqICAgdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRDaHVua0NhY2hlU2l6ZSgpKTtcbiAgICAgKi9cbn1cblV0aWwuaW5oZXJpdHMoUmVzdWx0LCBFdmVudEVtaXR0ZXIpO1xuLyoqXG4gKiBSZWZyZXNoZXMgdGhlIHJlc3VsdCBieSB1cGRhdGluZyB0aGUgY2h1bmsgdXJscy5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2h1bmtzID0gdGhpcy5fY2h1bmtzO1xuICAgIGNvbnN0IGNodW5rQ2ZncyA9IHJlc3BvbnNlLmRhdGEuY2h1bmtzO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gY2h1bmtzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY2h1bmtzW2luZGV4XS5zZXRVcmwoY2h1bmtDZmdzW2luZGV4XS51cmwpO1xuICAgIH1cbn07XG4vKipcbiAqIFRPRE9cbiAqXG4gKiBAcGFyYW0gY2h1bmtzXG4gKiBAcGFyYW0gY2FwYWNpdHlcbiAqXG4gKiBAcmV0dXJucyB7Q2h1bmtDYWNoZX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5mdW5jdGlvbiBjcmVhdGVDaHVua0NhY2hlKGNodW5rcywgY2FwYWNpdHkpIHtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGxlbmd0aDtcbiAgICAvLyBjcmVhdGUgYSBjaHVuayBjYWNoZVxuICAgIGNvbnN0IGNodW5rQ2FjaGUgPSBuZXcgQ2h1bmtDYWNoZShjYXBhY2l0eSk7XG4gICAgLy8gZXZlcnkgdGltZSBhIGNodW5rIGlzIGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBjYWNoZVxuICAgIC8vIFRPRE86IHNob3VsZCB0aGUgY2FjaGluZyBiZSBiYXNlZCBvbiBtb3N0IHJlY2VudGx5ICd1c2VkJyBvciBtb3N0IHJlY2VudGx5XG4gICAgLy8gJ2xvYWRlZCc/XG4gICAgY29uc3Qgb25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCBjaHVuaykge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgY2h1bmtDYWNoZS5wdXQoY2h1bmspO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBzdWJzY3JpYmUgdG8gdGhlICdsb2FkY29tcGxldGUnIGV2ZW50IG9uIGFsbCB0aGUgY2h1bmtzXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGNodW5rcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNodW5rc1tpbmRleF0ub24oJ2xvYWRjb21wbGV0ZScsIG9uTG9hZENvbXBsZXRlKTtcbiAgICB9XG4gICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byB1bnN1YnNjcmliZSBmcm9tIHRoZSBsb2FkY29tcGxldGUgZXZlbnQgYXQgc29tZSBwb2ludD9cbiAgICByZXR1cm4gY2h1bmtDYWNoZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHNlc3Npb24gc3RhdGUgb2JqZWN0IGZyb20gdGhlIHZhbHVlcyBvZiB0aGUgY3VycmVudCByb2xlLCBjdXJyZW50XG4gKiB3YXJlaG91c2UsIGV0Yy4sIHJldHVybmVkIGluIHRoZSByZXN1bHQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlRGF0YVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25TdGF0ZShyZXNwb25zZURhdGEpIHtcbiAgICBjb25zdCBjdXJyZW50Um9sZSA9IHJlc3BvbnNlRGF0YS5maW5hbFJvbGVOYW1lO1xuICAgIGNvbnN0IGN1cnJlbnRXYXJlaG91c2UgPSByZXNwb25zZURhdGEuZmluYWxXYXJlaG91c2VOYW1lO1xuICAgIGNvbnN0IGN1cnJlbnREYXRhYmFzZVByb3ZpZGVyID0gcmVzcG9uc2VEYXRhLmRhdGFiYXNlUHJvdmlkZXI7XG4gICAgY29uc3QgY3VycmVudERhdGFiYXNlID0gcmVzcG9uc2VEYXRhLmZpbmFsRGF0YWJhc2VOYW1lO1xuICAgIGNvbnN0IGN1cnJlbnRTY2hlbWEgPSByZXNwb25zZURhdGEuZmluYWxTY2hlbWFOYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEN1cnJlbnRSb2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJvbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnJlbnRXYXJlaG91c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50V2FyZWhvdXNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDdXJyZW50RGF0YWJhc2VQcm92aWRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRhYmFzZVByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDdXJyZW50RGF0YWJhc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0YWJhc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnJlbnRTY2hlbWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2NoZW1hO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgQ2h1bmsgaW5zdGFuY2VzIGZyb20gdGhlIGNodW5rLXJlbGF0ZWQgaW5mb3JtYXRpb24gaW4gdGhlXG4gKiByZXN1bHQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIGNodW5rQ2Znc1xuICogQHBhcmFtIHJvd3NldFxuICogQHBhcmFtIGNvbHVtbnNcbiAqIEBwYXJhbSBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzXG4gKiBAcGFyYW0gY2h1bmtIZWFkZXJzXG4gKiBAcGFyYW0gc3RhdGVtZW50UGFyYW1ldGVyc1xuICogQHBhcmFtIHJlc3VsdFZlcnNpb25cbiAqIEBwYXJhbSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSBzZXJ2aWNlc1xuICpcbiAqIEByZXR1cm5zIHtDaHVua31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtzKGNodW5rQ2Zncywgcm93c2V0LCBjb2x1bW5zLCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzLCBjaHVua0hlYWRlcnMsIHN0YXRlbWVudFBhcmFtZXRlcnMsIHJlc3VsdFZlcnNpb24sIHN0YXRlbWVudCwgc2VydmljZXMpIHtcbiAgICBsZXQgc3RhcnRJbmRleDtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGNodW5rQ2ZnO1xuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IGNodW5rcywgb3IgaWYgc29tZSByZWNvcmRzIHdlcmUgcmV0dXJuZWQgaW5saW5lLFxuICAgIC8vIGZhYnJpY2F0ZSBhIGNvbmZpZyBvYmplY3QgZm9yIHRoZSBmaXJzdCBjaHVua1xuICAgIGNodW5rQ2ZncyA9IGNodW5rQ2ZncyB8fCBbXTtcbiAgICBpZiAoIWNodW5rQ2ZncyB8fCByb3dzZXQubGVuZ3RoID4gMCkge1xuICAgICAgICBjaHVua0NmZ3MudW5zaGlmdCh7XG4gICAgICAgICAgICByb3dDb3VudDogcm93c2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgICAgIHJvd3NldDogcm93c2V0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ2Zncy5sZW5ndGgpO1xuICAgIExvZ2dlcigpLnRyYWNlKGBEb3dubG9hZGluZyAke2NodW5rQ2Zncy5sZW5ndGh9IGNodW5rc2ApO1xuICAgIC8vIGxvb3Agb3ZlciB0aGUgY2h1bmsgY29uZmlnIG9iamVjdHMgYW5kIGJ1aWxkIENodW5rIGluc3RhbmNlcyBvdXQgb2YgdGhlbVxuICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNodW5rQ2Zncy5sZW5ndGg7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNodW5rQ2ZnID0gY2h1bmtDZmdzW2luZGV4XTtcbiAgICAgICAgLy8gYXVnbWVudCB0aGUgY2h1bmsgY29uZmlnIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAgICAgICAgY2h1bmtDZmcuc3RhdGVtZW50ID0gc3RhdGVtZW50O1xuICAgICAgICBjaHVua0NmZy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgICAgICBjaHVua0NmZy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgY2h1bmtDZmcuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgIGNodW5rQ2ZnLm1hcENvbHVtbk5hbWVUb0luZGljZXMgPSBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzO1xuICAgICAgICBjaHVua0NmZy5jaHVua0hlYWRlcnMgPSBjaHVua0hlYWRlcnM7XG4gICAgICAgIGNodW5rQ2ZnLnN0YXRlbWVudFBhcmFtZXRlcnMgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzO1xuICAgICAgICBjaHVua0NmZy5yZXN1bHRWZXJzaW9uID0gcmVzdWx0VmVyc2lvbjtcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBzdGFydCBpbmRleCBmb3IgdGhlIG5leHQgY2h1bmtcbiAgICAgICAgc3RhcnRJbmRleCArPSBjaHVua0NmZy5yb3dDb3VudDtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IENodW5rIGZyb20gdGhlIGNvbmZpZyBvYmplY3QsIGFuZCBhZGQgaXQgdG8gdGhlIGNodW5rcyBhcnJheVxuICAgICAgICBjaHVua3NbaW5kZXhdID0gbmV3IENodW5rKGNodW5rQ2ZnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY2h1bmtzIGluIHRoaXMgcmVzdWx0IHRoYXQgb3ZlcmxhcCB3aXRoIGEgc3BlY2lmaWVkIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSB3aW5kb3cuXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIHRoZSBlbmQgaW5kZXggb2YgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcmV0dXJucyB7Q2h1bmtbXX1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5maW5kT3ZlcmxhcHBpbmdDaHVua3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBmaW5kT3ZlcmxhcHBpbmdDaHVua3ModGhpcy5fY2h1bmtzLCBzdGFydCwgZW5kKTtcbn07XG4vKipcbiAqIEZldGNoZXMgdGhlIHJvd3MgZnJvbSB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5mZXRjaFJvd3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNGdW5jdGlvbihvcHRpb25zLmVhY2gpKTtcbiAgICAvLyBpZiBubyB2YWx1ZSB3YXMgc3BlY2lmaWVkIGZvciB0aGUgc3RhcnQgaW5kZXggb3IgaWYgdGhlIHNwZWNpZmllZCBzdGFydFxuICAgIC8vIGluZGV4IGlzIG5lZ2F0aXZlLCBkZWZhdWx0IHRvIDAsIG90aGVyd2lzZSB0cnVuY2F0ZSB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gICAgbGV0IHN0YXJ0ID0gb3B0aW9ucy5zdGFydEluZGV4O1xuICAgIHN0YXJ0ID0gIVV0aWwuaXNOdW1iZXIoc3RhcnQpIHx8IHN0YXJ0IDwgMCA/IDAgOiBNYXRoLmZsb29yKHN0YXJ0KTtcbiAgICAvLyBpZiBubyB2YWx1ZSB3YXMgc3BlY2lmaWVkIGZvciB0aGUgZW5kIGluZGV4IG9yIGlmIHRoZSBlbmQgaW5kZXggaXMgbGFyZ2VyXG4gICAgLy8gdGhhbiB0aGUgcm93IGluZGV4IG9mIHRoZSBsYXN0IHJvdywgZGVmYXVsdCB0byB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgcm93LFxuICAgIC8vIG90aGVyd2lzZSB0cnVuY2F0ZSB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gICAgY29uc3QgcmV0dXJuZWRSb3dzID0gdGhpcy5nZXRSZXR1cm5lZFJvd3MoKTtcbiAgICBsZXQgZW5kID0gb3B0aW9ucy5lbmRJbmRleDtcbiAgICBlbmQgPSAhVXRpbC5pc051bWJlcihlbmQpIHx8IGVuZCA+PSByZXR1cm5lZFJvd3MgPyByZXR1cm5lZFJvd3MgLSAxIDogTWF0aC5mbG9vcihlbmQpO1xuICAgIC8vIGNyZWF0ZSBhbiBFdmVudEVtaXR0ZXIgdGhhdCB3aWxsIGJlIHJldHVybmVkIHRvIHRoZVxuICAgIC8vIGNhbGxlciB0byB0cmFjayBwcm9ncmVzcyBvZiB0aGUgZmV0Y2gtcm93cyBvcGVyYXRpb25cbiAgICBjb25zdCBvcGVyYXRpb24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLy8gZGVmaW5lIGEgZnVuY3Rpb24gdG8gYXN5bmNocm9ub3VzbHkgY29tcGxldGUgdGhlIG9wZXJhdGlvblxuICAgIGNvbnN0IGFzeW5jQ29tcGxldGUgPSBmdW5jdGlvbiAoZXJyLCBjb250aW51ZUNhbGxiYWNrKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBpZiB0aGUgc3RhcnQgaW5kZXggaXMgZ3JlYXRlciB0aGFuIHRoZSBlbmQgaW5kZXgsIGFzeW5jaHJvbm91c2x5XG4gICAgLy8gY29tcGxldGUgdGhlIG9wZXJhdGlvbiBhbmQgcmV0dXJuIHRoZSBvcGVyYXRpb25cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiBpcyBub3cgY29tcGxldGVcbiAgICAgICAgYXN5bmNDb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gdGhpcy5fY29ubmVjdGlvbkNvbmZpZztcbiAgICAvLyBjcmVhdGUgYSBjb250ZXh0IG9iamVjdCB0byBzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIG9wZXJhdGlvbjsgd2UgY291bGQgc3RvcmVcbiAgICAvLyB0aGUgc3RhdGUgaW4gdGhlIG9wZXJhdGlvbiBpdHNlbGYsIGJ1dCBpdCB3b3VsZCBiZSBnb29kIHRvIGtlZXAgdGhpcyBzdGF0ZVxuICAgIC8vIHByaXZhdGVcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBtYXhOdW1Sb3dzVG9Qcm9jZXNzOiBlbmQgLSBzdGFydCArIDEsXG4gICAgICAgIG51bVJvd3NQcm9jZXNzZWQ6IDAsXG4gICAgICAgIHJvd0JhdGNoU2l6ZTogY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRQcm9jZXNzaW5nQmF0Y2hTaXplKCksXG4gICAgICAgIHJvd0JhdGNoRHVyYXRpb246IGNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0UHJvY2Vzc2luZ0JhdGNoRHVyYXRpb24oKSxcbiAgICB9O1xuICAgIC8vIGlkZW50aWZ5IHRoZSBjaHVua3MgbmVlZGVkIHRvIGdldCB0aGUgcmVxdWVzdGVkIHJvd3MsIGFuZCBjcmVhdGUgYSBzdHJlYW1cbiAgICAvLyB0byByZWFkIHRoZWlyIGNvbnRlbnRzXG4gICAgY29uc3QgcmVzdWx0U3RyZWFtID0gbmV3IFJlc3VsdFN0cmVhbSh7XG4gICAgICAgIGNodW5rczogZmluZE92ZXJsYXBwaW5nQ2h1bmtzKHRoaXMuX2NodW5rcywgc3RhcnQsIGVuZCksXG4gICAgICAgIHByZWZldGNoU2l6ZTogY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRQcmVmZXRjaCgpLFxuICAgIH0pO1xuICAgIC8vIHN1YnNjcmliZSB0byB0aGUgc3RyZWFtJ3MgJ2Nsb3NlJyBldmVudFxuICAgIHJlc3VsdFN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoZXJyLCBjb250aW51ZUNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gaXMgbm93IGNvbXBsZXRlXG4gICAgICAgIGFzeW5jQ29tcGxldGUoZXJyLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIHN0cmVhbSdzICdkYXRhJyBldmVudFxuICAgIHJlc3VsdFN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHRoZSBjaHVuayByb3dzXG4gICAgICAgIHByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSByb3dzIGluIGEgZ2l2ZW4gY2h1bmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmtcbiAgICAgKi9cbiAgICBjb25zdCBwcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgcm93cyBpbiB0aGUgY3VycmVudCBjaHVuayB0aGF0IG92ZXJsYXAgd2l0aCB0aGUgcmVxdWVzdGVkXG4gICAgICAgIC8vIHdpbmRvd1xuICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgU3RhcnQgUHJvY2Vzc2luZyBjaHVua3NgKTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKS5zdGFydCgpO1xuICAgICAgICBjb25zdCBjaHVua1N0YXJ0ID0gY2h1bmsuZ2V0U3RhcnRJbmRleCgpO1xuICAgICAgICBjb25zdCBjaHVua0VuZCA9IGNodW5rLmdldEVuZEluZGV4KCk7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBjaHVua1xuICAgICAgICAgICAgLmdldFJvd3MoKVxuICAgICAgICAgICAgLnNsaWNlKE1hdGgubWF4KGNodW5rU3RhcnQsIHN0YXJ0KSAtIGNodW5rU3RhcnQsIE1hdGgubWluKGNodW5rRW5kLCBlbmQpICsgMSAtIGNodW5rU3RhcnQpO1xuICAgICAgICBsZXQgcm93SW5kZXggPSAwO1xuICAgICAgICBjb25zdCByb3dzTGVuZ3RoID0gcm93cy5sZW5ndGg7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byBiYXRjaC1wcm9jZXNzIHJvd3NcbiAgICAgICAgY29uc3QgcHJvY2Vzc1Jvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIGFuZCBzdGFydCB0aW1lXG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcm93SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgZWFjaCA9IG9wdGlvbnMuZWFjaDtcbiAgICAgICAgICAgIGxldCBzdG9wcGVkUHJvY2Vzc2luZ1Jvd3M7XG4gICAgICAgICAgICB3aGlsZSAocm93SW5kZXggPCByb3dzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBlYWNoKCkgY2FsbGJhY2sgb24gdGhlIGN1cnJlbnQgcm93XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gZWFjaChyb3dzW3Jvd0luZGV4KytdKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm51bVJvd3NQcm9jZXNzZWQrKztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UsIHN0b3AgcHJvY2Vzc2luZyByb3dzXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFByb2Nlc3NpbmdSb3dzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgY3VycmVudCB0aW1lIHRvIGNoZWNrIGlmIHdlJ3ZlIGJlZW5cbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHJvd3MgZm9yIHRvbyBsb25nOyBpZiBzbywgbGVhdmUgdGhlIHJlc3QgZm9yIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gdGljayBvZiB0aGUgZXZlbnQgbG9vcFxuICAgICAgICAgICAgICAgIGlmIChyb3dJbmRleCAtIHN0YXJ0SW5kZXggPj0gY29udGV4dC5yb3dCYXRjaFNpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IGNvbnRleHQucm93QmF0Y2hEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHByb2Nlc3NSb3dzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgcm93cyBmb3IgdXMgdG8gcHJvY2VzcyBpbiB0aGlzIGNodW5rXG4gICAgICAgICAgICBpZiAoIShyb3dJbmRleCA8IHJvd3NMZW5ndGgpIHx8IHN0b3BwZWRQcm9jZXNzaW5nUm93cykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGV4aGF1c3RlZCBhbGwgdGhlIHJvd3MgaW4gdGhpcyBjaHVuayBhbmQgd2UgaGF2ZW4ndCB5ZXRcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzZWQgYWxsIHRoZSByb3dzIHdlIHdhbnQgdG8gcHJvY2VzcywgYXNrIHRoZSByZXN1bHQgc3RyZWFtIHRvXG4gICAgICAgICAgICAgICAgLy8gZG8gYW5vdGhlciByZWFkXG4gICAgICAgICAgICAgICAgaWYgKCEocm93SW5kZXggPCByb3dzTGVuZ3RoKSAmJiBjb250ZXh0Lm51bVJvd3NQcm9jZXNzZWQgIT09IGNvbnRleHQubWF4TnVtUm93c1RvUHJvY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJlYW0ucmVhZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgZWl0aGVyIHByb2Nlc3NlZCBhbGwgdGhlIHJvd3Mgd2Ugd2FudGVkIHRvIHByb2Nlc3Mgb3Igd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2VyZSB0b2xkIHRvIHN0b3AgcHJvY2Vzc2luZyByb3dzIGJ5IHRoZSBlYWNoKCkgY2FsbGJhY2s7IGVpdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyB3YXksIGNsb3NlIHRoZSByZXN1bHQgc3RyZWFtIHRvIGNvbXBsZXRlIHRoZSBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyZWFtLmFzeW5jQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHN0YXJ0IHByb2Nlc3Npbmcgcm93c1xuICAgICAgICBwcm9jZXNzUm93cygpO1xuICAgICAgICB0aW1lci5zdG9wKCk7XG4gICAgICAgIExvZ2dlcigpLmRlYnVnKGBGaW5pc2hlZCBwcm9jZXNzaW5nIENodW5rczogUHJvY2Vzc2VkICR7cm93c0xlbmd0aH0gcm93cyBpbiAke3RpbWVyLmdldER1cmF0aW9uKCl9IG1zYCk7XG4gICAgfTtcbiAgICAvLyBzdGFydCByZWFkaW5nIGZyb20gdGhlIHN0cmVhbSBpbiB0aGUgbmV4dCB0aWNrIG9mIHRoZSBldmVudCBsb29wXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc3VsdFN0cmVhbS5yZWFkKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbn07XG4vKipcbiAqIEdpdmVuIGEgc29ydGVkIGFycmF5IG9mIGNodW5rcywgcmV0dXJucyBhIHN1Yi1hcnJheSB0aGF0IG92ZXJsYXBzIHdpdGggYVxuICogc3BlY2lmaWVkIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0gY2h1bmtzXG4gKiBAcGFyYW0gd2luZG93U3RhcnRcbiAqIEBwYXJhbSB3aW5kb3dFbmRcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZpbmRPdmVybGFwcGluZ0NodW5rcyhjaHVua3MsIHdpbmRvd1N0YXJ0LCB3aW5kb3dFbmQpIHtcbiAgICBjb25zdCBvdmVybGFwcGluZ0NodW5rcyA9IFtdO1xuICAgIGlmIChjaHVua3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNodW5rIHRoYXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIHdpbmRvd1xuICAgICAgICBsZXQgaW5kZXggPSBmaW5kRmlyc3RPdmVybGFwcGluZ0NodW5rKGNodW5rcywgd2luZG93U3RhcnQsIHdpbmRvd0VuZCk7XG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgY2h1bmtzIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IG92ZXJsYXBwaW5nIGNodW5rIGFuZFxuICAgICAgICAvLyBrZWVwIGdvaW5nIHVudGlsIHRoZXJlJ3Mgbm8gb3ZlcmxhcFxuICAgICAgICBmb3IgKGxldCBsZW5ndGggPSBjaHVua3MubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNodW5rLm92ZXJsYXBzV2l0aFdpbmRvdyh3aW5kb3dTdGFydCwgd2luZG93RW5kKSkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZnV0dXJlIGNodW5rcyB3aWxsIG92ZXJsYXAgYmVjYXVzZSB0aGUgY2h1bmtzIGFycmF5IGlzIHNvcnRlZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdmVybGFwcGluZ0NodW5rcztcbn1cbi8qKlxuICogR2l2ZW4gYSBzb3J0ZWQgYXJyYXkgb2YgY2h1bmtzLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2h1bmsgaW4gdGhlXG4gKiBhcnJheSB0aGF0IG92ZXJsYXBzIHdpdGggYSBzcGVjaWZpZWQgd2luZG93LlxuICpcbiAqIEBwYXJhbSBjaHVua3NcbiAqIEBwYXJhbSB3aW5kb3dTdGFydEluZGV4XG4gKiBAcGFyYW0gd2luZG93RW5kSW5kZXhcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaW5kRmlyc3RPdmVybGFwcGluZ0NodW5rKGNodW5rcywgd2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpIHtcbiAgICBjb25zdCBoZWxwZXIgPSBmdW5jdGlvbiAoY2h1bmtzLCBjaHVua0luZGV4TGVmdCwgY2h1bmtJbmRleFJpZ2h0LCB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgbWlkZGxlQ2h1bmtFbmRJbmRleDtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIHRvIC0xXG4gICAgICAgIHJlc3VsdCA9IC0xO1xuICAgICAgICAvLyBjb21wdXRlIHRoZSBpbmRleCBvZiB0aGUgbWlkZGxlIGNodW5rIGFuZCBnZXQgdGhlIG1pZGRsZSBjaHVua1xuICAgICAgICBjb25zdCBjaHVua0luZGV4TWlkZGxlID0gTWF0aC5mbG9vcigoY2h1bmtJbmRleExlZnQgKyBjaHVua0luZGV4UmlnaHQpIC8gMik7XG4gICAgICAgIGNvbnN0IG1pZGRsZUNodW5rID0gY2h1bmtzW2NodW5rSW5kZXhNaWRkbGVdO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIHR3byBvciBmZXdlciBjaHVua3NcbiAgICAgICAgaWYgKGNodW5rSW5kZXhNaWRkbGUgPT09IGNodW5rSW5kZXhMZWZ0IHx8IGNodW5rSW5kZXhNaWRkbGUgPT09IGNodW5rSW5kZXhSaWdodCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBqdXN0IG9uZSBjaHVuaywgYW5kIGl0IG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCB3aW5kb3csXG4gICAgICAgICAgICAvLyB3ZSd2ZSBmb3VuZCB0aGUgY2h1bmsgd2Ugd2VyZSBsb29raW5nIGZvclxuICAgICAgICAgICAgaWYgKGNodW5rSW5kZXhMZWZ0ID09PSBjaHVua0luZGV4UmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWlkZGxlQ2h1bmsub3ZlcmxhcHNXaXRoV2luZG93KHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjaHVua0luZGV4TGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGhhdmUgdHdvIGNodW5rcyBsZWZ0IHRvIGNoZWNrXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGNodW5rIG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCB3aW5kb3csIHRoYXQncyB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaHVuayB3ZSB3ZXJlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rc1tjaHVua0luZGV4TGVmdF0ub3ZlcmxhcHNXaXRoV2luZG93KHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjaHVua0luZGV4TGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmtzW2NodW5rSW5kZXhSaWdodF0ub3ZlcmxhcHNXaXRoV2luZG93KHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGlmIHRoZSBzZWNvbmQgY2h1bmsgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIHdpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCdzIHRoZSBjaHVuayB3ZSB3ZXJlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNodW5rSW5kZXhSaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBtaWRkbGUgY2h1bmsgZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIHRoZSBzcGVjaWZpZWQgd2luZG93XG4gICAgICAgIGlmICghbWlkZGxlQ2h1bmsub3ZlcmxhcHNXaXRoV2luZG93KHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KSkge1xuICAgICAgICAgICAgbWlkZGxlQ2h1bmtFbmRJbmRleCA9IG1pZGRsZUNodW5rLmdldEVuZEluZGV4KCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgd2luZG93IGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbWlkZGxlIGNodW5rLFxuICAgICAgICAgICAgLy8gcmVjdXJzZSBvbiB0aGUgcmlnaHQgaGFsZlxuICAgICAgICAgICAgaWYgKHdpbmRvd1N0YXJ0SW5kZXggPiBtaWRkbGVDaHVua0VuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjaHVua3MsIGNodW5rSW5kZXhNaWRkbGUsIGNodW5rSW5kZXhSaWdodCwgd2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzZSBvbiB0aGUgbGVmdCBoYWxmXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjaHVua3MsIGNodW5rSW5kZXhMZWZ0LCBjaHVua0luZGV4TWlkZGxlLCB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbWlkZGxlIGNodW5rIG92ZXJsYXBzIGJ1dCB0aGUgY2h1bmsgYmVmb3JlIGl0IGRvZXMgbm90LCB0aGVcbiAgICAgICAgICAgIC8vIG1pZGRsZSBjaHVuayBpcyB0aGUgb25lIHdlIHdlcmUgbG9va2luZ1xuICAgICAgICAgICAgaWYgKGNodW5rSW5kZXhNaWRkbGUgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAhY2h1bmtzW2NodW5rSW5kZXhNaWRkbGUgLSAxXS5vdmVybGFwc1dpdGhXaW5kb3cod2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rSW5kZXhNaWRkbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlIG9uIHRoZSBsZWZ0IGhhbGZcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGNodW5rcywgY2h1bmtJbmRleExlZnQsIGNodW5rSW5kZXhNaWRkbGUsIHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhlbHBlcihjaHVua3MsIDAsIGNodW5rcy5sZW5ndGggLSAxLCB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGNvbHVtbnMgaW4gdGhpcyByZXN1bHQuXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGNvbHVtbiBpZGVudGlmaWVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbi4gVGhlIGNvbHVtblxuICogaWRlbnRpZmllciBjYW4gYmUgZWl0aGVyIHRoZSBjb2x1bW4gbmFtZSAoU3RyaW5nKSBvciB0aGUgY29sdW1uIGluZGV4XG4gKiAoTnVtYmVyKS4gSWYgYSBjb2x1bW4gbmFtZSBpcyBzcGVjaWZpZWQgYW5kIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29sdW1uXG4gKiB3aXRoIHRoYXQgbmFtZSwgdGhlIGZpcnN0IGNvbHVtbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBjb2x1bW5JZGVudGlmaWVyXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRDb2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uSWRlbnRpZmllcikge1xuICAgIGxldCBjb2x1bW5JbmRleDtcbiAgICAvLyBpZiB0aGUgY29sdW1uIGlkZW50aWZpZXIgaXMgYSBzdHJpbmcsIHRyZWF0IGl0IGFzIGEgY29sdW1uXG4gICAgLy8gbmFtZSBhbmQgdXNlIGl0IHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjb2x1bW5cbiAgICBpZiAoVXRpbC5pc1N0cmluZyhjb2x1bW5JZGVudGlmaWVyKSkge1xuICAgICAgICAvLyBpZiBhIHZhbGlkIGNvbHVtbiBuYW1lIHdhcyBzcGVjaWZpZWQsIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICAvLyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX21hcENvbHVtbk5hbWVUb0luZGljZXMsIGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCA9IHRoaXMuX21hcENvbHVtbk5hbWVUb0luZGljZXNbY29sdW1uSWRlbnRpZmllcl1bMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5pc051bWJlcihjb2x1bW5JZGVudGlmaWVyKSkge1xuICAgICAgICAvLyBpZiB0aGUgY29sdW1uIGlkZW50aWZpZXIgaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGEgY29sdW1uIGluZGV4XG4gICAgICAgIGNvbHVtbkluZGV4ID0gY29sdW1uSWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNbY29sdW1uSW5kZXhdO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdGVtZW50IGlkIGdlbmVyYXRlZCBieSB0aGUgc2VydmVyIGZvciB0aGUgc3RhdGVtZW50IHRoYXRcbiAqIHByb2R1Y2VkIHRoaXMgcmVzdWx0LlxuICpcbiAqIFNob3VsZCB1c2UgZ2V0UXVlcnlJZCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0U3RhdGVtZW50SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXJ5SWQ7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBxdWVyeSBpZCBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBmb3IgdGhlIHN0YXRlbWVudCB0aGF0XG4gKiBwcm9kdWNlZCB0aGlzIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFF1ZXJ5SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXJ5SWQ7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFJldHVybmVkUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0dXJuZWRSb3dzO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZCBieSB0aGUgc3RhdGVtZW50IHRoYXQgcHJvZHVjZWQgdGhpc1xuICogcmVzdWx0LiBJZiB0aGUgc3RhdGVtZW50IGlzbid0IGEgRE1MLCB3ZSByZXR1cm4gLTEuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXROdW1VcGRhdGVkUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpbml0aWFsaXplIGlmIG5lY2Vzc2FyeVxuICAgIGlmICghdGhpcy5fbnVtVXBkYXRlZFJvd3MpIHtcbiAgICAgICAgbGV0IG51bVVwZGF0ZWRSb3dzID0gLTE7XG4gICAgICAgIC8vIHRoZSB1cGRhdGVkLXJvd3MgbWV0cmljIG9ubHkgYXBwbGllcyB0byBkbWwnc1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnRUeXBlSWQgPSB0aGlzLl9zdGF0ZW1lbnRUeXBlSWQ7XG4gICAgICAgIGlmIChTdGF0ZW1lbnRUeXBlLmlzRG1sKHN0YXRlbWVudFR5cGVJZCkpIHtcbiAgICAgICAgICAgIGlmIChTdGF0ZW1lbnRUeXBlLmlzSW5zZXJ0KHN0YXRlbWVudFR5cGVJZCkgfHxcbiAgICAgICAgICAgICAgICBTdGF0ZW1lbnRUeXBlLmlzVXBkYXRlKHN0YXRlbWVudFR5cGVJZCkgfHxcbiAgICAgICAgICAgICAgICBTdGF0ZW1lbnRUeXBlLmlzRGVsZXRlKHN0YXRlbWVudFR5cGVJZCkgfHxcbiAgICAgICAgICAgICAgICBTdGF0ZW1lbnRUeXBlLmlzTWVyZ2Uoc3RhdGVtZW50VHlwZUlkKSB8fFxuICAgICAgICAgICAgICAgIFN0YXRlbWVudFR5cGUuaXNNdWx0aVRhYmxlSW5zZXJ0KHN0YXRlbWVudFR5cGVJZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSB0aGlzLl9jaHVua3M7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHRoaXMuX2NvbHVtbnM7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRlbWVudCBpcyBhIGRtbCwgdGhlIHJlc3VsdCBzaG91bGQgYmUgc21hbGwsXG4gICAgICAgICAgICAgICAgLy8gbWVhbmluZyB3ZSBvbmx5IGhhdmUgb25lIGNodW5rXG4gICAgICAgICAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShjaHVua3MpICYmIGNodW5rcy5sZW5ndGggPT09IDEpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCB1cCB0aGUgdmFsdWVzIGluIGFsbCB0aGUgY29sdW1uc1xuICAgICAgICAgICAgICAgIG51bVVwZGF0ZWRSb3dzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gY2h1bmtzWzBdLmdldFJvd3MoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3dJbmRleCA9IDAsIHJvd3NMZW5ndGggPSByb3dzLmxlbmd0aDsgcm93SW5kZXggPCByb3dzTGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2xJbmRleCA9IDAsIGNvbHNMZW5ndGggPSBjb2x1bW5zLmxlbmd0aDsgY29sSW5kZXggPCBjb2xzTGVuZ3RoOyBjb2xJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1VcGRhdGVkUm93cyArPSBOdW1iZXIocm93LmdldENvbHVtblZhbHVlKGNvbHVtbnNbY29sSW5kZXhdLmdldElkKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSAnY29weScgYW5kICd1bmxvYWQnXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbnVtVXBkYXRlZFJvd3MgPSBudW1VcGRhdGVkUm93cztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX251bVVwZGF0ZWRSb3dzO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3Mgd2Ugd291bGQgaGF2ZSBoYWQgaW4gdGhpcyByZXN1bHQgaWYgdGhlIHZhbHVlIG9mXG4gKiB0aGUgUk9XU19QRVJfUkVTVUxUU0VUIHBhcmFtZXRlciB3YXMgMCBhdCB0aGUgdGltZSB0aGlzIHN0YXRlbWVudCB3YXNcbiAqIGV4ZWN1dGVkLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0VG90YWxSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJvd3M7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlc3VsdC4gVGhlc2UgcGFyYW1ldGVycyBjb250YWluXG4gKiBkaXJlY3RpdmVzIGFib3V0IGhvdyB0byBjb25zdW1lIGFuZCBwcmVzZW50IHRoZSByZXN1bHQuXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFBhcmFtZXRlcnNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyc0FycmF5O1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsdWVzIG9mIHRoZSBjdXJyZW50XG4gKiB3YXJlaG91c2UsIGN1cnJlbnQgZGF0YWJhc2UsIGFuZCBhbnkgb3RoZXIgc2Vzc2lvbi1yZWxhdGVkIHN0YXRlIHdoZW4gdGhlXG4gKiBzdGF0ZW1lbnQgdGhhdCBwcm9kdWNlZCB0aGlzIHJlc3VsdCBmaW5pc2hlZCBleGVjdXRpbmcuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRTZXNzaW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25TdGF0ZTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHZlcnNpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVzdWx0LlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3VsdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n/**\n * Creates a stream-like object that can be used to read the contents of an\n * array of chunks with the ability to prefetch chunks as we go. Every time the\n * contents of a new chunk become available, a 'data' event is fired. When there\n * are no more chunks to read, a 'close' event is fired to indicate that the\n * read operation is complete. If no chunks are specified in the options, the\n * stream asynchronously fires a 'close' event after it is returned.\n *\n * @param {Object} [options] An options object with the following properties:\n *   {Object[]} chunks       - The chunks to read.\n *   {Number}   prefetchSize - The number of chunks to prefetch every time a new\n *     chunk is read.\n *\n * @constructor\n */\nfunction ResultStream(options) {\n    // options should be an object\n    Errors.assertInternal(Util.isObject(options));\n    const chunks = options.chunks;\n    const prefetchSize = options.prefetchSize;\n    // chunks should be an array\n    Errors.assertInternal(Util.isArray(chunks));\n    // prefetch size should be non-negative\n    Errors.assertInternal(Util.isNumber(prefetchSize) && prefetchSize >= 0);\n    // Current chunk being streamed. Start with the first chunk.\n    let currChunk = 0;\n    const self = this;\n    /**\n     * Called when a chunk fires a 'loadcomplete' event.\n     *\n     * @param {Error} err\n     * @param {Chunk} chunk\n     */\n    const onLoadComplete = function (err, chunk) {\n        // unsubscribe from the 'loadcomplete' event\n        chunk.removeListener('loadcomplete', onLoadComplete);\n        // if the chunk load succeeded\n        if (!err) {\n            // Move on to the next chunk\n            currChunk++;\n            // emit an event to signal that new data is available\n            self.emit('data', chunk);\n        }\n        else {\n            // close the stream with an error; also, include a callback when emitting\n            // the event in case someone wants to fix the problem and ask us to\n            // continue from where we got interrupted\n            close(self, err, doLoad);\n        }\n    };\n    /**\n     * Identifies the next chunk to load and issues requests to fetch both its\n     * contents plus the contents of the next few chunks. If there are no more\n     * chunks to load, a 'close' event is fired on the stream to notify\n     * subscribers that all the chunks have been successfully read.\n     */\n    const doLoad = function () {\n        // All chunks were loaded, we're done\n        if (currChunk >= chunks.length) {\n            self.asyncClose();\n        }\n        else {\n            // Subscribe to the loadcomplete event on the current chunk being streamed to ensure the\n            // rows are returned in the correct order and not in the order chunk data are received\n            chunks[currChunk].on('loadcomplete', onLoadComplete);\n            // Fire off requests to load all the chunks in the buffer that aren't already loading\n            let chunk, index;\n            for (index = currChunk; index < chunks.length && index <= currChunk + prefetchSize; index++) {\n                chunk = chunks[index];\n                if (!chunk.isLoading()) {\n                    chunk.load();\n                }\n            }\n        }\n    };\n    /**\n     * Reads the next chunk of data in the result stream.\n     */\n    this.read = function () {\n        // TODO: if there are no more chunks to read, should we raise an error?\n        // TODO: what if we're already in the middle of a read?\n        // read the next chunk\n        doLoad();\n    };\n}\nUtil.inherits(ResultStream, EventEmitter);\n/**\n * Asynchronously closes this stream.\n *\n * @returns {ResultStream}\n */\nResultStream.prototype.asyncClose = function () {\n    // schedule an operation to close the stream in\n    // the next tick of the event loop\n    const self = this;\n    process.nextTick(function () {\n        close(self);\n    });\n    return this;\n};\n/**\n * Closes a given result stream.\n *\n * @param {ResultStream} stream The stream to close.\n * @param {Error} [err] The error, if any, to fire with the close event.\n * @param {Function} [callback] The callback, if any, to fire with the close\n *   event. This is in case someone wants to fix the problem and ask the stream\n *   to resume from the point of interruption.\n */\nfunction close(stream, err, callback) {\n    stream.emit('close', err, callback);\n}\nmodule.exports = ResultStream;\n//# sourceMappingURL=result_stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9yZXN1bHRfc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscUJBQXFCLDBEQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDJFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUE0RDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L3Jlc3VsdF9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBzdHJlYW0tbGlrZSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIHRoZSBjb250ZW50cyBvZiBhblxuICogYXJyYXkgb2YgY2h1bmtzIHdpdGggdGhlIGFiaWxpdHkgdG8gcHJlZmV0Y2ggY2h1bmtzIGFzIHdlIGdvLiBFdmVyeSB0aW1lIHRoZVxuICogY29udGVudHMgb2YgYSBuZXcgY2h1bmsgYmVjb21lIGF2YWlsYWJsZSwgYSAnZGF0YScgZXZlbnQgaXMgZmlyZWQuIFdoZW4gdGhlcmVcbiAqIGFyZSBubyBtb3JlIGNodW5rcyB0byByZWFkLCBhICdjbG9zZScgZXZlbnQgaXMgZmlyZWQgdG8gaW5kaWNhdGUgdGhhdCB0aGVcbiAqIHJlYWQgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLiBJZiBubyBjaHVua3MgYXJlIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucywgdGhlXG4gKiBzdHJlYW0gYXN5bmNocm9ub3VzbHkgZmlyZXMgYSAnY2xvc2UnIGV2ZW50IGFmdGVyIGl0IGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgIHtPYmplY3RbXX0gY2h1bmtzICAgICAgIC0gVGhlIGNodW5rcyB0byByZWFkLlxuICogICB7TnVtYmVyfSAgIHByZWZldGNoU2l6ZSAtIFRoZSBudW1iZXIgb2YgY2h1bmtzIHRvIHByZWZldGNoIGV2ZXJ5IHRpbWUgYSBuZXdcbiAqICAgICBjaHVuayBpcyByZWFkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZXN1bHRTdHJlYW0ob3B0aW9ucykge1xuICAgIC8vIG9wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICBjb25zdCBjaHVua3MgPSBvcHRpb25zLmNodW5rcztcbiAgICBjb25zdCBwcmVmZXRjaFNpemUgPSBvcHRpb25zLnByZWZldGNoU2l6ZTtcbiAgICAvLyBjaHVua3Mgc2hvdWxkIGJlIGFuIGFycmF5XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShjaHVua3MpKTtcbiAgICAvLyBwcmVmZXRjaCBzaXplIHNob3VsZCBiZSBub24tbmVnYXRpdmVcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc051bWJlcihwcmVmZXRjaFNpemUpICYmIHByZWZldGNoU2l6ZSA+PSAwKTtcbiAgICAvLyBDdXJyZW50IGNodW5rIGJlaW5nIHN0cmVhbWVkLiBTdGFydCB3aXRoIHRoZSBmaXJzdCBjaHVuay5cbiAgICBsZXQgY3VyckNodW5rID0gMDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGNodW5rIGZpcmVzIGEgJ2xvYWRjb21wbGV0ZScgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICAgKiBAcGFyYW0ge0NodW5rfSBjaHVua1xuICAgICAqL1xuICAgIGNvbnN0IG9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgY2h1bmspIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSB0aGUgJ2xvYWRjb21wbGV0ZScgZXZlbnRcbiAgICAgICAgY2h1bmsucmVtb3ZlTGlzdGVuZXIoJ2xvYWRjb21wbGV0ZScsIG9uTG9hZENvbXBsZXRlKTtcbiAgICAgICAgLy8gaWYgdGhlIGNodW5rIGxvYWQgc3VjY2VlZGVkXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIG9uIHRvIHRoZSBuZXh0IGNodW5rXG4gICAgICAgICAgICBjdXJyQ2h1bmsrKztcbiAgICAgICAgICAgIC8vIGVtaXQgYW4gZXZlbnQgdG8gc2lnbmFsIHRoYXQgbmV3IGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjbG9zZSB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3I7IGFsc28sIGluY2x1ZGUgYSBjYWxsYmFjayB3aGVuIGVtaXR0aW5nXG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgaW4gY2FzZSBzb21lb25lIHdhbnRzIHRvIGZpeCB0aGUgcHJvYmxlbSBhbmQgYXNrIHVzIHRvXG4gICAgICAgICAgICAvLyBjb250aW51ZSBmcm9tIHdoZXJlIHdlIGdvdCBpbnRlcnJ1cHRlZFxuICAgICAgICAgICAgY2xvc2Uoc2VsZiwgZXJyLCBkb0xvYWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIHRoZSBuZXh0IGNodW5rIHRvIGxvYWQgYW5kIGlzc3VlcyByZXF1ZXN0cyB0byBmZXRjaCBib3RoIGl0c1xuICAgICAqIGNvbnRlbnRzIHBsdXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBuZXh0IGZldyBjaHVua3MuIElmIHRoZXJlIGFyZSBubyBtb3JlXG4gICAgICogY2h1bmtzIHRvIGxvYWQsIGEgJ2Nsb3NlJyBldmVudCBpcyBmaXJlZCBvbiB0aGUgc3RyZWFtIHRvIG5vdGlmeVxuICAgICAqIHN1YnNjcmliZXJzIHRoYXQgYWxsIHRoZSBjaHVua3MgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSByZWFkLlxuICAgICAqL1xuICAgIGNvbnN0IGRvTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWxsIGNodW5rcyB3ZXJlIGxvYWRlZCwgd2UncmUgZG9uZVxuICAgICAgICBpZiAoY3VyckNodW5rID49IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGYuYXN5bmNDbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBsb2FkY29tcGxldGUgZXZlbnQgb24gdGhlIGN1cnJlbnQgY2h1bmsgYmVpbmcgc3RyZWFtZWQgdG8gZW5zdXJlIHRoZVxuICAgICAgICAgICAgLy8gcm93cyBhcmUgcmV0dXJuZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIG5vdCBpbiB0aGUgb3JkZXIgY2h1bmsgZGF0YSBhcmUgcmVjZWl2ZWRcbiAgICAgICAgICAgIGNodW5rc1tjdXJyQ2h1bmtdLm9uKCdsb2FkY29tcGxldGUnLCBvbkxvYWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAvLyBGaXJlIG9mZiByZXF1ZXN0cyB0byBsb2FkIGFsbCB0aGUgY2h1bmtzIGluIHRoZSBidWZmZXIgdGhhdCBhcmVuJ3QgYWxyZWFkeSBsb2FkaW5nXG4gICAgICAgICAgICBsZXQgY2h1bmssIGluZGV4O1xuICAgICAgICAgICAgZm9yIChpbmRleCA9IGN1cnJDaHVuazsgaW5kZXggPCBjaHVua3MubGVuZ3RoICYmIGluZGV4IDw9IGN1cnJDaHVuayArIHByZWZldGNoU2l6ZTsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmtzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNodW5rLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBuZXh0IGNodW5rIG9mIGRhdGEgaW4gdGhlIHJlc3VsdCBzdHJlYW0uXG4gICAgICovXG4gICAgdGhpcy5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaHVua3MgdG8gcmVhZCwgc2hvdWxkIHdlIHJhaXNlIGFuIGVycm9yP1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGlmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlYWQ/XG4gICAgICAgIC8vIHJlYWQgdGhlIG5leHQgY2h1bmtcbiAgICAgICAgZG9Mb2FkKCk7XG4gICAgfTtcbn1cblV0aWwuaW5oZXJpdHMoUmVzdWx0U3RyZWFtLCBFdmVudEVtaXR0ZXIpO1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSBjbG9zZXMgdGhpcyBzdHJlYW0uXG4gKlxuICogQHJldHVybnMge1Jlc3VsdFN0cmVhbX1cbiAqL1xuUmVzdWx0U3RyZWFtLnByb3RvdHlwZS5hc3luY0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNjaGVkdWxlIGFuIG9wZXJhdGlvbiB0byBjbG9zZSB0aGUgc3RyZWFtIGluXG4gICAgLy8gdGhlIG5leHQgdGljayBvZiB0aGUgZXZlbnQgbG9vcFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjbG9zZShzZWxmKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIENsb3NlcyBhIGdpdmVuIHJlc3VsdCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtSZXN1bHRTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIHRvIGNsb3NlLlxuICogQHBhcmFtIHtFcnJvcn0gW2Vycl0gVGhlIGVycm9yLCBpZiBhbnksIHRvIGZpcmUgd2l0aCB0aGUgY2xvc2UgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjaywgaWYgYW55LCB0byBmaXJlIHdpdGggdGhlIGNsb3NlXG4gKiAgIGV2ZW50LiBUaGlzIGlzIGluIGNhc2Ugc29tZW9uZSB3YW50cyB0byBmaXggdGhlIHByb2JsZW0gYW5kIGFzayB0aGUgc3RyZWFtXG4gKiAgIHRvIHJlc3VtZSBmcm9tIHRoZSBwb2ludCBvZiBpbnRlcnJ1cHRpb24uXG4gKi9cbmZ1bmN0aW9uIGNsb3NlKHN0cmVhbSwgZXJyLCBjYWxsYmFjaykge1xuICAgIHN0cmVhbS5lbWl0KCdjbG9zZScsIGVyciwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXN1bHRfc3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ResultStream = __webpack_require__(/*! ./result_stream */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result_stream.js\");\nconst DataTypes = __webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst RowMode = __webpack_require__(/*! ./../../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\n/**\n * Creates a stream that can be used to read a statement result row by row.\n *\n * @param {Object} statement\n * @param {Object} context\n * @param {Object} options\n * @constructor\n */\nfunction RowStream(statement, context, options) {\n    // validate non-user-specified arguments\n    Errors.assertInternal(Util.exists(statement));\n    Errors.assertInternal(Util.exists(context));\n    // call Readable constructor\n    Readable.call(this, {\n        objectMode: true,\n        highWaterMark: context.connectionConfig.getRowStreamHighWaterMark(),\n    });\n    // extract streaming options\n    let start, end, fetchAsString, rowMode;\n    if (Util.isObject(options)) {\n        start = options.start;\n        end = options.end;\n        fetchAsString = options.fetchAsString;\n    }\n    // if a fetchAsString value is not specified in the stream options, try the\n    // statement and connection options (in that order)\n    if (!Util.exists(fetchAsString)) {\n        fetchAsString = context.fetchAsString;\n    }\n    if (!Util.exists(fetchAsString)) {\n        fetchAsString = context.connectionConfig.getFetchAsString();\n    }\n    if (!Util.exists(rowMode)) {\n        rowMode = context.rowMode || context.connectionConfig.getRowMode();\n    }\n    let resultStream = null, numResultStreamInterrupts = 0;\n    let rowBuffer = null, rowIndex = 0;\n    let columns, mapColumnIdToExtractFnName;\n    let initialized = false;\n    let previousChunk = null;\n    const self = this;\n    /**\n     * Reads the next row in the result.\n     *\n     * @private\n     */\n    this._read = function () {\n        // if the stream has been initialized, just read the next row\n        if (initialized) {\n            readNextRow();\n        }\n        else if (context.isFetchingResult) {\n            // if we're still fetching the result, wait for the operation to complete\n            context.on('statement-complete', init);\n        }\n        else if (context.result || isStatementErrorFatal(context)) {\n            // if we have a result or a fatal error, call init() in the next tick of\n            // the event loop\n            process.nextTick(init);\n        }\n        else {\n            if (typeof context.multiResultIds === 'undefined') {\n                // fetch the result again and call init() upon completion of the operation\n                context.refresh(init);\n            }\n            else {\n                //do nothing\n            }\n        }\n    };\n    /**\n     * Initializes this stream.\n     */\n    const init = function init() {\n        // the stream has now been initialized\n        initialized = true;\n        // if we have a result\n        if (context.result) {\n            // if no value was specified for the start index or if the specified start\n            // index is negative, default to 0, otherwise truncate the fractional part\n            start = !Util.isNumber(start) || start < 0 ? 0 : Math.floor(start);\n            // if no value was specified for the end index or if the end index is\n            // larger than the row index of the last row, default to the index of the\n            // last row, otherwise truncate the fractional part\n            const returnedRows = context.result.getReturnedRows();\n            end = !Util.isNumber(end) || end >= returnedRows ? returnedRows - 1 : Math.floor(end);\n            // find all the chunks that overlap with the specified range\n            const overlappingChunks = context.result.findOverlappingChunks(start, end);\n            // if no chunks overlap or start is greater than end, we're done\n            if (overlappingChunks.length === 0 || start > end) {\n                process.nextTick(close);\n            }\n            else {\n                // create a result stream from the overlapping chunks\n                resultStream = new ResultStream({\n                    chunks: overlappingChunks,\n                    prefetchSize: context.connectionConfig.getResultPrefetch(),\n                });\n                readNextRow();\n            }\n        }\n        else {\n            close(context.resultError);\n        }\n    };\n    /**\n     * Processes the row buffer.\n     */\n    const processRowBuffer = function processRowBuffer() {\n        // get the row to add to the read queue\n        let row = rowBuffer[rowIndex++];\n        // if we just read the last row in the row buffer, clear the row buffer and\n        // reset the row index so that we load the next chunk in the result stream\n        // when _read() is called\n        if (rowIndex === rowBuffer.length) {\n            rowBuffer = null;\n            rowIndex = 0;\n        }\n        // initialize the columns and column-related maps if necessary\n        if (!columns) {\n            columns = statement.getColumns();\n        }\n        if (!mapColumnIdToExtractFnName) {\n            mapColumnIdToExtractFnName = buildMapColumnExtractFnNames(columns, fetchAsString);\n        }\n        // add the next row to the read queue\n        process.nextTick(function () {\n            // check if there are still rows available in the rowBuffer\n            if (rowBuffer && rowIndex > 0) {\n                rowIndex--; // decrement the index to include the previous row in the while loop\n                // push() data to readable stream until highWaterMark threshold is reached or all rows are pushed\n                while (rowIndex < rowBuffer.length) {\n                    row = rowBuffer[rowIndex++];\n                    // if buffer has reached the threshold based on the highWaterMark value then\n                    // push() will return false and pause sending data to the buffer until the data is read from the buffer\n                    if (!self.push(externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode))) {\n                        break;\n                    }\n                }\n                // check if all rows in rowBuffer has been pushed to the readable stream\n                if (rowIndex === rowBuffer.length) {\n                    // reset the buffer and index\n                    rowBuffer = null;\n                    rowIndex = 0;\n                }\n            }\n            else {\n                // No more rows left in the buffer\n                // Push the last row in the buffer\n                self.push(externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode));\n            }\n        });\n    };\n    /**\n     * Called when the result stream reads a new chunk.\n     *\n     * @param {Chunk} chunk\n     */\n    const onResultStreamData = function onResultStreamData(chunk) {\n        // unsubscribe from the result stream's 'data' and 'close' events\n        resultStream.removeListener('data', onResultStreamData);\n        resultStream.removeListener('close', onResultStreamClose);\n        // get all the rows in the chunk that overlap with the requested window,\n        // and use the resulting array as the new row buffer\n        const chunkStart = chunk.getStartIndex();\n        const chunkEnd = chunk.getEndIndex();\n        rowBuffer = chunk\n            .getRows()\n            .slice(Math.max(chunkStart, start) - chunkStart, Math.min(chunkEnd, end) + 1 - chunkStart);\n        // reset the row index\n        rowIndex = 0;\n        // process the row buffer\n        processRowBuffer();\n        if (previousChunk && previousChunk !== chunk) {\n            previousChunk.clearRows();\n        }\n        previousChunk = chunk;\n    };\n    /**\n     * Called when there are no more chunks to read in the result stream or an\n     * error is encountered while trying to read the next chunk.\n     *\n     * @param err\n     * @param continueCallback\n     */\n    const onResultStreamClose = function onResultStreamClose(err, continueCallback) {\n        // if the error is retryable and\n        // the result stream hasn't been closed too many times\n        if (isResultStreamErrorRetryable(err) &&\n            numResultStreamInterrupts < context.connectionConfig.getResultStreamInterrupts()) {\n            numResultStreamInterrupts++;\n            // fetch the statement result again\n            context.refresh(function () {\n                if (context.resultError) {\n                    close(context.resultError);\n                }\n                else {\n                    continueCallback();\n                }\n            });\n        }\n        else {\n            close(err);\n        }\n    };\n    /**\n     * Closes the row stream.\n     *\n     * @param {Error} [err]\n     */\n    const close = function (err) {\n        // if we have a result stream, stop listening to events on it\n        if (resultStream) {\n            resultStream.removeListener('data', onResultStreamData);\n            resultStream.removeListener('close', onResultStreamClose);\n        }\n        // we're done, so time to clean up\n        rowBuffer = null;\n        rowIndex = 0;\n        resultStream = null;\n        numResultStreamInterrupts = 0;\n        if (previousChunk) {\n            previousChunk.clearRows();\n            previousChunk = null;\n        }\n        if (err) {\n            emitError(err);\n        }\n        else {\n            self.push(null);\n        }\n    };\n    /**\n     * Called when we're ready to read the next row in the result.\n     */\n    const readNextRow = function readNextRow() {\n        // if we have a row buffer, process it\n        if (rowBuffer) {\n            processRowBuffer();\n        }\n        else {\n            // subscribe to the result stream's 'data' and 'close' events\n            resultStream.on('data', onResultStreamData);\n            resultStream.on('close', onResultStreamClose);\n            // issue a request to fetch the next chunk in the result stream\n            resultStream.read();\n        }\n    };\n    /**\n     * Externalizes an error and emits it.\n     *\n     * @param {Error} err\n     */\n    const emitError = function emitError(err) {\n        self.emit('error', Errors.externalize(err));\n    };\n}\nUtil.inherits(RowStream, Readable);\n/**\n * Determines if a statement error is fatal.\n *\n * @returns {Boolean}\n * @param context\n */\nfunction isStatementErrorFatal(context) {\n    const error = context.resultError;\n    return ((Errors.isOperationFailedError(error) && error.sqlState) ||\n        isFileUploadError(error, context.type));\n}\nfunction isFileUploadError(error, contextType) {\n    return error && contextType === 'FILE_PRE_EXEC';\n}\n/**\n * Determines if a result stream error is a retryable error.\n *\n * @param {Error} error\n * @returns {Boolean}\n */\nfunction isResultStreamErrorRetryable(error) {\n    return ((Errors.isLargeResultSetError(error) && error.response && error.response.statusCode === 403) ||\n        (error && (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT')));\n}\n/**\n * Builds a map in which the keys are column ids and the values are the names of\n * the extract functions to use when retrieving row values for the corresponding\n * columns.\n *\n * @param {Object[]} columns\n * @param {String[]} fetchAsString the native types that should be retrieved as\n *   strings.\n *\n * @returns {Object}\n */\nfunction buildMapColumnExtractFnNames(columns, fetchAsString) {\n    const fnNameGetColumnValue = 'getColumnValue';\n    const fnNameGetColumnValueAsString = 'getColumnValueAsString';\n    let index, length, column;\n    const mapColumnIdToExtractFnName = {};\n    // if no native types need to be retrieved as strings, extract values normally\n    if (!Util.exists(fetchAsString)) {\n        for (index = 0, length = columns.length; index < length; index++) {\n            column = columns[index];\n            mapColumnIdToExtractFnName[column.getId()] = fnNameGetColumnValue;\n        }\n    }\n    else {\n        // build a map that contains all the native types that need to be\n        // retrieved as strings when extracting column values from rows\n        const nativeTypesMap = {};\n        for (index = 0, length = fetchAsString.length; index < length; index++) {\n            nativeTypesMap[fetchAsString[index].toUpperCase()] = true;\n        }\n        // for each column, pick the appropriate extract function\n        // based on whether the value needs to be retrieved as a string\n        for (index = 0, length = columns.length; index < length; index++) {\n            column = columns[index];\n            mapColumnIdToExtractFnName[column.getId()] = nativeTypesMap[DataTypes.toNativeType(column.getType())]\n                ? fnNameGetColumnValueAsString\n                : fnNameGetColumnValue;\n        }\n    }\n    return mapColumnIdToExtractFnName;\n}\n/**\n * Converts an internal representation of a result row to a format appropriate\n * for consumption by the outside world.\n *\n * @param {Object} row\n * @param {Object[]} columns\n * @param {Object} [mapColumnIdToExtractFnName]\n * @param {String?} rowMode - string value ('array', 'object' or 'object_with_renamed_duplicated_columns'). Default is 'object' when parameter isn't set.\n *\n * @returns {Object}\n */\nfunction externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode) {\n    const isArrayRowMode = rowMode === RowMode.ARRAY;\n    const externalizedRow = isArrayRowMode ? [] : {};\n    for (let index = 0, length = columns.length; index < length; index++) {\n        const column = columns[index];\n        const extractFnName = mapColumnIdToExtractFnName[column.getId()];\n        externalizedRow[isArrayRowMode ? index : column.getName()] = row[extractFnName](column.getId());\n    }\n    return externalizedRow;\n}\nmodule.exports = RowStream;\n//# sourceMappingURL=row_stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9yb3dfc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLHNEQUEwQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsdUVBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDJFQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFpQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBYztBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9yZXN1bHQvcm93X3N0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBSZXN1bHRTdHJlYW0gPSByZXF1aXJlKCcuL3Jlc3VsdF9zdHJlYW0nKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YV90eXBlcycpO1xuY29uc3QgUm93TW9kZSA9IHJlcXVpcmUoJy4vLi4vLi4vY29uc3RhbnRzL3Jvd19tb2RlJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBzdHJlYW0gdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGEgc3RhdGVtZW50IHJlc3VsdCByb3cgYnkgcm93LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJvd1N0cmVhbShzdGF0ZW1lbnQsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAvLyB2YWxpZGF0ZSBub24tdXNlci1zcGVjaWZpZWQgYXJndW1lbnRzXG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKHN0YXRlbWVudCkpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmV4aXN0cyhjb250ZXh0KSk7XG4gICAgLy8gY2FsbCBSZWFkYWJsZSBjb25zdHJ1Y3RvclxuICAgIFJlYWRhYmxlLmNhbGwodGhpcywge1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0Um93U3RyZWFtSGlnaFdhdGVyTWFyaygpLFxuICAgIH0pO1xuICAgIC8vIGV4dHJhY3Qgc3RyZWFtaW5nIG9wdGlvbnNcbiAgICBsZXQgc3RhcnQsIGVuZCwgZmV0Y2hBc1N0cmluZywgcm93TW9kZTtcbiAgICBpZiAoVXRpbC5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBzdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gICAgICAgIGVuZCA9IG9wdGlvbnMuZW5kO1xuICAgICAgICBmZXRjaEFzU3RyaW5nID0gb3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIH1cbiAgICAvLyBpZiBhIGZldGNoQXNTdHJpbmcgdmFsdWUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgc3RyZWFtIG9wdGlvbnMsIHRyeSB0aGVcbiAgICAvLyBzdGF0ZW1lbnQgYW5kIGNvbm5lY3Rpb24gb3B0aW9ucyAoaW4gdGhhdCBvcmRlcilcbiAgICBpZiAoIVV0aWwuZXhpc3RzKGZldGNoQXNTdHJpbmcpKSB7XG4gICAgICAgIGZldGNoQXNTdHJpbmcgPSBjb250ZXh0LmZldGNoQXNTdHJpbmc7XG4gICAgfVxuICAgIGlmICghVXRpbC5leGlzdHMoZmV0Y2hBc1N0cmluZykpIHtcbiAgICAgICAgZmV0Y2hBc1N0cmluZyA9IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRGZXRjaEFzU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICghVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICAgICAgcm93TW9kZSA9IGNvbnRleHQucm93TW9kZSB8fCBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0Um93TW9kZSgpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0U3RyZWFtID0gbnVsbCwgbnVtUmVzdWx0U3RyZWFtSW50ZXJydXB0cyA9IDA7XG4gICAgbGV0IHJvd0J1ZmZlciA9IG51bGwsIHJvd0luZGV4ID0gMDtcbiAgICBsZXQgY29sdW1ucywgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWU7XG4gICAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgbGV0IHByZXZpb3VzQ2h1bmsgPSBudWxsO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBuZXh0IHJvdyBpbiB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGluaXRpYWxpemVkLCBqdXN0IHJlYWQgdGhlIG5leHQgcm93XG4gICAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmVhZE5leHRSb3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0LmlzRmV0Y2hpbmdSZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIGZldGNoaW5nIHRoZSByZXN1bHQsIHdhaXQgZm9yIHRoZSBvcGVyYXRpb24gdG8gY29tcGxldGVcbiAgICAgICAgICAgIGNvbnRleHQub24oJ3N0YXRlbWVudC1jb21wbGV0ZScsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHQucmVzdWx0IHx8IGlzU3RhdGVtZW50RXJyb3JGYXRhbChjb250ZXh0KSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJlc3VsdCBvciBhIGZhdGFsIGVycm9yLCBjYWxsIGluaXQoKSBpbiB0aGUgbmV4dCB0aWNrIG9mXG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgbG9vcFxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5tdWx0aVJlc3VsdElkcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBmZXRjaCB0aGUgcmVzdWx0IGFnYWluIGFuZCBjYWxsIGluaXQoKSB1cG9uIGNvbXBsZXRpb24gb2YgdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVmcmVzaChpbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjb25zdCBpbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgLy8gdGhlIHN0cmVhbSBoYXMgbm93IGJlZW4gaW5pdGlhbGl6ZWRcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgcmVzdWx0XG4gICAgICAgIGlmIChjb250ZXh0LnJlc3VsdCkge1xuICAgICAgICAgICAgLy8gaWYgbm8gdmFsdWUgd2FzIHNwZWNpZmllZCBmb3IgdGhlIHN0YXJ0IGluZGV4IG9yIGlmIHRoZSBzcGVjaWZpZWQgc3RhcnRcbiAgICAgICAgICAgIC8vIGluZGV4IGlzIG5lZ2F0aXZlLCBkZWZhdWx0IHRvIDAsIG90aGVyd2lzZSB0cnVuY2F0ZSB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gICAgICAgICAgICBzdGFydCA9ICFVdGlsLmlzTnVtYmVyKHN0YXJ0KSB8fCBzdGFydCA8IDAgPyAwIDogTWF0aC5mbG9vcihzdGFydCk7XG4gICAgICAgICAgICAvLyBpZiBubyB2YWx1ZSB3YXMgc3BlY2lmaWVkIGZvciB0aGUgZW5kIGluZGV4IG9yIGlmIHRoZSBlbmQgaW5kZXggaXNcbiAgICAgICAgICAgIC8vIGxhcmdlciB0aGFuIHRoZSByb3cgaW5kZXggb2YgdGhlIGxhc3Qgcm93LCBkZWZhdWx0IHRvIHRoZSBpbmRleCBvZiB0aGVcbiAgICAgICAgICAgIC8vIGxhc3Qgcm93LCBvdGhlcndpc2UgdHJ1bmNhdGUgdGhlIGZyYWN0aW9uYWwgcGFydFxuICAgICAgICAgICAgY29uc3QgcmV0dXJuZWRSb3dzID0gY29udGV4dC5yZXN1bHQuZ2V0UmV0dXJuZWRSb3dzKCk7XG4gICAgICAgICAgICBlbmQgPSAhVXRpbC5pc051bWJlcihlbmQpIHx8IGVuZCA+PSByZXR1cm5lZFJvd3MgPyByZXR1cm5lZFJvd3MgLSAxIDogTWF0aC5mbG9vcihlbmQpO1xuICAgICAgICAgICAgLy8gZmluZCBhbGwgdGhlIGNodW5rcyB0aGF0IG92ZXJsYXAgd2l0aCB0aGUgc3BlY2lmaWVkIHJhbmdlXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0NodW5rcyA9IGNvbnRleHQucmVzdWx0LmZpbmRPdmVybGFwcGluZ0NodW5rcyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIC8vIGlmIG5vIGNodW5rcyBvdmVybGFwIG9yIHN0YXJ0IGlzIGdyZWF0ZXIgdGhhbiBlbmQsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIGlmIChvdmVybGFwcGluZ0NodW5rcy5sZW5ndGggPT09IDAgfHwgc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNsb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJlc3VsdCBzdHJlYW0gZnJvbSB0aGUgb3ZlcmxhcHBpbmcgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyZWFtID0gbmV3IFJlc3VsdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rczogb3ZlcmxhcHBpbmdDaHVua3MsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoU2l6ZTogY29udGV4dC5jb25uZWN0aW9uQ29uZmlnLmdldFJlc3VsdFByZWZldGNoKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhZE5leHRSb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlKGNvbnRleHQucmVzdWx0RXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIHJvdyBidWZmZXIuXG4gICAgICovXG4gICAgY29uc3QgcHJvY2Vzc1Jvd0J1ZmZlciA9IGZ1bmN0aW9uIHByb2Nlc3NSb3dCdWZmZXIoKSB7XG4gICAgICAgIC8vIGdldCB0aGUgcm93IHRvIGFkZCB0byB0aGUgcmVhZCBxdWV1ZVxuICAgICAgICBsZXQgcm93ID0gcm93QnVmZmVyW3Jvd0luZGV4KytdO1xuICAgICAgICAvLyBpZiB3ZSBqdXN0IHJlYWQgdGhlIGxhc3Qgcm93IGluIHRoZSByb3cgYnVmZmVyLCBjbGVhciB0aGUgcm93IGJ1ZmZlciBhbmRcbiAgICAgICAgLy8gcmVzZXQgdGhlIHJvdyBpbmRleCBzbyB0aGF0IHdlIGxvYWQgdGhlIG5leHQgY2h1bmsgaW4gdGhlIHJlc3VsdCBzdHJlYW1cbiAgICAgICAgLy8gd2hlbiBfcmVhZCgpIGlzIGNhbGxlZFxuICAgICAgICBpZiAocm93SW5kZXggPT09IHJvd0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvd0J1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByb3dJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgY29sdW1ucyBhbmQgY29sdW1uLXJlbGF0ZWQgbWFwcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gc3RhdGVtZW50LmdldENvbHVtbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lKSB7XG4gICAgICAgICAgICBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSA9IGJ1aWxkTWFwQ29sdW1uRXh0cmFjdEZuTmFtZXMoY29sdW1ucywgZmV0Y2hBc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBuZXh0IHJvdyB0byB0aGUgcmVhZCBxdWV1ZVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBzdGlsbCByb3dzIGF2YWlsYWJsZSBpbiB0aGUgcm93QnVmZmVyXG4gICAgICAgICAgICBpZiAocm93QnVmZmVyICYmIHJvd0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHJvd0luZGV4LS07IC8vIGRlY3JlbWVudCB0aGUgaW5kZXggdG8gaW5jbHVkZSB0aGUgcHJldmlvdXMgcm93IGluIHRoZSB3aGlsZSBsb29wXG4gICAgICAgICAgICAgICAgLy8gcHVzaCgpIGRhdGEgdG8gcmVhZGFibGUgc3RyZWFtIHVudGlsIGhpZ2hXYXRlck1hcmsgdGhyZXNob2xkIGlzIHJlYWNoZWQgb3IgYWxsIHJvd3MgYXJlIHB1c2hlZFxuICAgICAgICAgICAgICAgIHdoaWxlIChyb3dJbmRleCA8IHJvd0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93QnVmZmVyW3Jvd0luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBidWZmZXIgaGFzIHJlYWNoZWQgdGhlIHRocmVzaG9sZCBiYXNlZCBvbiB0aGUgaGlnaFdhdGVyTWFyayB2YWx1ZSB0aGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2goKSB3aWxsIHJldHVybiBmYWxzZSBhbmQgcGF1c2Ugc2VuZGluZyBkYXRhIHRvIHRoZSBidWZmZXIgdW50aWwgdGhlIGRhdGEgaXMgcmVhZCBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnB1c2goZXh0ZXJuYWxpemVSb3cocm93LCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSwgcm93TW9kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhbGwgcm93cyBpbiByb3dCdWZmZXIgaGFzIGJlZW4gcHVzaGVkIHRvIHRoZSByZWFkYWJsZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAocm93SW5kZXggPT09IHJvd0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGJ1ZmZlciBhbmQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgcm93QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIG1vcmUgcm93cyBsZWZ0IGluIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAvLyBQdXNoIHRoZSBsYXN0IHJvdyBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgc2VsZi5wdXNoKGV4dGVybmFsaXplUm93KHJvdywgY29sdW1ucywgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWUsIHJvd01vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcmVzdWx0IHN0cmVhbSByZWFkcyBhIG5ldyBjaHVuay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2h1bmt9IGNodW5rXG4gICAgICovXG4gICAgY29uc3Qgb25SZXN1bHRTdHJlYW1EYXRhID0gZnVuY3Rpb24gb25SZXN1bHRTdHJlYW1EYXRhKGNodW5rKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIHJlc3VsdCBzdHJlYW0ncyAnZGF0YScgYW5kICdjbG9zZScgZXZlbnRzXG4gICAgICAgIHJlc3VsdFN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uUmVzdWx0U3RyZWFtRGF0YSk7XG4gICAgICAgIHJlc3VsdFN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblJlc3VsdFN0cmVhbUNsb3NlKTtcbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgcm93cyBpbiB0aGUgY2h1bmsgdGhhdCBvdmVybGFwIHdpdGggdGhlIHJlcXVlc3RlZCB3aW5kb3csXG4gICAgICAgIC8vIGFuZCB1c2UgdGhlIHJlc3VsdGluZyBhcnJheSBhcyB0aGUgbmV3IHJvdyBidWZmZXJcbiAgICAgICAgY29uc3QgY2h1bmtTdGFydCA9IGNodW5rLmdldFN0YXJ0SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY2h1bmtFbmQgPSBjaHVuay5nZXRFbmRJbmRleCgpO1xuICAgICAgICByb3dCdWZmZXIgPSBjaHVua1xuICAgICAgICAgICAgLmdldFJvd3MoKVxuICAgICAgICAgICAgLnNsaWNlKE1hdGgubWF4KGNodW5rU3RhcnQsIHN0YXJ0KSAtIGNodW5rU3RhcnQsIE1hdGgubWluKGNodW5rRW5kLCBlbmQpICsgMSAtIGNodW5rU3RhcnQpO1xuICAgICAgICAvLyByZXNldCB0aGUgcm93IGluZGV4XG4gICAgICAgIHJvd0luZGV4ID0gMDtcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgcm93IGJ1ZmZlclxuICAgICAgICBwcm9jZXNzUm93QnVmZmVyKCk7XG4gICAgICAgIGlmIChwcmV2aW91c0NodW5rICYmIHByZXZpb3VzQ2h1bmsgIT09IGNodW5rKSB7XG4gICAgICAgICAgICBwcmV2aW91c0NodW5rLmNsZWFyUm93cygpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzQ2h1bmsgPSBjaHVuaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyB0byByZWFkIGluIHRoZSByZXN1bHQgc3RyZWFtIG9yIGFuXG4gICAgICogZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hpbGUgdHJ5aW5nIHRvIHJlYWQgdGhlIG5leHQgY2h1bmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICogQHBhcmFtIGNvbnRpbnVlQ2FsbGJhY2tcbiAgICAgKi9cbiAgICBjb25zdCBvblJlc3VsdFN0cmVhbUNsb3NlID0gZnVuY3Rpb24gb25SZXN1bHRTdHJlYW1DbG9zZShlcnIsIGNvbnRpbnVlQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gaWYgdGhlIGVycm9yIGlzIHJldHJ5YWJsZSBhbmRcbiAgICAgICAgLy8gdGhlIHJlc3VsdCBzdHJlYW0gaGFzbid0IGJlZW4gY2xvc2VkIHRvbyBtYW55IHRpbWVzXG4gICAgICAgIGlmIChpc1Jlc3VsdFN0cmVhbUVycm9yUmV0cnlhYmxlKGVycikgJiZcbiAgICAgICAgICAgIG51bVJlc3VsdFN0cmVhbUludGVycnVwdHMgPCBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0U3RyZWFtSW50ZXJydXB0cygpKSB7XG4gICAgICAgICAgICBudW1SZXN1bHRTdHJlYW1JbnRlcnJ1cHRzKys7XG4gICAgICAgICAgICAvLyBmZXRjaCB0aGUgc3RhdGVtZW50IHJlc3VsdCBhZ2FpblxuICAgICAgICAgICAgY29udGV4dC5yZWZyZXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5yZXN1bHRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZShjb250ZXh0LnJlc3VsdEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgcm93IHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdXG4gICAgICovXG4gICAgY29uc3QgY2xvc2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSByZXN1bHQgc3RyZWFtLCBzdG9wIGxpc3RlbmluZyB0byBldmVudHMgb24gaXRcbiAgICAgICAgaWYgKHJlc3VsdFN0cmVhbSkge1xuICAgICAgICAgICAgcmVzdWx0U3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25SZXN1bHRTdHJlYW1EYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblJlc3VsdFN0cmVhbUNsb3NlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSdyZSBkb25lLCBzbyB0aW1lIHRvIGNsZWFuIHVwXG4gICAgICAgIHJvd0J1ZmZlciA9IG51bGw7XG4gICAgICAgIHJvd0luZGV4ID0gMDtcbiAgICAgICAgcmVzdWx0U3RyZWFtID0gbnVsbDtcbiAgICAgICAgbnVtUmVzdWx0U3RyZWFtSW50ZXJydXB0cyA9IDA7XG4gICAgICAgIGlmIChwcmV2aW91c0NodW5rKSB7XG4gICAgICAgICAgICBwcmV2aW91c0NodW5rLmNsZWFyUm93cygpO1xuICAgICAgICAgICAgcHJldmlvdXNDaHVuayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZW1pdEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHdlJ3JlIHJlYWR5IHRvIHJlYWQgdGhlIG5leHQgcm93IGluIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgY29uc3QgcmVhZE5leHRSb3cgPSBmdW5jdGlvbiByZWFkTmV4dFJvdygpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHJvdyBidWZmZXIsIHByb2Nlc3MgaXRcbiAgICAgICAgaWYgKHJvd0J1ZmZlcikge1xuICAgICAgICAgICAgcHJvY2Vzc1Jvd0J1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHRoZSByZXN1bHQgc3RyZWFtJ3MgJ2RhdGEnIGFuZCAnY2xvc2UnIGV2ZW50c1xuICAgICAgICAgICAgcmVzdWx0U3RyZWFtLm9uKCdkYXRhJywgb25SZXN1bHRTdHJlYW1EYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFN0cmVhbS5vbignY2xvc2UnLCBvblJlc3VsdFN0cmVhbUNsb3NlKTtcbiAgICAgICAgICAgIC8vIGlzc3VlIGEgcmVxdWVzdCB0byBmZXRjaCB0aGUgbmV4dCBjaHVuayBpbiB0aGUgcmVzdWx0IHN0cmVhbVxuICAgICAgICAgICAgcmVzdWx0U3RyZWFtLnJlYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWxpemVzIGFuIGVycm9yIGFuZCBlbWl0cyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgICAqL1xuICAgIGNvbnN0IGVtaXRFcnJvciA9IGZ1bmN0aW9uIGVtaXRFcnJvcihlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIEVycm9ycy5leHRlcm5hbGl6ZShlcnIpKTtcbiAgICB9O1xufVxuVXRpbC5pbmhlcml0cyhSb3dTdHJlYW0sIFJlYWRhYmxlKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHN0YXRlbWVudCBlcnJvciBpcyBmYXRhbC5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzU3RhdGVtZW50RXJyb3JGYXRhbChjb250ZXh0KSB7XG4gICAgY29uc3QgZXJyb3IgPSBjb250ZXh0LnJlc3VsdEVycm9yO1xuICAgIHJldHVybiAoKEVycm9ycy5pc09wZXJhdGlvbkZhaWxlZEVycm9yKGVycm9yKSAmJiBlcnJvci5zcWxTdGF0ZSkgfHxcbiAgICAgICAgaXNGaWxlVXBsb2FkRXJyb3IoZXJyb3IsIGNvbnRleHQudHlwZSkpO1xufVxuZnVuY3Rpb24gaXNGaWxlVXBsb2FkRXJyb3IoZXJyb3IsIGNvbnRleHRUeXBlKSB7XG4gICAgcmV0dXJuIGVycm9yICYmIGNvbnRleHRUeXBlID09PSAnRklMRV9QUkVfRVhFQyc7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgYSByZXN1bHQgc3RyZWFtIGVycm9yIGlzIGEgcmV0cnlhYmxlIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZXN1bHRTdHJlYW1FcnJvclJldHJ5YWJsZShlcnJvcikge1xuICAgIHJldHVybiAoKEVycm9ycy5pc0xhcmdlUmVzdWx0U2V0RXJyb3IoZXJyb3IpICYmIGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwMykgfHxcbiAgICAgICAgKGVycm9yICYmIChlcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHwgZXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpKSk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIG1hcCBpbiB3aGljaCB0aGUga2V5cyBhcmUgY29sdW1uIGlkcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIG5hbWVzIG9mXG4gKiB0aGUgZXh0cmFjdCBmdW5jdGlvbnMgdG8gdXNlIHdoZW4gcmV0cmlldmluZyByb3cgdmFsdWVzIGZvciB0aGUgY29ycmVzcG9uZGluZ1xuICogY29sdW1ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBmZXRjaEFzU3RyaW5nIHRoZSBuYXRpdmUgdHlwZXMgdGhhdCBzaG91bGQgYmUgcmV0cmlldmVkIGFzXG4gKiAgIHN0cmluZ3MuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXBDb2x1bW5FeHRyYWN0Rm5OYW1lcyhjb2x1bW5zLCBmZXRjaEFzU3RyaW5nKSB7XG4gICAgY29uc3QgZm5OYW1lR2V0Q29sdW1uVmFsdWUgPSAnZ2V0Q29sdW1uVmFsdWUnO1xuICAgIGNvbnN0IGZuTmFtZUdldENvbHVtblZhbHVlQXNTdHJpbmcgPSAnZ2V0Q29sdW1uVmFsdWVBc1N0cmluZyc7XG4gICAgbGV0IGluZGV4LCBsZW5ndGgsIGNvbHVtbjtcbiAgICBjb25zdCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSA9IHt9O1xuICAgIC8vIGlmIG5vIG5hdGl2ZSB0eXBlcyBuZWVkIHRvIGJlIHJldHJpZXZlZCBhcyBzdHJpbmdzLCBleHRyYWN0IHZhbHVlcyBub3JtYWxseVxuICAgIGlmICghVXRpbC5leGlzdHMoZmV0Y2hBc1N0cmluZykpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGNvbHVtbnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZVtjb2x1bW4uZ2V0SWQoKV0gPSBmbk5hbWVHZXRDb2x1bW5WYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYnVpbGQgYSBtYXAgdGhhdCBjb250YWlucyBhbGwgdGhlIG5hdGl2ZSB0eXBlcyB0aGF0IG5lZWQgdG8gYmVcbiAgICAgICAgLy8gcmV0cmlldmVkIGFzIHN0cmluZ3Mgd2hlbiBleHRyYWN0aW5nIGNvbHVtbiB2YWx1ZXMgZnJvbSByb3dzXG4gICAgICAgIGNvbnN0IG5hdGl2ZVR5cGVzTWFwID0ge307XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBmZXRjaEFzU3RyaW5nLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIG5hdGl2ZVR5cGVzTWFwW2ZldGNoQXNTdHJpbmdbaW5kZXhdLnRvVXBwZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgZWFjaCBjb2x1bW4sIHBpY2sgdGhlIGFwcHJvcHJpYXRlIGV4dHJhY3QgZnVuY3Rpb25cbiAgICAgICAgLy8gYmFzZWQgb24gd2hldGhlciB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcmV0cmlldmVkIGFzIGEgc3RyaW5nXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBjb2x1bW5zLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaW5kZXhdO1xuICAgICAgICAgICAgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWVbY29sdW1uLmdldElkKCldID0gbmF0aXZlVHlwZXNNYXBbRGF0YVR5cGVzLnRvTmF0aXZlVHlwZShjb2x1bW4uZ2V0VHlwZSgpKV1cbiAgICAgICAgICAgICAgICA/IGZuTmFtZUdldENvbHVtblZhbHVlQXNTdHJpbmdcbiAgICAgICAgICAgICAgICA6IGZuTmFtZUdldENvbHVtblZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSByZXN1bHQgcm93IHRvIGEgZm9ybWF0IGFwcHJvcHJpYXRlXG4gKiBmb3IgY29uc3VtcHRpb24gYnkgdGhlIG91dHNpZGUgd29ybGQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJvd1xuICogQHBhcmFtIHtPYmplY3RbXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IFttYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZV1cbiAqIEBwYXJhbSB7U3RyaW5nP30gcm93TW9kZSAtIHN0cmluZyB2YWx1ZSAoJ2FycmF5JywgJ29iamVjdCcgb3IgJ29iamVjdF93aXRoX3JlbmFtZWRfZHVwbGljYXRlZF9jb2x1bW5zJykuIERlZmF1bHQgaXMgJ29iamVjdCcgd2hlbiBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGV4dGVybmFsaXplUm93KHJvdywgY29sdW1ucywgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWUsIHJvd01vZGUpIHtcbiAgICBjb25zdCBpc0FycmF5Um93TW9kZSA9IHJvd01vZGUgPT09IFJvd01vZGUuQVJSQVk7XG4gICAgY29uc3QgZXh0ZXJuYWxpemVkUm93ID0gaXNBcnJheVJvd01vZGUgPyBbXSA6IHt9O1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gY29sdW1ucy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaW5kZXhdO1xuICAgICAgICBjb25zdCBleHRyYWN0Rm5OYW1lID0gbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWVbY29sdW1uLmdldElkKCldO1xuICAgICAgICBleHRlcm5hbGl6ZWRSb3dbaXNBcnJheVJvd01vZGUgPyBpbmRleCA6IGNvbHVtbi5nZXROYW1lKCldID0gcm93W2V4dHJhY3RGbk5hbWVdKGNvbHVtbi5nZXRJZCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVybmFsaXplZFJvdztcbn1cbm1vZHVsZS5leHBvcnRzID0gUm93U3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm93X3N0cmVhbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Moment = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst datetimeFormatConverter = __webpack_require__(/*! ./datetime_format_converter */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/datetime_format_converter.js\");\n/**\n * Creates a new SfTimestamp instance.\n *\n * @param {Number} epochSeconds the epoch time in seconds.\n * @param {Number} nanoSeconds the number of nano seconds (incremental, not\n *   epoch).\n * @param {Number} scale the precision for the fractional part of the timestamp.\n * @param {String | Number} [timezone] the timezone name as a string\n *   (e.g. 'America/New_York') or the timezone offset in minutes (e.g. -240).\n * @param {String} [format] the SQL format to use to format the timestamp.\n * @constructor\n */ function SfTimestamp(epochSeconds, nanoSeconds, scale, timezone, format) {\n    // pick reasonable defaults for the inputs if needed\n    epochSeconds = Util.isNumber(epochSeconds) ? epochSeconds : 0;\n    nanoSeconds = Util.isNumber(nanoSeconds) ? nanoSeconds : 0;\n    scale = Util.isNumber(scale) ? scale : 0;\n    format = Util.isString(format) ? format : '';\n    // save any information we'll need later\n    this.epochSeconds = epochSeconds;\n    this.nanoSeconds = nanoSeconds;\n    this.scale = scale;\n    this.timezone = timezone;\n    this.format = format;\n    // Milliseconds are truncated to avoid rounding issues, and the decimal part is not useful since Moment only supports milliseconds precision\n    const milliseconds = Math.trunc(nanoSeconds / 1000000);\n    let moment = Moment(epochSeconds * 1000 + milliseconds);\n    // set the moment's timezone\n    if (Util.isString(timezone)) {\n        moment = moment.tz(timezone);\n    } else if (Util.isNumber(timezone)) {\n        moment = moment.utcOffset(timezone);\n    }\n    // save the moment\n    this.moment = moment;\n}\n/**\n * Returns a string representing the specified SfTimestamp instance.\n *\n * @returns {String}\n */ SfTimestamp.prototype.toString = function() {\n    // use cached value if possible\n    if (this._valueAsString) {\n        return this._valueAsString;\n    }\n    const moment = this.moment;\n    const nanoSeconds = this.nanoSeconds;\n    let scale = this.scale;\n    const formatSql = this.format;\n    // get an upper-case version of the input sql format\n    const formatSqlUpper = formatSql.toUpperCase();\n    const tags = datetimeFormatConverter.formatTagsMap();\n    // iterate over the format string\n    const length = formatSql.length;\n    let formatMoment = '';\n    for(let pos = 0; pos < length;){\n        let tag = null;\n        let out = null;\n        // at each position, check if there's a tag at that position; if so, use\n        // 'out' as the replacement\n        for(let index = 0; index < tags.length; index++){\n            if (formatSqlUpper.substr(pos).indexOf(tags[index][0]) === 0) {\n                tag = tags[index][0];\n                out = tags[index][1];\n                break;\n            }\n        }\n        // if we didn't find a match, just insert the character after escaping it\n        // (by wrapping it in square brackets)\n        if (out === null) {\n            formatMoment += '[' + formatSql[pos] + ']';\n            pos++;\n        } else {\n            // we found one of our special tags\n            if (out === '') {\n                if (tag === 'TZH') {\n                    // format the moment to get the timezone string and extract the\n                    // hours; for example, '-0700' will be converted to '-07'\n                    out = moment.format('ZZ').substr(0, 3);\n                } else if (tag === 'TZM') {\n                    // format the moment to get the timezone string and extract the\n                    // minutes; for example, '-0700' will be converted to '00\n                    out = moment.format('ZZ').substr(3);\n                } else if (tag === 'FF') {\n                    // if 'FF' is followed by a digit, use the digit as the scale\n                    let digit = null;\n                    if (pos + tag.length < length) {\n                        const matches = formatSql[pos + tag.length].match(/[0-9]/);\n                        if (matches) {\n                            digit = matches[0];\n                        }\n                    }\n                    if (digit !== null) {\n                        scale = digit;\n                        pos++; // skip the digit as well\n                    }\n                    // if we need to include fractional seconds\n                    if (scale > 0) {\n                        // divide the nanoSeconds to get the requested number of\n                        // meaningful digits\n                        const scaled = Math.floor(nanoSeconds / Math.pow(10, 9 - scale));\n                        // pad with the appropriate number of leading zeros\n                        out = (new Array(9).join('0') + scaled).substr(-scale);\n                    }\n                }\n            }\n            // append the 'out' text to the moment format and update the position\n            formatMoment += out;\n            pos += tag.length;\n        }\n    }\n    // format the moment and cache the result\n    const timezone = this.timezone.name || this.timezone;\n    if (timezone) {\n        if (typeof timezone === 'number') {\n            this._valueAsString = moment.utcOffset(timezone).format(formatMoment);\n        } else {\n            this._valueAsString = moment.tz(timezone).format(formatMoment);\n        }\n    } else {\n        this._valueAsString = moment.format(formatMoment);\n    }\n    return this._valueAsString;\n};\n/**\n * Converts this SfTimestamp to an SfDate that's just a normal JavaScript Date\n * with some additional methods like getEpochSeconds(), getNanoSeconds(),\n * getTimezone(), etc.\n *\n * @returns {Date}\n */ SfTimestamp.prototype.toSfDate = function() {\n    // create a Date from the moment\n    const date = this.moment.toDate();\n    const self = this;\n    date.getEpochSeconds = function() {\n        return self.epochSeconds;\n    };\n    date.getNanoSeconds = function() {\n        return self.nanoSeconds;\n    };\n    date.getScale = function() {\n        return self.scale;\n    };\n    date.getTimezone = function() {\n        return self.timezone;\n    };\n    date.getFormat = function() {\n        return self.format;\n    };\n    date.toJSON = function() {\n        return self.toString();\n    };\n    return date;\n};\n/**\n * Converts this SfTimestamp to an SfTime, which is just a JavaScript Object\n * with some methods: getMidnightSeconds(), getNanoSeconds(), etc.\n *\n * @returns {Object}\n */ SfTimestamp.prototype.toSfTime = function() {\n    const self = this;\n    return {\n        getMidnightSeconds: function() {\n            return self.epochSeconds;\n        },\n        getNanoSeconds: function() {\n            return self.nanoSeconds;\n        },\n        getScale: function() {\n            return self.scale;\n        },\n        getFormat: function() {\n            return self.format;\n        },\n        toJSON: function() {\n            return self.toString();\n        }\n    };\n};\nmodule.exports = SfTimestamp; //# sourceMappingURL=sf_timestamp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9zZl90aW1lc3RhbXAuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sTUFBTSxHQUFHLG1CQUFPLENBQUMsc0VBQWlCLENBQUMsQ0FBQztBQUMxQyxNQUFNLElBQUksR0FBRyxtQkFBTyxDQUFDLHVFQUFZLENBQUMsQ0FBQztBQUNuQyxNQUFNLHVCQUF1QixHQUFHLG1CQUFPLENBQUMsK0hBQTZCLENBQUMsQ0FBQztBQUN2RTs7Ozs7Ozs7Ozs7R0FXRyxDQUNILFNBQVMsV0FBVyxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNO0lBQ3JFLG9EQUFvRDtJQUNwRCxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUQsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNELEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFN0Msd0NBQXdDO0lBQ3hDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0lBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQy9CLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBRXJCLDRJQUE0STtJQUM1SSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsQ0FBQztJQUN2RCxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsWUFBWSxHQUFHLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQztJQUV4RCw0QkFBNEI7SUFDNUIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDNUIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDL0IsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ25DLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7O0dBSUcsQ0FDSCxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRztJQUMvQiwrQkFBK0I7SUFDL0IsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDeEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzNCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDckMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN2QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBRTlCLG9EQUFvRDtJQUNwRCxNQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7SUFFL0MsTUFBTSxJQUFJLEdBQUcsdUJBQXVCLENBQUMsYUFBYSxFQUFFLENBQUM7SUFFckQsaUNBQWlDO0lBQ2pDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7SUFDaEMsSUFBSSxZQUFZLEdBQUcsRUFBRSxDQUFDO0lBQ3RCLElBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUksQ0FBQztRQUNqQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDZixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFFZix3RUFBd0U7UUFDeEUsMkJBQTJCO1FBQzNCLElBQUssSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFFLENBQUM7WUFDakQsSUFBSSxjQUFjLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDN0QsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckIsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckIsTUFBTTtZQUNSLENBQUM7UUFDSCxDQUFDO1FBRUQseUVBQXlFO1FBQ3pFLHNDQUFzQztRQUN0QyxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNqQixZQUFZLElBQUksR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDM0MsR0FBRyxFQUFFLENBQUM7UUFDUixDQUFDLE1BQU0sQ0FBQztZQUNOLG1DQUFtQztZQUNuQyxJQUFJLEdBQUcsS0FBSyxFQUFFLEVBQUUsQ0FBQztnQkFDZixJQUFJLEdBQUcsS0FBSyxLQUFLLEVBQUUsQ0FBQztvQkFDbEIsK0RBQStEO29CQUMvRCx5REFBeUQ7b0JBQ3pELEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pDLENBQUMsTUFBTSxJQUFJLEdBQUcsS0FBSyxLQUFLLEVBQUUsQ0FBQztvQkFDekIsK0RBQStEO29CQUMvRCx5REFBeUQ7b0JBQ3pELEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEMsQ0FBQyxNQUFNLElBQUksR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDO29CQUN4Qiw2REFBNkQ7b0JBQzdELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQztvQkFDakIsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQUUsQ0FBQzt3QkFDOUIsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUMzRCxJQUFJLE9BQU8sRUFBRSxDQUFDOzRCQUNaLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3JCLENBQUM7b0JBQ0gsQ0FBQztvQkFDRCxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUUsQ0FBQzt3QkFDbkIsS0FBSyxHQUFHLEtBQUssQ0FBQzt3QkFDZCxHQUFHLEVBQUUsQ0FBQyxDQUFDLHlCQUF5QjtvQkFDbEMsQ0FBQztvQkFFRCwyQ0FBMkM7b0JBQzNDLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDO3dCQUNkLHdEQUF3RDt3QkFDeEQsb0JBQW9CO3dCQUNwQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQzt3QkFFakUsbURBQW1EO3dCQUNuRCxHQUFHLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTSxDQUFDLE1BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN6RCxDQUFDO2dCQUNILENBQUM7WUFDSCxDQUFDO1lBRUQscUVBQXFFO1lBQ3JFLFlBQVksSUFBSSxHQUFHLENBQUM7WUFDcEIsR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUM7UUFDcEIsQ0FBQztJQUNILENBQUM7SUFDRCx5Q0FBeUM7SUFDekMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUNyRCxJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQ2IsSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUNqQyxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3hFLENBQUMsTUFBTSxDQUFDO1lBQ04sSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNqRSxDQUFDO0lBQ0gsQ0FBQyxNQUFNLENBQUM7UUFDTixJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUNELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztBQUM3QixDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUcsQ0FDSCxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRztJQUMvQixnQ0FBZ0M7SUFDaEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUVsQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUM7SUFFbEIsSUFBSSxDQUFDLGVBQWUsR0FBRztRQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQyxDQUFDO0lBRUYsSUFBSSxDQUFDLGNBQWMsR0FBRztRQUNwQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQyxDQUFDO0lBRUYsSUFBSSxDQUFDLFFBQVEsR0FBRztRQUNkLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDLENBQUM7SUFFRixJQUFJLENBQUMsV0FBVyxHQUFHO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDLENBQUM7SUFFRixJQUFJLENBQUMsU0FBUyxHQUFHO1FBQ2YsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQyxNQUFNLEdBQUc7UUFDWixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6QixDQUFDLENBQUM7SUFFRixPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQztBQUVGOzs7OztHQUtHLENBQ0gsV0FBVyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUc7SUFDL0IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ2xCLE9BQU87UUFDTCxrQkFBa0IsRUFBRTtZQUNsQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQztRQUNELGNBQWMsRUFBRTtZQUNkLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMxQixDQUFDO1FBQ0QsUUFBUSxFQUFFO1lBQ1IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BCLENBQUM7UUFDRCxTQUFTLEVBQUU7WUFDVCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDckIsQ0FBQztRQUNELE1BQU0sRUFBRTtZQUNOLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pCLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9saWIvY29ubmVjdGlvbi9yZXN1bHQvc2ZfdGltZXN0YW1wLmpzIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/sf_timestamp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.isDml = function (statementTypeId) {\n    return statementTypeId >= 0x3000 && statementTypeId < 0x4000;\n};\nexports.isInsert = function (statementTypeId) {\n    return statementTypeId === 0x3100;\n};\nexports.isUpdate = function (statementTypeId) {\n    return statementTypeId === 0x3200;\n};\nexports.isDelete = function (statementTypeId) {\n    return statementTypeId === 0x3300;\n};\nexports.isMerge = function (statementTypeId) {\n    return statementTypeId === 0x3400;\n};\nexports.isMultiTableInsert = function (statementTypeId) {\n    return statementTypeId === 0x3500;\n};\nexports.isDdl = function (statementTypeId) {\n    return statementTypeId >= 0x6000;\n};\n//# sourceMappingURL=statement_type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9zdGF0ZW1lbnRfdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L3N0YXRlbWVudF90eXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0RtbCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50VHlwZUlkID49IDB4MzAwMCAmJiBzdGF0ZW1lbnRUeXBlSWQgPCAweDQwMDA7XG59O1xuZXhwb3J0cy5pc0luc2VydCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50VHlwZUlkID09PSAweDMxMDA7XG59O1xuZXhwb3J0cy5pc1VwZGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50VHlwZUlkID09PSAweDMyMDA7XG59O1xuZXhwb3J0cy5pc0RlbGV0ZSA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50VHlwZUlkID09PSAweDMzMDA7XG59O1xuZXhwb3J0cy5pc01lcmdlID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnRUeXBlSWQgPT09IDB4MzQwMDtcbn07XG5leHBvcnRzLmlzTXVsdGlUYWJsZUluc2VydCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50VHlwZUlkID09PSAweDM1MDA7XG59O1xuZXhwb3J0cy5pc0RkbCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50VHlwZUlkID49IDB4NjAwMDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZW1lbnRfdHlwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/statement_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst resultContainsDuplicatedColumns = (rowtype) => {\n    const columnNames = rowtype.map((rt) => rt.name);\n    return columnNames.length !== new Set(columnNames).size;\n};\nfunction addOverriddenNamesForDuplicatedColumns(rowtype) {\n    //Prepare renamed columns for duplicates if row mode was set to 'object_with_renamed_duplicated_columns'\n    if (resultContainsDuplicatedColumns(rowtype)) {\n        const columnNames = new Set(rowtype.map((el) => el.name));\n        const quntityOfColumnNames = new Map();\n        for (let index = 0; index < rowtype.length; index++) {\n            const columnName = rowtype[index].name;\n            if (columnName) {\n                if (quntityOfColumnNames.has(columnName)) {\n                    let times = quntityOfColumnNames.get(columnName) + 1;\n                    let newColumnName = columnName + '_' + times;\n                    while (columnNames.has(newColumnName)) {\n                        times += 1;\n                        newColumnName = columnName + '_' + times;\n                    }\n                    quntityOfColumnNames.set(columnName, times);\n                    rowtype[index].overriddenName = newColumnName;\n                    columnNames.add(newColumnName);\n                }\n                else {\n                    quntityOfColumnNames.set(columnName, 1);\n                }\n            }\n        }\n    }\n}\nexports.addOverridenNamesForDuplicatedColumns = addOverriddenNamesForDuplicatedColumns;\n//# sourceMappingURL=unique_column_name_creator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3Jlc3VsdC91bmlxdWVfY29sdW1uX25hbWVfY3JlYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29ubmVjdGlvbi9yZXN1bHQvdW5pcXVlX2NvbHVtbl9uYW1lX2NyZWF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCByZXN1bHRDb250YWluc0R1cGxpY2F0ZWRDb2x1bW5zID0gKHJvd3R5cGUpID0+IHtcbiAgICBjb25zdCBjb2x1bW5OYW1lcyA9IHJvd3R5cGUubWFwKChydCkgPT4gcnQubmFtZSk7XG4gICAgcmV0dXJuIGNvbHVtbk5hbWVzLmxlbmd0aCAhPT0gbmV3IFNldChjb2x1bW5OYW1lcykuc2l6ZTtcbn07XG5mdW5jdGlvbiBhZGRPdmVycmlkZGVuTmFtZXNGb3JEdXBsaWNhdGVkQ29sdW1ucyhyb3d0eXBlKSB7XG4gICAgLy9QcmVwYXJlIHJlbmFtZWQgY29sdW1ucyBmb3IgZHVwbGljYXRlcyBpZiByb3cgbW9kZSB3YXMgc2V0IHRvICdvYmplY3Rfd2l0aF9yZW5hbWVkX2R1cGxpY2F0ZWRfY29sdW1ucydcbiAgICBpZiAocmVzdWx0Q29udGFpbnNEdXBsaWNhdGVkQ29sdW1ucyhyb3d0eXBlKSkge1xuICAgICAgICBjb25zdCBjb2x1bW5OYW1lcyA9IG5ldyBTZXQocm93dHlwZS5tYXAoKGVsKSA9PiBlbC5uYW1lKSk7XG4gICAgICAgIGNvbnN0IHF1bnRpdHlPZkNvbHVtbk5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcm93dHlwZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbk5hbWUgPSByb3d0eXBlW2luZGV4XS5uYW1lO1xuICAgICAgICAgICAgaWYgKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocXVudGl0eU9mQ29sdW1uTmFtZXMuaGFzKGNvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aW1lcyA9IHF1bnRpdHlPZkNvbHVtbk5hbWVzLmdldChjb2x1bW5OYW1lKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdDb2x1bW5OYW1lID0gY29sdW1uTmFtZSArICdfJyArIHRpbWVzO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29sdW1uTmFtZXMuaGFzKG5ld0NvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sdW1uTmFtZSA9IGNvbHVtbk5hbWUgKyAnXycgKyB0aW1lcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxdW50aXR5T2ZDb2x1bW5OYW1lcy5zZXQoY29sdW1uTmFtZSwgdGltZXMpO1xuICAgICAgICAgICAgICAgICAgICByb3d0eXBlW2luZGV4XS5vdmVycmlkZGVuTmFtZSA9IG5ld0NvbHVtbk5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzLmFkZChuZXdDb2x1bW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHF1bnRpdHlPZkNvbHVtbk5hbWVzLnNldChjb2x1bW5OYW1lLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFkZE92ZXJyaWRlbk5hbWVzRm9yRHVwbGljYXRlZENvbHVtbnMgPSBhZGRPdmVycmlkZGVuTmFtZXNGb3JEdXBsaWNhdGVkQ29sdW1ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZV9jb2x1bW5fbmFtZV9jcmVhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/unique_column_name_creator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/connection/statement.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/index.js\");\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Result = __webpack_require__(/*! ./result/result */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/result.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst RowStream = __webpack_require__(/*! ./result/row_stream */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/row_stream.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst NativeTypes = (__webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\").NativeTypes);\nconst FileTransferAgent = __webpack_require__(/*! ../file_transfer_agent/file_transfer_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js\");\nconst Bind = __webpack_require__(/*! ./bind_uploader */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/bind_uploader.js\");\nconst RowMode = __webpack_require__(/*! ./../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\");\nconst states = {\n    FETCHING: 'fetching',\n    COMPLETE: 'complete',\n};\nconst statementTypes = {\n    ROW_PRE_EXEC: 'ROW_PRE_EXEC',\n    ROW_POST_EXEC: 'ROW_POST_EXEC',\n    FILE_PRE_EXEC: 'FILE_PRE_EXEC',\n    FILE_POST_EXEC: 'FILE_POST_EXEC',\n};\nconst queryCodes = {\n    QUERY_IN_PROGRESS: '333333', // GS code: the query is in progress\n    QUERY_IN_PROGRESS_ASYNC: '333334', // GS code: the query is detached\n};\nexports.createContext = function (options, services, connectionConfig) {\n    // create a statement context for a pre-exec statement\n    const context = createContextPreExec(options, services, connectionConfig);\n    context.type = statementTypes.FILE_PRE_EXEC;\n    // A hackish way to extend context with BaseStatement\n    new BaseStatement(options, context, services, connectionConfig);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersFile();\n    return context;\n};\n/**\n * Check the type of command to execute.\n *\n * @param {Object} options\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nexports.createStatementPreExec = function (options, services, connectionConfig) {\n    Logger.getInstance().debug('--createStatementPreExec');\n    // create a statement context for a pre-exec statement\n    const context = createContextPreExec(options, services, connectionConfig);\n    if (options.sqlText &&\n        (Util.isPutCommand(options.sqlText) || Util.isGetCommand(options.sqlText))) {\n        if (options.fileStream) {\n            context.fileStream = options.fileStream;\n            options.fileStream = null;\n        }\n        return createFileStatementPreExec(options, context, services, connectionConfig);\n    }\n    const numBinds = countBinding(context.binds);\n    Logger.getInstance().debug('numBinds = %d', numBinds);\n    let threshold = Parameters.getValue(Parameters.names.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD);\n    if (connectionConfig.getbindThreshold()) {\n        threshold = connectionConfig.getbindThreshold();\n    }\n    Logger.getInstance().debug('threshold = %d', threshold);\n    // check array binding,\n    if (numBinds > threshold) {\n        return createStageStatementpreExec(options, context, services, connectionConfig);\n    }\n    else {\n        return createRowStatementPreExec(options, context, services, connectionConfig);\n    }\n};\n/**\n * Executes a statement and returns a statement object that can be used to fetch\n * its result.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createRowStatementPreExec(statementOptions, statementContext, services, connectionConfig) {\n    // set the statement type\n    statementContext.type = statementTypes.ROW_PRE_EXEC;\n    return new RowStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n/**\n * Creates a statement object that can be used to fetch the result of a\n * previously executed statement.\n *\n * @param {Object} statementOptions\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nexports.createStatementPostExec = function (statementOptions, services, connectionConfig) {\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(statementOptions), ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_OPTIONS);\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(statementOptions), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_OPTIONS);\n    // check for missing query id\n    Errors.checkArgumentExists(Util.exists(statementOptions.queryId), ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID);\n    // check for invalid query id\n    Errors.checkArgumentValid(Util.isString(statementOptions.queryId), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID);\n    // check for invalid complete callback\n    const complete = statementOptions.complete;\n    if (Util.exists(complete)) {\n        Errors.checkArgumentValid(Util.isFunction(complete), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_COMPLETE);\n    }\n    // check for invalid streamResult\n    if (Util.exists(statementOptions.streamResult)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.streamResult), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT);\n    }\n    // check for invalid fetchAsString\n    const fetchAsString = statementOptions.fetchAsString;\n    if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING);\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n    }\n    const rowMode = statementOptions.rowMode;\n    if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n    }\n    const cwd = statementOptions.cwd;\n    if (Util.exists(cwd)) {\n        Errors.checkArgumentValid(Util.isString(cwd), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_CWD);\n    }\n    // validate non-user-specified arguments\n    Errors.assertInternal(Util.isObject(services));\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    // create a statement context\n    const statementContext = createStatementContext();\n    statementContext.queryId = statementOptions.queryId;\n    statementContext.complete = complete;\n    statementContext.streamResult = statementOptions.streamResult;\n    statementContext.fetchAsString = statementOptions.fetchAsString;\n    statementContext.multiResultIds = statementOptions.multiResultIds;\n    statementContext.multiSqlTexts = statementOptions.multiSqlTexts;\n    statementContext.multiCurId = statementOptions.multiCurId;\n    statementContext.rowMode = statementOptions.rowMode;\n    statementContext.cwd = statementOptions.cwd;\n    statementContext.sqlText = statementOptions.sqlText;\n    // set the statement type\n    statementContext.type =\n        statementContext.type === statementTypes.ROW_PRE_EXEC\n            ? statementTypes.ROW_POST_EXEC\n            : statementTypes.FILE_POST_EXEC;\n    return new StatementPostExec(statementOptions, statementContext, services, connectionConfig);\n};\n/**\n * Creates a new statement context object.\n *\n * @returns {Object}\n */\nfunction createStatementContext() {\n    return new EventEmitter();\n}\n/**\n * Creates a statement object that can be used to execute a PUT or GET file\n * operation.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createFileStatementPreExec(statementOptions, statementContext, services, connectionConfig) {\n    // set the statement type\n    statementContext.type = statementTypes.FILE_PRE_EXEC;\n    return new FileStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n/**\n * Creates a statement object that can be used to execute stage binding\n * operation.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createStageStatementpreExec(statementOptions, statementContext, services, connectionConfig) {\n    return new StageBindingStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n/**\n * Creates a statement context object for pre-exec statement.\n *\n * @param {Object} statementOptions\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createContextPreExec(statementOptions, services, connectionConfig) {\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(statementOptions), ErrorCodes.ERR_CONN_EXEC_STMT_MISSING_OPTIONS);\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(statementOptions), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_OPTIONS);\n    if (!Util.exists(statementOptions.requestId)) {\n        // check for missing sql text\n        Errors.checkArgumentExists(Util.exists(statementOptions.sqlText), ErrorCodes.ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT);\n        // check for invalid sql text\n        Errors.checkArgumentValid(Util.isString(statementOptions.sqlText), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT);\n    }\n    // check for invalid complete callback\n    const complete = statementOptions.complete;\n    if (Util.exists(complete)) {\n        Errors.checkArgumentValid(Util.isFunction(complete), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_COMPLETE);\n    }\n    // check for invalid streamResult\n    if (Util.exists(statementOptions.streamResult)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.streamResult), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT);\n    }\n    // check for invalid fetchAsString\n    const fetchAsString = statementOptions.fetchAsString;\n    if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING);\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n    }\n    // check for invalid requestId\n    if (Util.exists(statementOptions.requestId)) {\n        Errors.checkArgumentValid(Util.isString(statementOptions.requestId), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID);\n    }\n    // if parameters are specified, make sure the specified value is an object\n    if (Util.exists(statementOptions.parameters)) {\n        Errors.checkArgumentValid(Util.isObject(statementOptions.parameters), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_PARAMETERS);\n    }\n    // if binds are specified\n    const binds = statementOptions.binds;\n    if (Util.exists(binds)) {\n        // make sure the specified value is an array\n        Errors.checkArgumentValid(Util.isArray(binds), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_BINDS);\n        // make sure everything in the binds array is stringifiable\n        for (let index = 0, length = binds.length; index < length; index++) {\n            Errors.checkArgumentValid(JSON.stringify(binds[index]) !== undefined, ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES, binds[index]);\n        }\n    }\n    // if an internal option is specified, make sure it's boolean\n    if (Util.exists(statementOptions.internal)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.internal), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_INTERNAL);\n    }\n    const rowMode = statementOptions.rowMode;\n    if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n    }\n    // if an asyncExec flag is specified, make sure it's boolean\n    if (Util.exists(statementOptions.asyncExec)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.asyncExec), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC);\n    }\n    // if a describeOnly flag is specified, make sure it's boolean\n    if (Util.exists(statementOptions.describeOnly)) {\n        Errors.checkArgumentValid(Util.isBoolean(statementOptions.describeOnly), ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY);\n    }\n    // create a statement context\n    const statementContext = createStatementContext();\n    statementContext.sqlText = statementOptions.sqlText;\n    statementContext.complete = complete;\n    statementContext.streamResult = statementOptions.streamResult;\n    statementContext.fetchAsString = statementOptions.fetchAsString;\n    statementContext.multiResultIds = statementOptions.multiResultIds;\n    statementContext.multiCurId = statementOptions.multiCurId;\n    statementContext.rowMode = statementOptions.rowMode;\n    statementContext.asyncExec = statementOptions.asyncExec;\n    // if a binds array is specified, add it to the statement context\n    if (Util.exists(statementOptions.binds)) {\n        statementContext.binds = statementOptions.binds;\n    }\n    // if parameters are specified, add them to the statement context\n    if (Util.exists(statementOptions.parameters)) {\n        statementContext.parameters = statementOptions.parameters;\n    }\n    // if the internal flag is specified, add it to the statement context\n    if (Util.exists(statementOptions.internal)) {\n        statementContext.internal = statementOptions.internal;\n    }\n    if (Util.exists(statementOptions.cwd)) {\n        statementContext.cwd = statementOptions.cwd;\n    }\n    // if the describeOnly flag is specified, add it to the statement context\n    if (Util.exists(statementOptions.describeOnly)) {\n        statementContext.describeOnly = statementOptions.describeOnly;\n    }\n    // validate non-user-specified arguments\n    Errors.assertInternal(Util.isObject(services));\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    if (connectionConfig.queryTag) {\n        statementOptions.parameters = statementOptions.parameters || {};\n        statementOptions.parameters.QUERY_TAG = connectionConfig.queryTag;\n    }\n    // use request id passed by user\n    if (statementOptions.requestId) {\n        statementContext.requestId = statementOptions.requestId;\n        statementContext.resubmitRequest = true;\n    }\n    else {\n        // use a random uuid for the statement request id\n        statementContext.requestId = uuidv4();\n    }\n    return statementContext;\n}\n/**\n * Creates a new BaseStatement.\n *\n * @param statementOptions\n * @param context\n * @param services\n * @param connectionConfig\n * @constructor\n */\nfunction BaseStatement(statementOptions, context, services, connectionConfig) {\n    // call super\n    EventEmitter.call(this);\n    // validate input\n    Errors.assertInternal(Util.isObject(statementOptions));\n    Errors.assertInternal(Util.isObject(context));\n    context.services = services;\n    context.connectionConfig = connectionConfig;\n    context.isFetchingResult = true;\n    context.rowMode = statementOptions.rowMode || connectionConfig.getRowMode();\n    // TODO: add the parameters map to the statement context\n    const statement = this;\n    /**\n     * Returns this statement's SQL text.\n     *\n     * @returns {String}\n     */\n    this.getSqlText = function () {\n        return context.sqlText;\n    };\n    /**\n     * Returns the current status of this statement.\n     *\n     * @returns {String}\n     */\n    this.getStatus = function () {\n        return context.isFetchingResult ? states.FETCHING : states.COMPLETE;\n    };\n    /**\n     * Returns the columns produced by this statement.\n     *\n     * @returns {Object[]}\n     */\n    this.getColumns = function () {\n        return context.result ? context.result.getColumns() : undefined;\n    };\n    /**\n     * Given a column identifier, returns the corresponding column. The column\n     * identifier can be either the column name (String) or the column index\n     * (Number). If a column is specified and there is more than one column with\n     * that name, the first column with the specified name will be returned.\n     *\n     * @param {String | Number} columnIdentifier\n     *\n     * @returns {Object}\n     */\n    this.getColumn = function (columnIdentifier) {\n        return context.result ? context.result.getColumn(columnIdentifier) : undefined;\n    };\n    /**\n     * Returns the number of rows returned by this statement.\n     *\n     * @returns {Number}\n     */\n    this.getNumRows = function () {\n        return context.result ? context.result.getReturnedRows() : undefined;\n    };\n    /**\n     * Returns the number of rows updated by this statement.\n     *\n     * @returns {Number}\n     */\n    this.getNumUpdatedRows = function () {\n        return context.result ? context.result.getNumUpdatedRows() : undefined;\n    };\n    /**\n     * Returns an object that contains information about the values of the\n     * current warehouse, current database, etc., when this statement finished\n     * executing.\n     *\n     * @returns {Object}\n     */\n    this.getSessionState = function () {\n        return context.result ? context.result.getSessionState() : undefined;\n    };\n    /**\n     * Returns the request id that was used when the statement was issued.\n     *\n     * @returns {String}\n     */\n    this.getRequestId = function () {\n        return context.requestId;\n    };\n    /**\n     * Returns the query id generated by the server for this statement.\n     * If the statement is still executing and we don't know the query id\n     * yet, this method will return undefined.\n     *\n     * Should use getQueryId instead.\n     * @deprecated\n     * @returns {String}\n     */\n    this.getStatementId = function () {\n        return context.queryId;\n    };\n    /**\n     * Returns the query id generated by the server for this statement.\n     * If the statement is still executing and we don't know the query id\n     * yet, this method will return undefined.\n     *\n     * @returns {String}\n     */\n    this.getQueryId = function () {\n        return context.queryId;\n    };\n    /**\n     * Cancels this statement if possible.\n     *\n     * @param {Function} [callback]\n     */\n    this.cancel = function (callback) {\n        sendCancelStatement(context, statement, callback);\n    };\n    //Integration Testing purpose.\n    this.getQueryContextCacheSize = function () {\n        return services.sf.getQueryContextCacheSize();\n    };\n    this.getQueryContextDTOSize = function () {\n        return services.sf.getQueryContextDTO().entries.length;\n    };\n    /**\n     * Issues a request to get the statement result again.\n     *\n     * @param {Function} callback\n     */\n    context.refresh = function (callback) {\n        // pick the appropriate function to get the result based on whether we\n        // have the query id or request id (we should have at least one)\n        const sendRequestFn = context.queryId ? sendRequestPostExec : sendRequestPreExec;\n        // the current result error might be transient,\n        // so issue a request to get the result again\n        sendRequestFn(context, function (err, body) {\n            // refresh the result\n            context.onStatementRequestComp(err, body);\n            // if a callback was specified, invoke it\n            if (Util.isFunction(callback)) {\n                callback(context);\n            }\n        });\n    };\n    /**\n     * Called when the statement request is complete.\n     *\n     * @param err\n     * @param body\n     */\n    context.onStatementRequestComp = async function (err, body) {\n        // if we already have a result or a result error, we invoked the complete\n        // callback once, so don't invoke it again\n        const suppressComplete = context.result || context.resultError;\n        // clear the previous result error\n        context.resultError = null;\n        // if there was no error, call the success function\n        if (!err) {\n            await context.onStatementRequestSucc(body);\n        }\n        else {\n            // save the error\n            context.resultError = err;\n            // if we don't have a query id and we got a response from GS, extract\n            // the query id from the data\n            if (!context.queryId && Errors.isOperationFailedError(err) && err.data) {\n                context.queryId = err.data.queryId;\n            }\n        }\n        // we're no longer fetching the result\n        context.isFetchingResult = false;\n        if (!suppressComplete) {\n            // emit a complete event\n            context.emit('statement-complete', Errors.externalize(err), statement);\n            // if a complete function was specified, invoke it\n            if (Util.exists(context.complete)) {\n                invokeStatementComplete(statement, context);\n            }\n        }\n        else {\n            Logger.getInstance().debug('refreshed result of statement with %s', context.requestId\n                ? Util.format('request id = %s', context.requestId)\n                : Util.format('query id = %s', context.queryId));\n        }\n    };\n    /**\n     * Called when the statement request is successful. Subclasses must provide\n     * their own implementation.\n     */\n    context.onStatementRequestSucc = function () { };\n}\nUtil.inherits(BaseStatement, EventEmitter);\n/**\n * Invokes the statement complete callback.\n *\n * @param {Object} statement\n * @param {Object} context\n */\nfunction invokeStatementComplete(statement, context) {\n    // find out if the result will be streamed;\n    // if a value is not specified, get it from the connection\n    let streamResult = context.streamResult;\n    if (!Util.exists(streamResult)) {\n        streamResult = context.connectionConfig.getStreamResult();\n    }\n    // if the result will be streamed later or in asyncExec mode,\n    // invoke the complete callback right away\n    if (streamResult) {\n        context.complete(Errors.externalize(context.resultError), statement);\n    }\n    else if (context.asyncExec) {\n        // return the result object with the query ID inside.\n        context.complete(null, statement, context.result);\n    }\n    else {\n        process.nextTick(function () {\n            // aggregate all the rows into an array and pass this\n            // array to the complete callback as the last argument\n            const rows = [];\n            statement\n                .streamRows()\n                .on('readable', function () {\n                // read only when data is available\n                let row;\n                // while there are rows available to read, push row to results array\n                while ((row = this.read()) !== null) {\n                    rows.push(row);\n                }\n            })\n                .on('end', function () {\n                context.complete(null, statement, rows);\n            })\n                .on('error', function (err) {\n                context.complete(Errors.externalize(err), statement);\n            });\n        });\n    }\n}\n/**\n * Creates a new RowStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction RowStatementPreExec(statementOptions, context, services, connectionConfig) {\n    Logger.getInstance().debug('RowStatementPreExec');\n    // call super\n    BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersRow();\n    /**\n     * Called when the request to get the statement result is successful.\n     *\n     * @param {Object} body\n     */\n    context.onStatementRequestSucc = createOnStatementRequestSuccRow(this, context);\n    /**\n     * Fetches the rows in this statement's result and invokes the each()\n     * callback on each row. If start and end values are specified, the each()\n     * callback will only be invoked on rows in the specified range.\n     *\n     * @param {Object} options\n     */\n    this.fetchRows = createFnFetchRows(this, context);\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    // send a request to execute the statement\n    sendRequestPreExec(context, context.onStatementRequestComp);\n}\nUtil.inherits(RowStatementPreExec, BaseStatement);\n/**\n * Creates a function that can be used by row statements to process the response\n * when the request is successful.\n *\n * @param statement\n * @param context\n * @returns {Function}\n */\nfunction createOnStatementRequestSuccRow(statement, context) {\n    return function (body) {\n        // if we don't already have a result\n        if (!context.result) {\n            if (body.code === queryCodes.QUERY_IN_PROGRESS_ASYNC) {\n                context.result = {\n                    queryId: body.data.queryId,\n                };\n                return;\n            }\n            if (body.data.resultIds != null && body.data.resultIds.length > 0) {\n                //multi statements\n                this._resultIds = body.data.resultIds.split(',');\n                context.isMulti = true;\n                context.multiResultIds = this._resultIds;\n                context.multiSqlTexts = context.sqlText.split(';');\n                context.multiCurId = 0;\n                context.sqlText = context.multiSqlTexts[context.multiCurId];\n                context.queryId = this._resultIds[context.multiCurId];\n                exports.createStatementPostExec(context, context.services, context.connectionConfig);\n            }\n            else {\n                // build a result from the response\n                context.result = new Result({\n                    response: body,\n                    statement: statement,\n                    services: context.services,\n                    connectionConfig: context.connectionConfig,\n                    rowMode: context.rowMode,\n                });\n                context.queryId = context.result.getQueryId();\n                this.services.sf.deserializeQueryContext(context.result.getQueryContext());\n            }\n        }\n        else {\n            // refresh the existing result\n            context.result.refresh(body);\n        }\n        if (context.isMulti == null || context.isMulti === false) {\n            // only update the parameters if the statement isn't a post-exec statement\n            if (context.type !== statementTypes.ROW_POST_EXEC ||\n                context.type !== statementTypes.FILE_POST_EXEC) {\n                Parameters.update(context.result.getParametersArray());\n            }\n        }\n    };\n}\n/**\n * Creates a new FileStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction FileStatementPreExec(statementOptions, context, services, connectionConfig) {\n    // call super\n    BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersFile();\n    /**\n     * Called when the statement request is successful.\n     *\n     * @param {Object} body\n     */\n    context.onStatementRequestSucc = async function (body) {\n        await executeFileTransferRequest(context, body, this);\n    };\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    this.hasNext = hasNextResult(this, context);\n    this.NextResult = createNextReuslt(this, context);\n    /**\n     * Returns the file metadata generated by the statement.\n     *\n     * @returns {Object}\n     */\n    this.getFileMetadata = function () {\n        return context.fileMetadata;\n    };\n    // send a request to execute the file statement\n    sendRequestPreExec(context, context.onStatementRequestComp);\n}\nasync function executeFileTransferRequest(context, body, statement, fileTransferAgent) {\n    context.fileMetadata = body;\n    const fta = fileTransferAgent ?? new FileTransferAgent(context);\n    await fta.execute();\n    try {\n        // build a result from the response\n        const result = fta.result();\n        // init result and meta\n        body.data = {\n            rowset: result.rowset,\n            returned: result.rowset.length,\n            rowtype: result.rowtype,\n            parameters: [],\n        };\n        context.result = new Result({\n            response: body,\n            statement: statement,\n            services: context.services,\n            connectionConfig: context.connectionConfig,\n        });\n    }\n    catch (error) {\n        context.resultError = error;\n    }\n}\nexports.executeFileTransferRequest = executeFileTransferRequest;\nUtil.inherits(FileStatementPreExec, BaseStatement);\n/**\n * Creates a new StageBindingStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction StageBindingStatementPreExec(statementOptions, context, services, connectionConfig) {\n    // call super\n    BaseStatement.apply(this, arguments);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersFile();\n    /**\n     * Called when the statement request is successful. Subclasses must provide\n     * their own implementation.\n     */\n    context.onStatementRequestSucc = function () {\n        //do nothing\n    };\n    /**\n     * Called the stage binding request\n     *\n     * @param {Object} options\n     * @param {Object} context\n     * @param {Object} services\n     * @param {Object} connectionConfig\n     */\n    this.StageBindingRequest = async function (options, context, services, connectionConfig) {\n        try {\n            const bindUploaderRequestId = uuidv4();\n            const bind = new Bind.BindUploader(options, services, connectionConfig, bindUploaderRequestId);\n            context.bindStage = Bind.GetStageName(bindUploaderRequestId);\n            await bind.Upload(context.binds);\n            return createRowStatementPreExec(options, context, services, connectionConfig);\n        }\n        catch (error) {\n            context.bindStage = null;\n            return createRowStatementPreExec(options, context, services, connectionConfig);\n        }\n    };\n    /**\n     * Fetches the rows in this statement's result and invokes the each()\n     * callback on each row. If start and end values are specified, the each()\n     * callback will only be invoked on rows in the specified range.\n     *\n     * @param {Object} options\n     */\n    this.fetchRows = createFnFetchRows(this, context);\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    this.hasNext = hasNextResult(this, context);\n    this.NextResult = createNextReuslt(this, context);\n    this.StageBindingRequest(statementOptions, context, services, connectionConfig);\n}\nUtil.inherits(StageBindingStatementPreExec, BaseStatement);\n/**\n * Creates a new StatementPostExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction StatementPostExec(statementOptions, context, services, connectionConfig) {\n    // call super\n    BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n    // add the result request headers to the context\n    context.resultRequestHeaders = buildResultRequestHeadersRow();\n    /**\n     * Called when the statement request is successful.\n     *\n     * @param {Object} body\n     */\n    context.onStatementRequestSucc = createOnStatementRequestSuccRow(this, context);\n    /**\n     * Fetches the rows in this statement's result and invokes the each()\n     * callback on each row. If startIndex and endIndex values are specified, the\n     * each() callback will only be invoked on rows in the requested range. The\n     * end() callback will be invoked when either all the requested rows have been\n     * successfully processed, or if an error was encountered while trying to\n     * fetch the requested rows.\n     *\n     * @param {Object} options\n     */\n    this.fetchRows = createFnFetchRows(this, context);\n    /**\n     * Streams the rows in this statement's result. If start and end values are\n     * specified, only rows in the specified range are streamed.\n     *\n     * @param {Object} options\n     */\n    this.streamRows = createFnStreamRows(this, context);\n    this.hasNext = hasNextResult(this, context);\n    this.NextResult = createNextReuslt(this, context);\n    // send a request to fetch the result\n    sendRequestPostExec(context, context.onStatementRequestComp);\n}\nUtil.inherits(StatementPostExec, BaseStatement);\n/**\n * Creates a function that fetches the rows in a statement's result and\n * invokes the each() callback on each row. If start and end values are\n * specified, the each() callback will only be invoked on rows in the\n * specified range.\n *\n * @param statement\n * @param context\n */\nfunction createFnFetchRows(statement, context) {\n    return function (options) {\n        // check for missing options\n        Errors.checkArgumentExists(Util.exists(options), ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_OPTIONS);\n        // check for invalid options\n        Errors.checkArgumentValid(Util.isObject(options), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS);\n        // check for missing each()\n        Errors.checkArgumentExists(Util.exists(options.each), ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_EACH);\n        // check for invalid each()\n        Errors.checkArgumentValid(Util.isFunction(options.each), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_EACH);\n        // check for missing end()\n        Errors.checkArgumentExists(Util.exists(options.end), ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_END);\n        // check for invalid end()\n        Errors.checkArgumentValid(Util.isFunction(options.end), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_END);\n        const rowMode = options.rowMode;\n        if (Util.exists(rowMode)) {\n            RowMode.checkRowModeValid(rowMode);\n        }\n        // if we're still trying to fetch the result, create an error of our own\n        // and invoke the end() callback\n        if (context.isFetchingResult) {\n            process.nextTick(function () {\n                options.end(Errors.createClientError(ErrorCodes.ERR_STMT_FETCH_ROWS_FETCHING_RESULT).externalize(), statement);\n            });\n        }\n        else if (context.resultError) {\n            // if there was an error the last time we tried to get the result\n            // if we have a fatal error, end the fetch rows operation since we're not\n            // going to be able to get any rows, either because the statement failed\n            // or because the result's been purged\n            if (Errors.isOperationFailedError(context.resultError) && context.resultError.sqlState) {\n                process.nextTick(function () {\n                    endFetchRows(options, statement, context);\n                });\n            }\n            else {\n                context.refresh(function () {\n                    // if there was no error, fetch rows from the result\n                    if (!context.resultError) {\n                        fetchRowsFromResult(options, statement, context);\n                    }\n                    else {\n                        // give up because it's unlikely we'll succeed if we retry again\n                        endFetchRows(options, statement, context);\n                    }\n                });\n            }\n        }\n        else {\n            fetchRowsFromResult(options, statement, context);\n        }\n    };\n}\n/**\n * Creates a function that streams the rows in a statement's result. If start\n * and end values are specified, only rows in the specified range are streamed.\n *\n * @param statement\n * @param context\n */\nfunction createFnStreamRows(statement, context) {\n    return function (options) {\n        // if some options are specified\n        if (Util.exists(options)) {\n            // check for invalid options\n            Errors.checkArgumentValid(Util.isObject(options), ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS);\n            // check for invalid start\n            if (Util.exists(options.start)) {\n                Errors.checkArgumentValid(Util.isNumber(options.start), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_START);\n            }\n            // check for invalid end\n            if (Util.exists(options.end)) {\n                Errors.checkArgumentValid(Util.isNumber(options.end), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_END);\n            }\n            // check for invalid fetchAsString\n            const fetchAsString = options.fetchAsString;\n            if (Util.exists(fetchAsString)) {\n                // check that the value is an array\n                Errors.checkArgumentValid(Util.isArray(fetchAsString), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING);\n                // check that all the array elements are valid\n                const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n                Errors.checkArgumentValid(invalidValueIndex === -1, ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES, JSON.stringify(fetchAsString[invalidValueIndex]));\n            }\n            const rowMode = context.rowMode;\n            if (Util.exists(rowMode)) {\n                RowMode.checkRowModeValid(rowMode);\n            }\n        }\n        return new RowStream(statement, context, options);\n    };\n}\n/**\n * Ends the fetchRows() operation.\n *\n * @param {Object} options the options passed to fetchRows().\n * @param {Object} statement\n * @param {Object} context\n */\nfunction endFetchRows(options, statement, context) {\n    options.end(Errors.externalize(context.resultError), statement);\n}\n/**\n * Fetches rows from the statement's result.\n *\n * @param {Object} options the options passed to fetchRows().\n * @param {Object} statement\n * @param {Object} context\n */\nfunction fetchRowsFromResult(options, statement, context) {\n    let numInterrupts = 0;\n    // forward to the result to get a FetchRowsOperation object\n    const operation = context.result.fetchRows(options);\n    // subscribe to the operation's 'complete' event\n    operation.on('complete', function (err, continueCallback) {\n        // we want to retry if the error is retryable and the\n        // result stream hasn't been closed too many times\n        if (Errors.isLargeResultSetError(err) &&\n            err.response &&\n            err.response.statusCode === 403 &&\n            numInterrupts < context.connectionConfig.getResultStreamInterrupts()) {\n            // increment the interrupt counter\n            numInterrupts++;\n            // issue a request to fetch the result again\n            sendRequestPostExec(context, function (err, body) {\n                // refresh the result\n                context.onStatementRequestComp(err, body);\n                // if there was no error, continue from where we got interrupted\n                if (!err) {\n                    continueCallback();\n                }\n            });\n        }\n        else {\n            endFetchRows(options, statement, context);\n        }\n    });\n}\n/**\n * Issues a request to cancel a statement.\n *\n * @param {Object} statementContext\n * @param {Object} statement\n * @param {Function} callback\n */\nfunction sendCancelStatement(statementContext, statement, callback) {\n    let url;\n    let json;\n    // use different rest endpoints based on whether the query id is available\n    if (statementContext.queryId) {\n        url = '/queries/' + statementContext.queryId + '/abort-request';\n    }\n    else {\n        url = '/queries/v1/abort-request';\n        json = {\n            requestId: statementContext.requestId,\n        };\n    }\n    // issue a request to cancel the statement\n    statementContext.services.sf.request({\n        method: 'POST',\n        url: url,\n        json: json,\n        callback: function (err) {\n            // if a callback was specified, invoke it\n            if (Util.isFunction(callback)) {\n                callback(Errors.externalize(err), statement);\n            }\n        },\n    });\n}\n/**\n * Issues a request to get the result of a statement that hasn't been previously\n * executed.\n *\n * @param statementContext\n * @param onResultAvailable\n */\nfunction sendRequestPreExec(statementContext, onResultAvailable) {\n    // get the request headers\n    const headers = statementContext.resultRequestHeaders;\n    // build the basic json for the request\n    const json = {\n        disableOfflineChunks: false,\n    };\n    json.sqlText = statementContext.sqlText;\n    if (statementContext.resubmitRequest && !json.sqlText) {\n        json.sqlText =\n            `SELECT 'Error retrieving query results for request id: ${statementContext.requestId}, ` +\n                \"please use RESULT_SCAN instead' AS ErrorMessage;\";\n    }\n    Logger.getInstance().debug('context.bindStage=' + statementContext.bindStage);\n    if (Util.exists(statementContext.bindStage)) {\n        json.bindStage = statementContext.bindStage;\n    }\n    else if (Util.exists(statementContext.binds)) {\n        // if binds are specified, build a binds map and include it in the request\n        json.bindings = buildBindsMap(statementContext.binds);\n    }\n    // include statement parameters if a value was specified\n    if (Util.exists(statementContext.parameters)) {\n        json.parameters = statementContext.parameters;\n        Logger.getInstance().debug('context.parameters=' + statementContext.parameters);\n    }\n    // include the internal flag if a value was specified\n    if (Util.exists(statementContext.internal)) {\n        json.isInternal = statementContext.internal;\n    }\n    if (!statementContext.disableQueryContextCache) {\n        json.queryContextDTO = statementContext.services.sf.getQueryContextDTO();\n    }\n    // include the asyncExec flag if a value was specified\n    if (Util.exists(statementContext.asyncExec)) {\n        json.asyncExec = statementContext.asyncExec;\n    }\n    // include describeOnly flag if a value was specified\n    if (Util.exists(statementContext.describeOnly)) {\n        json.describeOnly = statementContext.describeOnly;\n    }\n    // use the snowflake service to issue the request\n    sendSfRequest(statementContext, {\n        method: 'POST',\n        headers: headers,\n        url: Url.format({\n            pathname: '/queries/v1/query-request',\n            search: QueryString.stringify({\n                requestId: statementContext.requestId,\n            }),\n        }),\n        json: json,\n        callback: buildResultRequestCallback(statementContext, headers, onResultAvailable),\n    }, true);\n}\nthis.sendRequest = function (statementContext, onResultAvailable) {\n    // get the request headers\n    const headers = statementContext.resultRequestHeaders;\n    // build the basic json for the request\n    const json = {\n        disableOfflineChunks: false,\n        sqlText: statementContext.sqlText,\n    };\n    Logger.getInstance().debug('context.bindStage=' + statementContext.bindStage);\n    if (Util.exists(statementContext.bindStage)) {\n        json.bindStage = statementContext.bindStage;\n    }\n    else if (Util.exists(statementContext.binds)) {\n        // if binds are specified, build a binds map and include it in the request\n        json.bindings = buildBindsMap(statementContext.binds);\n    }\n    // include statement parameters if a value was specified\n    if (Util.exists(statementContext.parameters)) {\n        json.parameters = statementContext.parameters;\n    }\n    // include the internal flag if a value was specified\n    if (Util.exists(statementContext.internal)) {\n        json.isInternal = statementContext.internal;\n    }\n    if (!statementContext.disableQueryContextCache) {\n        json.queryContextDTO = statementContext.services.sf.getQueryContextDTO();\n    }\n    let options = {\n        method: 'POST',\n        headers: headers,\n        url: Url.format({\n            pathname: '/queries/v1/query-request',\n            search: QueryString.stringify({\n                requestId: statementContext.requestId,\n            }),\n        }),\n        json: json,\n        callback: buildResultRequestCallback(statementContext, headers, onResultAvailable),\n    };\n    const sf = statementContext.services.sf;\n    // clone the options\n    options = Util.apply({}, options);\n    return new Promise((resolve) => {\n        resolve(sf.postAsync(options));\n    });\n};\n/**\n * Converts a bind variables array to a map that can be included in the\n * POST-body when issuing a pre-exec statement request.\n *\n * @param bindsArray\n *\n * @returns {Object}\n */\nfunction buildBindsMap(bindsArray) {\n    const bindsMap = {};\n    const isArrayBinding = bindsArray.length > 0 && Util.isArray(bindsArray[0]);\n    const singleArray = isArrayBinding ? bindsArray[0] : bindsArray;\n    for (let index = 0, length = singleArray.length; index < length; index++) {\n        let value = singleArray[index];\n        // pick the appropriate logical data type based on the bind value\n        let type;\n        if (Util.isBoolean(value)) {\n            type = 'BOOLEAN';\n        }\n        else if (Util.isObject(value) || Util.isArray(value)) {\n            type = 'VARIANT';\n        }\n        else if (Util.isNumber(value)) {\n            if (Number(value) === value && value % 1 === 0) {\n                // if value is integer\n                type = 'FIXED';\n            }\n            else {\n                type = 'REAL';\n            }\n        }\n        else {\n            type = 'TEXT';\n        }\n        // convert non-null values to a string if necessary; we don't convert null\n        // because the client might want to run something like\n        //   sql text = update t set name = :1 where id = 1;, binds = [null]\n        // and converting null to a string would result in us executing\n        //   sql text = update t set name = 'null' where id = 1;\n        // instead of\n        //   sql text = update t set name = null where id = 1;\n        if (!isArrayBinding) {\n            if (value !== null && !Util.isString(value)) {\n                if (value instanceof Date) {\n                    value = value.toJSON();\n                }\n                else {\n                    value = JSON.stringify(value);\n                }\n            }\n        }\n        else {\n            value = [];\n            for (let rowIndex = 0; rowIndex < bindsArray.length; rowIndex++) {\n                let value0 = bindsArray[rowIndex][index];\n                if (value0 !== null && !Util.isString(value0)) {\n                    if (value0 instanceof Date) {\n                        value0 = value0.toJSON();\n                    }\n                    else {\n                        value0 = JSON.stringify(value0);\n                    }\n                }\n                value.push(value0);\n            }\n        }\n        // add an entry for the bind variable to the map\n        bindsMap[index + 1] = {\n            type: type,\n            value: value,\n        };\n    }\n    return bindsMap;\n}\n/**\n * Issues a request to get the result of a statement that has been previously\n * executed.\n *\n * @param statementContext\n * @param onResultAvailable\n */\nfunction sendRequestPostExec(statementContext, onResultAvailable) {\n    // get the request headers\n    const headers = statementContext.resultRequestHeaders;\n    // use the snowflake service to issue the request\n    sendSfRequest(statementContext, {\n        method: 'GET',\n        headers: headers,\n        url: Url.format({\n            pathname: '/queries/' + statementContext.queryId + '/result',\n            search: QueryString.stringify({\n                disableOfflineChunks: false,\n            }),\n        }),\n        callback: buildResultRequestCallback(statementContext, headers, onResultAvailable),\n    });\n}\n/**\n * Issues a statement-related request using the Snowflake service.\n *\n * @param {Object} statementContext the statement context.\n * @param {Object} options the request options.\n * @param {Boolean} [appendQueryParamOnRetry] whether retry=true should be\n *   appended to the url if the request is retried.\n */\nfunction sendSfRequest(statementContext, options, appendQueryParamOnRetry) {\n    const sf = statementContext.services.sf;\n    const connectionConfig = statementContext.connectionConfig;\n    // clone the options\n    options = Util.apply({}, options);\n    // get the original url and callback\n    const urlOrig = options.url;\n    const callbackOrig = options.callback;\n    let numRetries = 0;\n    const maxNumRetries = connectionConfig.getRetrySfMaxNumRetries();\n    let sleep = connectionConfig.getRetrySfStartingSleepTime();\n    let lastStatusCodeForRetry;\n    // create a function to send the request\n    const sendRequest = function () {\n        // if this is a retry and a query parameter should be appended to the url on\n        // retry, update the url\n        if (numRetries > 0 && appendQueryParamOnRetry) {\n            const retryOption = {\n                url: urlOrig,\n                retryCount: numRetries,\n                retryReason: lastStatusCodeForRetry,\n                includeRetryReason: connectionConfig.getIncludeRetryReason(),\n            };\n            options.url = Util.url.appendRetryParam(retryOption);\n        }\n        sf.request(options);\n    };\n    // replace the specified callback with a new one that retries\n    options.callback = async function (err) {\n        // if we haven't exceeded the maximum number of retries yet and the server\n        // came back with a retryable error code\n        if (numRetries < maxNumRetries &&\n            err &&\n            Util.isRetryableHttpError(err.response, false)) {\n            // increment the retry count\n            numRetries++;\n            lastStatusCodeForRetry = err.response ? err.response.statusCode : 0;\n            // use exponential backoff with decorrelated jitter to compute the\n            // next sleep time.\n            const cap = connectionConfig.getRetrySfMaxSleepTime();\n            sleep = Util.nextSleepTime(1, cap, sleep);\n            Logger.getInstance().debug('Retrying statement with request id %s, retry count = %s', statementContext.requestId, numRetries);\n            // wait the appropriate amount of time before retrying the request\n            setTimeout(sendRequest, sleep * 1000);\n        }\n        else {\n            // invoke the original callback\n            await callbackOrig.apply(this, arguments);\n        }\n    };\n    // issue the request\n    sendRequest();\n}\n/**\n * Builds a callback for use in an exec-statement or fetch-result request.\n *\n * @param statementContext\n * @param headers\n * @param onResultAvailable\n *\n * @returns {Function}\n */\nfunction buildResultRequestCallback(statementContext, headers, onResultAvailable) {\n    const callback = async function (err, body) {\n        if (err) {\n            await onResultAvailable.call(null, err, null);\n        }\n        else {\n            // extract the query id from the response and save it\n            statementContext.queryId = body.data.queryId;\n            // if the result is not ready yet, extract the result url from the response\n            // and issue a GET request to try to fetch the result again unless asyncExec is enabled.\n            if (body &&\n                (body.code === queryCodes.QUERY_IN_PROGRESS ||\n                    body.code === queryCodes.QUERY_IN_PROGRESS_ASYNC)) {\n                if (statementContext.asyncExec) {\n                    await onResultAvailable.call(null, err, body);\n                    return;\n                }\n                // extract the result url from the response and try to get the result\n                // again\n                sendSfRequest(statementContext, {\n                    method: 'GET',\n                    headers: headers,\n                    url: body.data.getResultUrl,\n                    callback: callback,\n                });\n            }\n            else {\n                await onResultAvailable.call(null, err, body);\n            }\n        }\n    };\n    return callback;\n}\n/**\n * Builds the request headers for a row statement request.\n *\n * @returns {Object}\n */\nfunction buildResultRequestHeadersRow() {\n    return {\n        Accept: 'application/snowflake',\n    };\n}\n/**\n * Builds the request headers for a file statement request.\n *\n * @returns {Object}\n */\nfunction buildResultRequestHeadersFile() {\n    return {\n        Accept: 'application/json',\n    };\n}\n/**\n * Count number of bindings\n *\n * @returns {int}\n */\nfunction countBinding(binds) {\n    if (!Util.isArray(binds)) {\n        return 0;\n    }\n    Logger.getInstance().debug('-- binds.length= %d', binds.length);\n    let count = 0;\n    for (let index = 0; index < binds.length; index++) {\n        if (binds[index] != null && Util.isArray(binds[index])) {\n            count += binds[index].length;\n        }\n    }\n    return count;\n}\nfunction hasNextResult(statement, context) {\n    return function () {\n        return context.multiResultIds != null && context.multiCurId + 1 < context.multiResultIds.length;\n    };\n}\nfunction createNextReuslt(statement, context) {\n    return function () {\n        if (hasNextResult(statement, context)) {\n            context.multiCurId++;\n            context.queryId = context.multiResultIds[context.multiCurId];\n            context.sqlText = context.multiSqlTexts[context.multiCurId];\n            exports.createStatementPostExec(context, context.services, context.connectionConfig);\n        }\n    };\n}\n//# sourceMappingURL=statement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25uZWN0aW9uL3N0YXRlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMseUZBQU07QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxnR0FBaUI7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsd0dBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyxvQkFBb0IsMklBQTBDO0FBQzlELDBCQUEwQixtQkFBTyxDQUFDLDBJQUE0QztBQUM5RSxhQUFhLG1CQUFPLENBQUMsZ0dBQWlCO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLGtHQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkJBQTJCO0FBQ2pHLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Nvbm5lY3Rpb24vc3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyB2NDogdXVpZHY0IH0gPSByZXF1aXJlKCd1dWlkJyk7XG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IFF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBSZXN1bHQgPSByZXF1aXJlKCcuL3Jlc3VsdC9yZXN1bHQnKTtcbmNvbnN0IFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuLi9wYXJhbWV0ZXJzJyk7XG5jb25zdCBSb3dTdHJlYW0gPSByZXF1aXJlKCcuL3Jlc3VsdC9yb3dfc3RyZWFtJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IE5hdGl2ZVR5cGVzID0gcmVxdWlyZSgnLi9yZXN1bHQvZGF0YV90eXBlcycpLk5hdGl2ZVR5cGVzO1xuY29uc3QgRmlsZVRyYW5zZmVyQWdlbnQgPSByZXF1aXJlKCcuLi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfdHJhbnNmZXJfYWdlbnQnKTtcbmNvbnN0IEJpbmQgPSByZXF1aXJlKCcuL2JpbmRfdXBsb2FkZXInKTtcbmNvbnN0IFJvd01vZGUgPSByZXF1aXJlKCcuLy4uL2NvbnN0YW50cy9yb3dfbW9kZScpO1xuY29uc3Qgc3RhdGVzID0ge1xuICAgIEZFVENISU5HOiAnZmV0Y2hpbmcnLFxuICAgIENPTVBMRVRFOiAnY29tcGxldGUnLFxufTtcbmNvbnN0IHN0YXRlbWVudFR5cGVzID0ge1xuICAgIFJPV19QUkVfRVhFQzogJ1JPV19QUkVfRVhFQycsXG4gICAgUk9XX1BPU1RfRVhFQzogJ1JPV19QT1NUX0VYRUMnLFxuICAgIEZJTEVfUFJFX0VYRUM6ICdGSUxFX1BSRV9FWEVDJyxcbiAgICBGSUxFX1BPU1RfRVhFQzogJ0ZJTEVfUE9TVF9FWEVDJyxcbn07XG5jb25zdCBxdWVyeUNvZGVzID0ge1xuICAgIFFVRVJZX0lOX1BST0dSRVNTOiAnMzMzMzMzJywgLy8gR1MgY29kZTogdGhlIHF1ZXJ5IGlzIGluIHByb2dyZXNzXG4gICAgUVVFUllfSU5fUFJPR1JFU1NfQVNZTkM6ICczMzMzMzQnLCAvLyBHUyBjb2RlOiB0aGUgcXVlcnkgaXMgZGV0YWNoZWRcbn07XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBjcmVhdGUgYSBzdGF0ZW1lbnQgY29udGV4dCBmb3IgYSBwcmUtZXhlYyBzdGF0ZW1lbnRcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dFByZUV4ZWMob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgIGNvbnRleHQudHlwZSA9IHN0YXRlbWVudFR5cGVzLkZJTEVfUFJFX0VYRUM7XG4gICAgLy8gQSBoYWNraXNoIHdheSB0byBleHRlbmQgY29udGV4dCB3aXRoIEJhc2VTdGF0ZW1lbnRcbiAgICBuZXcgQmFzZVN0YXRlbWVudChvcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gICAgY29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycyA9IGJ1aWxkUmVzdWx0UmVxdWVzdEhlYWRlcnNGaWxlKCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59O1xuLyoqXG4gKiBDaGVjayB0aGUgdHlwZSBvZiBjb21tYW5kIHRvIGV4ZWN1dGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmNyZWF0ZVN0YXRlbWVudFByZUV4ZWMgPSBmdW5jdGlvbiAob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnLS1jcmVhdGVTdGF0ZW1lbnRQcmVFeGVjJyk7XG4gICAgLy8gY3JlYXRlIGEgc3RhdGVtZW50IGNvbnRleHQgZm9yIGEgcHJlLWV4ZWMgc3RhdGVtZW50XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvbnRleHRQcmVFeGVjKG9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICBpZiAob3B0aW9ucy5zcWxUZXh0ICYmXG4gICAgICAgIChVdGlsLmlzUHV0Q29tbWFuZChvcHRpb25zLnNxbFRleHQpIHx8IFV0aWwuaXNHZXRDb21tYW5kKG9wdGlvbnMuc3FsVGV4dCkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmZpbGVTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsZVN0cmVhbSA9IG9wdGlvbnMuZmlsZVN0cmVhbTtcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsZVN0cmVhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbGVTdGF0ZW1lbnRQcmVFeGVjKG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgbnVtQmluZHMgPSBjb3VudEJpbmRpbmcoY29udGV4dC5iaW5kcyk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ251bUJpbmRzID0gJWQnLCBudW1CaW5kcyk7XG4gICAgbGV0IHRocmVzaG9sZCA9IFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU1RBR0VfQVJSQVlfQklORElOR19USFJFU0hPTEQpO1xuICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmdldGJpbmRUaHJlc2hvbGQoKSkge1xuICAgICAgICB0aHJlc2hvbGQgPSBjb25uZWN0aW9uQ29uZmlnLmdldGJpbmRUaHJlc2hvbGQoKTtcbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3RocmVzaG9sZCA9ICVkJywgdGhyZXNob2xkKTtcbiAgICAvLyBjaGVjayBhcnJheSBiaW5kaW5nLFxuICAgIGlmIChudW1CaW5kcyA+IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3RhZ2VTdGF0ZW1lbnRwcmVFeGVjKG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9XG59O1xuLyoqXG4gKiBFeGVjdXRlcyBhIHN0YXRlbWVudCBhbmQgcmV0dXJucyBhIHN0YXRlbWVudCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBmZXRjaFxuICogaXRzIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudENvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gc2V0IHRoZSBzdGF0ZW1lbnQgdHlwZVxuICAgIHN0YXRlbWVudENvbnRleHQudHlwZSA9IHN0YXRlbWVudFR5cGVzLlJPV19QUkVfRVhFQztcbiAgICByZXR1cm4gbmV3IFJvd1N0YXRlbWVudFByZUV4ZWMoc3RhdGVtZW50T3B0aW9ucywgc3RhdGVtZW50Q29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhdGVtZW50IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGZldGNoIHRoZSByZXN1bHQgb2YgYVxuICogcHJldmlvdXNseSBleGVjdXRlZCBzdGF0ZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmNyZWF0ZVN0YXRlbWVudFBvc3RFeGVjID0gZnVuY3Rpb24gKHN0YXRlbWVudE9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX09QVElPTlMpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3Qoc3RhdGVtZW50T3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfT1BUSU9OUyk7XG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcXVlcnkgaWRcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnF1ZXJ5SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX1FVRVJZX0lEKTtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBxdWVyeSBpZFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhzdGF0ZW1lbnRPcHRpb25zLnF1ZXJ5SWQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1FVRVJZX0lEKTtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBjb21wbGV0ZSBjYWxsYmFja1xuICAgIGNvbnN0IGNvbXBsZXRlID0gc3RhdGVtZW50T3B0aW9ucy5jb21wbGV0ZTtcbiAgICBpZiAoVXRpbC5leGlzdHMoY29tcGxldGUpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKGNvbXBsZXRlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9DT01QTEVURSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHN0cmVhbVJlc3VsdFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfU1RSRUFNX1JFU1VMVCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZldGNoQXNTdHJpbmdcbiAgICBjb25zdCBmZXRjaEFzU3RyaW5nID0gc3RhdGVtZW50T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIGlmIChVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNBcnJheShmZXRjaEFzU3RyaW5nKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgICAgIGNvbnN0IGludmFsaWRWYWx1ZUluZGV4ID0gTmF0aXZlVHlwZXMuZmluZEludmFsaWRWYWx1ZShmZXRjaEFzU3RyaW5nKTtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChpbnZhbGlkVmFsdWVJbmRleCA9PT0gLTEsIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUywgSlNPTi5zdHJpbmdpZnkoZmV0Y2hBc1N0cmluZ1tpbnZhbGlkVmFsdWVJbmRleF0pKTtcbiAgICB9XG4gICAgY29uc3Qgcm93TW9kZSA9IHN0YXRlbWVudE9wdGlvbnMucm93TW9kZTtcbiAgICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICAgICAgUm93TW9kZS5jaGVja1Jvd01vZGVWYWxpZChyb3dNb2RlKTtcbiAgICB9XG4gICAgY29uc3QgY3dkID0gc3RhdGVtZW50T3B0aW9ucy5jd2Q7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGN3ZCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGN3ZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfQ1dEKTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgbm9uLXVzZXItc3BlY2lmaWVkIGFyZ3VtZW50c1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KHNlcnZpY2VzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29ubmVjdGlvbkNvbmZpZykpO1xuICAgIC8vIGNyZWF0ZSBhIHN0YXRlbWVudCBjb250ZXh0XG4gICAgY29uc3Qgc3RhdGVtZW50Q29udGV4dCA9IGNyZWF0ZVN0YXRlbWVudENvbnRleHQoKTtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQgPSBzdGF0ZW1lbnRPcHRpb25zLnF1ZXJ5SWQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIHN0YXRlbWVudENvbnRleHQuc3RyZWFtUmVzdWx0ID0gc3RhdGVtZW50T3B0aW9ucy5zdHJlYW1SZXN1bHQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5mZXRjaEFzU3RyaW5nID0gc3RhdGVtZW50T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgIHN0YXRlbWVudENvbnRleHQubXVsdGlSZXN1bHRJZHMgPSBzdGF0ZW1lbnRPcHRpb25zLm11bHRpUmVzdWx0SWRzO1xuICAgIHN0YXRlbWVudENvbnRleHQubXVsdGlTcWxUZXh0cyA9IHN0YXRlbWVudE9wdGlvbnMubXVsdGlTcWxUZXh0cztcbiAgICBzdGF0ZW1lbnRDb250ZXh0Lm11bHRpQ3VySWQgPSBzdGF0ZW1lbnRPcHRpb25zLm11bHRpQ3VySWQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5yb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlO1xuICAgIHN0YXRlbWVudENvbnRleHQuY3dkID0gc3RhdGVtZW50T3B0aW9ucy5jd2Q7XG4gICAgc3RhdGVtZW50Q29udGV4dC5zcWxUZXh0ID0gc3RhdGVtZW50T3B0aW9ucy5zcWxUZXh0O1xuICAgIC8vIHNldCB0aGUgc3RhdGVtZW50IHR5cGVcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnR5cGUgPVxuICAgICAgICBzdGF0ZW1lbnRDb250ZXh0LnR5cGUgPT09IHN0YXRlbWVudFR5cGVzLlJPV19QUkVfRVhFQ1xuICAgICAgICAgICAgPyBzdGF0ZW1lbnRUeXBlcy5ST1dfUE9TVF9FWEVDXG4gICAgICAgICAgICA6IHN0YXRlbWVudFR5cGVzLkZJTEVfUE9TVF9FWEVDO1xuICAgIHJldHVybiBuZXcgU3RhdGVtZW50UG9zdEV4ZWMoc3RhdGVtZW50T3B0aW9ucywgc3RhdGVtZW50Q29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzdGF0ZW1lbnQgY29udGV4dCBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGVtZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50RW1pdHRlcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhdGVtZW50IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgYSBQVVQgb3IgR0VUIGZpbGVcbiAqIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudENvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVGaWxlU3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIC8vIHNldCB0aGUgc3RhdGVtZW50IHR5cGVcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnR5cGUgPSBzdGF0ZW1lbnRUeXBlcy5GSUxFX1BSRV9FWEVDO1xuICAgIHJldHVybiBuZXcgRmlsZVN0YXRlbWVudFByZUV4ZWMoc3RhdGVtZW50T3B0aW9ucywgc3RhdGVtZW50Q29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhdGVtZW50IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgc3RhZ2UgYmluZGluZ1xuICogb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YWdlU3RhdGVtZW50cHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBuZXcgU3RhZ2VCaW5kaW5nU3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZW1lbnQgY29udGV4dCBvYmplY3QgZm9yIHByZS1leGVjIHN0YXRlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9NSVNTSU5HX09QVElPTlMpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3Qoc3RhdGVtZW50T3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfT1BUSU9OUyk7XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnJlcXVlc3RJZCkpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgc3FsIHRleHRcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5zcWxUZXh0KSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfTUlTU0lOR19TUUxfVEVYVCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHNxbCB0ZXh0XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhzdGF0ZW1lbnRPcHRpb25zLnNxbFRleHQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NRTF9URVhUKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgY29tcGxldGUgY2FsbGJhY2tcbiAgICBjb25zdCBjb21wbGV0ZSA9IHN0YXRlbWVudE9wdGlvbnMuY29tcGxldGU7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNvbXBsZXRlKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNGdW5jdGlvbihjb21wbGV0ZSksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQ09NUExFVEUpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBzdHJlYW1SZXN1bHRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5zdHJlYW1SZXN1bHQpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oc3RhdGVtZW50T3B0aW9ucy5zdHJlYW1SZXN1bHQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NUUkVBTV9SRVNVTFQpO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBmZXRjaEFzU3RyaW5nXG4gICAgY29uc3QgZmV0Y2hBc1N0cmluZyA9IHN0YXRlbWVudE9wdGlvbnMuZmV0Y2hBc1N0cmluZztcbiAgICBpZiAoVXRpbC5leGlzdHMoZmV0Y2hBc1N0cmluZykpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQXJyYXkoZmV0Y2hBc1N0cmluZyksIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HKTtcbiAgICAgICAgLy8gY2hlY2sgdGhhdCBhbGwgdGhlIGFycmF5IGVsZW1lbnRzIGFyZSB2YWxpZFxuICAgICAgICBjb25zdCBpbnZhbGlkVmFsdWVJbmRleCA9IE5hdGl2ZVR5cGVzLmZpbmRJbnZhbGlkVmFsdWUoZmV0Y2hBc1N0cmluZyk7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoaW52YWxpZFZhbHVlSW5kZXggPT09IC0xLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVMsIEpTT04uc3RyaW5naWZ5KGZldGNoQXNTdHJpbmdbaW52YWxpZFZhbHVlSW5kZXhdKSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHJlcXVlc3RJZFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnJlcXVlc3RJZCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHN0YXRlbWVudE9wdGlvbnMucmVxdWVzdElkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9SRVFVRVNUX0lEKTtcbiAgICB9XG4gICAgLy8gaWYgcGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkLCBtYWtlIHN1cmUgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3Qoc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9QQVJBTUVURVJTKTtcbiAgICB9XG4gICAgLy8gaWYgYmluZHMgYXJlIHNwZWNpZmllZFxuICAgIGNvbnN0IGJpbmRzID0gc3RhdGVtZW50T3B0aW9ucy5iaW5kcztcbiAgICBpZiAoVXRpbC5leGlzdHMoYmluZHMpKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0FycmF5KGJpbmRzKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EUyk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGluIHRoZSBiaW5kcyBhcnJheSBpcyBzdHJpbmdpZmlhYmxlXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gYmluZHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChKU09OLnN0cmluZ2lmeShiaW5kc1tpbmRleF0pICE9PSB1bmRlZmluZWQsIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQklORF9WQUxVRVMsIGJpbmRzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgYW4gaW50ZXJuYWwgb3B0aW9uIGlzIHNwZWNpZmllZCwgbWFrZSBzdXJlIGl0J3MgYm9vbGVhblxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmludGVybmFsKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0YXRlbWVudE9wdGlvbnMuaW50ZXJuYWwpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0lOVEVSTkFMKTtcbiAgICB9XG4gICAgY29uc3Qgcm93TW9kZSA9IHN0YXRlbWVudE9wdGlvbnMucm93TW9kZTtcbiAgICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICAgICAgUm93TW9kZS5jaGVja1Jvd01vZGVWYWxpZChyb3dNb2RlKTtcbiAgICB9XG4gICAgLy8gaWYgYW4gYXN5bmNFeGVjIGZsYWcgaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmUgaXQncyBib29sZWFuXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuYXN5bmNFeGVjKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0YXRlbWVudE9wdGlvbnMuYXN5bmNFeGVjKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9BU1lOQ19FWEVDKTtcbiAgICB9XG4gICAgLy8gaWYgYSBkZXNjcmliZU9ubHkgZmxhZyBpcyBzcGVjaWZpZWQsIG1ha2Ugc3VyZSBpdCdzIGJvb2xlYW5cbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5kZXNjcmliZU9ubHkpKSB7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oc3RhdGVtZW50T3B0aW9ucy5kZXNjcmliZU9ubHkpLCBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0RFU0NSSUJFX09OTFkpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYSBzdGF0ZW1lbnQgY29udGV4dFxuICAgIGNvbnN0IHN0YXRlbWVudENvbnRleHQgPSBjcmVhdGVTdGF0ZW1lbnRDb250ZXh0KCk7XG4gICAgc3RhdGVtZW50Q29udGV4dC5zcWxUZXh0ID0gc3RhdGVtZW50T3B0aW9ucy5zcWxUZXh0O1xuICAgIHN0YXRlbWVudENvbnRleHQuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnN0cmVhbVJlc3VsdCA9IHN0YXRlbWVudE9wdGlvbnMuc3RyZWFtUmVzdWx0O1xuICAgIHN0YXRlbWVudENvbnRleHQuZmV0Y2hBc1N0cmluZyA9IHN0YXRlbWVudE9wdGlvbnMuZmV0Y2hBc1N0cmluZztcbiAgICBzdGF0ZW1lbnRDb250ZXh0Lm11bHRpUmVzdWx0SWRzID0gc3RhdGVtZW50T3B0aW9ucy5tdWx0aVJlc3VsdElkcztcbiAgICBzdGF0ZW1lbnRDb250ZXh0Lm11bHRpQ3VySWQgPSBzdGF0ZW1lbnRPcHRpb25zLm11bHRpQ3VySWQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5yb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlO1xuICAgIHN0YXRlbWVudENvbnRleHQuYXN5bmNFeGVjID0gc3RhdGVtZW50T3B0aW9ucy5hc3luY0V4ZWM7XG4gICAgLy8gaWYgYSBiaW5kcyBhcnJheSBpcyBzcGVjaWZpZWQsIGFkZCBpdCB0byB0aGUgc3RhdGVtZW50IGNvbnRleHRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5iaW5kcykpIHtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5iaW5kcyA9IHN0YXRlbWVudE9wdGlvbnMuYmluZHM7XG4gICAgfVxuICAgIC8vIGlmIHBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCwgYWRkIHRoZW0gdG8gdGhlIHN0YXRlbWVudCBjb250ZXh0XG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMucGFyYW1ldGVycykpIHtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzID0gc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgaW50ZXJuYWwgZmxhZyBpcyBzcGVjaWZpZWQsIGFkZCBpdCB0byB0aGUgc3RhdGVtZW50IGNvbnRleHRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5pbnRlcm5hbCkpIHtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5pbnRlcm5hbCA9IHN0YXRlbWVudE9wdGlvbnMuaW50ZXJuYWw7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmN3ZCkpIHtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5jd2QgPSBzdGF0ZW1lbnRPcHRpb25zLmN3ZDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGRlc2NyaWJlT25seSBmbGFnIGlzIHNwZWNpZmllZCwgYWRkIGl0IHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmRlc2NyaWJlT25seSkpIHtcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5kZXNjcmliZU9ubHkgPSBzdGF0ZW1lbnRPcHRpb25zLmRlc2NyaWJlT25seTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgbm9uLXVzZXItc3BlY2lmaWVkIGFyZ3VtZW50c1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KHNlcnZpY2VzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29ubmVjdGlvbkNvbmZpZykpO1xuICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLnF1ZXJ5VGFnKSB7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMucGFyYW1ldGVycyA9IHN0YXRlbWVudE9wdGlvbnMucGFyYW1ldGVycyB8fCB7fTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzLlFVRVJZX1RBRyA9IGNvbm5lY3Rpb25Db25maWcucXVlcnlUYWc7XG4gICAgfVxuICAgIC8vIHVzZSByZXF1ZXN0IGlkIHBhc3NlZCBieSB1c2VyXG4gICAgaWYgKHN0YXRlbWVudE9wdGlvbnMucmVxdWVzdElkKSB7XG4gICAgICAgIHN0YXRlbWVudENvbnRleHQucmVxdWVzdElkID0gc3RhdGVtZW50T3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgICAgIHN0YXRlbWVudENvbnRleHQucmVzdWJtaXRSZXF1ZXN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHVzZSBhIHJhbmRvbSB1dWlkIGZvciB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaWRcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWQgPSB1dWlkdjQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudENvbnRleHQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQmFzZVN0YXRlbWVudC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBzZXJ2aWNlc1xuICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCYXNlU3RhdGVtZW50KHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gY2FsbCBzdXBlclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qoc3RhdGVtZW50T3B0aW9ucykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbnRleHQpKTtcbiAgICBjb250ZXh0LnNlcnZpY2VzID0gc2VydmljZXM7XG4gICAgY29udGV4dC5jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICBjb250ZXh0LmlzRmV0Y2hpbmdSZXN1bHQgPSB0cnVlO1xuICAgIGNvbnRleHQucm93TW9kZSA9IHN0YXRlbWVudE9wdGlvbnMucm93TW9kZSB8fCBjb25uZWN0aW9uQ29uZmlnLmdldFJvd01vZGUoKTtcbiAgICAvLyBUT0RPOiBhZGQgdGhlIHBhcmFtZXRlcnMgbWFwIHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICAgIGNvbnN0IHN0YXRlbWVudCA9IHRoaXM7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIHN0YXRlbWVudCdzIFNRTCB0ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFNxbFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnNxbFRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGlzIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmlzRmV0Y2hpbmdSZXN1bHQgPyBzdGF0ZXMuRkVUQ0hJTkcgOiBzdGF0ZXMuQ09NUExFVEU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb2x1bW5zIHByb2R1Y2VkIGJ5IHRoaXMgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0Q29sdW1ucygpIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb2x1bW4gaWRlbnRpZmllciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBjb2x1bW4uIFRoZSBjb2x1bW5cbiAgICAgKiBpZGVudGlmaWVyIGNhbiBiZSBlaXRoZXIgdGhlIGNvbHVtbiBuYW1lIChTdHJpbmcpIG9yIHRoZSBjb2x1bW4gaW5kZXhcbiAgICAgKiAoTnVtYmVyKS4gSWYgYSBjb2x1bW4gaXMgc3BlY2lmaWVkIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbHVtbiB3aXRoXG4gICAgICogdGhhdCBuYW1lLCB0aGUgZmlyc3QgY29sdW1uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gY29sdW1uSWRlbnRpZmllclxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW5JZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlc3VsdCA/IGNvbnRleHQucmVzdWx0LmdldENvbHVtbihjb2x1bW5JZGVudGlmaWVyKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIHJldHVybmVkIGJ5IHRoaXMgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldE51bVJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlc3VsdCA/IGNvbnRleHQucmVzdWx0LmdldFJldHVybmVkUm93cygpIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZCBieSB0aGlzIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXROdW1VcGRhdGVkUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0TnVtVXBkYXRlZFJvd3MoKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZhbHVlcyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IHdhcmVob3VzZSwgY3VycmVudCBkYXRhYmFzZSwgZXRjLiwgd2hlbiB0aGlzIHN0YXRlbWVudCBmaW5pc2hlZFxuICAgICAqIGV4ZWN1dGluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRTZXNzaW9uU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlc3VsdCA/IGNvbnRleHQucmVzdWx0LmdldFNlc3Npb25TdGF0ZSgpIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVxdWVzdCBpZCB0aGF0IHdhcyB1c2VkIHdoZW4gdGhlIHN0YXRlbWVudCB3YXMgaXNzdWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVxdWVzdElkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcXVlcnkgaWQgZ2VuZXJhdGVkIGJ5IHRoZSBzZXJ2ZXIgZm9yIHRoaXMgc3RhdGVtZW50LlxuICAgICAqIElmIHRoZSBzdGF0ZW1lbnQgaXMgc3RpbGwgZXhlY3V0aW5nIGFuZCB3ZSBkb24ndCBrbm93IHRoZSBxdWVyeSBpZFxuICAgICAqIHlldCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogU2hvdWxkIHVzZSBnZXRRdWVyeUlkIGluc3RlYWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RhdGVtZW50SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5SWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBxdWVyeSBpZCBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBmb3IgdGhpcyBzdGF0ZW1lbnQuXG4gICAgICogSWYgdGhlIHN0YXRlbWVudCBpcyBzdGlsbCBleGVjdXRpbmcgYW5kIHdlIGRvbid0IGtub3cgdGhlIHF1ZXJ5IGlkXG4gICAgICogeWV0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UXVlcnlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlJZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhpcyBzdGF0ZW1lbnQgaWYgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICovXG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgc2VuZENhbmNlbFN0YXRlbWVudChjb250ZXh0LCBzdGF0ZW1lbnQsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vSW50ZWdyYXRpb24gVGVzdGluZyBwdXJwb3NlLlxuICAgIHRoaXMuZ2V0UXVlcnlDb250ZXh0Q2FjaGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0UXVlcnlDb250ZXh0Q2FjaGVTaXplKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFF1ZXJ5Q29udGV4dERUT1NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy5zZi5nZXRRdWVyeUNvbnRleHREVE8oKS5lbnRyaWVzLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzc3VlcyBhIHJlcXVlc3QgdG8gZ2V0IHRoZSBzdGF0ZW1lbnQgcmVzdWx0IGFnYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjb250ZXh0LnJlZnJlc2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcGljayB0aGUgYXBwcm9wcmlhdGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSByZXN1bHQgYmFzZWQgb24gd2hldGhlciB3ZVxuICAgICAgICAvLyBoYXZlIHRoZSBxdWVyeSBpZCBvciByZXF1ZXN0IGlkICh3ZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUpXG4gICAgICAgIGNvbnN0IHNlbmRSZXF1ZXN0Rm4gPSBjb250ZXh0LnF1ZXJ5SWQgPyBzZW5kUmVxdWVzdFBvc3RFeGVjIDogc2VuZFJlcXVlc3RQcmVFeGVjO1xuICAgICAgICAvLyB0aGUgY3VycmVudCByZXN1bHQgZXJyb3IgbWlnaHQgYmUgdHJhbnNpZW50LFxuICAgICAgICAvLyBzbyBpc3N1ZSBhIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW5cbiAgICAgICAgc2VuZFJlcXVlc3RGbihjb250ZXh0LCBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0Q29tcChlcnIsIGJvZHkpO1xuICAgICAgICAgICAgLy8gaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVyclxuICAgICAqIEBwYXJhbSBib2R5XG4gICAgICovXG4gICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wID0gYXN5bmMgZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSByZXN1bHQgb3IgYSByZXN1bHQgZXJyb3IsIHdlIGludm9rZWQgdGhlIGNvbXBsZXRlXG4gICAgICAgIC8vIGNhbGxiYWNrIG9uY2UsIHNvIGRvbid0IGludm9rZSBpdCBhZ2FpblxuICAgICAgICBjb25zdCBzdXBwcmVzc0NvbXBsZXRlID0gY29udGV4dC5yZXN1bHQgfHwgY29udGV4dC5yZXN1bHRFcnJvcjtcbiAgICAgICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHJlc3VsdCBlcnJvclxuICAgICAgICBjb250ZXh0LnJlc3VsdEVycm9yID0gbnVsbDtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIGVycm9yLCBjYWxsIHRoZSBzdWNjZXNzIGZ1bmN0aW9uXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdFN1Y2MoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzYXZlIHRoZSBlcnJvclxuICAgICAgICAgICAgY29udGV4dC5yZXN1bHRFcnJvciA9IGVycjtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBxdWVyeSBpZCBhbmQgd2UgZ290IGEgcmVzcG9uc2UgZnJvbSBHUywgZXh0cmFjdFxuICAgICAgICAgICAgLy8gdGhlIHF1ZXJ5IGlkIGZyb20gdGhlIGRhdGFcbiAgICAgICAgICAgIGlmICghY29udGV4dC5xdWVyeUlkICYmIEVycm9ycy5pc09wZXJhdGlvbkZhaWxlZEVycm9yKGVycikgJiYgZXJyLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnF1ZXJ5SWQgPSBlcnIuZGF0YS5xdWVyeUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdlJ3JlIG5vIGxvbmdlciBmZXRjaGluZyB0aGUgcmVzdWx0XG4gICAgICAgIGNvbnRleHQuaXNGZXRjaGluZ1Jlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXN1cHByZXNzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIC8vIGVtaXQgYSBjb21wbGV0ZSBldmVudFxuICAgICAgICAgICAgY29udGV4dC5lbWl0KCdzdGF0ZW1lbnQtY29tcGxldGUnLCBFcnJvcnMuZXh0ZXJuYWxpemUoZXJyKSwgc3RhdGVtZW50KTtcbiAgICAgICAgICAgIC8vIGlmIGEgY29tcGxldGUgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCwgaW52b2tlIGl0XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoY29udGV4dC5jb21wbGV0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VTdGF0ZW1lbnRDb21wbGV0ZShzdGF0ZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3JlZnJlc2hlZCByZXN1bHQgb2Ygc3RhdGVtZW50IHdpdGggJXMnLCBjb250ZXh0LnJlcXVlc3RJZFxuICAgICAgICAgICAgICAgID8gVXRpbC5mb3JtYXQoJ3JlcXVlc3QgaWQgPSAlcycsIGNvbnRleHQucmVxdWVzdElkKVxuICAgICAgICAgICAgICAgIDogVXRpbC5mb3JtYXQoJ3F1ZXJ5IGlkID0gJXMnLCBjb250ZXh0LnF1ZXJ5SWQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuIFN1YmNsYXNzZXMgbXVzdCBwcm92aWRlXG4gICAgICogdGhlaXIgb3duIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyA9IGZ1bmN0aW9uICgpIHsgfTtcbn1cblV0aWwuaW5oZXJpdHMoQmFzZVN0YXRlbWVudCwgRXZlbnRFbWl0dGVyKTtcbi8qKlxuICogSW52b2tlcyB0aGUgc3RhdGVtZW50IGNvbXBsZXRlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGludm9rZVN0YXRlbWVudENvbXBsZXRlKHN0YXRlbWVudCwgY29udGV4dCkge1xuICAgIC8vIGZpbmQgb3V0IGlmIHRoZSByZXN1bHQgd2lsbCBiZSBzdHJlYW1lZDtcbiAgICAvLyBpZiBhIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQsIGdldCBpdCBmcm9tIHRoZSBjb25uZWN0aW9uXG4gICAgbGV0IHN0cmVhbVJlc3VsdCA9IGNvbnRleHQuc3RyZWFtUmVzdWx0O1xuICAgIGlmICghVXRpbC5leGlzdHMoc3RyZWFtUmVzdWx0KSkge1xuICAgICAgICBzdHJlYW1SZXN1bHQgPSBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0U3RyZWFtUmVzdWx0KCk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXN1bHQgd2lsbCBiZSBzdHJlYW1lZCBsYXRlciBvciBpbiBhc3luY0V4ZWMgbW9kZSxcbiAgICAvLyBpbnZva2UgdGhlIGNvbXBsZXRlIGNhbGxiYWNrIHJpZ2h0IGF3YXlcbiAgICBpZiAoc3RyZWFtUmVzdWx0KSB7XG4gICAgICAgIGNvbnRleHQuY29tcGxldGUoRXJyb3JzLmV4dGVybmFsaXplKGNvbnRleHQucmVzdWx0RXJyb3IpLCBzdGF0ZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0LmFzeW5jRXhlYykge1xuICAgICAgICAvLyByZXR1cm4gdGhlIHJlc3VsdCBvYmplY3Qgd2l0aCB0aGUgcXVlcnkgSUQgaW5zaWRlLlxuICAgICAgICBjb250ZXh0LmNvbXBsZXRlKG51bGwsIHN0YXRlbWVudCwgY29udGV4dC5yZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBhZ2dyZWdhdGUgYWxsIHRoZSByb3dzIGludG8gYW4gYXJyYXkgYW5kIHBhc3MgdGhpc1xuICAgICAgICAgICAgLy8gYXJyYXkgdG8gdGhlIGNvbXBsZXRlIGNhbGxiYWNrIGFzIHRoZSBsYXN0IGFyZ3VtZW50XG4gICAgICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgICAgICBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAuc3RyZWFtUm93cygpXG4gICAgICAgICAgICAgICAgLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIG9ubHkgd2hlbiBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGxldCByb3c7XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgdGhlcmUgYXJlIHJvd3MgYXZhaWxhYmxlIHRvIHJlYWQsIHB1c2ggcm93IHRvIHJlc3VsdHMgYXJyYXlcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHJvdyA9IHRoaXMucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcGxldGUobnVsbCwgc3RhdGVtZW50LCByb3dzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbXBsZXRlKEVycm9ycy5leHRlcm5hbGl6ZShlcnIpLCBzdGF0ZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSb3dTdGF0ZW1lbnRQcmVFeGVjIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJvd1N0YXRlbWVudFByZUV4ZWMoc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUm93U3RhdGVtZW50UHJlRXhlYycpO1xuICAgIC8vIGNhbGwgc3VwZXJcbiAgICBCYXNlU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZ10pO1xuICAgIC8vIGFkZCB0aGUgcmVzdWx0IHJlcXVlc3QgaGVhZGVycyB0byB0aGUgY29udGV4dFxuICAgIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzUm93KCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgdG8gZ2V0IHRoZSBzdGF0ZW1lbnQgcmVzdWx0IGlzIHN1Y2Nlc3NmdWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgICAqL1xuICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyA9IGNyZWF0ZU9uU3RhdGVtZW50UmVxdWVzdFN1Y2NSb3codGhpcywgY29udGV4dCk7XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdCBhbmQgaW52b2tlcyB0aGUgZWFjaCgpXG4gICAgICogY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYWNoKClcbiAgICAgKiBjYWxsYmFjayB3aWxsIG9ubHkgYmUgaW52b2tlZCBvbiByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZmV0Y2hSb3dzID0gY3JlYXRlRm5GZXRjaFJvd3ModGhpcywgY29udGV4dCk7XG4gICAgLyoqXG4gICAgICogU3RyZWFtcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gICAgICogc3BlY2lmaWVkLCBvbmx5IHJvd3MgaW4gdGhlIHNwZWNpZmllZCByYW5nZSBhcmUgc3RyZWFtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtUm93cyA9IGNyZWF0ZUZuU3RyZWFtUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgICAvLyBzZW5kIGEgcmVxdWVzdCB0byBleGVjdXRlIHRoZSBzdGF0ZW1lbnRcbiAgICBzZW5kUmVxdWVzdFByZUV4ZWMoY29udGV4dCwgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wKTtcbn1cblV0aWwuaW5oZXJpdHMoUm93U3RhdGVtZW50UHJlRXhlYywgQmFzZVN0YXRlbWVudCk7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGJ5IHJvdyBzdGF0ZW1lbnRzIHRvIHByb2Nlc3MgdGhlIHJlc3BvbnNlXG4gKiB3aGVuIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudFxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlT25TdGF0ZW1lbnRSZXF1ZXN0U3VjY1JvdyhzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgcmVzdWx0XG4gICAgICAgIGlmICghY29udGV4dC5yZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChib2R5LmNvZGUgPT09IHF1ZXJ5Q29kZXMuUVVFUllfSU5fUFJPR1JFU1NfQVNZTkMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlJZDogYm9keS5kYXRhLnF1ZXJ5SWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9keS5kYXRhLnJlc3VsdElkcyAhPSBudWxsICYmIGJvZHkuZGF0YS5yZXN1bHRJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vbXVsdGkgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdElkcyA9IGJvZHkuZGF0YS5yZXN1bHRJZHMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmlzTXVsdGkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubXVsdGlSZXN1bHRJZHMgPSB0aGlzLl9yZXN1bHRJZHM7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tdWx0aVNxbFRleHRzID0gY29udGV4dC5zcWxUZXh0LnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tdWx0aUN1cklkID0gMDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNxbFRleHQgPSBjb250ZXh0Lm11bHRpU3FsVGV4dHNbY29udGV4dC5tdWx0aUN1cklkXTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnF1ZXJ5SWQgPSB0aGlzLl9yZXN1bHRJZHNbY29udGV4dC5tdWx0aUN1cklkXTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmNyZWF0ZVN0YXRlbWVudFBvc3RFeGVjKGNvbnRleHQsIGNvbnRleHQuc2VydmljZXMsIGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBidWlsZCBhIHJlc3VsdCBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdWx0ID0gbmV3IFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZXM6IGNvbnRleHQuc2VydmljZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWc6IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcm93TW9kZTogY29udGV4dC5yb3dNb2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucXVlcnlJZCA9IGNvbnRleHQucmVzdWx0LmdldFF1ZXJ5SWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2VzLnNmLmRlc2VyaWFsaXplUXVlcnlDb250ZXh0KGNvbnRleHQucmVzdWx0LmdldFF1ZXJ5Q29udGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGV4aXN0aW5nIHJlc3VsdFxuICAgICAgICAgICAgY29udGV4dC5yZXN1bHQucmVmcmVzaChib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5pc011bHRpID09IG51bGwgfHwgY29udGV4dC5pc011bHRpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdGhlIHBhcmFtZXRlcnMgaWYgdGhlIHN0YXRlbWVudCBpc24ndCBhIHBvc3QtZXhlYyBzdGF0ZW1lbnRcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgIT09IHN0YXRlbWVudFR5cGVzLlJPV19QT1NUX0VYRUMgfHxcbiAgICAgICAgICAgICAgICBjb250ZXh0LnR5cGUgIT09IHN0YXRlbWVudFR5cGVzLkZJTEVfUE9TVF9FWEVDKSB7XG4gICAgICAgICAgICAgICAgUGFyYW1ldGVycy51cGRhdGUoY29udGV4dC5yZXN1bHQuZ2V0UGFyYW1ldGVyc0FycmF5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBGaWxlU3RhdGVtZW50UHJlRXhlYyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlU3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIC8vIGNhbGwgc3VwZXJcbiAgICBCYXNlU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZ10pO1xuICAgIC8vIGFkZCB0aGUgcmVzdWx0IHJlcXVlc3QgaGVhZGVycyB0byB0aGUgY29udGV4dFxuICAgIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzRmlsZSgpO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBzdGF0ZW1lbnQgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICAgKi9cbiAgICBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdFN1Y2MgPSBhc3luYyBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICBhd2FpdCBleGVjdXRlRmlsZVRyYW5zZmVyUmVxdWVzdChjb250ZXh0LCBib2R5LCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0cmVhbXMgdGhlIHJvd3MgaW4gdGhpcyBzdGF0ZW1lbnQncyByZXN1bHQuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZVxuICAgICAqIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLnN0cmVhbVJvd3MgPSBjcmVhdGVGblN0cmVhbVJvd3ModGhpcywgY29udGV4dCk7XG4gICAgdGhpcy5oYXNOZXh0ID0gaGFzTmV4dFJlc3VsdCh0aGlzLCBjb250ZXh0KTtcbiAgICB0aGlzLk5leHRSZXN1bHQgPSBjcmVhdGVOZXh0UmV1c2x0KHRoaXMsIGNvbnRleHQpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbGUgbWV0YWRhdGEgZ2VuZXJhdGVkIGJ5IHRoZSBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RmlsZU1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5maWxlTWV0YWRhdGE7XG4gICAgfTtcbiAgICAvLyBzZW5kIGEgcmVxdWVzdCB0byBleGVjdXRlIHRoZSBmaWxlIHN0YXRlbWVudFxuICAgIHNlbmRSZXF1ZXN0UHJlRXhlYyhjb250ZXh0LCBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdENvbXApO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUZpbGVUcmFuc2ZlclJlcXVlc3QoY29udGV4dCwgYm9keSwgc3RhdGVtZW50LCBmaWxlVHJhbnNmZXJBZ2VudCkge1xuICAgIGNvbnRleHQuZmlsZU1ldGFkYXRhID0gYm9keTtcbiAgICBjb25zdCBmdGEgPSBmaWxlVHJhbnNmZXJBZ2VudCA/PyBuZXcgRmlsZVRyYW5zZmVyQWdlbnQoY29udGV4dCk7XG4gICAgYXdhaXQgZnRhLmV4ZWN1dGUoKTtcbiAgICB0cnkge1xuICAgICAgICAvLyBidWlsZCBhIHJlc3VsdCBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBmdGEucmVzdWx0KCk7XG4gICAgICAgIC8vIGluaXQgcmVzdWx0IGFuZCBtZXRhXG4gICAgICAgIGJvZHkuZGF0YSA9IHtcbiAgICAgICAgICAgIHJvd3NldDogcmVzdWx0LnJvd3NldCxcbiAgICAgICAgICAgIHJldHVybmVkOiByZXN1bHQucm93c2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIHJvd3R5cGU6IHJlc3VsdC5yb3d0eXBlLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQucmVzdWx0ID0gbmV3IFJlc3VsdCh7XG4gICAgICAgICAgICByZXNwb25zZTogYm9keSxcbiAgICAgICAgICAgIHN0YXRlbWVudDogc3RhdGVtZW50LFxuICAgICAgICAgICAgc2VydmljZXM6IGNvbnRleHQuc2VydmljZXMsXG4gICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udGV4dC5yZXN1bHRFcnJvciA9IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuZXhlY3V0ZUZpbGVUcmFuc2ZlclJlcXVlc3QgPSBleGVjdXRlRmlsZVRyYW5zZmVyUmVxdWVzdDtcblV0aWwuaW5oZXJpdHMoRmlsZVN0YXRlbWVudFByZUV4ZWMsIEJhc2VTdGF0ZW1lbnQpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN0YWdlQmluZGluZ1N0YXRlbWVudFByZUV4ZWMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhZ2VCaW5kaW5nU3RhdGVtZW50UHJlRXhlYyhzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIC8vIGNhbGwgc3VwZXJcbiAgICBCYXNlU3RhdGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gICAgY29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycyA9IGJ1aWxkUmVzdWx0UmVxdWVzdEhlYWRlcnNGaWxlKCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuIFN1YmNsYXNzZXMgbXVzdCBwcm92aWRlXG4gICAgICogdGhlaXIgb3duIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9kbyBub3RoaW5nXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdGhlIHN0YWdlIGJpbmRpbmcgcmVxdWVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gICAgICovXG4gICAgdGhpcy5TdGFnZUJpbmRpbmdSZXF1ZXN0ID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiaW5kVXBsb2FkZXJSZXF1ZXN0SWQgPSB1dWlkdjQoKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmQgPSBuZXcgQmluZC5CaW5kVXBsb2FkZXIob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcsIGJpbmRVcGxvYWRlclJlcXVlc3RJZCk7XG4gICAgICAgICAgICBjb250ZXh0LmJpbmRTdGFnZSA9IEJpbmQuR2V0U3RhZ2VOYW1lKGJpbmRVcGxvYWRlclJlcXVlc3RJZCk7XG4gICAgICAgICAgICBhd2FpdCBiaW5kLlVwbG9hZChjb250ZXh0LmJpbmRzKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmluZFN0YWdlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdCBhbmQgaW52b2tlcyB0aGUgZWFjaCgpXG4gICAgICogY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYWNoKClcbiAgICAgKiBjYWxsYmFjayB3aWxsIG9ubHkgYmUgaW52b2tlZCBvbiByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZmV0Y2hSb3dzID0gY3JlYXRlRm5GZXRjaFJvd3ModGhpcywgY29udGV4dCk7XG4gICAgLyoqXG4gICAgICogU3RyZWFtcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gICAgICogc3BlY2lmaWVkLCBvbmx5IHJvd3MgaW4gdGhlIHNwZWNpZmllZCByYW5nZSBhcmUgc3RyZWFtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtUm93cyA9IGNyZWF0ZUZuU3RyZWFtUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgICB0aGlzLmhhc05leHQgPSBoYXNOZXh0UmVzdWx0KHRoaXMsIGNvbnRleHQpO1xuICAgIHRoaXMuTmV4dFJlc3VsdCA9IGNyZWF0ZU5leHRSZXVzbHQodGhpcywgY29udGV4dCk7XG4gICAgdGhpcy5TdGFnZUJpbmRpbmdSZXF1ZXN0KHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbn1cblV0aWwuaW5oZXJpdHMoU3RhZ2VCaW5kaW5nU3RhdGVtZW50UHJlRXhlYywgQmFzZVN0YXRlbWVudCk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3RhdGVtZW50UG9zdEV4ZWMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdGVtZW50UG9zdEV4ZWMoc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvLyBjYWxsIHN1cGVyXG4gICAgQmFzZVN0YXRlbWVudC5hcHBseSh0aGlzLCBbc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWddKTtcbiAgICAvLyBhZGQgdGhlIHJlc3VsdCByZXF1ZXN0IGhlYWRlcnMgdG8gdGhlIGNvbnRleHRcbiAgICBjb250ZXh0LnJlc3VsdFJlcXVlc3RIZWFkZXJzID0gYnVpbGRSZXN1bHRSZXF1ZXN0SGVhZGVyc1JvdygpO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBzdGF0ZW1lbnQgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICAgKi9cbiAgICBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdFN1Y2MgPSBjcmVhdGVPblN0YXRlbWVudFJlcXVlc3RTdWNjUm93KHRoaXMsIGNvbnRleHQpO1xuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHJvd3MgaW4gdGhpcyBzdGF0ZW1lbnQncyByZXN1bHQgYW5kIGludm9rZXMgdGhlIGVhY2goKVxuICAgICAqIGNhbGxiYWNrIG9uIGVhY2ggcm93LiBJZiBzdGFydEluZGV4IGFuZCBlbmRJbmRleCB2YWx1ZXMgYXJlIHNwZWNpZmllZCwgdGhlXG4gICAgICogZWFjaCgpIGNhbGxiYWNrIHdpbGwgb25seSBiZSBpbnZva2VkIG9uIHJvd3MgaW4gdGhlIHJlcXVlc3RlZCByYW5nZS4gVGhlXG4gICAgICogZW5kKCkgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWl0aGVyIGFsbCB0aGUgcmVxdWVzdGVkIHJvd3MgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCwgb3IgaWYgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIHdoaWxlIHRyeWluZyB0b1xuICAgICAqIGZldGNoIHRoZSByZXF1ZXN0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5mZXRjaFJvd3MgPSBjcmVhdGVGbkZldGNoUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgICAvKipcbiAgICAgKiBTdHJlYW1zIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0LiBJZiBzdGFydCBhbmQgZW5kIHZhbHVlcyBhcmVcbiAgICAgKiBzcGVjaWZpZWQsIG9ubHkgcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlIGFyZSBzdHJlYW1lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1Sb3dzID0gY3JlYXRlRm5TdHJlYW1Sb3dzKHRoaXMsIGNvbnRleHQpO1xuICAgIHRoaXMuaGFzTmV4dCA9IGhhc05leHRSZXN1bHQodGhpcywgY29udGV4dCk7XG4gICAgdGhpcy5OZXh0UmVzdWx0ID0gY3JlYXRlTmV4dFJldXNsdCh0aGlzLCBjb250ZXh0KTtcbiAgICAvLyBzZW5kIGEgcmVxdWVzdCB0byBmZXRjaCB0aGUgcmVzdWx0XG4gICAgc2VuZFJlcXVlc3RQb3N0RXhlYyhjb250ZXh0LCBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdENvbXApO1xufVxuVXRpbC5pbmhlcml0cyhTdGF0ZW1lbnRQb3N0RXhlYywgQmFzZVN0YXRlbWVudCk7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgdGhlIHJvd3MgaW4gYSBzdGF0ZW1lbnQncyByZXN1bHQgYW5kXG4gKiBpbnZva2VzIHRoZSBlYWNoKCkgY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZVxuICogc3BlY2lmaWVkLCB0aGUgZWFjaCgpIGNhbGxiYWNrIHdpbGwgb25seSBiZSBpbnZva2VkIG9uIHJvd3MgaW4gdGhlXG4gKiBzcGVjaWZpZWQgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudFxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm5GZXRjaFJvd3Moc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIG9wdGlvbnNcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX09QVElPTlMpO1xuICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBvcHRpb25zXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChvcHRpb25zKSwgRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfT1BUSU9OUyk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIGVhY2goKVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmVhY2gpLCBFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19FQUNIKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgZWFjaCgpXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuZWFjaCksIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX0VBQ0gpO1xuICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBlbmQoKVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmVuZCksIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VORCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGVuZCgpXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuZW5kKSwgRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfRU5EKTtcbiAgICAgICAgY29uc3Qgcm93TW9kZSA9IG9wdGlvbnMucm93TW9kZTtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHJvd01vZGUpKSB7XG4gICAgICAgICAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIHRyeWluZyB0byBmZXRjaCB0aGUgcmVzdWx0LCBjcmVhdGUgYW4gZXJyb3Igb2Ygb3VyIG93blxuICAgICAgICAvLyBhbmQgaW52b2tlIHRoZSBlbmQoKSBjYWxsYmFja1xuICAgICAgICBpZiAoY29udGV4dC5pc0ZldGNoaW5nUmVzdWx0KSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVuZChFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0ZFVENISU5HX1JFU1VMVCkuZXh0ZXJuYWxpemUoKSwgc3RhdGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHQucmVzdWx0RXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB0aGUgbGFzdCB0aW1lIHdlIHRyaWVkIHRvIGdldCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgZmF0YWwgZXJyb3IsIGVuZCB0aGUgZmV0Y2ggcm93cyBvcGVyYXRpb24gc2luY2Ugd2UncmUgbm90XG4gICAgICAgICAgICAvLyBnb2luZyB0byBiZSBhYmxlIHRvIGdldCBhbnkgcm93cywgZWl0aGVyIGJlY2F1c2UgdGhlIHN0YXRlbWVudCBmYWlsZWRcbiAgICAgICAgICAgIC8vIG9yIGJlY2F1c2UgdGhlIHJlc3VsdCdzIGJlZW4gcHVyZ2VkXG4gICAgICAgICAgICBpZiAoRXJyb3JzLmlzT3BlcmF0aW9uRmFpbGVkRXJyb3IoY29udGV4dC5yZXN1bHRFcnJvcikgJiYgY29udGV4dC5yZXN1bHRFcnJvci5zcWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbmRGZXRjaFJvd3Mob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVmcmVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBlcnJvciwgZmV0Y2ggcm93cyBmcm9tIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnJlc3VsdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFJvd3NGcm9tUmVzdWx0KG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIHVwIGJlY2F1c2UgaXQncyB1bmxpa2VseSB3ZSdsbCBzdWNjZWVkIGlmIHdlIHJldHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRGZXRjaFJvd3Mob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hSb3dzRnJvbVJlc3VsdChvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgc3RyZWFtcyB0aGUgcm93cyBpbiBhIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnRcbiAqIGFuZCBlbmQgdmFsdWVzIGFyZSBzcGVjaWZpZWQsIG9ubHkgcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlIGFyZSBzdHJlYW1lZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50XG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBjcmVhdGVGblN0cmVhbVJvd3Moc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGlmIHNvbWUgb3B0aW9ucyBhcmUgc3BlY2lmaWVkXG4gICAgICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgb3B0aW9uc1xuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpLCBFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9PUFRJT05TKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHN0YXJ0XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNOdW1iZXIob3B0aW9ucy5zdGFydCksIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9TVEFSVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBlbmRcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmVuZCkpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNOdW1iZXIob3B0aW9ucy5lbmQpLCBFcnJvckNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRU5EKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZldGNoQXNTdHJpbmdcbiAgICAgICAgICAgIGNvbnN0IGZldGNoQXNTdHJpbmcgPSBvcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoZmV0Y2hBc1N0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0FycmF5KGZldGNoQXNTdHJpbmcpLCBFcnJvckNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFZhbHVlSW5kZXggPSBOYXRpdmVUeXBlcy5maW5kSW52YWxpZFZhbHVlKGZldGNoQXNTdHJpbmcpO1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoaW52YWxpZFZhbHVlSW5kZXggPT09IC0xLCBFcnJvckNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUywgSlNPTi5zdHJpbmdpZnkoZmV0Y2hBc1N0cmluZ1tpbnZhbGlkVmFsdWVJbmRleF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvd01vZGUgPSBjb250ZXh0LnJvd01vZGU7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICAgICAgICAgICAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUm93U3RyZWFtKHN0YXRlbWVudCwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbi8qKlxuICogRW5kcyB0aGUgZmV0Y2hSb3dzKCkgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHBhc3NlZCB0byBmZXRjaFJvd3MoKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGVuZEZldGNoUm93cyhvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgICBvcHRpb25zLmVuZChFcnJvcnMuZXh0ZXJuYWxpemUoY29udGV4dC5yZXN1bHRFcnJvciksIHN0YXRlbWVudCk7XG59XG4vKipcbiAqIEZldGNoZXMgcm93cyBmcm9tIHRoZSBzdGF0ZW1lbnQncyByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGZldGNoUm93cygpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZmV0Y2hSb3dzRnJvbVJlc3VsdChvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgICBsZXQgbnVtSW50ZXJydXB0cyA9IDA7XG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzdWx0IHRvIGdldCBhIEZldGNoUm93c09wZXJhdGlvbiBvYmplY3RcbiAgICBjb25zdCBvcGVyYXRpb24gPSBjb250ZXh0LnJlc3VsdC5mZXRjaFJvd3Mob3B0aW9ucyk7XG4gICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBvcGVyYXRpb24ncyAnY29tcGxldGUnIGV2ZW50XG4gICAgb3BlcmF0aW9uLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIsIGNvbnRpbnVlQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byByZXRyeSBpZiB0aGUgZXJyb3IgaXMgcmV0cnlhYmxlIGFuZCB0aGVcbiAgICAgICAgLy8gcmVzdWx0IHN0cmVhbSBoYXNuJ3QgYmVlbiBjbG9zZWQgdG9vIG1hbnkgdGltZXNcbiAgICAgICAgaWYgKEVycm9ycy5pc0xhcmdlUmVzdWx0U2V0RXJyb3IoZXJyKSAmJlxuICAgICAgICAgICAgZXJyLnJlc3BvbnNlICYmXG4gICAgICAgICAgICBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAzICYmXG4gICAgICAgICAgICBudW1JbnRlcnJ1cHRzIDwgY29udGV4dC5jb25uZWN0aW9uQ29uZmlnLmdldFJlc3VsdFN0cmVhbUludGVycnVwdHMoKSkge1xuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBpbnRlcnJ1cHQgY291bnRlclxuICAgICAgICAgICAgbnVtSW50ZXJydXB0cysrO1xuICAgICAgICAgICAgLy8gaXNzdWUgYSByZXF1ZXN0IHRvIGZldGNoIHRoZSByZXN1bHQgYWdhaW5cbiAgICAgICAgICAgIHNlbmRSZXF1ZXN0UG9zdEV4ZWMoY29udGV4dCwgZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0Q29tcChlcnIsIGJvZHkpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBlcnJvciwgY29udGludWUgZnJvbSB3aGVyZSB3ZSBnb3QgaW50ZXJydXB0ZWRcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRGZXRjaFJvd3Mob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBJc3N1ZXMgYSByZXF1ZXN0IHRvIGNhbmNlbCBhIHN0YXRlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gc2VuZENhbmNlbFN0YXRlbWVudChzdGF0ZW1lbnRDb250ZXh0LCBzdGF0ZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHVybDtcbiAgICBsZXQganNvbjtcbiAgICAvLyB1c2UgZGlmZmVyZW50IHJlc3QgZW5kcG9pbnRzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHF1ZXJ5IGlkIGlzIGF2YWlsYWJsZVxuICAgIGlmIChzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQpIHtcbiAgICAgICAgdXJsID0gJy9xdWVyaWVzLycgKyBzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQgKyAnL2Fib3J0LXJlcXVlc3QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsID0gJy9xdWVyaWVzL3YxL2Fib3J0LXJlcXVlc3QnO1xuICAgICAgICBqc29uID0ge1xuICAgICAgICAgICAgcmVxdWVzdElkOiBzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaXNzdWUgYSByZXF1ZXN0IHRvIGNhbmNlbCB0aGUgc3RhdGVtZW50XG4gICAgc3RhdGVtZW50Q29udGV4dC5zZXJ2aWNlcy5zZi5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBqc29uOiBqc29uLFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3JzLmV4dGVybmFsaXplKGVyciksIHN0YXRlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIElzc3VlcyBhIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXN1bHQgb2YgYSBzdGF0ZW1lbnQgdGhhdCBoYXNuJ3QgYmVlbiBwcmV2aW91c2x5XG4gKiBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIG9uUmVzdWx0QXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0UHJlRXhlYyhzdGF0ZW1lbnRDb250ZXh0LCBvblJlc3VsdEF2YWlsYWJsZSkge1xuICAgIC8vIGdldCB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gICAgY29uc3QgaGVhZGVycyA9IHN0YXRlbWVudENvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnM7XG4gICAgLy8gYnVpbGQgdGhlIGJhc2ljIGpzb24gZm9yIHRoZSByZXF1ZXN0XG4gICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgZGlzYWJsZU9mZmxpbmVDaHVua3M6IGZhbHNlLFxuICAgIH07XG4gICAganNvbi5zcWxUZXh0ID0gc3RhdGVtZW50Q29udGV4dC5zcWxUZXh0O1xuICAgIGlmIChzdGF0ZW1lbnRDb250ZXh0LnJlc3VibWl0UmVxdWVzdCAmJiAhanNvbi5zcWxUZXh0KSB7XG4gICAgICAgIGpzb24uc3FsVGV4dCA9XG4gICAgICAgICAgICBgU0VMRUNUICdFcnJvciByZXRyaWV2aW5nIHF1ZXJ5IHJlc3VsdHMgZm9yIHJlcXVlc3QgaWQ6ICR7c3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWR9LCBgICtcbiAgICAgICAgICAgICAgICBcInBsZWFzZSB1c2UgUkVTVUxUX1NDQU4gaW5zdGVhZCcgQVMgRXJyb3JNZXNzYWdlO1wiO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnY29udGV4dC5iaW5kU3RhZ2U9JyArIHN0YXRlbWVudENvbnRleHQuYmluZFN0YWdlKTtcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5iaW5kU3RhZ2UpKSB7XG4gICAgICAgIGpzb24uYmluZFN0YWdlID0gc3RhdGVtZW50Q29udGV4dC5iaW5kU3RhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuYmluZHMpKSB7XG4gICAgICAgIC8vIGlmIGJpbmRzIGFyZSBzcGVjaWZpZWQsIGJ1aWxkIGEgYmluZHMgbWFwIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXF1ZXN0XG4gICAgICAgIGpzb24uYmluZGluZ3MgPSBidWlsZEJpbmRzTWFwKHN0YXRlbWVudENvbnRleHQuYmluZHMpO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIHN0YXRlbWVudCBwYXJhbWV0ZXJzIGlmIGEgdmFsdWUgd2FzIHNwZWNpZmllZFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGpzb24ucGFyYW1ldGVycyA9IHN0YXRlbWVudENvbnRleHQucGFyYW1ldGVycztcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ2NvbnRleHQucGFyYW1ldGVycz0nICsgc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSB0aGUgaW50ZXJuYWwgZmxhZyBpZiBhIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5pbnRlcm5hbCkpIHtcbiAgICAgICAganNvbi5pc0ludGVybmFsID0gc3RhdGVtZW50Q29udGV4dC5pbnRlcm5hbDtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZW1lbnRDb250ZXh0LmRpc2FibGVRdWVyeUNvbnRleHRDYWNoZSkge1xuICAgICAgICBqc29uLnF1ZXJ5Q29udGV4dERUTyA9IHN0YXRlbWVudENvbnRleHQuc2VydmljZXMuc2YuZ2V0UXVlcnlDb250ZXh0RFRPKCk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgdGhlIGFzeW5jRXhlYyBmbGFnIGlmIGEgdmFsdWUgd2FzIHNwZWNpZmllZFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmFzeW5jRXhlYykpIHtcbiAgICAgICAganNvbi5hc3luY0V4ZWMgPSBzdGF0ZW1lbnRDb250ZXh0LmFzeW5jRXhlYztcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBkZXNjcmliZU9ubHkgZmxhZyBpZiBhIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5kZXNjcmliZU9ubHkpKSB7XG4gICAgICAgIGpzb24uZGVzY3JpYmVPbmx5ID0gc3RhdGVtZW50Q29udGV4dC5kZXNjcmliZU9ubHk7XG4gICAgfVxuICAgIC8vIHVzZSB0aGUgc25vd2ZsYWtlIHNlcnZpY2UgdG8gaXNzdWUgdGhlIHJlcXVlc3RcbiAgICBzZW5kU2ZSZXF1ZXN0KHN0YXRlbWVudENvbnRleHQsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHVybDogVXJsLmZvcm1hdCh7XG4gICAgICAgICAgICBwYXRobmFtZTogJy9xdWVyaWVzL3YxL3F1ZXJ5LXJlcXVlc3QnLFxuICAgICAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICAgIGpzb246IGpzb24sXG4gICAgICAgIGNhbGxiYWNrOiBidWlsZFJlc3VsdFJlcXVlc3RDYWxsYmFjayhzdGF0ZW1lbnRDb250ZXh0LCBoZWFkZXJzLCBvblJlc3VsdEF2YWlsYWJsZSksXG4gICAgfSwgdHJ1ZSk7XG59XG50aGlzLnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKHN0YXRlbWVudENvbnRleHQsIG9uUmVzdWx0QXZhaWxhYmxlKSB7XG4gICAgLy8gZ2V0IHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICBjb25zdCBoZWFkZXJzID0gc3RhdGVtZW50Q29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycztcbiAgICAvLyBidWlsZCB0aGUgYmFzaWMganNvbiBmb3IgdGhlIHJlcXVlc3RcbiAgICBjb25zdCBqc29uID0ge1xuICAgICAgICBkaXNhYmxlT2ZmbGluZUNodW5rczogZmFsc2UsXG4gICAgICAgIHNxbFRleHQ6IHN0YXRlbWVudENvbnRleHQuc3FsVGV4dCxcbiAgICB9O1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdjb250ZXh0LmJpbmRTdGFnZT0nICsgc3RhdGVtZW50Q29udGV4dC5iaW5kU3RhZ2UpO1xuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZSkpIHtcbiAgICAgICAganNvbi5iaW5kU3RhZ2UgPSBzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5iaW5kcykpIHtcbiAgICAgICAgLy8gaWYgYmluZHMgYXJlIHNwZWNpZmllZCwgYnVpbGQgYSBiaW5kcyBtYXAgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcXVlc3RcbiAgICAgICAganNvbi5iaW5kaW5ncyA9IGJ1aWxkQmluZHNNYXAoc3RhdGVtZW50Q29udGV4dC5iaW5kcyk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgc3RhdGVtZW50IHBhcmFtZXRlcnMgaWYgYSB2YWx1ZSB3YXMgc3BlY2lmaWVkXG4gICAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQucGFyYW1ldGVycykpIHtcbiAgICAgICAganNvbi5wYXJhbWV0ZXJzID0gc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIHRoZSBpbnRlcm5hbCBmbGFnIGlmIGEgdmFsdWUgd2FzIHNwZWNpZmllZFxuICAgIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsKSkge1xuICAgICAgICBqc29uLmlzSW50ZXJuYWwgPSBzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlbWVudENvbnRleHQuZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlKSB7XG4gICAgICAgIGpzb24ucXVlcnlDb250ZXh0RFRPID0gc3RhdGVtZW50Q29udGV4dC5zZXJ2aWNlcy5zZi5nZXRRdWVyeUNvbnRleHREVE8oKTtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB1cmw6IFVybC5mb3JtYXQoe1xuICAgICAgICAgICAgcGF0aG5hbWU6ICcvcXVlcmllcy92MS9xdWVyeS1yZXF1ZXN0JyxcbiAgICAgICAgICAgIHNlYXJjaDogUXVlcnlTdHJpbmcuc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHN0YXRlbWVudENvbnRleHQucmVxdWVzdElkLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgICBqc29uOiBqc29uLFxuICAgICAgICBjYWxsYmFjazogYnVpbGRSZXN1bHRSZXF1ZXN0Q2FsbGJhY2soc3RhdGVtZW50Q29udGV4dCwgaGVhZGVycywgb25SZXN1bHRBdmFpbGFibGUpLFxuICAgIH07XG4gICAgY29uc3Qgc2YgPSBzdGF0ZW1lbnRDb250ZXh0LnNlcnZpY2VzLnNmO1xuICAgIC8vIGNsb25lIHRoZSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IFV0aWwuYXBwbHkoe30sIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlKHNmLnBvc3RBc3luYyhvcHRpb25zKSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJpbmQgdmFyaWFibGVzIGFycmF5IHRvIGEgbWFwIHRoYXQgY2FuIGJlIGluY2x1ZGVkIGluIHRoZVxuICogUE9TVC1ib2R5IHdoZW4gaXNzdWluZyBhIHByZS1leGVjIHN0YXRlbWVudCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBiaW5kc0FycmF5XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRCaW5kc01hcChiaW5kc0FycmF5KSB7XG4gICAgY29uc3QgYmluZHNNYXAgPSB7fTtcbiAgICBjb25zdCBpc0FycmF5QmluZGluZyA9IGJpbmRzQXJyYXkubGVuZ3RoID4gMCAmJiBVdGlsLmlzQXJyYXkoYmluZHNBcnJheVswXSk7XG4gICAgY29uc3Qgc2luZ2xlQXJyYXkgPSBpc0FycmF5QmluZGluZyA/IGJpbmRzQXJyYXlbMF0gOiBiaW5kc0FycmF5O1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gc2luZ2xlQXJyYXkubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBzaW5nbGVBcnJheVtpbmRleF07XG4gICAgICAgIC8vIHBpY2sgdGhlIGFwcHJvcHJpYXRlIGxvZ2ljYWwgZGF0YSB0eXBlIGJhc2VkIG9uIHRoZSBiaW5kIHZhbHVlXG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBpZiAoVXRpbC5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICB0eXBlID0gJ0JPT0xFQU4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWwuaXNPYmplY3QodmFsdWUpIHx8IFV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnVkFSSUFOVCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbC5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdHlwZSA9ICdGSVhFRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1JFQUwnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9ICdURVhUJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0IG5vbi1udWxsIHZhbHVlcyB0byBhIHN0cmluZyBpZiBuZWNlc3Nhcnk7IHdlIGRvbid0IGNvbnZlcnQgbnVsbFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBjbGllbnQgbWlnaHQgd2FudCB0byBydW4gc29tZXRoaW5nIGxpa2VcbiAgICAgICAgLy8gICBzcWwgdGV4dCA9IHVwZGF0ZSB0IHNldCBuYW1lID0gOjEgd2hlcmUgaWQgPSAxOywgYmluZHMgPSBbbnVsbF1cbiAgICAgICAgLy8gYW5kIGNvbnZlcnRpbmcgbnVsbCB0byBhIHN0cmluZyB3b3VsZCByZXN1bHQgaW4gdXMgZXhlY3V0aW5nXG4gICAgICAgIC8vICAgc3FsIHRleHQgPSB1cGRhdGUgdCBzZXQgbmFtZSA9ICdudWxsJyB3aGVyZSBpZCA9IDE7XG4gICAgICAgIC8vIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gICBzcWwgdGV4dCA9IHVwZGF0ZSB0IHNldCBuYW1lID0gbnVsbCB3aGVyZSBpZCA9IDE7XG4gICAgICAgIGlmICghaXNBcnJheUJpbmRpbmcpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhVXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGJpbmRzQXJyYXkubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlMCA9IGJpbmRzQXJyYXlbcm93SW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUwICE9PSBudWxsICYmICFVdGlsLmlzU3RyaW5nKHZhbHVlMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlMCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMCA9IHZhbHVlMC50b0pTT04oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2YWx1ZTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBhbiBlbnRyeSBmb3IgdGhlIGJpbmQgdmFyaWFibGUgdG8gdGhlIG1hcFxuICAgICAgICBiaW5kc01hcFtpbmRleCArIDFdID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRzTWFwO1xufVxuLyoqXG4gKiBJc3N1ZXMgYSByZXF1ZXN0IHRvIGdldCB0aGUgcmVzdWx0IG9mIGEgc3RhdGVtZW50IHRoYXQgaGFzIGJlZW4gcHJldmlvdXNseVxuICogZXhlY3V0ZWQuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudENvbnRleHRcbiAqIEBwYXJhbSBvblJlc3VsdEF2YWlsYWJsZVxuICovXG5mdW5jdGlvbiBzZW5kUmVxdWVzdFBvc3RFeGVjKHN0YXRlbWVudENvbnRleHQsIG9uUmVzdWx0QXZhaWxhYmxlKSB7XG4gICAgLy8gZ2V0IHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICBjb25zdCBoZWFkZXJzID0gc3RhdGVtZW50Q29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycztcbiAgICAvLyB1c2UgdGhlIHNub3dmbGFrZSBzZXJ2aWNlIHRvIGlzc3VlIHRoZSByZXF1ZXN0XG4gICAgc2VuZFNmUmVxdWVzdChzdGF0ZW1lbnRDb250ZXh0LCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHVybDogVXJsLmZvcm1hdCh7XG4gICAgICAgICAgICBwYXRobmFtZTogJy9xdWVyaWVzLycgKyBzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQgKyAnL3Jlc3VsdCcsXG4gICAgICAgICAgICBzZWFyY2g6IFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZU9mZmxpbmVDaHVua3M6IGZhbHNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgICBjYWxsYmFjazogYnVpbGRSZXN1bHRSZXF1ZXN0Q2FsbGJhY2soc3RhdGVtZW50Q29udGV4dCwgaGVhZGVycywgb25SZXN1bHRBdmFpbGFibGUpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBJc3N1ZXMgYSBzdGF0ZW1lbnQtcmVsYXRlZCByZXF1ZXN0IHVzaW5nIHRoZSBTbm93Zmxha2Ugc2VydmljZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dCB0aGUgc3RhdGVtZW50IGNvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgcmVxdWVzdCBvcHRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbYXBwZW5kUXVlcnlQYXJhbU9uUmV0cnldIHdoZXRoZXIgcmV0cnk9dHJ1ZSBzaG91bGQgYmVcbiAqICAgYXBwZW5kZWQgdG8gdGhlIHVybCBpZiB0aGUgcmVxdWVzdCBpcyByZXRyaWVkLlxuICovXG5mdW5jdGlvbiBzZW5kU2ZSZXF1ZXN0KHN0YXRlbWVudENvbnRleHQsIG9wdGlvbnMsIGFwcGVuZFF1ZXJ5UGFyYW1PblJldHJ5KSB7XG4gICAgY29uc3Qgc2YgPSBzdGF0ZW1lbnRDb250ZXh0LnNlcnZpY2VzLnNmO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBzdGF0ZW1lbnRDb250ZXh0LmNvbm5lY3Rpb25Db25maWc7XG4gICAgLy8gY2xvbmUgdGhlIG9wdGlvbnNcbiAgICBvcHRpb25zID0gVXRpbC5hcHBseSh7fSwgb3B0aW9ucyk7XG4gICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCB1cmwgYW5kIGNhbGxiYWNrXG4gICAgY29uc3QgdXJsT3JpZyA9IG9wdGlvbnMudXJsO1xuICAgIGNvbnN0IGNhbGxiYWNrT3JpZyA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgbGV0IG51bVJldHJpZXMgPSAwO1xuICAgIGNvbnN0IG1heE51bVJldHJpZXMgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZNYXhOdW1SZXRyaWVzKCk7XG4gICAgbGV0IHNsZWVwID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmU3RhcnRpbmdTbGVlcFRpbWUoKTtcbiAgICBsZXQgbGFzdFN0YXR1c0NvZGVGb3JSZXRyeTtcbiAgICAvLyBjcmVhdGUgYSBmdW5jdGlvbiB0byBzZW5kIHRoZSByZXF1ZXN0XG4gICAgY29uc3Qgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSByZXRyeSBhbmQgYSBxdWVyeSBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSB1cmwgb25cbiAgICAgICAgLy8gcmV0cnksIHVwZGF0ZSB0aGUgdXJsXG4gICAgICAgIGlmIChudW1SZXRyaWVzID4gMCAmJiBhcHBlbmRRdWVyeVBhcmFtT25SZXRyeSkge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlPcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxPcmlnLFxuICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IG51bVJldHJpZXMsXG4gICAgICAgICAgICAgICAgcmV0cnlSZWFzb246IGxhc3RTdGF0dXNDb2RlRm9yUmV0cnksXG4gICAgICAgICAgICAgICAgaW5jbHVkZVJldHJ5UmVhc29uOiBjb25uZWN0aW9uQ29uZmlnLmdldEluY2x1ZGVSZXRyeVJlYXNvbigpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wdGlvbnMudXJsID0gVXRpbC51cmwuYXBwZW5kUmV0cnlQYXJhbShyZXRyeU9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc2YucmVxdWVzdChvcHRpb25zKTtcbiAgICB9O1xuICAgIC8vIHJlcGxhY2UgdGhlIHNwZWNpZmllZCBjYWxsYmFjayB3aXRoIGEgbmV3IG9uZSB0aGF0IHJldHJpZXNcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IGV4Y2VlZGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIHlldCBhbmQgdGhlIHNlcnZlclxuICAgICAgICAvLyBjYW1lIGJhY2sgd2l0aCBhIHJldHJ5YWJsZSBlcnJvciBjb2RlXG4gICAgICAgIGlmIChudW1SZXRyaWVzIDwgbWF4TnVtUmV0cmllcyAmJlxuICAgICAgICAgICAgZXJyICYmXG4gICAgICAgICAgICBVdGlsLmlzUmV0cnlhYmxlSHR0cEVycm9yKGVyci5yZXNwb25zZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHJldHJ5IGNvdW50XG4gICAgICAgICAgICBudW1SZXRyaWVzKys7XG4gICAgICAgICAgICBsYXN0U3RhdHVzQ29kZUZvclJldHJ5ID0gZXJyLnJlc3BvbnNlID8gZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgOiAwO1xuICAgICAgICAgICAgLy8gdXNlIGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBkZWNvcnJlbGF0ZWQgaml0dGVyIHRvIGNvbXB1dGUgdGhlXG4gICAgICAgICAgICAvLyBuZXh0IHNsZWVwIHRpbWUuXG4gICAgICAgICAgICBjb25zdCBjYXAgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZNYXhTbGVlcFRpbWUoKTtcbiAgICAgICAgICAgIHNsZWVwID0gVXRpbC5uZXh0U2xlZXBUaW1lKDEsIGNhcCwgc2xlZXApO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JldHJ5aW5nIHN0YXRlbWVudCB3aXRoIHJlcXVlc3QgaWQgJXMsIHJldHJ5IGNvdW50ID0gJXMnLCBzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZCwgbnVtUmV0cmllcyk7XG4gICAgICAgICAgICAvLyB3YWl0IHRoZSBhcHByb3ByaWF0ZSBhbW91bnQgb2YgdGltZSBiZWZvcmUgcmV0cnlpbmcgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIHNsZWVwICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnZva2UgdGhlIG9yaWdpbmFsIGNhbGxiYWNrXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja09yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gaXNzdWUgdGhlIHJlcXVlc3RcbiAgICBzZW5kUmVxdWVzdCgpO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBjYWxsYmFjayBmb3IgdXNlIGluIGFuIGV4ZWMtc3RhdGVtZW50IG9yIGZldGNoLXJlc3VsdCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRDb250ZXh0XG4gKiBAcGFyYW0gaGVhZGVyc1xuICogQHBhcmFtIG9uUmVzdWx0QXZhaWxhYmxlXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBidWlsZFJlc3VsdFJlcXVlc3RDYWxsYmFjayhzdGF0ZW1lbnRDb250ZXh0LCBoZWFkZXJzLCBvblJlc3VsdEF2YWlsYWJsZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBvblJlc3VsdEF2YWlsYWJsZS5jYWxsKG51bGwsIGVyciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBleHRyYWN0IHRoZSBxdWVyeSBpZCBmcm9tIHRoZSByZXNwb25zZSBhbmQgc2F2ZSBpdFxuICAgICAgICAgICAgc3RhdGVtZW50Q29udGV4dC5xdWVyeUlkID0gYm9keS5kYXRhLnF1ZXJ5SWQ7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVzdWx0IGlzIG5vdCByZWFkeSB5ZXQsIGV4dHJhY3QgdGhlIHJlc3VsdCB1cmwgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIGFuZCBpc3N1ZSBhIEdFVCByZXF1ZXN0IHRvIHRyeSB0byBmZXRjaCB0aGUgcmVzdWx0IGFnYWluIHVubGVzcyBhc3luY0V4ZWMgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgIGlmIChib2R5ICYmXG4gICAgICAgICAgICAgICAgKGJvZHkuY29kZSA9PT0gcXVlcnlDb2Rlcy5RVUVSWV9JTl9QUk9HUkVTUyB8fFxuICAgICAgICAgICAgICAgICAgICBib2R5LmNvZGUgPT09IHF1ZXJ5Q29kZXMuUVVFUllfSU5fUFJPR1JFU1NfQVNZTkMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlbWVudENvbnRleHQuYXN5bmNFeGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG9uUmVzdWx0QXZhaWxhYmxlLmNhbGwobnVsbCwgZXJyLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBleHRyYWN0IHRoZSByZXN1bHQgdXJsIGZyb20gdGhlIHJlc3BvbnNlIGFuZCB0cnkgdG8gZ2V0IHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyBhZ2FpblxuICAgICAgICAgICAgICAgIHNlbmRTZlJlcXVlc3Qoc3RhdGVtZW50Q29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGJvZHkuZGF0YS5nZXRSZXN1bHRVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uUmVzdWx0QXZhaWxhYmxlLmNhbGwobnVsbCwgZXJyLCBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xufVxuLyoqXG4gKiBCdWlsZHMgdGhlIHJlcXVlc3QgaGVhZGVycyBmb3IgYSByb3cgc3RhdGVtZW50IHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRSZXN1bHRSZXF1ZXN0SGVhZGVyc1JvdygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9zbm93Zmxha2UnLFxuICAgIH07XG59XG4vKipcbiAqIEJ1aWxkcyB0aGUgcmVxdWVzdCBoZWFkZXJzIGZvciBhIGZpbGUgc3RhdGVtZW50IHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRSZXN1bHRSZXF1ZXN0SGVhZGVyc0ZpbGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfTtcbn1cbi8qKlxuICogQ291bnQgbnVtYmVyIG9mIGJpbmRpbmdzXG4gKlxuICogQHJldHVybnMge2ludH1cbiAqL1xuZnVuY3Rpb24gY291bnRCaW5kaW5nKGJpbmRzKSB7XG4gICAgaWYgKCFVdGlsLmlzQXJyYXkoYmluZHMpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnLS0gYmluZHMubGVuZ3RoPSAlZCcsIGJpbmRzLmxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYmluZHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChiaW5kc1tpbmRleF0gIT0gbnVsbCAmJiBVdGlsLmlzQXJyYXkoYmluZHNbaW5kZXhdKSkge1xuICAgICAgICAgICAgY291bnQgKz0gYmluZHNbaW5kZXhdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBoYXNOZXh0UmVzdWx0KHN0YXRlbWVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0Lm11bHRpUmVzdWx0SWRzICE9IG51bGwgJiYgY29udGV4dC5tdWx0aUN1cklkICsgMSA8IGNvbnRleHQubXVsdGlSZXN1bHRJZHMubGVuZ3RoO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVOZXh0UmV1c2x0KHN0YXRlbWVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChoYXNOZXh0UmVzdWx0KHN0YXRlbWVudCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQubXVsdGlDdXJJZCsrO1xuICAgICAgICAgICAgY29udGV4dC5xdWVyeUlkID0gY29udGV4dC5tdWx0aVJlc3VsdElkc1tjb250ZXh0Lm11bHRpQ3VySWRdO1xuICAgICAgICAgICAgY29udGV4dC5zcWxUZXh0ID0gY29udGV4dC5tdWx0aVNxbFRleHRzW2NvbnRleHQubXVsdGlDdXJJZF07XG4gICAgICAgICAgICBleHBvcnRzLmNyZWF0ZVN0YXRlbWVudFBvc3RFeGVjKGNvbnRleHQsIGNvbnRleHQuc2VydmljZXMsIGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVtZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.HEARTBEAT_FREQUENCY_MASTER_VALIDITY = 14400;\n//# sourceMappingURL=connection_constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvY29ubmVjdGlvbl9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiwyQ0FBMkM7QUFDM0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbnN0YW50cy9jb25uZWN0aW9uX2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuSEVBUlRCRUFUX0ZSRVFVRU5DWV9NQVNURVJfVkFMSURJVFkgPSAxNDQwMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb25fY29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/connection_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// 400001\nexports[400001] = 'An internal error has occurred. Please contact Snowflake support.';\nexports[400002] = 'You are using an unsupported version of Node.js. Please use %s or above.';\n// 401001\nexports[401001] = 'Network error. Could not reach Snowflake.';\nexports[401002] = 'Request to Snowflake failed.';\nexports[401003] = 'Snowflake responded with non-JSON content.';\nexports[401004] = 'Request to Snowflake failed.  Invalid token';\n// 402001\nexports[402001] = 'Network error. Could not reach S3/Blob.';\nexports[402002] = 'Request to S3/Blob failed.';\n// 403001\nexports[403001] =\n    'Invalid logLevel. The specified value must be one of these five levels: error, warn, debug, info and trace.';\nexports[403002] = 'Invalid disableOCSPChecks option. The specified value must be a boolean.';\nexports[403003] =\n    'Invalid OCSP mode. The specified value must be FAIL_CLOSED, FAIL_OPEN, or INSECURE_MODE.';\nexports[403004] = 'Invalid custom JSON parser. The specified value must be a function.';\nexports[403005] = 'Invalid custom XML parser. The specified value must be a function.';\nexports[403006] = 'Invalid keep alive value. The specified value must be a boolean.';\nexports[403007] =\n    'Invalid custom credential manager value. The specified value must be an object, and it should have three methods: write, read, remove';\nexports[403008] = 'Invalid useEnvProxy value. The specified value must be a boolean.';\n// 404001\nexports[404001] = 'Connection options must be specified.';\nexports[404002] = 'Invalid connection options. The specified value must be an object.';\nexports[404003] = 'A user name must be specified.';\nexports[404004] = 'Invalid user name. The specified value must be a string.';\nexports[404005] = 'A password must be specified.';\nexports[404006] = 'Invalid password. The specified value must be a string.';\nexports[404007] = 'An account must be specified.';\nexports[404008] = 'Invalid account. The specified value must be a string.';\nexports[404009] = 'An accessUrl must be specified.';\nexports[404010] = 'Invalid accessUrl. The specified value must be a string.';\nexports[404011] = 'Invalid warehouse. The specified value must be a string.';\nexports[404012] = 'Invalid database. The specified value must be a string.';\nexports[404013] = 'Invalid schema. The specified value must be a string.';\nexports[404014] = 'Invalid role. The specified value must be a string.';\nexports[404015] = 'A proxyHost must be specified';\nexports[404016] = 'Invalid proxyHost. The specified value must be a string.';\nexports[404017] = 'A proxyPort must be specified.';\nexports[404018] = 'Invalid proxyPort. The specified value must be a number.';\nexports[404019] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[404020] = 'Invalid fetchAsString option. The specified value must be an Array.';\nexports[404021] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[404022] = 'Invalid region. The specified value must be a string.';\nexports[404023] = 'Invalid clientSessionKeepAlive. The specified value must be a boolean.';\nexports[404024] =\n    'Invalid clientSessionKeepAliveHeartbeatFrequency. The specified value must be a number.';\nexports[404025] = 'Invalid jsTreatIntegerAsBigInt. The specified value must be a boolean';\nexports[404026] =\n    'Invalid private key. The specified value must be a string in pem format of type pkcs8';\nexports[404027] = 'Invalid private key file location. The specified value must be a string';\nexports[404028] = 'Invalid private key passphrase. The specified value must be a string';\nexports[404029] = 'Invalid oauth token. The specified value must be a string';\nexports[404030] =\n    'Invalid validate default parameters value. The specified value must be a boolean';\nexports[404031] =\n    'Invalid application value. The specified value must be a string that starts with a letter and a length between 1-50';\nexports[404032] = 'A proxyUser must be specified';\nexports[404033] = 'Invalid proxyUser. The specified value must be a string.';\nexports[404034] = 'A proxyPassword must be specified.';\nexports[404035] = 'Invalid proxyPassword. The specified value must be a string.';\nexports[404036] = 'Invalid noProxy. The specified value must be a string.';\nexports[404037] = 'Invalid arrayBindingThreshold. The specified value must be a number.';\nexports[404038] = 'Invalid gcsUseDownscopedCredential. The specified value must be a boolean.';\nexports[404039] = 'Invalid forceStageBindError. The specified value must be a number.';\nexports[404040] = 'Invalid browser timeout value. The specified value must be a positive number.';\nexports[404041] = 'Invalid disableQueryContextCache. The specified value must be a boolean.';\nexports[404042] = 'Invalid includeRetryReason. The specified value must be a boolean.';\nexports[404043] = 'Invalid clientConfigFile value. The specified value must be a string.';\nexports[404044] = 'Invalid retryTimeout value. The specified value must be a number.';\nexports[404045] = 'Invalid account. The specified value must be a valid subdomain string.';\nexports[404046] = 'Invalid region. The specified value must be a valid subdomain string.';\nexports[404047] = 'Invalid disableConsoleLogin. The specified value must be a boolean';\nexports[404048] = 'Invalid disableGCPTokenUpload. The specified value must be a boolean';\nexports[404048] = 'Invalid forceGCPUseDownscopedCredential. The specified value must be a boolean';\nexports[404049] = 'Invalid clientStoreTemporaryCredential. The specified value must be a boolean.';\nexports[404050] = 'Invalid representNullAsStringNull. The specified value must be a boolean';\nexports[404051] = 'Invalid disableSamlURLCheck. The specified value must be a boolean';\nexports[404052] = 'Invalid clientRequestMFAToken. The specified value must be a boolean.';\nexports[404053] = 'A host must be specified.';\nexports[404054] = 'Invalid host. The specified value must be a string.';\nexports[404055] = 'Invalid passcodeInPassword. The specified value must be a boolean';\nexports[404056] = 'Invalid passcode. The specified value must be a string';\nexports[404057] = 'A password or token must be specified.';\nexports[404058] =\n    'Invalid oauth authorization URL. The specified value must be a valid URL starting with the https or http protocol.';\nexports[404059] = 'Invalid oauth client id. The specified value must not be an empty string';\nexports[404060] = 'Invalid oauth client secret. The specified value must not be an empty string';\nexports[404061] =\n    'Invalid oauth token request URL. The specified value must be a valid URL starting with the https or http protocol.';\nexports[404062] = 'Invalid authenticator: WORKLOAD_IDENTITY parameters. %s';\nexports[404063] = 'Invalid query tag. The specified value must be a string;';\n// 405001\nexports[405001] = 'Invalid callback. The specified value must be a function.';\n// 405501\nexports[405501] = 'Connection already in progress.';\nexports[405502] = 'Already connected.';\nexports[405503] = 'Connection already terminated. Cannot connect again.';\nexports[405504] =\n    'connect() does not work with external browser or okta authenticators, call connectAsync() instead';\nexports[405505] = 'Configuration from client config file failed';\nexports[405506] = 'Wrong authorization type';\nexports[405507] = 'Authenticator not allowed';\n// 406001\nexports[406001] = 'Invalid callback. The specified value must be a function.';\n// 406501\nexports[406501] = 'Not connected, so nothing to destroy.';\nexports[406502] = 'Already disconnected.';\n// 407001\nexports[407001] = 'Unable to perform operation because a connection was never established.';\nexports[407002] = 'Unable to perform operation using terminated connection.';\n// 408001\nexports[408001] = 'A serializedConnection must be specified.';\nexports[408002] = 'Invalid serializedConnection. The specified value must be a string.';\nexports[408003] =\n    \"Invalid serializedConnection. The value must be a string obtained by calling another connection's serialize() method.\";\n// 409001\nexports[409001] = 'Execute options must be specified.';\nexports[409002] = 'Invalid execute options. The specified value must be an object.';\nexports[409003] = 'A sqlText value must be specified.';\nexports[409004] = 'Invalid sqlText. The specified value must be a string.';\nexports[409005] = 'Invalid internal flag. The specified value must be a boolean.';\nexports[409006] = 'Invalid parameters. The specified value must be an object.';\nexports[409007] = 'Invalid binds. The specified value must be an array.';\nexports[409008] = 'Invalid bind variable: %s. Only stringifiable values are supported.';\nexports[409009] = 'Invalid complete callback. The specified value must be a function.';\nexports[409010] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[409011] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[409012] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[409013] = 'Invalid requestId. The specified value must be a string.';\nexports[409014] = 'Invalid asyncExec. The specified value must be a boolean.';\nexports[409015] = 'Invalid describeOnly. The specified value must be a boolean.';\n// 410001\nexports[410001] = 'Fetch-result options must be specified.';\nexports[410002] = 'Invalid options. The specified value must be an object.';\nexports[410003] = 'A query id/statement id must be specified.';\nexports[410004] = 'Invalid query id/statement id. The specified value must be a string.';\nexports[410005] = 'Invalid complete callback. The specified value must be a function.';\nexports[410006] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[410007] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[410008] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[410009] =\n    'Invalid cwd (current working directory) type: %s. The specified value must be a string.';\n// 411001\nexports[411001] = 'Invalid options. The specified value must be an object.';\nexports[411002] = 'Invalid start index. The specified value must be a number.';\nexports[411003] = 'Invalid end index. The specified value must be a number.';\nexports[411004] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[411005] =\n    'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[411006] =\n    'Invalid row mode value. The specified value should be array or object or object_with_renamed_duplicated_columns';\nexports[412001] = 'Certificate is REVOKED.';\nexports[412002] = 'Certificate status is UNKNOWN.';\nexports[412003] = 'Not recognize signature algorithm.';\nexports[412004] = 'Invalid signature.';\nexports[412005] = 'No OCSP response data is attached.';\nexports[412006] = 'Invalid validity.';\nexports[412007] = 'Could not verify the certificate revocation status.';\nexports[412008] = 'Not two elements are in the cache.';\nexports[412009] = 'Cache entry expired.';\nexports[412010] = 'Failed to parse OCSP response.';\nexports[412011] = 'Invalid Signing Certificate validity.';\nexports[412012] = 'Timeout OCSP responder.';\nexports[412013] = 'Timeout OCSP Cache server.';\nexports[412014] = 'Failed to obtain OCSP response: %s';\nexports[413001] = 'CRL validation failed.';\n// 450001\nexports[450001] = 'Fetch-row options must be specified.';\nexports[450002] = 'Invalid options. The specified value must be an object.';\nexports[450003] = 'An each() callback must be specified.';\nexports[450004] = 'Invalid each() callback. The specified value must be a function.';\nexports[450005] = 'An end() callback must be specified.';\nexports[450006] = 'Invalid end() callback. The specified value must be a function.';\nexports[450007] = 'Operation failed because the statement is still in progress.';\n// 460001\nexports[460001] = 'Invalid queryId: %s';\nexports[460002] = 'Cannot retrieve data. No information returned from server for query %s';\nexports[460003] = 'Status of query %s is %s, results are unavailable';\n//# sourceMappingURL=error_messages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvZXJyb3JfbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZSw0REFBNEQ7QUFDM0U7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29uc3RhbnRzL2Vycm9yX21lc3NhZ2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gNDAwMDAxXG5leHBvcnRzWzQwMDAwMV0gPSAnQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLiBQbGVhc2UgY29udGFjdCBTbm93Zmxha2Ugc3VwcG9ydC4nO1xuZXhwb3J0c1s0MDAwMDJdID0gJ1lvdSBhcmUgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgdmVyc2lvbiBvZiBOb2RlLmpzLiBQbGVhc2UgdXNlICVzIG9yIGFib3ZlLic7XG4vLyA0MDEwMDFcbmV4cG9ydHNbNDAxMDAxXSA9ICdOZXR3b3JrIGVycm9yLiBDb3VsZCBub3QgcmVhY2ggU25vd2ZsYWtlLic7XG5leHBvcnRzWzQwMTAwMl0gPSAnUmVxdWVzdCB0byBTbm93Zmxha2UgZmFpbGVkLic7XG5leHBvcnRzWzQwMTAwM10gPSAnU25vd2ZsYWtlIHJlc3BvbmRlZCB3aXRoIG5vbi1KU09OIGNvbnRlbnQuJztcbmV4cG9ydHNbNDAxMDA0XSA9ICdSZXF1ZXN0IHRvIFNub3dmbGFrZSBmYWlsZWQuICBJbnZhbGlkIHRva2VuJztcbi8vIDQwMjAwMVxuZXhwb3J0c1s0MDIwMDFdID0gJ05ldHdvcmsgZXJyb3IuIENvdWxkIG5vdCByZWFjaCBTMy9CbG9iLic7XG5leHBvcnRzWzQwMjAwMl0gPSAnUmVxdWVzdCB0byBTMy9CbG9iIGZhaWxlZC4nO1xuLy8gNDAzMDAxXG5leHBvcnRzWzQwMzAwMV0gPVxuICAgICdJbnZhbGlkIGxvZ0xldmVsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgb25lIG9mIHRoZXNlIGZpdmUgbGV2ZWxzOiBlcnJvciwgd2FybiwgZGVidWcsIGluZm8gYW5kIHRyYWNlLic7XG5leHBvcnRzWzQwMzAwMl0gPSAnSW52YWxpZCBkaXNhYmxlT0NTUENoZWNrcyBvcHRpb24uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDAzMDAzXSA9XG4gICAgJ0ludmFsaWQgT0NTUCBtb2RlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgRkFJTF9DTE9TRUQsIEZBSUxfT1BFTiwgb3IgSU5TRUNVUkVfTU9ERS4nO1xuZXhwb3J0c1s0MDMwMDRdID0gJ0ludmFsaWQgY3VzdG9tIEpTT04gcGFyc2VyLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0MDMwMDVdID0gJ0ludmFsaWQgY3VzdG9tIFhNTCBwYXJzZXIuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQwMzAwNl0gPSAnSW52YWxpZCBrZWVwIGFsaXZlIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwMzAwN10gPVxuICAgICdJbnZhbGlkIGN1c3RvbSBjcmVkZW50aWFsIG1hbmFnZXIgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QsIGFuZCBpdCBzaG91bGQgaGF2ZSB0aHJlZSBtZXRob2RzOiB3cml0ZSwgcmVhZCwgcmVtb3ZlJztcbmV4cG9ydHNbNDAzMDA4XSA9ICdJbnZhbGlkIHVzZUVudlByb3h5IHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG4vLyA0MDQwMDFcbmV4cG9ydHNbNDA0MDAxXSA9ICdDb25uZWN0aW9uIG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDAyXSA9ICdJbnZhbGlkIGNvbm5lY3Rpb24gb3B0aW9ucy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nO1xuZXhwb3J0c1s0MDQwMDNdID0gJ0EgdXNlciBuYW1lIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwNDAwNF0gPSAnSW52YWxpZCB1c2VyIG5hbWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMDVdID0gJ0EgcGFzc3dvcmQgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDA2XSA9ICdJbnZhbGlkIHBhc3N3b3JkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDA3XSA9ICdBbiBhY2NvdW50IG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwNDAwOF0gPSAnSW52YWxpZCBhY2NvdW50LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDA5XSA9ICdBbiBhY2Nlc3NVcmwgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDEwXSA9ICdJbnZhbGlkIGFjY2Vzc1VybC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxMV0gPSAnSW52YWxpZCB3YXJlaG91c2UuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMTJdID0gJ0ludmFsaWQgZGF0YWJhc2UuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMTNdID0gJ0ludmFsaWQgc2NoZW1hLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDE0XSA9ICdJbnZhbGlkIHJvbGUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMTVdID0gJ0EgcHJveHlIb3N0IG11c3QgYmUgc3BlY2lmaWVkJztcbmV4cG9ydHNbNDA0MDE2XSA9ICdJbnZhbGlkIHByb3h5SG9zdC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxN10gPSAnQSBwcm94eVBvcnQgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDE4XSA9ICdJbnZhbGlkIHByb3h5UG9ydC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQwNDAxOV0gPSAnSW52YWxpZCBzdHJlYW1SZXN1bHQgZmxhZy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDQwMjBdID0gJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyBvcHRpb24uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBBcnJheS4nO1xuZXhwb3J0c1s0MDQwMjFdID1cbiAgICAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHR5cGU6ICVzLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZTogU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIEJ1ZmZlciwgYW5kIEpTT04uJztcbmV4cG9ydHNbNDA0MDIyXSA9ICdJbnZhbGlkIHJlZ2lvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAyM10gPSAnSW52YWxpZCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDAyNF0gPVxuICAgICdJbnZhbGlkIGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nO1xuZXhwb3J0c1s0MDQwMjVdID0gJ0ludmFsaWQganNUcmVhdEludGVnZXJBc0JpZ0ludC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDAyNl0gPVxuICAgICdJbnZhbGlkIHByaXZhdGUga2V5LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gcGVtIGZvcm1hdCBvZiB0eXBlIHBrY3M4JztcbmV4cG9ydHNbNDA0MDI3XSA9ICdJbnZhbGlkIHByaXZhdGUga2V5IGZpbGUgbG9jYXRpb24uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyc7XG5leHBvcnRzWzQwNDAyOF0gPSAnSW52YWxpZCBwcml2YXRlIGtleSBwYXNzcGhyYXNlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcnO1xuZXhwb3J0c1s0MDQwMjldID0gJ0ludmFsaWQgb2F1dGggdG9rZW4uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyc7XG5leHBvcnRzWzQwNDAzMF0gPVxuICAgICdJbnZhbGlkIHZhbGlkYXRlIGRlZmF1bHQgcGFyYW1ldGVycyB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDAzMV0gPVxuICAgICdJbnZhbGlkIGFwcGxpY2F0aW9uIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgdGhhdCBzdGFydHMgd2l0aCBhIGxldHRlciBhbmQgYSBsZW5ndGggYmV0d2VlbiAxLTUwJztcbmV4cG9ydHNbNDA0MDMyXSA9ICdBIHByb3h5VXNlciBtdXN0IGJlIHNwZWNpZmllZCc7XG5leHBvcnRzWzQwNDAzM10gPSAnSW52YWxpZCBwcm94eVVzZXIuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMzRdID0gJ0EgcHJveHlQYXNzd29yZCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMzVdID0gJ0ludmFsaWQgcHJveHlQYXNzd29yZC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAzNl0gPSAnSW52YWxpZCBub1Byb3h5LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDM3XSA9ICdJbnZhbGlkIGFycmF5QmluZGluZ1RocmVzaG9sZC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQwNDAzOF0gPSAnSW52YWxpZCBnY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDQwMzldID0gJ0ludmFsaWQgZm9yY2VTdGFnZUJpbmRFcnJvci4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQwNDA0MF0gPSAnSW52YWxpZCBicm93c2VyIHRpbWVvdXQgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4nO1xuZXhwb3J0c1s0MDQwNDFdID0gJ0ludmFsaWQgZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDA0Ml0gPSAnSW52YWxpZCBpbmNsdWRlUmV0cnlSZWFzb24uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA0MDQzXSA9ICdJbnZhbGlkIGNsaWVudENvbmZpZ0ZpbGUgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwNDRdID0gJ0ludmFsaWQgcmV0cnlUaW1lb3V0IHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDQ1XSA9ICdJbnZhbGlkIGFjY291bnQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIHN1YmRvbWFpbiBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDQ2XSA9ICdJbnZhbGlkIHJlZ2lvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgc3ViZG9tYWluIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwNDddID0gJ0ludmFsaWQgZGlzYWJsZUNvbnNvbGVMb2dpbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDA0OF0gPSAnSW52YWxpZCBkaXNhYmxlR0NQVG9rZW5VcGxvYWQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwNDhdID0gJ0ludmFsaWQgZm9yY2VHQ1BVc2VEb3duc2NvcGVkQ3JlZGVudGlhbC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDA0OV0gPSAnSW52YWxpZCBjbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA0MDUwXSA9ICdJbnZhbGlkIHJlcHJlc2VudE51bGxBc1N0cmluZ051bGwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwNTFdID0gJ0ludmFsaWQgZGlzYWJsZVNhbWxVUkxDaGVjay4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDA1Ml0gPSAnSW52YWxpZCBjbGllbnRSZXF1ZXN0TUZBVG9rZW4uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA0MDUzXSA9ICdBIGhvc3QgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDU0XSA9ICdJbnZhbGlkIGhvc3QuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwNTVdID0gJ0ludmFsaWQgcGFzc2NvZGVJblBhc3N3b3JkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDU2XSA9ICdJbnZhbGlkIHBhc3Njb2RlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcnO1xuZXhwb3J0c1s0MDQwNTddID0gJ0EgcGFzc3dvcmQgb3IgdG9rZW4gbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDU4XSA9XG4gICAgJ0ludmFsaWQgb2F1dGggYXV0aG9yaXphdGlvbiBVUkwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIFVSTCBzdGFydGluZyB3aXRoIHRoZSBodHRwcyBvciBodHRwIHByb3RvY29sLic7XG5leHBvcnRzWzQwNDA1OV0gPSAnSW52YWxpZCBvYXV0aCBjbGllbnQgaWQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nJztcbmV4cG9ydHNbNDA0MDYwXSA9ICdJbnZhbGlkIG9hdXRoIGNsaWVudCBzZWNyZXQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nJztcbmV4cG9ydHNbNDA0MDYxXSA9XG4gICAgJ0ludmFsaWQgb2F1dGggdG9rZW4gcmVxdWVzdCBVUkwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIFVSTCBzdGFydGluZyB3aXRoIHRoZSBodHRwcyBvciBodHRwIHByb3RvY29sLic7XG5leHBvcnRzWzQwNDA2Ml0gPSAnSW52YWxpZCBhdXRoZW50aWNhdG9yOiBXT1JLTE9BRF9JREVOVElUWSBwYXJhbWV0ZXJzLiAlcyc7XG5leHBvcnRzWzQwNDA2M10gPSAnSW52YWxpZCBxdWVyeSB0YWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZzsnO1xuLy8gNDA1MDAxXG5leHBvcnRzWzQwNTAwMV0gPSAnSW52YWxpZCBjYWxsYmFjay4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcbi8vIDQwNTUwMVxuZXhwb3J0c1s0MDU1MDFdID0gJ0Nvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcy4nO1xuZXhwb3J0c1s0MDU1MDJdID0gJ0FscmVhZHkgY29ubmVjdGVkLic7XG5leHBvcnRzWzQwNTUwM10gPSAnQ29ubmVjdGlvbiBhbHJlYWR5IHRlcm1pbmF0ZWQuIENhbm5vdCBjb25uZWN0IGFnYWluLic7XG5leHBvcnRzWzQwNTUwNF0gPVxuICAgICdjb25uZWN0KCkgZG9lcyBub3Qgd29yayB3aXRoIGV4dGVybmFsIGJyb3dzZXIgb3Igb2t0YSBhdXRoZW50aWNhdG9ycywgY2FsbCBjb25uZWN0QXN5bmMoKSBpbnN0ZWFkJztcbmV4cG9ydHNbNDA1NTA1XSA9ICdDb25maWd1cmF0aW9uIGZyb20gY2xpZW50IGNvbmZpZyBmaWxlIGZhaWxlZCc7XG5leHBvcnRzWzQwNTUwNl0gPSAnV3JvbmcgYXV0aG9yaXphdGlvbiB0eXBlJztcbmV4cG9ydHNbNDA1NTA3XSA9ICdBdXRoZW50aWNhdG9yIG5vdCBhbGxvd2VkJztcbi8vIDQwNjAwMVxuZXhwb3J0c1s0MDYwMDFdID0gJ0ludmFsaWQgY2FsbGJhY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG4vLyA0MDY1MDFcbmV4cG9ydHNbNDA2NTAxXSA9ICdOb3QgY29ubmVjdGVkLCBzbyBub3RoaW5nIHRvIGRlc3Ryb3kuJztcbmV4cG9ydHNbNDA2NTAyXSA9ICdBbHJlYWR5IGRpc2Nvbm5lY3RlZC4nO1xuLy8gNDA3MDAxXG5leHBvcnRzWzQwNzAwMV0gPSAnVW5hYmxlIHRvIHBlcmZvcm0gb3BlcmF0aW9uIGJlY2F1c2UgYSBjb25uZWN0aW9uIHdhcyBuZXZlciBlc3RhYmxpc2hlZC4nO1xuZXhwb3J0c1s0MDcwMDJdID0gJ1VuYWJsZSB0byBwZXJmb3JtIG9wZXJhdGlvbiB1c2luZyB0ZXJtaW5hdGVkIGNvbm5lY3Rpb24uJztcbi8vIDQwODAwMVxuZXhwb3J0c1s0MDgwMDFdID0gJ0Egc2VyaWFsaXplZENvbm5lY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA4MDAyXSA9ICdJbnZhbGlkIHNlcmlhbGl6ZWRDb25uZWN0aW9uLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA4MDAzXSA9XG4gICAgXCJJbnZhbGlkIHNlcmlhbGl6ZWRDb25uZWN0aW9uLiBUaGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvYnRhaW5lZCBieSBjYWxsaW5nIGFub3RoZXIgY29ubmVjdGlvbidzIHNlcmlhbGl6ZSgpIG1ldGhvZC5cIjtcbi8vIDQwOTAwMVxuZXhwb3J0c1s0MDkwMDFdID0gJ0V4ZWN1dGUgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDkwMDJdID0gJ0ludmFsaWQgZXhlY3V0ZSBvcHRpb25zLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Lic7XG5leHBvcnRzWzQwOTAwM10gPSAnQSBzcWxUZXh0IHZhbHVlIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwOTAwNF0gPSAnSW52YWxpZCBzcWxUZXh0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA5MDA1XSA9ICdJbnZhbGlkIGludGVybmFsIGZsYWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA5MDA2XSA9ICdJbnZhbGlkIHBhcmFtZXRlcnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDA5MDA3XSA9ICdJbnZhbGlkIGJpbmRzLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkuJztcbmV4cG9ydHNbNDA5MDA4XSA9ICdJbnZhbGlkIGJpbmQgdmFyaWFibGU6ICVzLiBPbmx5IHN0cmluZ2lmaWFibGUgdmFsdWVzIGFyZSBzdXBwb3J0ZWQuJztcbmV4cG9ydHNbNDA5MDA5XSA9ICdJbnZhbGlkIGNvbXBsZXRlIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0MDkwMTBdID0gJ0ludmFsaWQgc3RyZWFtUmVzdWx0IGZsYWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA5MDExXSA9ICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBBcnJheS4nO1xuZXhwb3J0c1s0MDkwMTJdID1cbiAgICAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHR5cGU6ICVzLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZTogU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIEJ1ZmZlciwgYW5kIEpTT04uJztcbmV4cG9ydHNbNDA5MDEzXSA9ICdJbnZhbGlkIHJlcXVlc3RJZC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwOTAxNF0gPSAnSW52YWxpZCBhc3luY0V4ZWMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA5MDE1XSA9ICdJbnZhbGlkIGRlc2NyaWJlT25seS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuLy8gNDEwMDAxXG5leHBvcnRzWzQxMDAwMV0gPSAnRmV0Y2gtcmVzdWx0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDEwMDAyXSA9ICdJbnZhbGlkIG9wdGlvbnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDEwMDAzXSA9ICdBIHF1ZXJ5IGlkL3N0YXRlbWVudCBpZCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MTAwMDRdID0gJ0ludmFsaWQgcXVlcnkgaWQvc3RhdGVtZW50IGlkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDEwMDA1XSA9ICdJbnZhbGlkIGNvbXBsZXRlIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0MTAwMDZdID0gJ0ludmFsaWQgc3RyZWFtUmVzdWx0IGZsYWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDEwMDA3XSA9ICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBBcnJheS4nO1xuZXhwb3J0c1s0MTAwMDhdID1cbiAgICAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHR5cGU6ICVzLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZTogU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIEJ1ZmZlciwgYW5kIEpTT04uJztcbmV4cG9ydHNbNDEwMDA5XSA9XG4gICAgJ0ludmFsaWQgY3dkIChjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5KSB0eXBlOiAlcy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG4vLyA0MTEwMDFcbmV4cG9ydHNbNDExMDAxXSA9ICdJbnZhbGlkIG9wdGlvbnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDExMDAyXSA9ICdJbnZhbGlkIHN0YXJ0IGluZGV4LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDExMDAzXSA9ICdJbnZhbGlkIGVuZCBpbmRleC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQxMTAwNF0gPSAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gQXJyYXkuJztcbmV4cG9ydHNbNDExMDA1XSA9XG4gICAgJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyB0eXBlOiAlcy4gVGhlIHN1cHBvcnRlZCB0eXBlcyBhcmU6IFN0cmluZywgQm9vbGVhbiwgTnVtYmVyLCBEYXRlLCBCdWZmZXIsIGFuZCBKU09OLic7XG5leHBvcnRzWzQxMTAwNl0gPVxuICAgICdJbnZhbGlkIHJvdyBtb2RlIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIHNob3VsZCBiZSBhcnJheSBvciBvYmplY3Qgb3Igb2JqZWN0X3dpdGhfcmVuYW1lZF9kdXBsaWNhdGVkX2NvbHVtbnMnO1xuZXhwb3J0c1s0MTIwMDFdID0gJ0NlcnRpZmljYXRlIGlzIFJFVk9LRUQuJztcbmV4cG9ydHNbNDEyMDAyXSA9ICdDZXJ0aWZpY2F0ZSBzdGF0dXMgaXMgVU5LTk9XTi4nO1xuZXhwb3J0c1s0MTIwMDNdID0gJ05vdCByZWNvZ25pemUgc2lnbmF0dXJlIGFsZ29yaXRobS4nO1xuZXhwb3J0c1s0MTIwMDRdID0gJ0ludmFsaWQgc2lnbmF0dXJlLic7XG5leHBvcnRzWzQxMjAwNV0gPSAnTm8gT0NTUCByZXNwb25zZSBkYXRhIGlzIGF0dGFjaGVkLic7XG5leHBvcnRzWzQxMjAwNl0gPSAnSW52YWxpZCB2YWxpZGl0eS4nO1xuZXhwb3J0c1s0MTIwMDddID0gJ0NvdWxkIG5vdCB2ZXJpZnkgdGhlIGNlcnRpZmljYXRlIHJldm9jYXRpb24gc3RhdHVzLic7XG5leHBvcnRzWzQxMjAwOF0gPSAnTm90IHR3byBlbGVtZW50cyBhcmUgaW4gdGhlIGNhY2hlLic7XG5leHBvcnRzWzQxMjAwOV0gPSAnQ2FjaGUgZW50cnkgZXhwaXJlZC4nO1xuZXhwb3J0c1s0MTIwMTBdID0gJ0ZhaWxlZCB0byBwYXJzZSBPQ1NQIHJlc3BvbnNlLic7XG5leHBvcnRzWzQxMjAxMV0gPSAnSW52YWxpZCBTaWduaW5nIENlcnRpZmljYXRlIHZhbGlkaXR5Lic7XG5leHBvcnRzWzQxMjAxMl0gPSAnVGltZW91dCBPQ1NQIHJlc3BvbmRlci4nO1xuZXhwb3J0c1s0MTIwMTNdID0gJ1RpbWVvdXQgT0NTUCBDYWNoZSBzZXJ2ZXIuJztcbmV4cG9ydHNbNDEyMDE0XSA9ICdGYWlsZWQgdG8gb2J0YWluIE9DU1AgcmVzcG9uc2U6ICVzJztcbmV4cG9ydHNbNDEzMDAxXSA9ICdDUkwgdmFsaWRhdGlvbiBmYWlsZWQuJztcbi8vIDQ1MDAwMVxuZXhwb3J0c1s0NTAwMDFdID0gJ0ZldGNoLXJvdyBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQ1MDAwMl0gPSAnSW52YWxpZCBvcHRpb25zLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Lic7XG5leHBvcnRzWzQ1MDAwM10gPSAnQW4gZWFjaCgpIGNhbGxiYWNrIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQ1MDAwNF0gPSAnSW52YWxpZCBlYWNoKCkgY2FsbGJhY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQ1MDAwNV0gPSAnQW4gZW5kKCkgY2FsbGJhY2sgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDUwMDA2XSA9ICdJbnZhbGlkIGVuZCgpIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0NTAwMDddID0gJ09wZXJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgc3RhdGVtZW50IGlzIHN0aWxsIGluIHByb2dyZXNzLic7XG4vLyA0NjAwMDFcbmV4cG9ydHNbNDYwMDAxXSA9ICdJbnZhbGlkIHF1ZXJ5SWQ6ICVzJztcbmV4cG9ydHNbNDYwMDAyXSA9ICdDYW5ub3QgcmV0cmlldmUgZGF0YS4gTm8gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBzZXJ2ZXIgZm9yIHF1ZXJ5ICVzJztcbmV4cG9ydHNbNDYwMDAzXSA9ICdTdGF0dXMgb2YgcXVlcnkgJXMgaXMgJXMsIHJlc3VsdHMgYXJlIHVuYXZhaWxhYmxlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yX21lc3NhZ2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst code = {};\ncode.INCORRECT_USERNAME_PASSWORD = '390100';\ncode.SESSION_TOKEN_INVALID = '390104';\ncode.GONE_SESSION = '390111';\ncode.SESSION_TOKEN_EXPIRED = '390112';\ncode.OAUTH_TOKEN_EXPIRED = '390318';\ncode.MASTER_TOKEN_EXPIRED = '390114';\ncode.ID_TOKEN_INVALID = '390195';\nexports.code = code;\n//# sourceMappingURL=gs_errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvZ3NfZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29uc3RhbnRzL2dzX2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvZGUgPSB7fTtcbmNvZGUuSU5DT1JSRUNUX1VTRVJOQU1FX1BBU1NXT1JEID0gJzM5MDEwMCc7XG5jb2RlLlNFU1NJT05fVE9LRU5fSU5WQUxJRCA9ICczOTAxMDQnO1xuY29kZS5HT05FX1NFU1NJT04gPSAnMzkwMTExJztcbmNvZGUuU0VTU0lPTl9UT0tFTl9FWFBJUkVEID0gJzM5MDExMic7XG5jb2RlLk9BVVRIX1RPS0VOX0VYUElSRUQgPSAnMzkwMzE4JztcbmNvZGUuTUFTVEVSX1RPS0VOX0VYUElSRUQgPSAnMzkwMTE0JztcbmNvZGUuSURfVE9LRU5fSU5WQUxJRCA9ICczOTAxOTUnO1xuZXhwb3J0cy5jb2RlID0gY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdzX2Vycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/query_status.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/query_status.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nconst code = {};\ncode.RUNNING = 'RUNNING';\ncode.ABORTING = 'ABORTING';\ncode.SUCCESS = 'SUCCESS';\ncode.FAILED_WITH_ERROR = 'FAILED_WITH_ERROR';\ncode.ABORTED = 'ABORTED';\ncode.QUEUED = 'QUEUED';\ncode.FAILED_WITH_INCIDENT = 'FAILED_WITH_INCIDENT';\ncode.DISCONNECTED = 'DISCONNECTED';\ncode.RESUMING_WAREHOUSE = 'RESUMING_WAREHOUSE';\n// purposeful typo.Is present in QueryDTO.java\ncode.QUEUED_REPARING_WAREHOUSE = 'QUEUED_REPARING_WAREHOUSE';\ncode.RESTARTED = 'RESTARTED';\ncode.BLOCKED = 'BLOCKED';\ncode.NO_DATA = 'NO_DATA';\ncode.NO_QUERY_DATA = 'NO_QUERY_DATA';\n// All running query statuses\nconst runningStatuses = [\n    code.RUNNING,\n    code.RESUMING_WAREHOUSE,\n    code.QUEUED,\n    code.QUEUED_REPARING_WAREHOUSE,\n    code.NO_DATA,\n];\n// All error query statuses\nconst errorStatuses = [\n    code.ABORTING,\n    code.FAILED_WITH_ERROR,\n    code.ABORTED,\n    code.FAILED_WITH_INCIDENT,\n    code.DISCONNECTED,\n    code.BLOCKED,\n];\nexports.code = code;\nexports.runningStatuses = runningStatuses;\nexports.errorStatuses = errorStatuses;\n//# sourceMappingURL=query_status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvcXVlcnlfc3RhdHVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbnN0YW50cy9xdWVyeV9zdGF0dXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjb2RlID0ge307XG5jb2RlLlJVTk5JTkcgPSAnUlVOTklORyc7XG5jb2RlLkFCT1JUSU5HID0gJ0FCT1JUSU5HJztcbmNvZGUuU1VDQ0VTUyA9ICdTVUNDRVNTJztcbmNvZGUuRkFJTEVEX1dJVEhfRVJST1IgPSAnRkFJTEVEX1dJVEhfRVJST1InO1xuY29kZS5BQk9SVEVEID0gJ0FCT1JURUQnO1xuY29kZS5RVUVVRUQgPSAnUVVFVUVEJztcbmNvZGUuRkFJTEVEX1dJVEhfSU5DSURFTlQgPSAnRkFJTEVEX1dJVEhfSU5DSURFTlQnO1xuY29kZS5ESVNDT05ORUNURUQgPSAnRElTQ09OTkVDVEVEJztcbmNvZGUuUkVTVU1JTkdfV0FSRUhPVVNFID0gJ1JFU1VNSU5HX1dBUkVIT1VTRSc7XG4vLyBwdXJwb3NlZnVsIHR5cG8uSXMgcHJlc2VudCBpbiBRdWVyeURUTy5qYXZhXG5jb2RlLlFVRVVFRF9SRVBBUklOR19XQVJFSE9VU0UgPSAnUVVFVUVEX1JFUEFSSU5HX1dBUkVIT1VTRSc7XG5jb2RlLlJFU1RBUlRFRCA9ICdSRVNUQVJURUQnO1xuY29kZS5CTE9DS0VEID0gJ0JMT0NLRUQnO1xuY29kZS5OT19EQVRBID0gJ05PX0RBVEEnO1xuY29kZS5OT19RVUVSWV9EQVRBID0gJ05PX1FVRVJZX0RBVEEnO1xuLy8gQWxsIHJ1bm5pbmcgcXVlcnkgc3RhdHVzZXNcbmNvbnN0IHJ1bm5pbmdTdGF0dXNlcyA9IFtcbiAgICBjb2RlLlJVTk5JTkcsXG4gICAgY29kZS5SRVNVTUlOR19XQVJFSE9VU0UsXG4gICAgY29kZS5RVUVVRUQsXG4gICAgY29kZS5RVUVVRURfUkVQQVJJTkdfV0FSRUhPVVNFLFxuICAgIGNvZGUuTk9fREFUQSxcbl07XG4vLyBBbGwgZXJyb3IgcXVlcnkgc3RhdHVzZXNcbmNvbnN0IGVycm9yU3RhdHVzZXMgPSBbXG4gICAgY29kZS5BQk9SVElORyxcbiAgICBjb2RlLkZBSUxFRF9XSVRIX0VSUk9SLFxuICAgIGNvZGUuQUJPUlRFRCxcbiAgICBjb2RlLkZBSUxFRF9XSVRIX0lOQ0lERU5ULFxuICAgIGNvZGUuRElTQ09OTkVDVEVELFxuICAgIGNvZGUuQkxPQ0tFRCxcbl07XG5leHBvcnRzLmNvZGUgPSBjb2RlO1xuZXhwb3J0cy5ydW5uaW5nU3RhdHVzZXMgPSBydW5uaW5nU3RhdHVzZXM7XG5leHBvcnRzLmVycm9yU3RhdHVzZXMgPSBlcnJvclN0YXR1c2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlfc3RhdHVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/query_status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst ARRAY = 'array';\nconst OBJECT = 'object';\nconst OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS = 'object_with_renamed_duplicated_columns';\nconst isValidRowMode = (rowMode) => [ARRAY, OBJECT, OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS].includes(rowMode);\nconst checkRowModeValid = (rowMode) => {\n    Errors.checkArgumentValid(isValidRowMode(rowMode), ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE, JSON.stringify(rowMode));\n};\nexports.ARRAY = ARRAY;\nexports.OBJECT = OBJECT;\nexports.OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS = OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS;\nexports.isValidRowMode = isValidRowMode;\nexports.checkRowModeValid = checkRowModeValid;\n//# sourceMappingURL=row_mode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvcm93X21vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjO0FBQ2QsOENBQThDO0FBQzlDLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2NvbnN0YW50cy9yb3dfbW9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IEFSUkFZID0gJ2FycmF5JztcbmNvbnN0IE9CSkVDVCA9ICdvYmplY3QnO1xuY29uc3QgT0JKRUNUX1dJVEhfUkVOQU1FRF9EVVBMSUNBVEVEX0NPTFVNTlMgPSAnb2JqZWN0X3dpdGhfcmVuYW1lZF9kdXBsaWNhdGVkX2NvbHVtbnMnO1xuY29uc3QgaXNWYWxpZFJvd01vZGUgPSAocm93TW9kZSkgPT4gW0FSUkFZLCBPQkpFQ1QsIE9CSkVDVF9XSVRIX1JFTkFNRURfRFVQTElDQVRFRF9DT0xVTU5TXS5pbmNsdWRlcyhyb3dNb2RlKTtcbmNvbnN0IGNoZWNrUm93TW9kZVZhbGlkID0gKHJvd01vZGUpID0+IHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGlzVmFsaWRSb3dNb2RlKHJvd01vZGUpLCBFcnJvckNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfUk9XX01PREUsIEpTT04uc3RyaW5naWZ5KHJvd01vZGUpKTtcbn07XG5leHBvcnRzLkFSUkFZID0gQVJSQVk7XG5leHBvcnRzLk9CSkVDVCA9IE9CSkVDVDtcbmV4cG9ydHMuT0JKRUNUX1dJVEhfUkVOQU1FRF9EVVBMSUNBVEVEX0NPTFVNTlMgPSBPQkpFQ1RfV0lUSF9SRU5BTUVEX0RVUExJQ0FURURfQ09MVU1OUztcbmV4cG9ydHMuaXNWYWxpZFJvd01vZGUgPSBpc1ZhbGlkUm93TW9kZTtcbmV4cG9ydHMuY2hlY2tSb3dNb2RlVmFsaWQgPSBjaGVja1Jvd01vZGVWYWxpZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvd19tb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/row_mode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nexports.paramsNames = Object.freeze({\n    SF_REQUEST_GUID: 'request_guid',\n    SF_REQUEST_ID: 'requestId',\n    SF_TOKEN: 'token',\n    SF_WAREHOUSE_NAME: 'warehouse',\n    SF_DB_NAME: 'databaseName',\n    SF_SCHEMA_NAME: 'schemaName',\n});\n//# sourceMappingURL=sf_params.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb25zdGFudHMvc2ZfcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvY29uc3RhbnRzL3NmX3BhcmFtcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucGFyYW1zTmFtZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBTRl9SRVFVRVNUX0dVSUQ6ICdyZXF1ZXN0X2d1aWQnLFxuICAgIFNGX1JFUVVFU1RfSUQ6ICdyZXF1ZXN0SWQnLFxuICAgIFNGX1RPS0VOOiAndG9rZW4nLFxuICAgIFNGX1dBUkVIT1VTRV9OQU1FOiAnd2FyZWhvdXNlJyxcbiAgICBTRl9EQl9OQU1FOiAnZGF0YWJhc2VOYW1lJyxcbiAgICBTRl9TQ0hFTUFfTkFNRTogJ3NjaGVtYU5hbWUnLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZl9wYXJhbXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/core.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/core.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Connection = __webpack_require__(/*! ./connection/connection */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection.js\");\nconst ConnectionConfig = __webpack_require__(/*! ./connection/connection_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_config.js\");\nconst ConnectionContext = __webpack_require__(/*! ./connection/connection_context */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/connection_context.js\");\nconst GenericPool = __webpack_require__(/*! generic-pool */ \"(rsc)/./node_modules/generic-pool/index.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst LoggerCore = __webpack_require__(/*! ./logger/core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\nconst DataTypes = __webpack_require__(/*! ./connection/result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/result/data_types.js\");\nconst GlobalConfig = __webpack_require__(/*! ./global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst GlobalConfigTyped = (__webpack_require__(/*! ./global_config_typed */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\")[\"default\"]);\nconst { loadConnectionConfiguration } = __webpack_require__(/*! ./configuration/connection_configuration */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/connection_configuration.js\");\n/**\n * Creates a new instance of the Snowflake core module.\n *\n * @param {Object} options\n *\n * @returns {Object}\n * @constructor\n */\nfunction Core(options) {\n    // validate input\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.exists(options.httpClient || options.httpClientClass));\n    Errors.assertInternal(Util.exists(options.loggerClass));\n    // set the logger instance\n    Logger.setInstance(new options.loggerClass());\n    Logger.getInstance().trace('Logger was initialized.');\n    // if a connection class is specified, it must be an object or function\n    let connectionClass = options.connectionClass;\n    if (Util.exists(connectionClass)) {\n        Errors.assertInternal(Util.isObject(connectionClass) || Util.isFunction(connectionClass));\n        Logger.getInstance().debug('Connection class provided in driver core options will be used.');\n    }\n    else {\n        // fall back to Connection\n        connectionClass = Connection;\n        Logger.getInstance().debug('Connection class was not overridden. Default connection class will be used.');\n    }\n    const qaMode = options.qaMode;\n    const clientInfo = options.client;\n    const ocspModes = GlobalConfig.ocspModes;\n    /**\n     * Creates a new Connection instance.\n     *\n     * @param {Object} connectionOptions\n     * @param {Object} [config]\n     *\n     * @returns {Object}\n     */\n    const createConnection = function createConnection(connectionOptions, config) {\n        // create a new ConnectionConfig and skip credential-validation if a config\n        // object has been specified; this is because if a config object has been\n        // specified, we're trying to deserialize a connection and the account name,\n        // username and password don't need to be specified because the config\n        // object already contains the tokens we need\n        // Alternatively, if the connectionOptions includes token information then we will use that\n        // instead of the username/password\n        Logger.getInstance().info('Creating new connection object');\n        if (connectionOptions == null) {\n            Logger.getInstance().info('Connection options were not specified. Loading connection configuration.');\n            try {\n                connectionOptions = loadConnectionConfiguration();\n            }\n            catch (error) {\n                Logger.getInstance().error('Unable to load the connection configuration. Error: %s', error.message);\n                Errors.checkArgumentExists(Util.exists(connectionOptions), ErrorCodes.ERR_CONN_CREATE_MISSING_OPTIONS);\n            }\n        }\n        const validateCredentials = !config && connectionOptions && !connectionOptions.sessionToken;\n        const connectionConfig = new ConnectionConfig(connectionOptions, validateCredentials, qaMode, clientInfo);\n        Logger.getInstance().debug('Connection configuration object created');\n        // if an http client was specified in the options passed to the module, use\n        // it, otherwise create a new HttpClient\n        const httpClient = options.httpClient || new options.httpClientClass(connectionConfig);\n        Logger.getInstance().debug('HttpClient setup finished');\n        const connection = new connectionClass(new ConnectionContext(connectionConfig, httpClient, config));\n        Logger.getInstance().info('Connection[id: %s] - connection object created successfully.', connection.getId());\n        return connection;\n    };\n    const instance = {\n        ocspModes: ocspModes,\n        ErrorCode: ErrorCodes,\n        /**\n         * Creates a connection object that can be used to communicate with\n         * Snowflake.\n         *\n         * @param {Object} options\n         *\n         * @returns {Object}\n         */\n        createConnection: function (options) {\n            return createConnection(options);\n        },\n        /**\n         * Creates a connection pool for Snowflake connections\n         *\n         * @param {Object} connectionOptions\n         * @param {Object} poolOptions\n         *\n         * @returns {Object}\n         */\n        createPool: function (connectionOptions, poolOptions) {\n            return createPool(connectionOptions, poolOptions);\n        },\n        /**\n         * Deserializes a serialized connection.\n         *\n         * @param {Object} options\n         * @param {String} serializedConnection\n         *\n         * @returns {Object}\n         */\n        deserializeConnection: function (options, serializedConnection) {\n            // check for missing serializedConfig\n            Logger.getInstance().trace('Deserializing connection');\n            Errors.checkArgumentExists(Util.exists(serializedConnection), ErrorCodes.ERR_CONN_DESERIALIZE_MISSING_CONFIG);\n            // check for invalid serializedConfig\n            Errors.checkArgumentValid(Util.isString(serializedConnection), ErrorCodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE);\n            Logger.getInstance().debug('Deserializing connection from string object');\n            // try to json-parse serializedConfig\n            let config;\n            try {\n                config = JSON.parse(serializedConnection);\n            }\n            finally {\n                // if serializedConfig can't be parsed to json, throw an error\n                Errors.checkArgumentValid(Util.isObject(config), ErrorCodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM);\n            }\n            Logger.getInstance().debug('Connection deserialized successfully');\n            return createConnection(options, config);\n        },\n        /**\n         * Serializes a given connection.\n         *\n         * @param {Object} connection\n         *\n         * @returns {String} a serialized version of the connection.\n         */\n        serializeConnection: function (connection) {\n            Logger.getInstance().trace('Connection[id: %s] - serializing connection.', connection.getId());\n            return connection ? connection.serialize() : connection;\n        },\n        /**\n         * Configures this instance of the Snowflake core module.\n         *\n         * @param {Object} options\n         */\n        configure: function (options) {\n            Logger.getInstance().debug('Configuring Snowflake core module.');\n            const logLevel = extractLogLevel(options);\n            const logFilePath = options.logFilePath;\n            const additionalLogToConsole = options.additionalLogToConsole;\n            if (logLevel != null || logFilePath) {\n                Logger.getInstance().configure({\n                    level: logLevel,\n                    filePath: logFilePath,\n                    additionalLogToConsole: additionalLogToConsole,\n                });\n                Logger.getInstance().info('Configuring logger with level: %s, filePath: %s, additionalLogToConsole: %s', logLevel, logFilePath, additionalLogToConsole);\n            }\n            GlobalConfigTyped.setValues(options);\n            const disableOCSPChecks = options.disableOCSPChecks;\n            if (Util.exists(disableOCSPChecks)) {\n                // check that the specified value is a boolean\n                Errors.checkArgumentValid(Util.isBoolean(disableOCSPChecks), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS);\n                GlobalConfig.setDisableOCSPChecks(disableOCSPChecks);\n                Logger.getInstance().debug('Setting disableOCSPChecks to value from core options: %s', disableOCSPChecks);\n            }\n            const ocspFailOpen = options.ocspFailOpen;\n            if (Util.exists(ocspFailOpen)) {\n                Errors.checkArgumentValid(Util.isBoolean(ocspFailOpen), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE);\n                GlobalConfig.setOcspFailOpen(ocspFailOpen);\n                Logger.getInstance().debug('Setting ocspFailOpen to value from core options: %s ', ocspFailOpen);\n            }\n            const jsonColumnVariantParser = options.jsonColumnVariantParser;\n            if (Util.exists(jsonColumnVariantParser)) {\n                Errors.checkArgumentValid(Util.isFunction(jsonColumnVariantParser), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER);\n                GlobalConfig.setJsonColumnVariantParser(jsonColumnVariantParser);\n                Logger.getInstance().debug('Setting JSON Column Variant Parser to value from core options');\n            }\n            const xmlColumnVariantParser = options.xmlColumnVariantParser;\n            const xmlParserConfig = options.xmlParserConfig;\n            if (Util.exists(xmlColumnVariantParser)) {\n                Errors.checkArgumentValid(Util.isFunction(xmlColumnVariantParser), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER);\n                GlobalConfig.setXmlColumnVariantParser(xmlColumnVariantParser);\n                Logger.getInstance().debug('Setting XML Column Variant Parser to value from core options');\n            }\n            else if (Util.exists(xmlParserConfig)) {\n                GlobalConfig.createXmlColumnVariantParserWithParameters(xmlParserConfig);\n                Logger.getInstance().debug('Creating XML Column Variant Parser with parameters from core options');\n            }\n            const keepAlive = options.keepAlive;\n            if (Util.exists(keepAlive)) {\n                Errors.checkArgumentValid(Util.isBoolean(keepAlive), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE);\n                GlobalConfig.setKeepAlive(keepAlive);\n                Logger.getInstance().debug('Setting keepAlive to value from core options: %s', keepAlive);\n            }\n            const useEnvProxy = options.useEnvProxy;\n            if (Util.exists(useEnvProxy)) {\n                Errors.checkArgumentValid(Util.isBoolean(useEnvProxy), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY);\n                GlobalConfig.setEnvProxy(useEnvProxy);\n            }\n            const customCredentialManager = options.customCredentialManager;\n            if (Util.exists(customCredentialManager)) {\n                Errors.checkArgumentValid(Util.isObject(customCredentialManager), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER);\n                GlobalConfig.setCustomCredentialManager(customCredentialManager);\n                Logger.getInstance().debug('Setting customCredentialManager to value from core options %s', customCredentialManager);\n            }\n        },\n    };\n    function extractLogLevel(options) {\n        const logTag = options.logLevel;\n        if (Util.exists(logTag)) {\n            Errors.checkArgumentValid(LoggerCore.isValidLogTag(logTag), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL);\n            return LoggerCore.logTagToLevel(logTag);\n        }\n        return null;\n    }\n    // add some read-only constants\n    const nativeTypeValues = DataTypes.NativeTypes.values;\n    Object.defineProperties(instance, {\n        STRING: { value: nativeTypeValues.STRING },\n        BOOLEAN: { value: nativeTypeValues.BOOLEAN },\n        NUMBER: { value: nativeTypeValues.NUMBER },\n        DATE: { value: nativeTypeValues.DATE },\n        OBJECT: { value: nativeTypeValues.OBJECT },\n        ARRAY: { value: nativeTypeValues.ARRAY },\n        MAP: { value: nativeTypeValues.MAP },\n        JSON: { value: nativeTypeValues.JSON },\n    });\n    /**\n     * Factory for Snowflake connections based on Generic Pool\n     *\n     * @param {Object} connectionOptions\n     *\n     * @returns {null}\n     */\n    function ConnectionFactory(connectionOptions) {\n        /**\n         * Creates a new connection instance.\n         *\n         * @returns {Object}\n         */\n        this.create = function () {\n            Logger.getInstance().debug('Creating new connection from factory.');\n            const connection = new createConnection(connectionOptions);\n            return new Promise((resolve, reject) => {\n                connection.connect(function (err, conn) {\n                    if (err) {\n                        Logger.getInstance().error('Connection[id: %s] - Unable to connect. Error: %s', conn.getId(), err.message);\n                        reject(new Error(err.message));\n                    }\n                    else {\n                        Logger.getInstance().debug('Connection[id: %s] - connected successfully. Callback called.', conn.getId());\n                        resolve(conn);\n                    }\n                });\n            });\n        };\n        /**\n         * Destroys the specified connection instance.\n         *\n         * @param {Object} connection\n         *\n         * @returns {Object}\n         */\n        this.destroy = function (connection) {\n            Logger.getInstance().debug('Destroying connection instance.');\n            return new Promise((resolve) => {\n                connection.destroy(function (err, conn) {\n                    if (err) {\n                        Logger.getInstance().error('Connection[id: %s] - disconnecting failed with error: %s', conn.getId(), err.message);\n                    }\n                    else {\n                        Logger.getInstance().debug('Connection[id: %s] - connection disconnected successfully. Callback called.', conn.getId());\n                    }\n                    resolve();\n                });\n            });\n        };\n        /**\n         * Returns the status of the connection.\n         *\n         * @param {Object} connection\n         *\n         * @returns {Boolean}\n         */\n        this.validate = async function (connection) {\n            Logger.getInstance().debug('Connection[id: %s] - validating connection instance', connection.getId());\n            return await connection.isValidAsync();\n        };\n    }\n    /**\n     * Creates a connection pool for Snowflake connections\n     *\n     * @param {Object} connectionOptions\n     * @param {Object} poolOptions\n     *\n     * @returns {Object}\n     */\n    const createPool = function createPool(connectionOptions, poolOptions) {\n        Logger.getInstance().info('Creating connection pool with provided options');\n        const connectionPool = GenericPool.createPool(new ConnectionFactory(connectionOptions), poolOptions);\n        Logger.getInstance().debug('Base for connection pool created');\n        // avoid infinite loop if factory creation fails\n        connectionPool.on('factoryCreateError', function (err) {\n            Logger.getInstance().error('Connection pool factory creation failed: %s', err.message);\n            const clientResourceRequest = connectionPool._waitingClientsQueue.dequeue();\n            if (clientResourceRequest) {\n                clientResourceRequest.reject(err);\n            }\n        });\n        Logger.getInstance().info('Connection pool object created successfully');\n        return connectionPool;\n    };\n    return instance;\n}\nmodule.exports = Core;\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHFHQUF5QjtBQUNwRCx5QkFBeUIsbUJBQU8sQ0FBQyxtSEFBZ0M7QUFDakUsMEJBQTBCLG1CQUFPLENBQUMscUhBQWlDO0FBQ25FLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBZTtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxtSEFBZ0M7QUFDMUQscUJBQXFCLG1CQUFPLENBQUMscUZBQWlCO0FBQzlDLDBCQUEwQixtSUFBd0M7QUFDbEUsUUFBUSw4QkFBOEIsRUFBRSxtQkFBTyxDQUFDLHVJQUEwQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQsbUJBQW1CLGlDQUFpQztBQUNwRCxrQkFBa0IsZ0NBQWdDO0FBQ2xELGdCQUFnQiw4QkFBOEI7QUFDOUMsa0JBQWtCLGdDQUFnQztBQUNsRCxpQkFBaUIsK0JBQStCO0FBQ2hELGVBQWUsNkJBQTZCO0FBQzVDLGdCQUFnQiw4QkFBOEI7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24nKTtcbmNvbnN0IENvbm5lY3Rpb25Db25maWcgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9jb25maWcnKTtcbmNvbnN0IENvbm5lY3Rpb25Db250ZXh0ID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29udGV4dCcpO1xuY29uc3QgR2VuZXJpY1Bvb2wgPSByZXF1aXJlKCdnZW5lcmljLXBvb2wnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jb25zdCBMb2dnZXJDb3JlID0gcmVxdWlyZSgnLi9sb2dnZXIvY29yZScpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRhX3R5cGVzJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IEdsb2JhbENvbmZpZ1R5cGVkID0gcmVxdWlyZSgnLi9nbG9iYWxfY29uZmlnX3R5cGVkJykuZGVmYXVsdDtcbmNvbnN0IHsgbG9hZENvbm5lY3Rpb25Db25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2NvbmZpZ3VyYXRpb24vY29ubmVjdGlvbl9jb25maWd1cmF0aW9uJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFNub3dmbGFrZSBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29yZShvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKG9wdGlvbnMuaHR0cENsaWVudCB8fCBvcHRpb25zLmh0dHBDbGllbnRDbGFzcykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmV4aXN0cyhvcHRpb25zLmxvZ2dlckNsYXNzKSk7XG4gICAgLy8gc2V0IHRoZSBsb2dnZXIgaW5zdGFuY2VcbiAgICBMb2dnZXIuc2V0SW5zdGFuY2UobmV3IG9wdGlvbnMubG9nZ2VyQ2xhc3MoKSk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0xvZ2dlciB3YXMgaW5pdGlhbGl6ZWQuJyk7XG4gICAgLy8gaWYgYSBjb25uZWN0aW9uIGNsYXNzIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb25cbiAgICBsZXQgY29ubmVjdGlvbkNsYXNzID0gb3B0aW9ucy5jb25uZWN0aW9uQ2xhc3M7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNvbm5lY3Rpb25DbGFzcykpIHtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29ubmVjdGlvbkNsYXNzKSB8fCBVdGlsLmlzRnVuY3Rpb24oY29ubmVjdGlvbkNsYXNzKSk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uIGNsYXNzIHByb3ZpZGVkIGluIGRyaXZlciBjb3JlIG9wdGlvbnMgd2lsbCBiZSB1c2VkLicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIENvbm5lY3Rpb25cbiAgICAgICAgY29ubmVjdGlvbkNsYXNzID0gQ29ubmVjdGlvbjtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb24gY2xhc3Mgd2FzIG5vdCBvdmVycmlkZGVuLiBEZWZhdWx0IGNvbm5lY3Rpb24gY2xhc3Mgd2lsbCBiZSB1c2VkLicpO1xuICAgIH1cbiAgICBjb25zdCBxYU1vZGUgPSBvcHRpb25zLnFhTW9kZTtcbiAgICBjb25zdCBjbGllbnRJbmZvID0gb3B0aW9ucy5jbGllbnQ7XG4gICAgY29uc3Qgb2NzcE1vZGVzID0gR2xvYmFsQ29uZmlnLm9jc3BNb2RlcztcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbk9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbk9wdGlvbnMsIGNvbmZpZykge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgQ29ubmVjdGlvbkNvbmZpZyBhbmQgc2tpcCBjcmVkZW50aWFsLXZhbGlkYXRpb24gaWYgYSBjb25maWdcbiAgICAgICAgLy8gb2JqZWN0IGhhcyBiZWVuIHNwZWNpZmllZDsgdGhpcyBpcyBiZWNhdXNlIGlmIGEgY29uZmlnIG9iamVjdCBoYXMgYmVlblxuICAgICAgICAvLyBzcGVjaWZpZWQsIHdlJ3JlIHRyeWluZyB0byBkZXNlcmlhbGl6ZSBhIGNvbm5lY3Rpb24gYW5kIHRoZSBhY2NvdW50IG5hbWUsXG4gICAgICAgIC8vIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBkb24ndCBuZWVkIHRvIGJlIHNwZWNpZmllZCBiZWNhdXNlIHRoZSBjb25maWdcbiAgICAgICAgLy8gb2JqZWN0IGFscmVhZHkgY29udGFpbnMgdGhlIHRva2VucyB3ZSBuZWVkXG4gICAgICAgIC8vIEFsdGVybmF0aXZlbHksIGlmIHRoZSBjb25uZWN0aW9uT3B0aW9ucyBpbmNsdWRlcyB0b2tlbiBpbmZvcm1hdGlvbiB0aGVuIHdlIHdpbGwgdXNlIHRoYXRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgdXNlcm5hbWUvcGFzc3dvcmRcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ3JlYXRpbmcgbmV3IGNvbm5lY3Rpb24gb2JqZWN0Jyk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uT3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uIG9wdGlvbnMgd2VyZSBub3Qgc3BlY2lmaWVkLiBMb2FkaW5nIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbi4nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSBsb2FkQ29ubmVjdGlvbkNvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdVbmFibGUgdG8gbG9hZCB0aGUgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLiBFcnJvcjogJXMnLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhjb25uZWN0aW9uT3B0aW9ucyksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfT1BUSU9OUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRhdGVDcmVkZW50aWFscyA9ICFjb25maWcgJiYgY29ubmVjdGlvbk9wdGlvbnMgJiYgIWNvbm5lY3Rpb25PcHRpb25zLnNlc3Npb25Ub2tlbjtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKGNvbm5lY3Rpb25PcHRpb25zLCB2YWxpZGF0ZUNyZWRlbnRpYWxzLCBxYU1vZGUsIGNsaWVudEluZm8pO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdCBjcmVhdGVkJyk7XG4gICAgICAgIC8vIGlmIGFuIGh0dHAgY2xpZW50IHdhcyBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBtb2R1bGUsIHVzZVxuICAgICAgICAvLyBpdCwgb3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBIdHRwQ2xpZW50XG4gICAgICAgIGNvbnN0IGh0dHBDbGllbnQgPSBvcHRpb25zLmh0dHBDbGllbnQgfHwgbmV3IG9wdGlvbnMuaHR0cENsaWVudENsYXNzKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSHR0cENsaWVudCBzZXR1cCBmaW5pc2hlZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IGNvbm5lY3Rpb25DbGFzcyhuZXcgQ29ubmVjdGlvbkNvbnRleHQoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgY29uZmlnKSk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3Rpb24gb2JqZWN0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LicsIGNvbm5lY3Rpb24uZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICAgIG9jc3BNb2Rlczogb2NzcE1vZGVzLFxuICAgICAgICBFcnJvckNvZGU6IEVycm9yQ29kZXMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29ubmVjdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoXG4gICAgICAgICAqIFNub3dmbGFrZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNvbm5lY3Rpb246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb25uZWN0aW9uIHBvb2wgZm9yIFNub3dmbGFrZSBjb25uZWN0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbk9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvb2xPcHRpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQb29sOiBmdW5jdGlvbiAoY29ubmVjdGlvbk9wdGlvbnMsIHBvb2xPcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUG9vbChjb25uZWN0aW9uT3B0aW9ucywgcG9vbE9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzZXJpYWxpemVzIGEgc2VyaWFsaXplZCBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VyaWFsaXplZENvbm5lY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGRlc2VyaWFsaXplQ29ubmVjdGlvbjogZnVuY3Rpb24gKG9wdGlvbnMsIHNlcmlhbGl6ZWRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBzZXJpYWxpemVkQ29uZmlnXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnRGVzZXJpYWxpemluZyBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhzZXJpYWxpemVkQ29ubmVjdGlvbiksIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTRVJJQUxJWkVfTUlTU0lOR19DT05GSUcpO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgc2VyaWFsaXplZENvbmZpZ1xuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHNlcmlhbGl6ZWRDb25uZWN0aW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9ERVNFUklBTElaRV9JTlZBTElEX0NPTkZJR19UWVBFKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdEZXNlcmlhbGl6aW5nIGNvbm5lY3Rpb24gZnJvbSBzdHJpbmcgb2JqZWN0Jyk7XG4gICAgICAgICAgICAvLyB0cnkgdG8ganNvbi1wYXJzZSBzZXJpYWxpemVkQ29uZmlnXG4gICAgICAgICAgICBsZXQgY29uZmlnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHNlcmlhbGl6ZWRDb25maWcgY2FuJ3QgYmUgcGFyc2VkIHRvIGpzb24sIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzT2JqZWN0KGNvbmZpZyksIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfRk9STSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbiBkZXNlcmlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VyaWFsaXplcyBhIGdpdmVuIGNvbm5lY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VyaWFsaXplQ29ubmVjdGlvbjogZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBzZXJpYWxpemluZyBjb25uZWN0aW9uLicsIGNvbm5lY3Rpb24uZ2V0SWQoKSk7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbiA/IGNvbm5lY3Rpb24uc2VyaWFsaXplKCkgOiBjb25uZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGlzIGluc3RhbmNlIG9mIHRoZSBTbm93Zmxha2UgY29yZSBtb2R1bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29uZmlndXJpbmcgU25vd2ZsYWtlIGNvcmUgbW9kdWxlLicpO1xuICAgICAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBleHRyYWN0TG9nTGV2ZWwob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2dGaWxlUGF0aCA9IG9wdGlvbnMubG9nRmlsZVBhdGg7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsTG9nVG9Db25zb2xlID0gb3B0aW9ucy5hZGRpdGlvbmFsTG9nVG9Db25zb2xlO1xuICAgICAgICAgICAgaWYgKGxvZ0xldmVsICE9IG51bGwgfHwgbG9nRmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICBsZXZlbDogbG9nTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBsb2dGaWxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZTogYWRkaXRpb25hbExvZ1RvQ29uc29sZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25maWd1cmluZyBsb2dnZXIgd2l0aCBsZXZlbDogJXMsIGZpbGVQYXRoOiAlcywgYWRkaXRpb25hbExvZ1RvQ29uc29sZTogJXMnLCBsb2dMZXZlbCwgbG9nRmlsZVBhdGgsIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2xvYmFsQ29uZmlnVHlwZWQuc2V0VmFsdWVzKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZGlzYWJsZU9DU1BDaGVja3MgPSBvcHRpb25zLmRpc2FibGVPQ1NQQ2hlY2tzO1xuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKGRpc2FibGVPQ1NQQ2hlY2tzKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKGRpc2FibGVPQ1NQQ2hlY2tzKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0RJU0FCTEVfT0NTUF9DSEVDS1MpO1xuICAgICAgICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXREaXNhYmxlT0NTUENoZWNrcyhkaXNhYmxlT0NTUENoZWNrcyk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1NldHRpbmcgZGlzYWJsZU9DU1BDaGVja3MgdG8gdmFsdWUgZnJvbSBjb3JlIG9wdGlvbnM6ICVzJywgZGlzYWJsZU9DU1BDaGVja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2NzcEZhaWxPcGVuID0gb3B0aW9ucy5vY3NwRmFpbE9wZW47XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob2NzcEZhaWxPcGVuKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob2NzcEZhaWxPcGVuKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX09DU1BfTU9ERSk7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldE9jc3BGYWlsT3BlbihvY3NwRmFpbE9wZW4pO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIG9jc3BGYWlsT3BlbiB0byB2YWx1ZSBmcm9tIGNvcmUgb3B0aW9uczogJXMgJywgb2NzcEZhaWxPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGpzb25Db2x1bW5WYXJpYW50UGFyc2VyID0gb3B0aW9ucy5qc29uQ29sdW1uVmFyaWFudFBhcnNlcjtcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhqc29uQ29sdW1uVmFyaWFudFBhcnNlcikpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNGdW5jdGlvbihqc29uQ29sdW1uVmFyaWFudFBhcnNlciksIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9KU09OX1BBUlNFUik7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLnNldEpzb25Db2x1bW5WYXJpYW50UGFyc2VyKGpzb25Db2x1bW5WYXJpYW50UGFyc2VyKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBKU09OIENvbHVtbiBWYXJpYW50IFBhcnNlciB0byB2YWx1ZSBmcm9tIGNvcmUgb3B0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeG1sQ29sdW1uVmFyaWFudFBhcnNlciA9IG9wdGlvbnMueG1sQ29sdW1uVmFyaWFudFBhcnNlcjtcbiAgICAgICAgICAgIGNvbnN0IHhtbFBhcnNlckNvbmZpZyA9IG9wdGlvbnMueG1sUGFyc2VyQ29uZmlnO1xuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHhtbENvbHVtblZhcmlhbnRQYXJzZXIpKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzRnVuY3Rpb24oeG1sQ29sdW1uVmFyaWFudFBhcnNlciksIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9YTUxfUEFSU0VSKTtcbiAgICAgICAgICAgICAgICBHbG9iYWxDb25maWcuc2V0WG1sQ29sdW1uVmFyaWFudFBhcnNlcih4bWxDb2x1bW5WYXJpYW50UGFyc2VyKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBYTUwgQ29sdW1uIFZhcmlhbnQgUGFyc2VyIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChVdGlsLmV4aXN0cyh4bWxQYXJzZXJDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgR2xvYmFsQ29uZmlnLmNyZWF0ZVhtbENvbHVtblZhcmlhbnRQYXJzZXJXaXRoUGFyYW1ldGVycyh4bWxQYXJzZXJDb25maWcpO1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDcmVhdGluZyBYTUwgQ29sdW1uIFZhcmlhbnQgUGFyc2VyIHdpdGggcGFyYW1ldGVycyBmcm9tIGNvcmUgb3B0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2VlcEFsaXZlID0gb3B0aW9ucy5rZWVwQWxpdmU7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoa2VlcEFsaXZlKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oa2VlcEFsaXZlKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0tFRVBfQUxJVkUpO1xuICAgICAgICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXRLZWVwQWxpdmUoa2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBrZWVwQWxpdmUgdG8gdmFsdWUgZnJvbSBjb3JlIG9wdGlvbnM6ICVzJywga2VlcEFsaXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVzZUVudlByb3h5ID0gb3B0aW9ucy51c2VFbnZQcm94eTtcbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyh1c2VFbnZQcm94eSkpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHVzZUVudlByb3h5KSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1VTRV9FTlZfUFJPWFkpO1xuICAgICAgICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXRFbnZQcm94eSh1c2VFbnZQcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXN0b21DcmVkZW50aWFsTWFuYWdlciA9IG9wdGlvbnMuY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXI7XG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpKSB7XG4gICAgICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzT2JqZWN0KGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0NVU1RPTV9DUkVERU5USUFMX01BTkFHRVIpO1xuICAgICAgICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXRDdXN0b21DcmVkZW50aWFsTWFuYWdlcihjdXN0b21DcmVkZW50aWFsTWFuYWdlcik7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1NldHRpbmcgY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIgdG8gdmFsdWUgZnJvbSBjb3JlIG9wdGlvbnMgJXMnLCBjdXN0b21DcmVkZW50aWFsTWFuYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBleHRyYWN0TG9nTGV2ZWwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBsb2dUYWcgPSBvcHRpb25zLmxvZ0xldmVsO1xuICAgICAgICBpZiAoVXRpbC5leGlzdHMobG9nVGFnKSkge1xuICAgICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChMb2dnZXJDb3JlLmlzVmFsaWRMb2dUYWcobG9nVGFnKSwgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0xPR19MRVZFTCk7XG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyQ29yZS5sb2dUYWdUb0xldmVsKGxvZ1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGFkZCBzb21lIHJlYWQtb25seSBjb25zdGFudHNcbiAgICBjb25zdCBuYXRpdmVUeXBlVmFsdWVzID0gRGF0YVR5cGVzLk5hdGl2ZVR5cGVzLnZhbHVlcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0YW5jZSwge1xuICAgICAgICBTVFJJTkc6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuU1RSSU5HIH0sXG4gICAgICAgIEJPT0xFQU46IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuQk9PTEVBTiB9LFxuICAgICAgICBOVU1CRVI6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuTlVNQkVSIH0sXG4gICAgICAgIERBVEU6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuREFURSB9LFxuICAgICAgICBPQkpFQ1Q6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuT0JKRUNUIH0sXG4gICAgICAgIEFSUkFZOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLkFSUkFZIH0sXG4gICAgICAgIE1BUDogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5NQVAgfSxcbiAgICAgICAgSlNPTjogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5KU09OIH0sXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBmb3IgU25vd2ZsYWtlIGNvbm5lY3Rpb25zIGJhc2VkIG9uIEdlbmVyaWMgUG9vbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25PcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uRmFjdG9yeShjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ3JlYXRpbmcgbmV3IGNvbm5lY3Rpb24gZnJvbSBmYWN0b3J5LicpO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBjcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KGZ1bmN0aW9uIChlcnIsIGNvbm4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFVuYWJsZSB0byBjb25uZWN0LiBFcnJvcjogJXMnLCBjb25uLmdldElkKCksIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5LiBDYWxsYmFjayBjYWxsZWQuJywgY29ubi5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29ubik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIHNwZWNpZmllZCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdEZXN0cm95aW5nIGNvbm5lY3Rpb24gaW5zdGFuY2UuJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmRlc3Ryb3koZnVuY3Rpb24gKGVyciwgY29ubikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gZGlzY29ubmVjdGluZyBmYWlsZWQgd2l0aCBlcnJvcjogJXMnLCBjb25uLmdldElkKCksIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0aW9uIGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHkuIENhbGxiYWNrIGNhbGxlZC4nLCBjb25uLmdldElkKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSBhc3luYyBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHZhbGlkYXRpbmcgY29ubmVjdGlvbiBpbnN0YW5jZScsIGNvbm5lY3Rpb24uZ2V0SWQoKSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5pc1ZhbGlkQXN5bmMoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbm5lY3Rpb24gcG9vbCBmb3IgU25vd2ZsYWtlIGNvbm5lY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbk9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9vbE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlUG9vbCA9IGZ1bmN0aW9uIGNyZWF0ZVBvb2woY29ubmVjdGlvbk9wdGlvbnMsIHBvb2xPcHRpb25zKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0NyZWF0aW5nIGNvbm5lY3Rpb24gcG9vbCB3aXRoIHByb3ZpZGVkIG9wdGlvbnMnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblBvb2wgPSBHZW5lcmljUG9vbC5jcmVhdGVQb29sKG5ldyBDb25uZWN0aW9uRmFjdG9yeShjb25uZWN0aW9uT3B0aW9ucyksIHBvb2xPcHRpb25zKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Jhc2UgZm9yIGNvbm5lY3Rpb24gcG9vbCBjcmVhdGVkJyk7XG4gICAgICAgIC8vIGF2b2lkIGluZmluaXRlIGxvb3AgaWYgZmFjdG9yeSBjcmVhdGlvbiBmYWlsc1xuICAgICAgICBjb25uZWN0aW9uUG9vbC5vbignZmFjdG9yeUNyZWF0ZUVycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb24gcG9vbCBmYWN0b3J5IGNyZWF0aW9uIGZhaWxlZDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRSZXNvdXJjZVJlcXVlc3QgPSBjb25uZWN0aW9uUG9vbC5fd2FpdGluZ0NsaWVudHNRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAoY2xpZW50UmVzb3VyY2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgY2xpZW50UmVzb3VyY2VSZXF1ZXN0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbiBwb29sIG9iamVjdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvblBvb2w7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/disk_cache.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultCacheDir = getDefaultCacheDir;\nexports.isFileNotFoundError = isFileNotFoundError;\nexports.createCacheDirIfNotExists = createCacheDirIfNotExists;\nexports.writeCacheFile = writeCacheFile;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst promises_1 = __importDefault(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst os_1 = __importDefault(__webpack_require__(/*! os */ \"os\"));\n// NOTE:\n// Besides this file, there are other entrypoints implementing reading/writing cache files:\n// - global_config.js\n// - authentication/secure_storage/json_credential_manager.js\n//\n// We should refactor the code so every place is using utils from this file\nfunction getDefaultCacheDir() {\n    switch (process.platform) {\n        case 'win32':\n            return path_1.default.join(os_1.default.homedir(), 'AppData', 'Local', 'Snowflake', 'Caches');\n        case 'linux':\n            return path_1.default.join(os_1.default.homedir(), '.cache', 'snowflake');\n        case 'darwin':\n            return path_1.default.join(os_1.default.homedir(), 'Library');\n        default:\n            throw new Error(`Unsupported platform: ${process.platform}`);\n    }\n}\nfunction isFileNotFoundError(error) {\n    return error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT';\n}\nasync function createCacheDirIfNotExists(cacheDir) {\n    const options = { recursive: true };\n    if (process.platform !== 'win32') {\n        options.mode = 0o755;\n    }\n    await promises_1.default.mkdir(cacheDir, options);\n    if (process.platform !== 'win32') {\n        await promises_1.default.chmod(cacheDir, 0o700);\n    }\n}\nasync function writeCacheFile(filePath, content) {\n    const dirName = path_1.default.dirname(filePath);\n    await createCacheDirIfNotExists(dirName);\n    await promises_1.default.writeFile(filePath, content);\n    if (process.platform !== 'win32') {\n        await promises_1.default.chmod(filePath, 0o600);\n    }\n}\n//# sourceMappingURL=disk_cache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9kaXNrX2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDLG1DQUFtQyxtQkFBTyxDQUFDLGdDQUFhO0FBQ3hELDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZGlza19jYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdENhY2hlRGlyID0gZ2V0RGVmYXVsdENhY2hlRGlyO1xuZXhwb3J0cy5pc0ZpbGVOb3RGb3VuZEVycm9yID0gaXNGaWxlTm90Rm91bmRFcnJvcjtcbmV4cG9ydHMuY3JlYXRlQ2FjaGVEaXJJZk5vdEV4aXN0cyA9IGNyZWF0ZUNhY2hlRGlySWZOb3RFeGlzdHM7XG5leHBvcnRzLndyaXRlQ2FjaGVGaWxlID0gd3JpdGVDYWNoZUZpbGU7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgcHJvbWlzZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnMvcHJvbWlzZXNcIikpO1xuY29uc3Qgb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwib3NcIikpO1xuLy8gTk9URTpcbi8vIEJlc2lkZXMgdGhpcyBmaWxlLCB0aGVyZSBhcmUgb3RoZXIgZW50cnlwb2ludHMgaW1wbGVtZW50aW5nIHJlYWRpbmcvd3JpdGluZyBjYWNoZSBmaWxlczpcbi8vIC0gZ2xvYmFsX2NvbmZpZy5qc1xuLy8gLSBhdXRoZW50aWNhdGlvbi9zZWN1cmVfc3RvcmFnZS9qc29uX2NyZWRlbnRpYWxfbWFuYWdlci5qc1xuLy9cbi8vIFdlIHNob3VsZCByZWZhY3RvciB0aGUgY29kZSBzbyBldmVyeSBwbGFjZSBpcyB1c2luZyB1dGlscyBmcm9tIHRoaXMgZmlsZVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENhY2hlRGlyKCkge1xuICAgIHN3aXRjaCAocHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgICAgICBjYXNlICd3aW4zMic6XG4gICAgICAgICAgICByZXR1cm4gcGF0aF8xLmRlZmF1bHQuam9pbihvc18xLmRlZmF1bHQuaG9tZWRpcigpLCAnQXBwRGF0YScsICdMb2NhbCcsICdTbm93Zmxha2UnLCAnQ2FjaGVzJyk7XG4gICAgICAgIGNhc2UgJ2xpbnV4JzpcbiAgICAgICAgICAgIHJldHVybiBwYXRoXzEuZGVmYXVsdC5qb2luKG9zXzEuZGVmYXVsdC5ob21lZGlyKCksICcuY2FjaGUnLCAnc25vd2ZsYWtlJyk7XG4gICAgICAgIGNhc2UgJ2Rhcndpbic6XG4gICAgICAgICAgICByZXR1cm4gcGF0aF8xLmRlZmF1bHQuam9pbihvc18xLmRlZmF1bHQuaG9tZWRpcigpLCAnTGlicmFyeScpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwbGF0Zm9ybTogJHtwcm9jZXNzLnBsYXRmb3JtfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRmlsZU5vdEZvdW5kRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAnY29kZScgaW4gZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCc7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVDYWNoZURpcklmTm90RXhpc3RzKGNhY2hlRGlyKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgcmVjdXJzaXZlOiB0cnVlIH07XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgb3B0aW9ucy5tb2RlID0gMG83NTU7XG4gICAgfVxuICAgIGF3YWl0IHByb21pc2VzXzEuZGVmYXVsdC5ta2RpcihjYWNoZURpciwgb3B0aW9ucyk7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZXNfMS5kZWZhdWx0LmNobW9kKGNhY2hlRGlyLCAwbzcwMCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd3JpdGVDYWNoZUZpbGUoZmlsZVBhdGgsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBkaXJOYW1lID0gcGF0aF8xLmRlZmF1bHQuZGlybmFtZShmaWxlUGF0aCk7XG4gICAgYXdhaXQgY3JlYXRlQ2FjaGVEaXJJZk5vdEV4aXN0cyhkaXJOYW1lKTtcbiAgICBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQud3JpdGVGaWxlKGZpbGVQYXRoLCBjb250ZW50KTtcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuICAgICAgICBhd2FpdCBwcm9taXNlc18xLmRlZmF1bHQuY2htb2QoZmlsZVBhdGgsIDBvNjAwKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNrX2NhY2hlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/error_code.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/error_code.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"ERR_INTERNAL_ASSERT_FAILED\"] = 400001] = \"ERR_INTERNAL_ASSERT_FAILED\";\n    ErrorCode[ErrorCode[\"ERR_UNSUPPORTED_NODE_JS_VERSION\"] = 400002] = \"ERR_UNSUPPORTED_NODE_JS_VERSION\";\n    // 401001\n    ErrorCode[ErrorCode[\"ERR_SF_NETWORK_COULD_NOT_CONNECT\"] = 401001] = \"ERR_SF_NETWORK_COULD_NOT_CONNECT\";\n    ErrorCode[ErrorCode[\"ERR_SF_RESPONSE_FAILURE\"] = 401002] = \"ERR_SF_RESPONSE_FAILURE\";\n    ErrorCode[ErrorCode[\"ERR_SF_RESPONSE_NOT_JSON\"] = 401003] = \"ERR_SF_RESPONSE_NOT_JSON\";\n    ErrorCode[ErrorCode[\"ERR_SF_RESPONSE_INVALID_TOKEN\"] = 401004] = \"ERR_SF_RESPONSE_INVALID_TOKEN\";\n    // 402001\n    ErrorCode[ErrorCode[\"ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT\"] = 402001] = \"ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT\";\n    ErrorCode[ErrorCode[\"ERR_LARGE_RESULT_SET_RESPONSE_FAILURE\"] = 402002] = \"ERR_LARGE_RESULT_SET_RESPONSE_FAILURE\";\n    // 403001\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL\"] = 403001] = \"ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS\"] = 403002] = \"ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE\"] = 403003] = \"ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER\"] = 403004] = \"ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER\"] = 403005] = \"ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE\"] = 403006] = \"ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER\"] = 403007] = \"ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER\";\n    ErrorCode[ErrorCode[\"ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY\"] = 403008] = \"ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY\";\n    // 404001\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_OPTIONS\"] = 404001] = \"ERR_CONN_CREATE_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OPTIONS\"] = 404002] = \"ERR_CONN_CREATE_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_USERNAME\"] = 404003] = \"ERR_CONN_CREATE_MISSING_USERNAME\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_USERNAME\"] = 404004] = \"ERR_CONN_CREATE_INVALID_USERNAME\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PASSWORD\"] = 404005] = \"ERR_CONN_CREATE_MISSING_PASSWORD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PASSWORD\"] = 404006] = \"ERR_CONN_CREATE_INVALID_PASSWORD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_ACCOUNT\"] = 404007] = \"ERR_CONN_CREATE_MISSING_ACCOUNT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ACCOUNT\"] = 404008] = \"ERR_CONN_CREATE_INVALID_ACCOUNT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_ACCESS_URL\"] = 404009] = \"ERR_CONN_CREATE_MISSING_ACCESS_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ACCESS_URL\"] = 404010] = \"ERR_CONN_CREATE_INVALID_ACCESS_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_WAREHOUSE\"] = 404011] = \"ERR_CONN_CREATE_INVALID_WAREHOUSE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DATABASE\"] = 404012] = \"ERR_CONN_CREATE_INVALID_DATABASE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_SCHEMA\"] = 404013] = \"ERR_CONN_CREATE_INVALID_SCHEMA\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ROLE\"] = 404014] = \"ERR_CONN_CREATE_INVALID_ROLE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_HOST\"] = 404015] = \"ERR_CONN_CREATE_MISSING_PROXY_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_HOST\"] = 404016] = \"ERR_CONN_CREATE_INVALID_PROXY_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_PORT\"] = 404017] = \"ERR_CONN_CREATE_MISSING_PROXY_PORT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_PORT\"] = 404018] = \"ERR_CONN_CREATE_INVALID_PROXY_PORT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_STREAM_RESULT\"] = 404019] = \"ERR_CONN_CREATE_INVALID_STREAM_RESULT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING\"] = 404020] = \"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES\"] = 404021] = \"ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_REGION\"] = 404022] = \"ERR_CONN_CREATE_INVALID_REGION\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_KEEP_ALIVE\"] = 404023] = \"ERR_CONN_CREATE_INVALID_KEEP_ALIVE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ\"] = 404024] = \"ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT\"] = 404025] = \"ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PRIVATE_KEY\"] = 404026] = \"ERR_CONN_CREATE_INVALID_PRIVATE_KEY\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH\"] = 404027] = \"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS\"] = 404028] = \"ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OAUTH_TOKEN\"] = 404029] = \"ERR_CONN_CREATE_INVALID_OAUTH_TOKEN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS\"] = 404030] = \"ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_APPLICATION\"] = 404031] = \"ERR_CONN_CREATE_INVALID_APPLICATION\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_USER\"] = 404032] = \"ERR_CONN_CREATE_MISSING_PROXY_USER\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_USER\"] = 404033] = \"ERR_CONN_CREATE_INVALID_PROXY_USER\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PROXY_PASS\"] = 404034] = \"ERR_CONN_CREATE_MISSING_PROXY_PASS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PROXY_PASS\"] = 404035] = \"ERR_CONN_CREATE_INVALID_PROXY_PASS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_NO_PROXY\"] = 404036] = \"ERR_CONN_CREATE_INVALID_NO_PROXY\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD\"] = 404037] = \"ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL\"] = 404038] = \"ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR\"] = 404039] = \"ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT\"] = 404040] = \"ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE\"] = 404041] = \"ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON\"] = 404042] = \"ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE\"] = 404043] = \"ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_RETRY_TIMEOUT\"] = 404044] = \"ERR_CONN_CREATE_INVALID_RETRY_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX\"] = 404045] = \"ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_REGION_REGEX\"] = 404046] = \"ERR_CONN_CREATE_INVALID_REGION_REGEX\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN\"] = 404047] = \"ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL\"] = 404048] = \"ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL\"] = 404049] = \"ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL\"] = 404050] = \"ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK\"] = 404051] = \"ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN\"] = 404052] = \"ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_HOST\"] = 404053] = \"ERR_CONN_CREATE_MISSING_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_HOST\"] = 404054] = \"ERR_CONN_CREATE_INVALID_HOST\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD\"] = 404055] = \"ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_PASSCODE\"] = 404056] = \"ERR_CONN_CREATE_INVALID_PASSCODE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_MISSING_PASSWORD_AND_TOKEN\"] = 404057] = \"ERR_CONN_CREATE_MISSING_PASSWORD_AND_TOKEN\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL\"] = 404058] = \"ERR_CONN_CREATE_INVALID_OUATH_AUTHORIZATION_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID\"] = 404059] = \"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET\"] = 404060] = \"ERR_CONN_CREATE_INVALID_OUATH_CLIENT_SECRET\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL\"] = 404061] = \"ERR_CONN_CREATE_INVALID_OUATH_TOKEN_REQUEST_URL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS\"] = 404062] = \"ERR_CONN_CREATE_INVALID_WORKLOAD_IDENTITY_PARAMETERS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_QUERY_TAG\"] = 404063] = \"ERR_CONN_CREATE_INVALID_QUERY_TAG\";\n    // 405001\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_INVALID_CALLBACK\"] = 405001] = \"ERR_CONN_CONNECT_INVALID_CALLBACK\";\n    // 405501\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_STATUS_CONNECTING\"] = 405501] = \"ERR_CONN_CONNECT_STATUS_CONNECTING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_STATUS_CONNECTED\"] = 405502] = \"ERR_CONN_CONNECT_STATUS_CONNECTED\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_STATUS_DISCONNECTED\"] = 405503] = \"ERR_CONN_CONNECT_STATUS_DISCONNECTED\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_AUTH_CONNECT\"] = 405504] = \"ERR_CONN_CREATE_INVALID_AUTH_CONNECT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG\"] = 405505] = \"ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED\"] = 405506] = \"ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED\";\n    ErrorCode[ErrorCode[\"ERR_CONN_CREATE_AUTH_NOT_ALLOWED\"] = 405507] = \"ERR_CONN_CREATE_AUTH_NOT_ALLOWED\";\n    // 406001\n    ErrorCode[ErrorCode[\"ERR_CONN_DESTROY_INVALID_CALLBACK\"] = 406001] = \"ERR_CONN_DESTROY_INVALID_CALLBACK\";\n    // 406501\n    ErrorCode[ErrorCode[\"ERR_CONN_DESTROY_STATUS_PRISTINE\"] = 406501] = \"ERR_CONN_DESTROY_STATUS_PRISTINE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_DESTROY_STATUS_DISCONNECTED\"] = 406502] = \"ERR_CONN_DESTROY_STATUS_DISCONNECTED\";\n    // 407001\n    ErrorCode[ErrorCode[\"ERR_CONN_REQUEST_STATUS_PRISTINE\"] = 407001] = \"ERR_CONN_REQUEST_STATUS_PRISTINE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_REQUEST_STATUS_DISCONNECTED\"] = 407002] = \"ERR_CONN_REQUEST_STATUS_DISCONNECTED\";\n    // 408001\n    ErrorCode[ErrorCode[\"ERR_CONN_DESERIALIZE_MISSING_CONFIG\"] = 408001] = \"ERR_CONN_DESERIALIZE_MISSING_CONFIG\";\n    ErrorCode[ErrorCode[\"ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE\"] = 408002] = \"ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM\"] = 408003] = \"ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM\";\n    // 409001\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_MISSING_OPTIONS\"] = 409001] = \"ERR_CONN_EXEC_STMT_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_OPTIONS\"] = 409002] = \"ERR_CONN_EXEC_STMT_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT\"] = 409003] = \"ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT\"] = 409004] = \"ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_INTERNAL\"] = 409005] = \"ERR_CONN_EXEC_STMT_INVALID_INTERNAL\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_PARAMETERS\"] = 409006] = \"ERR_CONN_EXEC_STMT_INVALID_PARAMETERS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_BINDS\"] = 409007] = \"ERR_CONN_EXEC_STMT_INVALID_BINDS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES\"] = 409008] = \"ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_COMPLETE\"] = 409009] = \"ERR_CONN_EXEC_STMT_INVALID_COMPLETE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT\"] = 409010] = \"ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING\"] = 409011] = \"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES\"] = 409012] = \"ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID\"] = 409013] = \"ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC\"] = 409014] = \"ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC\";\n    ErrorCode[ErrorCode[\"ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY\"] = 409015] = \"ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY\";\n    // 410001\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_MISSING_OPTIONS\"] = 410001] = \"ERR_CONN_FETCH_RESULT_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_OPTIONS\"] = 410002] = \"ERR_CONN_FETCH_RESULT_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID\"] = 410003] = \"ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID\"] = 410004] = \"ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_COMPLETE\"] = 410005] = \"ERR_CONN_FETCH_RESULT_INVALID_COMPLETE\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT\"] = 410006] = \"ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING\"] = 410007] = \"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES\"] = 410008] = \"ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_CONN_FETCH_RESULT_INVALID_CWD\"] = 410009] = \"ERR_CONN_FETCH_RESULT_INVALID_CWD\";\n    // 411001\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_OPTIONS\"] = 411001] = \"ERR_STMT_STREAM_ROWS_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_START\"] = 411002] = \"ERR_STMT_STREAM_ROWS_INVALID_START\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_END\"] = 411003] = \"ERR_STMT_STREAM_ROWS_INVALID_END\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING\"] = 411004] = \"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES\"] = 411005] = \"ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES\";\n    ErrorCode[ErrorCode[\"ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE\"] = 411006] = \"ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE\";\n    // 412001\n    ErrorCode[ErrorCode[\"ERR_OCSP_REVOKED\"] = 412001] = \"ERR_OCSP_REVOKED\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_UNKNOWN\"] = 412002] = \"ERR_OCSP_UNKNOWN\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_NO_SIGNATURE_ALGORITHM\"] = 412003] = \"ERR_OCSP_NO_SIGNATURE_ALGORITHM\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_INVALID_SIGNATURE\"] = 412004] = \"ERR_OCSP_INVALID_SIGNATURE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_NO_RESPONSE\"] = 412005] = \"ERR_OCSP_NO_RESPONSE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_INVALID_VALIDITY\"] = 412006] = \"ERR_OCSP_INVALID_VALIDITY\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_UNKNOWN_STATE\"] = 412007] = \"ERR_OCSP_UNKNOWN_STATE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_NOT_TWO_ELEMENTS\"] = 412008] = \"ERR_OCSP_NOT_TWO_ELEMENTS\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_CACHE_EXPIRED\"] = 412009] = \"ERR_OCSP_CACHE_EXPIRED\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_FAILED_PARSE_RESPONSE\"] = 412010] = \"ERR_OCSP_FAILED_PARSE_RESPONSE\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_INVALID_CERTIFICATE_VALIDITY\"] = 412011] = \"ERR_OCSP_INVALID_CERTIFICATE_VALIDITY\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_RESPONDER_TIMEOUT\"] = 412012] = \"ERR_OCSP_RESPONDER_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_CACHE_SERVER_TIMEOUT\"] = 412013] = \"ERR_OCSP_CACHE_SERVER_TIMEOUT\";\n    ErrorCode[ErrorCode[\"ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE\"] = 412014] = \"ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE\";\n    ErrorCode[ErrorCode[\"ERR_CRL_ERROR\"] = 413001] = \"ERR_CRL_ERROR\";\n    // 450001\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_MISSING_OPTIONS\"] = 450001] = \"ERR_STMT_FETCH_ROWS_MISSING_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_INVALID_OPTIONS\"] = 450002] = \"ERR_STMT_FETCH_ROWS_INVALID_OPTIONS\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_MISSING_EACH\"] = 450003] = \"ERR_STMT_FETCH_ROWS_MISSING_EACH\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_INVALID_EACH\"] = 450004] = \"ERR_STMT_FETCH_ROWS_INVALID_EACH\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_MISSING_END\"] = 450005] = \"ERR_STMT_FETCH_ROWS_MISSING_END\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_INVALID_END\"] = 450006] = \"ERR_STMT_FETCH_ROWS_INVALID_END\";\n    ErrorCode[ErrorCode[\"ERR_STMT_FETCH_ROWS_FETCHING_RESULT\"] = 450007] = \"ERR_STMT_FETCH_ROWS_FETCHING_RESULT\";\n    // 460001\n    ErrorCode[ErrorCode[\"ERR_GET_RESPONSE_QUERY_INVALID_UUID\"] = 460001] = \"ERR_GET_RESPONSE_QUERY_INVALID_UUID\";\n    ErrorCode[ErrorCode[\"ERR_GET_RESULTS_QUERY_ID_NO_DATA\"] = 460002] = \"ERR_GET_RESULTS_QUERY_ID_NO_DATA\";\n    ErrorCode[ErrorCode[\"ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS\"] = 460003] = \"ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS\";\n})(ErrorCode || (ErrorCode = {}));\nexports[\"default\"] = ErrorCode;\n//# sourceMappingURL=error_code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9lcnJvcl9jb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Vycm9yX2NvZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0lOVEVSTkFMX0FTU0VSVF9GQUlMRURcIl0gPSA0MDAwMDFdID0gXCJFUlJfSU5URVJOQUxfQVNTRVJUX0ZBSUxFRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfVU5TVVBQT1JURURfTk9ERV9KU19WRVJTSU9OXCJdID0gNDAwMDAyXSA9IFwiRVJSX1VOU1VQUE9SVEVEX05PREVfSlNfVkVSU0lPTlwiO1xuICAgIC8vIDQwMTAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU0ZfTkVUV09SS19DT1VMRF9OT1RfQ09OTkVDVFwiXSA9IDQwMTAwMV0gPSBcIkVSUl9TRl9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TRl9SRVNQT05TRV9GQUlMVVJFXCJdID0gNDAxMDAyXSA9IFwiRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NGX1JFU1BPTlNFX05PVF9KU09OXCJdID0gNDAxMDAzXSA9IFwiRVJSX1NGX1JFU1BPTlNFX05PVF9KU09OXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TRl9SRVNQT05TRV9JTlZBTElEX1RPS0VOXCJdID0gNDAxMDA0XSA9IFwiRVJSX1NGX1JFU1BPTlNFX0lOVkFMSURfVE9LRU5cIjtcbiAgICAvLyA0MDIwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0xBUkdFX1JFU1VMVF9TRVRfTkVUV09SS19DT1VMRF9OT1RfQ09OTkVDVFwiXSA9IDQwMjAwMV0gPSBcIkVSUl9MQVJHRV9SRVNVTFRfU0VUX05FVFdPUktfQ09VTERfTk9UX0NPTk5FQ1RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0xBUkdFX1JFU1VMVF9TRVRfUkVTUE9OU0VfRkFJTFVSRVwiXSA9IDQwMjAwMl0gPSBcIkVSUl9MQVJHRV9SRVNVTFRfU0VUX1JFU1BPTlNFX0ZBSUxVUkVcIjtcbiAgICAvLyA0MDMwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9MT0dfTEVWRUxcIl0gPSA0MDMwMDFdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0xPR19MRVZFTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0RJU0FCTEVfT0NTUF9DSEVDS1NcIl0gPSA0MDMwMDJdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0RJU0FCTEVfT0NTUF9DSEVDS1NcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9PQ1NQX01PREVcIl0gPSA0MDMwMDNdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX09DU1BfTU9ERVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0pTT05fUEFSU0VSXCJdID0gNDAzMDA0XSA9IFwiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9KU09OX1BBUlNFUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1hNTF9QQVJTRVJcIl0gPSA0MDMwMDVdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1hNTF9QQVJTRVJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9LRUVQX0FMSVZFXCJdID0gNDAzMDA2XSA9IFwiRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9LRUVQX0FMSVZFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfQ1VTVE9NX0NSRURFTlRJQUxfTUFOQUdFUlwiXSA9IDQwMzAwN10gPSBcIkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfQ1VTVE9NX0NSRURFTlRJQUxfTUFOQUdFUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1VTRV9FTlZfUFJPWFlcIl0gPSA0MDMwMDhdID0gXCJFUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1VTRV9FTlZfUFJPWFlcIjtcbiAgICAvLyA0MDQwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfT1BUSU9OU1wiXSA9IDQwNDAwMV0gPSBcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1BUSU9OU1wiXSA9IDQwNDAwMl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfVVNFUk5BTUVcIl0gPSA0MDQwMDNdID0gXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19VU0VSTkFNRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9VU0VSTkFNRVwiXSA9IDQwNDAwNF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1VTRVJOQU1FXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BBU1NXT1JEXCJdID0gNDA0MDA1XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU1dPUkRcIl0gPSA0MDQwMDZdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19BQ0NPVU5UXCJdID0gNDA0MDA3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDT1VOVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NPVU5UXCJdID0gNDA0MDA4XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDT1VOVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19BQ0NFU1NfVVJMXCJdID0gNDA0MDA5XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDRVNTX1VSTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NFU1NfVVJMXCJdID0gNDA0MDEwXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDRVNTX1VSTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XQVJFSE9VU0VcIl0gPSA0MDQwMTFdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XQVJFSE9VU0VcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfREFUQUJBU0VcIl0gPSA0MDQwMTJdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9EQVRBQkFTRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9TQ0hFTUFcIl0gPSA0MDQwMTNdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9TQ0hFTUFcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUk9MRVwiXSA9IDQwNDAxNF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JPTEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfSE9TVFwiXSA9IDQwNDAxNV0gPSBcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX0hPU1RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfSE9TVFwiXSA9IDQwNDAxNl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX0hPU1RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfUE9SVFwiXSA9IDQwNDAxN10gPSBcIkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1BPUlRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfUE9SVFwiXSA9IDQwNDAxOF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX1BPUlRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfU1RSRUFNX1JFU1VMVFwiXSA9IDQwNDAxOV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NUUkVBTV9SRVNVTFRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCJdID0gNDA0MDIwXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIl0gPSA0MDQwMjFdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFR0lPTlwiXSA9IDQwNDAyMl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFR0lPTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFXCJdID0gNDA0MDIzXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfS0VFUF9BTElWRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRXCJdID0gNDA0MDI0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9UUkVBVF9JTlRFR0VSX0FTX0JJR0lOVFwiXSA9IDQwNDAyNV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZXCJdID0gNDA0MDI2XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFUSFwiXSA9IDQwNDAyN10gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZX1BBVEhcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFTU1wiXSA9IDQwNDAyOF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZX1BBU1NcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT0FVVEhfVE9LRU5cIl0gPSA0MDQwMjldID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PQVVUSF9UT0tFTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9WQUxJREFURV9ERUZBVUxUX1BBUkFNRVRFUlNcIl0gPSA0MDQwMzBdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9WQUxJREFURV9ERUZBVUxUX1BBUkFNRVRFUlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVBQTElDQVRJT05cIl0gPSA0MDQwMzFdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUFBMSUNBVElPTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9VU0VSXCJdID0gNDA0MDMyXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfVVNFUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9VU0VSXCJdID0gNDA0MDMzXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfVVNFUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9QQVNTXCJdID0gNDA0MDM0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfUEFTU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QQVNTXCJdID0gNDA0MDM1XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfUEFTU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9OT19QUk9YWVwiXSA9IDQwNDAzNl0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX05PX1BST1hZXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FSUkFZX0JJTkRJTkdfVEhSRVNIT0xEXCJdID0gNDA0MDM3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVJSQVlfQklORElOR19USFJFU0hPTERcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfR0NTX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUxcIl0gPSA0MDQwMzhdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9HQ1NfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GT1JDRV9TVEFHRV9CSU5EX0VSUk9SXCJdID0gNDA0MDM5XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfU1RBR0VfQklORF9FUlJPUlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9CUk9XU0VSX1RJTUVPVVRcIl0gPSA0MDQwNDBdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9CUk9XU0VSX1RJTUVPVVRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRURfUVVFUllfQ09OVEVYVF9DQUNIRVwiXSA9IDQwNDA0MV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVEX1FVRVJZX0NPTlRFWFRfQ0FDSEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfSU5DTFVERV9SRVRSWV9SRUFTT05cIl0gPSA0MDQwNDJdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9JTkNMVURFX1JFVFJZX1JFQVNPTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfQ09ORklHX0ZJTEVcIl0gPSA0MDQwNDNdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfQ09ORklHX0ZJTEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVUUllfVElNRU9VVFwiXSA9IDQwNDA0NF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFVFJZX1RJTUVPVVRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDT1VOVF9SRUdFWFwiXSA9IDQwNDA0NV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ09VTlRfUkVHRVhcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVHSU9OX1JFR0VYXCJdID0gNDA0MDQ2XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVHSU9OX1JFR0VYXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVfQ09OU09MRV9MT0dJTlwiXSA9IDQwNDA0N10gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVfQ09OU09MRV9MT0dJTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9GT1JDRV9HQ1BfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTFwiXSA9IDQwNDA0OF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZPUkNFX0dDUF9VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9TVE9SRV9URU1QT1JBUllfQ1JFREVOVElBTFwiXSA9IDQwNDA0OV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9TVE9SRV9URU1QT1JBUllfQ1JFREVOVElBTFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRVBSRVNFTlRfTlVMTF9BU19TVFJJTkdfTlVMTFwiXSA9IDQwNDA1MF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFUFJFU0VOVF9OVUxMX0FTX1NUUklOR19OVUxMXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVfU0FNTF9VUkxfQ0hFQ0tcIl0gPSA0MDQwNTFdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ESVNBQkxFX1NBTUxfVVJMX0NIRUNLXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9SRVFVRVNUX01GQV9UT0tFTlwiXSA9IDQwNDA1Ml0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9SRVFVRVNUX01GQV9UT0tFTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19IT1NUXCJdID0gNDA0MDUzXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfSE9TVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9IT1NUXCJdID0gNDA0MDU0XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfSE9TVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTQ09ERV9JTl9QQVNTV09SRFwiXSA9IDQwNDA1NV0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NDT0RFX0lOX1BBU1NXT1JEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NDT0RFXCJdID0gNDA0MDU2XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkRfQU5EX1RPS0VOXCJdID0gNDA0MDU3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkRfQU5EX1RPS0VOXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0FVVEhPUklaQVRJT05fVVJMXCJdID0gNDA0MDU4XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQVVUSE9SSVpBVElPTl9VUkxcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQ0xJRU5UX0lEXCJdID0gNDA0MDU5XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfQ0xJRU5UX0lEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX0NMSUVOVF9TRUNSRVRcIl0gPSA0MDQwNjBdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9PVUFUSF9DTElFTlRfU0VDUkVUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09VQVRIX1RPS0VOX1JFUVVFU1RfVVJMXCJdID0gNDA0MDYxXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT1VBVEhfVE9LRU5fUkVRVUVTVF9VUkxcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfV09SS0xPQURfSURFTlRJVFlfUEFSQU1FVEVSU1wiXSA9IDQwNDA2Ml0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1dPUktMT0FEX0lERU5USVRZX1BBUkFNRVRFUlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUVVFUllfVEFHXCJdID0gNDA0MDYzXSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUVVFUllfVEFHXCI7XG4gICAgLy8gNDA1MDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DQUxMQkFDS1wiXSA9IDQwNTAwMV0gPSBcIkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DQUxMQkFDS1wiO1xuICAgIC8vIDQwNTUwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DT05ORUNUX1NUQVRVU19DT05ORUNUSU5HXCJdID0gNDA1NTAxXSA9IFwiRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfQ09OTkVDVElOR1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DT05ORUNUX1NUQVRVU19DT05ORUNURURcIl0gPSA0MDU1MDJdID0gXCJFUlJfQ09OTl9DT05ORUNUX1NUQVRVU19DT05ORUNURURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfRElTQ09OTkVDVEVEXCJdID0gNDA1NTAzXSA9IFwiRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfRElTQ09OTkVDVEVEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FVVEhfQ09OTkVDVFwiXSA9IDQwNTUwNF0gPSBcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FVVEhfQ09OTkVDVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0xJRU5UX0NPTkZJR1wiXSA9IDQwNTUwNV0gPSBcIkVSUl9DT05OX0NPTk5FQ1RfSU5WQUxJRF9DTElFTlRfQ09ORklHXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FVVEhfVU5TVVBQT1JURURcIl0gPSA0MDU1MDZdID0gXCJFUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BVVRIX1VOU1VQUE9SVEVEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0NSRUFURV9BVVRIX05PVF9BTExPV0VEXCJdID0gNDA1NTA3XSA9IFwiRVJSX0NPTk5fQ1JFQVRFX0FVVEhfTk9UX0FMTE9XRURcIjtcbiAgICAvLyA0MDYwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fREVTVFJPWV9JTlZBTElEX0NBTExCQUNLXCJdID0gNDA2MDAxXSA9IFwiRVJSX0NPTk5fREVTVFJPWV9JTlZBTElEX0NBTExCQUNLXCI7XG4gICAgLy8gNDA2NTAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0RFU1RST1lfU1RBVFVTX1BSSVNUSU5FXCJdID0gNDA2NTAxXSA9IFwiRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfUFJJU1RJTkVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfRElTQ09OTkVDVEVEXCJdID0gNDA2NTAyXSA9IFwiRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfRElTQ09OTkVDVEVEXCI7XG4gICAgLy8gNDA3MDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX1JFUVVFU1RfU1RBVFVTX1BSSVNUSU5FXCJdID0gNDA3MDAxXSA9IFwiRVJSX0NPTk5fUkVRVUVTVF9TVEFUVVNfUFJJU1RJTkVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fUkVRVUVTVF9TVEFUVVNfRElTQ09OTkVDVEVEXCJdID0gNDA3MDAyXSA9IFwiRVJSX0NPTk5fUkVRVUVTVF9TVEFUVVNfRElTQ09OTkVDVEVEXCI7XG4gICAgLy8gNDA4MDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0RFU0VSSUFMSVpFX01JU1NJTkdfQ09ORklHXCJdID0gNDA4MDAxXSA9IFwiRVJSX0NPTk5fREVTRVJJQUxJWkVfTUlTU0lOR19DT05GSUdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfVFlQRVwiXSA9IDQwODAwMl0gPSBcIkVSUl9DT05OX0RFU0VSSUFMSVpFX0lOVkFMSURfQ09ORklHX1RZUEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfRk9STVwiXSA9IDQwODAwM10gPSBcIkVSUl9DT05OX0RFU0VSSUFMSVpFX0lOVkFMSURfQ09ORklHX0ZPUk1cIjtcbiAgICAvLyA0MDkwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX01JU1NJTkdfT1BUSU9OU1wiXSA9IDQwOTAwMV0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9NSVNTSU5HX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfT1BUSU9OU1wiXSA9IDQwOTAwMl0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX01JU1NJTkdfU1FMX1RFWFRcIl0gPSA0MDkwMDNdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfTUlTU0lOR19TUUxfVEVYVFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9TUUxfVEVYVFwiXSA9IDQwOTAwNF0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NRTF9URVhUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0lOVEVSTkFMXCJdID0gNDA5MDA1XSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfSU5URVJOQUxcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfUEFSQU1FVEVSU1wiXSA9IDQwOTAwNl0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1BBUkFNRVRFUlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQklORFNcIl0gPSA0MDkwMDddID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EX1ZBTFVFU1wiXSA9IDQwOTAwOF0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0JJTkRfVkFMVUVTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0NPTVBMRVRFXCJdID0gNDA5MDA5XSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQ09NUExFVEVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1RSRUFNX1JFU1VMVFwiXSA9IDQwOTAxMF0gPSBcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NUUkVBTV9SRVNVTFRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCJdID0gNDA5MDExXSA9IFwiRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIl0gPSA0MDkwMTJdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1JFUVVFU1RfSURcIl0gPSA0MDkwMTNdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9SRVFVRVNUX0lEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0FTWU5DX0VYRUNcIl0gPSA0MDkwMTRdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9BU1lOQ19FWEVDXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0RFU0NSSUJFX09OTFlcIl0gPSA0MDkwMTVdID0gXCJFUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9ERVNDUklCRV9PTkxZXCI7XG4gICAgLy8gNDEwMDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX09QVElPTlNcIl0gPSA0MTAwMDFdID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfTUlTU0lOR19PUFRJT05TXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX09QVElPTlNcIl0gPSA0MTAwMDJdID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9PUFRJT05TXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX1FVRVJZX0lEXCJdID0gNDEwMDAzXSA9IFwiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfUVVFUllfSURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfUVVFUllfSURcIl0gPSA0MTAwMDRdID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9RVUVSWV9JRFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9DT01QTEVURVwiXSA9IDQxMDAwNV0gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NPTVBMRVRFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1NUUkVBTV9SRVNVTFRcIl0gPSA0MTAwMDZdID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9TVFJFQU1fUkVTVUxUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR1wiXSA9IDQxMDAwN10gPSBcIkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTXCJdID0gNDEwMDA4XSA9IFwiRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9DV0RcIl0gPSA0MTAwMDldID0gXCJFUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9DV0RcIjtcbiAgICAvLyA0MTEwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9PUFRJT05TXCJdID0gNDExMDAxXSA9IFwiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9PUFRJT05TXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfU1RBUlRcIl0gPSA0MTEwMDJdID0gXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX1NUQVJUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRU5EXCJdID0gNDExMDAzXSA9IFwiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9FTkRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdcIl0gPSA0MTEwMDRdID0gXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX0ZFVENIX0FTX1NUUklOR1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIl0gPSA0MTEwMDVdID0gXCJFUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9ST1dfTU9ERVwiXSA9IDQxMTAwNl0gPSBcIkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfUk9XX01PREVcIjtcbiAgICAvLyA0MTIwMDFcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfUkVWT0tFRFwiXSA9IDQxMjAwMV0gPSBcIkVSUl9PQ1NQX1JFVk9LRURcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfVU5LTk9XTlwiXSA9IDQxMjAwMl0gPSBcIkVSUl9PQ1NQX1VOS05PV05cIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfTk9fU0lHTkFUVVJFX0FMR09SSVRITVwiXSA9IDQxMjAwM10gPSBcIkVSUl9PQ1NQX05PX1NJR05BVFVSRV9BTEdPUklUSE1cIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfSU5WQUxJRF9TSUdOQVRVUkVcIl0gPSA0MTIwMDRdID0gXCJFUlJfT0NTUF9JTlZBTElEX1NJR05BVFVSRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9OT19SRVNQT05TRVwiXSA9IDQxMjAwNV0gPSBcIkVSUl9PQ1NQX05PX1JFU1BPTlNFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX0lOVkFMSURfVkFMSURJVFlcIl0gPSA0MTIwMDZdID0gXCJFUlJfT0NTUF9JTlZBTElEX1ZBTElESVRZXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX1VOS05PV05fU1RBVEVcIl0gPSA0MTIwMDddID0gXCJFUlJfT0NTUF9VTktOT1dOX1NUQVRFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX05PVF9UV09fRUxFTUVOVFNcIl0gPSA0MTIwMDhdID0gXCJFUlJfT0NTUF9OT1RfVFdPX0VMRU1FTlRTXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX0NBQ0hFX0VYUElSRURcIl0gPSA0MTIwMDldID0gXCJFUlJfT0NTUF9DQUNIRV9FWFBJUkVEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX0ZBSUxFRF9QQVJTRV9SRVNQT05TRVwiXSA9IDQxMjAxMF0gPSBcIkVSUl9PQ1NQX0ZBSUxFRF9QQVJTRV9SRVNQT05TRVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9JTlZBTElEX0NFUlRJRklDQVRFX1ZBTElESVRZXCJdID0gNDEyMDExXSA9IFwiRVJSX09DU1BfSU5WQUxJRF9DRVJUSUZJQ0FURV9WQUxJRElUWVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfT0NTUF9SRVNQT05ERVJfVElNRU9VVFwiXSA9IDQxMjAxMl0gPSBcIkVSUl9PQ1NQX1JFU1BPTkRFUl9USU1FT1VUXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9PQ1NQX0NBQ0hFX1NFUlZFUl9USU1FT1VUXCJdID0gNDEyMDEzXSA9IFwiRVJSX09DU1BfQ0FDSEVfU0VSVkVSX1RJTUVPVVRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX09DU1BfRkFJTEVEX09CVEFJTl9PQ1NQX1JFU1BPTlNFXCJdID0gNDEyMDE0XSA9IFwiRVJSX09DU1BfRkFJTEVEX09CVEFJTl9PQ1NQX1JFU1BPTlNFXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9DUkxfRVJST1JcIl0gPSA0MTMwMDFdID0gXCJFUlJfQ1JMX0VSUk9SXCI7XG4gICAgLy8gNDUwMDAxXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19PUFRJT05TXCJdID0gNDUwMDAxXSA9IFwiRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX09QVElPTlNcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX09QVElPTlNcIl0gPSA0NTAwMDJdID0gXCJFUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfT1BUSU9OU1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfU1RNVF9GRVRDSF9ST1dTX01JU1NJTkdfRUFDSFwiXSA9IDQ1MDAwM10gPSBcIkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19FQUNIXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9FQUNIXCJdID0gNDUwMDA0XSA9IFwiRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX0VBQ0hcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VORFwiXSA9IDQ1MDAwNV0gPSBcIkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19FTkRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX0VORFwiXSA9IDQ1MDAwNl0gPSBcIkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9FTkRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX1NUTVRfRkVUQ0hfUk9XU19GRVRDSElOR19SRVNVTFRcIl0gPSA0NTAwMDddID0gXCJFUlJfU1RNVF9GRVRDSF9ST1dTX0ZFVENISU5HX1JFU1VMVFwiO1xuICAgIC8vIDQ2MDAwMVxuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFUlJfR0VUX1JFU1BPTlNFX1FVRVJZX0lOVkFMSURfVVVJRFwiXSA9IDQ2MDAwMV0gPSBcIkVSUl9HRVRfUkVTUE9OU0VfUVVFUllfSU5WQUxJRF9VVUlEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT19EQVRBXCJdID0gNDYwMDAyXSA9IFwiRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PX0RBVEFcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PVF9TVUNDRVNTX1NUQVRVU1wiXSA9IDQ2MDAwM10gPSBcIkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT1RfU1VDQ0VTU19TVEFUVVNcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVycm9yQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yX2NvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/error_code.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst errorMessages = __webpack_require__(/*! ./constants/error_messages */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/error_messages.js\");\nconst ErrorCode = (__webpack_require__(/*! ./error_code */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/error_code.js\")[\"default\"]);\n/**\n * @deprecated Use `ErrorCode` instead\n */\nexports.codes = ErrorCode;\nexports.ErrorCode = ErrorCode;\n/**\n * A map in which the keys are the error codes and the values are the\n * corresponding SQL-states.\n */\nconst errCodeToSqlState = (exports.mapErrorCodeToSqlState = {\n    405501: '08002',\n    405502: '08002',\n    405503: '08003',\n    407001: '08003',\n    407002: '08003',\n});\n/**\n * An enumeration of all the different types of errors we create.\n */\nconst errorTypes = {\n    // internal synchronous errors\n    InternalAssertError: 'InternalAssertError',\n    // external synchronous errors\n    MissingParameterError: 'MissingParameterError',\n    InvalidParameterError: 'InvalidParameterError',\n    // external asynchronous errors\n    NetworkError: 'NetworkError',\n    RequestFailedError: 'RequestFailedError',\n    UnexpectedContentError: 'UnexpectedContentError',\n    OperationFailedError: 'OperationFailedError',\n    LargeResultSetError: 'LargeResultSetError',\n    ClientError: 'ClientError',\n    OCSPError: 'OCSPError',\n    CRLError: 'CRLError',\n};\n/**\n * Ensures the truth of an expression. Used to catch internal programming\n * errors. If the given expression is false, an InternalAssertError will be\n * thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {String} [message] a message for the error should the check fail.\n */\nexports.assertInternal = function (expression, message) {\n    if (!expression) {\n        throw createError(errorTypes.InternalAssertError, {\n            code: ErrorCode.ERR_INTERNAL_ASSERT_FAILED,\n            message: message,\n            synchronous: true,\n        });\n    }\n};\n// TODO:\n// Consider removing MissingParameterError + checkArgumentExits + checkArgumentValid\n// to reduce amount of error types we have. Use createInvalidParameterError instead.\n/**\n * Ensures the truth of an expression. Used to make sure all required arguments\n * are passed in to a method. If the specified expression is false, a\n * MissingParameterError will be thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {Number} errorCode a code for the error should the check fail.\n *\n * @throws will throw an MissingParameter error if the expression is false.\n */\nexports.checkArgumentExists = function (expression, errorCode) {\n    if (!expression) {\n        throw createError(errorTypes.MissingParameterError, {\n            code: errorCode,\n            messageArgs: Array.prototype.slice.call(arguments, 2),\n            synchronous: true,\n        });\n    }\n};\n/**\n * Ensures the truth of an expression. Used for validating arguments to methods.\n * If the specified expression is false, an InvalidParameterError will be\n * thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {Number} errorCode a code for the error should the check fail.\n *\n * @throws will throw an InvalidParameter error if the expression is false.\n */\nexports.checkArgumentValid = function (expression, errorCode) {\n    if (!expression) {\n        throw createError(errorTypes.InvalidParameterError, {\n            code: errorCode,\n            messageArgs: Array.prototype.slice.call(arguments, 2),\n            synchronous: true,\n        });\n    }\n};\n/**\n * Creates a new InvalidParameterError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {messageArgs} array of error massages\n * @returns {Error}\n */\nexports.createInvalidParameterError = function (errorCode, ...messageArgs) {\n    return createError(errorTypes.InvalidParameterError, {\n        code: errorCode,\n        messageArgs: messageArgs,\n        synchronous: true,\n    });\n};\n/**\n * Creates a new NetworkError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Error} cause the underlying cause of the network error.\n *\n * @returns {Error}\n */\nexports.createNetworkError = function (errorCode, cause) {\n    return createError(errorTypes.NetworkError, {\n        code: errorCode,\n        cause: cause,\n    });\n};\n/**\n * Creates a new RequestFailedError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} response the response sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createRequestFailedError = function (errorCode, response) {\n    return createError(errorTypes.RequestFailedError, {\n        code: errorCode,\n        response: response,\n    });\n};\n/**\n * Creates a new UnexpectedContentError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {String} responseBody the response body sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createUnexpectedContentError = function (errorCode, responseBody) {\n    return createError(errorTypes.UnexpectedContentError, {\n        code: errorCode,\n        responseBody: responseBody,\n    });\n};\n/**\n * Creates a new OperationFailedError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} data the data sent by Global Services.\n * @param {String} message the error message sent by Global Services.\n * @param {String} sqlState the sql state sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createOperationFailedError = function (errorCode, data, message, sqlState) {\n    return createError(errorTypes.OperationFailedError, {\n        code: errorCode,\n        data: data,\n        message: message,\n        sqlState: sqlState,\n    });\n};\n/**\n * Creates a new LargeResultSetError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} response the response sent by S3/Blob.\n *\n * @returns {Error}\n */\nexports.createLargeResultSetError = function (errorCode, response) {\n    return createError(errorTypes.LargeResultSetError, {\n        code: errorCode,\n        response: response,\n    });\n};\n/**\n * Creates a new ClientError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} [isFatal] whether the error is fatal.\n *\n * @return {Error}\n */\nexports.createClientError = function (errorCode, isFatal) {\n    return createError(errorTypes.ClientError, {\n        code: errorCode,\n        isFatal: isFatal,\n        messageArgs: Array.prototype.slice.call(arguments, 2),\n    });\n};\n/**\n * Creates a OCSPError\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {String} message\n * @returns {Error}\n */\nexports.createOCSPError = function (errorCode) {\n    return createError(errorTypes.OCSPError, {\n        code: errorCode,\n        messageArgs: Array.prototype.slice.call(arguments, 1),\n    });\n};\n/**\n * Wraps an error into CrlError. Allows to catch any errors coming from CRL validation.\n *\n * @param {Error} originalError\n * @returns {Error}\n */\nexports.createCrlError = function (originalError) {\n    const error = createError(errorTypes.CRLError, {\n        code: ErrorCode.ERR_CRL_ERROR,\n        cause: originalError,\n    });\n    return error;\n};\n/**\n * Creates a new error by combining the error messages from the json parser and xml parser\n *\n * @param {Object} jsonParseError contains the JSON parse error message\n * @param {Object} xmlParseError contains the XML parse error message\n * @returns {Error}\n */\nexports.VariantParseError = function (jsonParseError, xmlParseError) {\n    const errMessage = 'VariantParseError: Variant cannot be parsed neither as JSON nor as XML:\\n' +\n        ` - JSON parse error message: ${jsonParseError.message}\\n` +\n        ` - XML parse error message: ${xmlParseError.message}`;\n    return new Error(errMessage);\n};\n/**\n * Determines if a given error is an InternalAssertError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isInternalAssertError = function (error) {\n    return isErrorOfType(error, errorTypes.InternalAssertError);\n};\n/**\n * Determines if a given error is a MissingParameterError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isMissingParameterError = function (error) {\n    return isErrorOfType(error, errorTypes.MissingParameterError);\n};\n/**\n * Determines if a given error is an InvalidParameterError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isInvalidParameterError = function (error) {\n    return isErrorOfType(error, errorTypes.InvalidParameterError);\n};\n/**\n * Determines if a given error is a NetworkError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isNetworkError = function (error) {\n    return isErrorOfType(error, errorTypes.NetworkError);\n};\n/**\n * Determines if a given error is a RequestFailedError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isRequestFailedError = function (error) {\n    return isErrorOfType(error, errorTypes.RequestFailedError);\n};\n/**\n * Determines if a given error is an UnexpectedContentError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isUnexpectedContentError = function (error) {\n    return isErrorOfType(error, errorTypes.UnexpectedContentError);\n};\n/**\n * Determines if a given error is an OperationFailedError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isOperationFailedError = function (error) {\n    return isErrorOfType(error, errorTypes.OperationFailedError);\n};\n/**\n * Determines if a given error is an LargeResultSetError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isLargeResultSetError = function (error) {\n    return isErrorOfType(error, errorTypes.LargeResultSetError);\n};\n/**\n * Externalizes an error.\n *\n * @param {Error} error\n *\n * @returns {Error}\n */\nexports.externalize = function (error) {\n    return error && error.externalize ? error.externalize() : error;\n};\n/**\n * Determines if a given error is of a specific type.\n *\n * @param {Error} error\n * @param {String} type\n *\n * @returns {Boolean}\n */\nfunction isErrorOfType(error, type) {\n    return error && error.name === type;\n}\n/**\n * Creates a generic error.\n *\n * @param {String} name\n * @param {Object} options\n *\n * @returns {Error}\n */\nfunction createError(name, options) {\n    // TODO: validate that name is a string and options is an object\n    // TODO: this code is a bit of a mess and needs to be cleaned up\n    // create a new error\n    const error = new Error();\n    // set its name\n    error.name = name;\n    // set the error code\n    let code;\n    error.code = code = options.code;\n    // if no error message was specified in the options\n    let message = options.message ?? options.cause?.message;\n    if (!message) {\n        // use the error code to get the error message template\n        const messageTemplate = errorMessages[code];\n        // if some error message arguments were specified, substitute them into the\n        // error message template to get the full error message, otherwise just use\n        // the error message template as the error message\n        let messageArgs = options.messageArgs;\n        if (messageArgs) {\n            messageArgs = messageArgs.slice();\n            messageArgs.unshift(messageTemplate);\n            message = Util.format.apply(Util, messageArgs);\n        }\n        else {\n            message = messageTemplate;\n        }\n    }\n    error.message = message;\n    // if no sql state was specified in the options, use the error code to try to\n    // get the appropriate sql state\n    let sqlState = options.sqlState;\n    if (!sqlState) {\n        sqlState = errCodeToSqlState[code];\n    }\n    error.sqlState = sqlState;\n    // set the error data\n    error.data = options.data;\n    // set the error response and response body\n    error.response = options.response;\n    error.responseBody = options.responseBody;\n    // set the error cause\n    error.cause = options.cause;\n    // set the error's fatal flag\n    error.isFatal = options.isFatal;\n    // if the error is not synchronous, add an externalize() method\n    if (!options.synchronous) {\n        error.externalize = function () {\n            const propNames = [\n                'name',\n                'code',\n                'message',\n                'sqlState',\n                'data',\n                'response',\n                'responseBody',\n                'cause',\n                'isFatal',\n                'stack',\n            ];\n            const externalizedError = new Error();\n            let propName, propValue;\n            for (let index = 0, length = propNames.length; index < length; index++) {\n                propName = propNames[index];\n                propValue = this[propName];\n                if (Util.exists(propValue)) {\n                    externalizedError[propName] = propValue;\n                }\n            }\n            return externalizedError;\n        };\n    }\n    return error;\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0Isc0JBQXNCLG1CQUFPLENBQUMsMkdBQTRCO0FBQzFELGtCQUFrQixpSEFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHdDQUF3Qyx1QkFBdUI7QUFDL0QsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGVycm9yTWVzc2FnZXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9lcnJvcl9tZXNzYWdlcycpO1xuY29uc3QgRXJyb3JDb2RlID0gcmVxdWlyZSgnLi9lcnJvcl9jb2RlJykuZGVmYXVsdDtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBFcnJvckNvZGVgIGluc3RlYWRcbiAqL1xuZXhwb3J0cy5jb2RlcyA9IEVycm9yQ29kZTtcbmV4cG9ydHMuRXJyb3JDb2RlID0gRXJyb3JDb2RlO1xuLyoqXG4gKiBBIG1hcCBpbiB3aGljaCB0aGUga2V5cyBhcmUgdGhlIGVycm9yIGNvZGVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgU1FMLXN0YXRlcy5cbiAqL1xuY29uc3QgZXJyQ29kZVRvU3FsU3RhdGUgPSAoZXhwb3J0cy5tYXBFcnJvckNvZGVUb1NxbFN0YXRlID0ge1xuICAgIDQwNTUwMTogJzA4MDAyJyxcbiAgICA0MDU1MDI6ICcwODAwMicsXG4gICAgNDA1NTAzOiAnMDgwMDMnLFxuICAgIDQwNzAwMTogJzA4MDAzJyxcbiAgICA0MDcwMDI6ICcwODAwMycsXG59KTtcbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgYWxsIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgZXJyb3JzIHdlIGNyZWF0ZS5cbiAqL1xuY29uc3QgZXJyb3JUeXBlcyA9IHtcbiAgICAvLyBpbnRlcm5hbCBzeW5jaHJvbm91cyBlcnJvcnNcbiAgICBJbnRlcm5hbEFzc2VydEVycm9yOiAnSW50ZXJuYWxBc3NlcnRFcnJvcicsXG4gICAgLy8gZXh0ZXJuYWwgc3luY2hyb25vdXMgZXJyb3JzXG4gICAgTWlzc2luZ1BhcmFtZXRlckVycm9yOiAnTWlzc2luZ1BhcmFtZXRlckVycm9yJyxcbiAgICBJbnZhbGlkUGFyYW1ldGVyRXJyb3I6ICdJbnZhbGlkUGFyYW1ldGVyRXJyb3InLFxuICAgIC8vIGV4dGVybmFsIGFzeW5jaHJvbm91cyBlcnJvcnNcbiAgICBOZXR3b3JrRXJyb3I6ICdOZXR3b3JrRXJyb3InLFxuICAgIFJlcXVlc3RGYWlsZWRFcnJvcjogJ1JlcXVlc3RGYWlsZWRFcnJvcicsXG4gICAgVW5leHBlY3RlZENvbnRlbnRFcnJvcjogJ1VuZXhwZWN0ZWRDb250ZW50RXJyb3InLFxuICAgIE9wZXJhdGlvbkZhaWxlZEVycm9yOiAnT3BlcmF0aW9uRmFpbGVkRXJyb3InLFxuICAgIExhcmdlUmVzdWx0U2V0RXJyb3I6ICdMYXJnZVJlc3VsdFNldEVycm9yJyxcbiAgICBDbGllbnRFcnJvcjogJ0NsaWVudEVycm9yJyxcbiAgICBPQ1NQRXJyb3I6ICdPQ1NQRXJyb3InLFxuICAgIENSTEVycm9yOiAnQ1JMRXJyb3InLFxufTtcbi8qKlxuICogRW5zdXJlcyB0aGUgdHJ1dGggb2YgYW4gZXhwcmVzc2lvbi4gVXNlZCB0byBjYXRjaCBpbnRlcm5hbCBwcm9ncmFtbWluZ1xuICogZXJyb3JzLiBJZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBmYWxzZSwgYW4gSW50ZXJuYWxBc3NlcnRFcnJvciB3aWxsIGJlXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBleHByZXNzaW9uIGEgYm9vbGVhbiBleHByZXNzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBhIG1lc3NhZ2UgZm9yIHRoZSBlcnJvciBzaG91bGQgdGhlIGNoZWNrIGZhaWwuXG4gKi9cbmV4cG9ydHMuYXNzZXJ0SW50ZXJuYWwgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgbWVzc2FnZSkge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihlcnJvclR5cGVzLkludGVybmFsQXNzZXJ0RXJyb3IsIHtcbiAgICAgICAgICAgIGNvZGU6IEVycm9yQ29kZS5FUlJfSU5URVJOQUxfQVNTRVJUX0ZBSUxFRCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBzeW5jaHJvbm91czogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8vIFRPRE86XG4vLyBDb25zaWRlciByZW1vdmluZyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IgKyBjaGVja0FyZ3VtZW50RXhpdHMgKyBjaGVja0FyZ3VtZW50VmFsaWRcbi8vIHRvIHJlZHVjZSBhbW91bnQgb2YgZXJyb3IgdHlwZXMgd2UgaGF2ZS4gVXNlIGNyZWF0ZUludmFsaWRQYXJhbWV0ZXJFcnJvciBpbnN0ZWFkLlxuLyoqXG4gKiBFbnN1cmVzIHRoZSB0cnV0aCBvZiBhbiBleHByZXNzaW9uLiBVc2VkIHRvIG1ha2Ugc3VyZSBhbGwgcmVxdWlyZWQgYXJndW1lbnRzXG4gKiBhcmUgcGFzc2VkIGluIHRvIGEgbWV0aG9kLiBJZiB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb24gaXMgZmFsc2UsIGFcbiAqIE1pc3NpbmdQYXJhbWV0ZXJFcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4cHJlc3Npb24gYSBib29sZWFuIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIGEgY29kZSBmb3IgdGhlIGVycm9yIHNob3VsZCB0aGUgY2hlY2sgZmFpbC5cbiAqXG4gKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gTWlzc2luZ1BhcmFtZXRlciBlcnJvciBpZiB0aGUgZXhwcmVzc2lvbiBpcyBmYWxzZS5cbiAqL1xuZXhwb3J0cy5jaGVja0FyZ3VtZW50RXhpc3RzID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGVycm9yQ29kZSkge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk1pc3NpbmdQYXJhbWV0ZXJFcnJvciwge1xuICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgbWVzc2FnZUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgICBzeW5jaHJvbm91czogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogRW5zdXJlcyB0aGUgdHJ1dGggb2YgYW4gZXhwcmVzc2lvbi4gVXNlZCBmb3IgdmFsaWRhdGluZyBhcmd1bWVudHMgdG8gbWV0aG9kcy5cbiAqIElmIHRoZSBzcGVjaWZpZWQgZXhwcmVzc2lvbiBpcyBmYWxzZSwgYW4gSW52YWxpZFBhcmFtZXRlckVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4cHJlc3Npb24gYSBib29sZWFuIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIGEgY29kZSBmb3IgdGhlIGVycm9yIHNob3VsZCB0aGUgY2hlY2sgZmFpbC5cbiAqXG4gKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gSW52YWxpZFBhcmFtZXRlciBlcnJvciBpZiB0aGUgZXhwcmVzc2lvbiBpcyBmYWxzZS5cbiAqL1xuZXhwb3J0cy5jaGVja0FyZ3VtZW50VmFsaWQgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgZXJyb3JDb2RlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuSW52YWxpZFBhcmFtZXRlckVycm9yLCB7XG4gICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlQXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICAgIHN5bmNocm9ub3VzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEludmFsaWRQYXJhbWV0ZXJFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7bWVzc2FnZUFyZ3N9IGFycmF5IG9mIGVycm9yIG1hc3NhZ2VzXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlSW52YWxpZFBhcmFtZXRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgLi4ubWVzc2FnZUFyZ3MpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5JbnZhbGlkUGFyYW1ldGVyRXJyb3IsIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBtZXNzYWdlQXJnczogbWVzc2FnZUFyZ3MsXG4gICAgICAgIHN5bmNocm9ub3VzOiB0cnVlLFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBOZXR3b3JrRXJyb3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSB0aGUgZXJyb3IgY29kZSB0byB1c2Ugd2hlbiBidWlsZGluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge0Vycm9yfSBjYXVzZSB0aGUgdW5kZXJseWluZyBjYXVzZSBvZiB0aGUgbmV0d29yayBlcnJvci5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlTmV0d29ya0Vycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgY2F1c2UpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5OZXR3b3JrRXJyb3IsIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBjYXVzZTogY2F1c2UsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlcXVlc3RGYWlsZWRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSB0aGUgcmVzcG9uc2Ugc2VudCBieSBHbG9iYWwgU2VydmljZXMuXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZVJlcXVlc3RGYWlsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuUmVxdWVzdEZhaWxlZEVycm9yLCB7XG4gICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVbmV4cGVjdGVkQ29udGVudEVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IHJlc3BvbnNlQm9keSB0aGUgcmVzcG9uc2UgYm9keSBzZW50IGJ5IEdsb2JhbCBTZXJ2aWNlcy5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlVW5leHBlY3RlZENvbnRlbnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHJlc3BvbnNlQm9keSkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLlVuZXhwZWN0ZWRDb250ZW50RXJyb3IsIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICByZXNwb25zZUJvZHk6IHJlc3BvbnNlQm9keSxcbiAgICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0aW9uRmFpbGVkRXJyb3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSB0aGUgZXJyb3IgY29kZSB0byB1c2Ugd2hlbiBidWlsZGluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSBzZW50IGJ5IEdsb2JhbCBTZXJ2aWNlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRoZSBlcnJvciBtZXNzYWdlIHNlbnQgYnkgR2xvYmFsIFNlcnZpY2VzLlxuICogQHBhcmFtIHtTdHJpbmd9IHNxbFN0YXRlIHRoZSBzcWwgc3RhdGUgc2VudCBieSBHbG9iYWwgU2VydmljZXMuXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZU9wZXJhdGlvbkZhaWxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgZGF0YSwgbWVzc2FnZSwgc3FsU3RhdGUpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5PcGVyYXRpb25GYWlsZWRFcnJvciwge1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHNxbFN0YXRlOiBzcWxTdGF0ZSxcbiAgICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGFyZ2VSZXN1bHRTZXRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSB0aGUgcmVzcG9uc2Ugc2VudCBieSBTMy9CbG9iLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVMYXJnZVJlc3VsdFNldEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5MYXJnZVJlc3VsdFNldEVycm9yLCB7XG4gICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDbGllbnRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaXNGYXRhbF0gd2hldGhlciB0aGUgZXJyb3IgaXMgZmF0YWwuXG4gKlxuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlQ2xpZW50RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBpc0ZhdGFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuQ2xpZW50RXJyb3IsIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBpc0ZhdGFsOiBpc0ZhdGFsLFxuICAgICAgICBtZXNzYWdlQXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBPQ1NQRXJyb3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlT0NTUEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk9DU1BFcnJvciwge1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIG1lc3NhZ2VBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgIH0pO1xufTtcbi8qKlxuICogV3JhcHMgYW4gZXJyb3IgaW50byBDcmxFcnJvci4gQWxsb3dzIHRvIGNhdGNoIGFueSBlcnJvcnMgY29taW5nIGZyb20gQ1JMIHZhbGlkYXRpb24uXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gb3JpZ2luYWxFcnJvclxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZUNybEVycm9yID0gZnVuY3Rpb24gKG9yaWdpbmFsRXJyb3IpIHtcbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuQ1JMRXJyb3IsIHtcbiAgICAgICAgY29kZTogRXJyb3JDb2RlLkVSUl9DUkxfRVJST1IsXG4gICAgICAgIGNhdXNlOiBvcmlnaW5hbEVycm9yLFxuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZXJyb3IgYnkgY29tYmluaW5nIHRoZSBlcnJvciBtZXNzYWdlcyBmcm9tIHRoZSBqc29uIHBhcnNlciBhbmQgeG1sIHBhcnNlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBqc29uUGFyc2VFcnJvciBjb250YWlucyB0aGUgSlNPTiBwYXJzZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0geG1sUGFyc2VFcnJvciBjb250YWlucyB0aGUgWE1MIHBhcnNlIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5WYXJpYW50UGFyc2VFcnJvciA9IGZ1bmN0aW9uIChqc29uUGFyc2VFcnJvciwgeG1sUGFyc2VFcnJvcikge1xuICAgIGNvbnN0IGVyck1lc3NhZ2UgPSAnVmFyaWFudFBhcnNlRXJyb3I6IFZhcmlhbnQgY2Fubm90IGJlIHBhcnNlZCBuZWl0aGVyIGFzIEpTT04gbm9yIGFzIFhNTDpcXG4nICtcbiAgICAgICAgYCAtIEpTT04gcGFyc2UgZXJyb3IgbWVzc2FnZTogJHtqc29uUGFyc2VFcnJvci5tZXNzYWdlfVxcbmAgK1xuICAgICAgICBgIC0gWE1MIHBhcnNlIGVycm9yIG1lc3NhZ2U6ICR7eG1sUGFyc2VFcnJvci5tZXNzYWdlfWA7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihlcnJNZXNzYWdlKTtcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhbiBJbnRlcm5hbEFzc2VydEVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNJbnRlcm5hbEFzc2VydEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3JPZlR5cGUoZXJyb3IsIGVycm9yVHlwZXMuSW50ZXJuYWxBc3NlcnRFcnJvcik7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYSBNaXNzaW5nUGFyYW1ldGVyRXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc01pc3NpbmdQYXJhbWV0ZXJFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLk1pc3NpbmdQYXJhbWV0ZXJFcnJvcik7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYW4gSW52YWxpZFBhcmFtZXRlckVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNJbnZhbGlkUGFyYW1ldGVyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5JbnZhbGlkUGFyYW1ldGVyRXJyb3IpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGEgTmV0d29ya0Vycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNOZXR3b3JrRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5OZXR3b3JrRXJyb3IpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGEgUmVxdWVzdEZhaWxlZEVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNSZXF1ZXN0RmFpbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5SZXF1ZXN0RmFpbGVkRXJyb3IpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGFuIFVuZXhwZWN0ZWRDb250ZW50RXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1VuZXhwZWN0ZWRDb250ZW50RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5VbmV4cGVjdGVkQ29udGVudEVycm9yKTtcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhbiBPcGVyYXRpb25GYWlsZWRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzT3BlcmF0aW9uRmFpbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5PcGVyYXRpb25GYWlsZWRFcnJvcik7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYW4gTGFyZ2VSZXN1bHRTZXRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzTGFyZ2VSZXN1bHRTZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLkxhcmdlUmVzdWx0U2V0RXJyb3IpO1xufTtcbi8qKlxuICogRXh0ZXJuYWxpemVzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmV4dGVybmFsaXplID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yICYmIGVycm9yLmV4dGVybmFsaXplID8gZXJyb3IuZXh0ZXJuYWxpemUoKSA6IGVycm9yO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFcnJvck9mVHlwZShlcnJvciwgdHlwZSkge1xuICAgIHJldHVybiBlcnJvciAmJiBlcnJvci5uYW1lID09PSB0eXBlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZ2VuZXJpYyBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSB0aGF0IG5hbWUgaXMgYSBzdHJpbmcgYW5kIG9wdGlvbnMgaXMgYW4gb2JqZWN0XG4gICAgLy8gVE9ETzogdGhpcyBjb2RlIGlzIGEgYml0IG9mIGEgbWVzcyBhbmQgbmVlZHMgdG8gYmUgY2xlYW5lZCB1cFxuICAgIC8vIGNyZWF0ZSBhIG5ldyBlcnJvclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgLy8gc2V0IGl0cyBuYW1lXG4gICAgZXJyb3IubmFtZSA9IG5hbWU7XG4gICAgLy8gc2V0IHRoZSBlcnJvciBjb2RlXG4gICAgbGV0IGNvZGU7XG4gICAgZXJyb3IuY29kZSA9IGNvZGUgPSBvcHRpb25zLmNvZGU7XG4gICAgLy8gaWYgbm8gZXJyb3IgbWVzc2FnZSB3YXMgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zXG4gICAgbGV0IG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgPz8gb3B0aW9ucy5jYXVzZT8ubWVzc2FnZTtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBlcnJvciBjb2RlIHRvIGdldCB0aGUgZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZVxuICAgICAgICBjb25zdCBtZXNzYWdlVGVtcGxhdGUgPSBlcnJvck1lc3NhZ2VzW2NvZGVdO1xuICAgICAgICAvLyBpZiBzb21lIGVycm9yIG1lc3NhZ2UgYXJndW1lbnRzIHdlcmUgc3BlY2lmaWVkLCBzdWJzdGl0dXRlIHRoZW0gaW50byB0aGVcbiAgICAgICAgLy8gZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZSB0byBnZXQgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSwgb3RoZXJ3aXNlIGp1c3QgdXNlXG4gICAgICAgIC8vIHRoZSBlcnJvciBtZXNzYWdlIHRlbXBsYXRlIGFzIHRoZSBlcnJvciBtZXNzYWdlXG4gICAgICAgIGxldCBtZXNzYWdlQXJncyA9IG9wdGlvbnMubWVzc2FnZUFyZ3M7XG4gICAgICAgIGlmIChtZXNzYWdlQXJncykge1xuICAgICAgICAgICAgbWVzc2FnZUFyZ3MgPSBtZXNzYWdlQXJncy5zbGljZSgpO1xuICAgICAgICAgICAgbWVzc2FnZUFyZ3MudW5zaGlmdChtZXNzYWdlVGVtcGxhdGUpO1xuICAgICAgICAgICAgbWVzc2FnZSA9IFV0aWwuZm9ybWF0LmFwcGx5KFV0aWwsIG1lc3NhZ2VBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgLy8gaWYgbm8gc3FsIHN0YXRlIHdhcyBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMsIHVzZSB0aGUgZXJyb3IgY29kZSB0byB0cnkgdG9cbiAgICAvLyBnZXQgdGhlIGFwcHJvcHJpYXRlIHNxbCBzdGF0ZVxuICAgIGxldCBzcWxTdGF0ZSA9IG9wdGlvbnMuc3FsU3RhdGU7XG4gICAgaWYgKCFzcWxTdGF0ZSkge1xuICAgICAgICBzcWxTdGF0ZSA9IGVyckNvZGVUb1NxbFN0YXRlW2NvZGVdO1xuICAgIH1cbiAgICBlcnJvci5zcWxTdGF0ZSA9IHNxbFN0YXRlO1xuICAgIC8vIHNldCB0aGUgZXJyb3IgZGF0YVxuICAgIGVycm9yLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgLy8gc2V0IHRoZSBlcnJvciByZXNwb25zZSBhbmQgcmVzcG9uc2UgYm9keVxuICAgIGVycm9yLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICBlcnJvci5yZXNwb25zZUJvZHkgPSBvcHRpb25zLnJlc3BvbnNlQm9keTtcbiAgICAvLyBzZXQgdGhlIGVycm9yIGNhdXNlXG4gICAgZXJyb3IuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgIC8vIHNldCB0aGUgZXJyb3IncyBmYXRhbCBmbGFnXG4gICAgZXJyb3IuaXNGYXRhbCA9IG9wdGlvbnMuaXNGYXRhbDtcbiAgICAvLyBpZiB0aGUgZXJyb3IgaXMgbm90IHN5bmNocm9ub3VzLCBhZGQgYW4gZXh0ZXJuYWxpemUoKSBtZXRob2RcbiAgICBpZiAoIW9wdGlvbnMuc3luY2hyb25vdXMpIHtcbiAgICAgICAgZXJyb3IuZXh0ZXJuYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wTmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgICAgICdjb2RlJyxcbiAgICAgICAgICAgICAgICAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgJ3NxbFN0YXRlJyxcbiAgICAgICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgICAgICAgICAncmVzcG9uc2VCb2R5JyxcbiAgICAgICAgICAgICAgICAnY2F1c2UnLFxuICAgICAgICAgICAgICAgICdpc0ZhdGFsJyxcbiAgICAgICAgICAgICAgICAnc3RhY2snLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsaXplZEVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBsZXQgcHJvcE5hbWUsIHByb3BWYWx1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gcHJvcE5hbWVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxpemVkRXJyb3JbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbGl6ZWRFcnJvcjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AZURE = __webpack_require__(/*! @azure/storage-blob */ \"(rsc)/./node_modules/@azure/storage-blob/dist-esm/storage-blob/src/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").FileHeader);\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst { isBypassProxy } = __webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst EXPIRED_TOKEN = 'ExpiredToken';\n// Azure Location\nfunction AzureLocation(containerName, path) {\n    return {\n        containerName: containerName,\n        path: path,\n    };\n}\n/**\n * Creates an Azure utility object.\n *\n * @param {module} azure\n * @param {module} filestream\n *\n * @returns {Object}\n * @constructor\n */\nfunction AzureUtil(connectionConfig) {\n    /**\n     * Create a blob service client using an Azure SAS token.\n     *\n     * @param {Object} stageInfo\n     *\n     * @returns {String}\n     */\n    this.createClient = function (stageInfo) {\n        const stageCredentials = stageInfo['creds'];\n        const sasToken = stageCredentials['AZURE_SAS_TOKEN'];\n        const account = stageInfo['storageAccount'];\n        const connectionString = `https://${account}.blob.core.windows.net${sasToken}`;\n        let proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'Azure Util');\n        if (proxy && !isBypassProxy(proxy, connectionString)) {\n            Logger().debug(`The destination host is: ${ProxyUtil.getHostFromURL(connectionString)} and the proxy host is: ${proxy.host}`);\n            Logger().trace(`Initializing the proxy information for the Azure Client: ${ProxyUtil.describeProxy(proxy)}`);\n            proxy = ProxyUtil.getAzureProxy(proxy);\n        }\n        ProxyUtil.hideEnvironmentProxy();\n        const blobServiceClient = new AZURE.BlobServiceClient(connectionString, null, {\n            proxyOptions: proxy,\n        });\n        ProxyUtil.restoreEnvironmentProxy();\n        return blobServiceClient;\n    };\n    /**\n     * Extract the container name and path from the metadata's stage location.\n     *\n     * @param {String} stageLocation\n     *\n     * @returns {Object}\n     */\n    this.extractContainerNameAndPath = function (stageLocation) {\n        // expand '~' and '~user' expressions\n        if (process.platform !== 'win32') {\n            stageLocation = expandTilde(stageLocation);\n        }\n        let containerName = stageLocation;\n        let path;\n        // split stage location as bucket name and path\n        if (stageLocation.includes('/')) {\n            containerName = stageLocation.substring(0, stageLocation.indexOf('/'));\n            path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n            if (path && !path.endsWith('/')) {\n                path += '/';\n            }\n        }\n        return AzureLocation(containerName, path);\n    };\n    /**\n     * Create file header based on file being uploaded or not.\n     *\n     * @param {Object} meta\n     * @param {String} filename\n     *\n     * @returns {Object}\n     */\n    this.getFileHeader = async function (meta, filename) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n        const containerClient = client.getContainerClient(azureLocation.containerName);\n        const blobClient = containerClient.getBlobClient(azureLocation.path + filename);\n        let blobDetails;\n        try {\n            await blobClient.getProperties().then(function (data) {\n                blobDetails = data;\n            });\n        }\n        catch (err) {\n            if (err['code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else if (err['statusCode'] === 404) {\n                meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                return FileHeader(null, null, null);\n            }\n            else if (err['statusCode'] === 400) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else {\n                meta['resultStatus'] = resultStatus.ERROR;\n                return null;\n            }\n        }\n        meta['resultStatus'] = resultStatus.UPLOADED;\n        let encryptionMetadata = null;\n        if (blobDetails.metadata['encryptiondata']) {\n            const encryptionData = JSON.parse(blobDetails.metadata['encryptiondata']);\n            encryptionMetadata = EncryptionMetadata(encryptionData['WrappedContentKey']['EncryptedKey'], encryptionData['ContentEncryptionIV'], blobDetails.metadata['matdesc']);\n        }\n        return FileHeader(blobDetails.metadata['sfcdigest'], blobDetails.contentLength, encryptionMetadata);\n    };\n    /**\n     * Create the file metadata then upload the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     * @param {Number} maxConcurrency\n     *\n     * @returns {null}\n     */\n    this.uploadFile = async function (dataFile, meta, encryptionMetadata, maxConcurrency) {\n        const fileStream = fs.readFileSync(dataFile);\n        await this.uploadFileStream(fileStream, meta, encryptionMetadata, maxConcurrency);\n    };\n    /**\n     * Create the file metadata then upload the file stream.\n     *\n     * @param {String} fileStream\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     *\n     * @returns {null}\n     */\n    this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n        const azureMetadata = {\n            sfcdigest: meta['SHA256_DIGEST'],\n        };\n        if (encryptionMetadata) {\n            azureMetadata['encryptiondata'] = JSON.stringify({\n                EncryptionMode: 'FullBlob',\n                WrappedContentKey: {\n                    KeyId: 'symmKey1',\n                    EncryptedKey: encryptionMetadata.key,\n                    Algorithm: 'AES_CBC_256',\n                },\n                EncryptionAgent: {\n                    Protocol: '1.0',\n                    EncryptionAlgorithm: 'AES_CBC_128',\n                },\n                ContentEncryptionIV: encryptionMetadata.iv,\n                KeyWrappingMetadata: {\n                    EncryptionLibrary: 'Java 5.3.0',\n                },\n            });\n            azureMetadata['matdesc'] = encryptionMetadata.matDesc;\n        }\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n        const blobName = azureLocation.path + meta['dstFileName'];\n        const containerClient = client.getContainerClient(azureLocation.containerName);\n        const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n        try {\n            await blockBlobClient.upload(fileStream, fileStream.length, {\n                metadata: azureMetadata,\n                blobHTTPHeaders: {\n                    blobContentEncoding: 'UTF-8',\n                    blobContentType: 'application/octet-stream',\n                },\n            });\n        }\n        catch (err) {\n            if (err['statusCode'] === 403 && detectAzureTokenExpireError(err)) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return;\n            }\n            else {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.NEED_RETRY;\n            }\n            return;\n        }\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n    };\n    /**\n     * Download the file blob then write the file.\n     *\n     * @param {Object} meta\n     * @param fullDstPath\n     *\n     * @returns {null}\n     */\n    this.nativeDownloadFile = async function (meta, fullDstPath) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n        const blobName = azureLocation.path + meta['srcFileName'];\n        const containerClient = client.getContainerClient(azureLocation.containerName);\n        const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n        try {\n            const downloadBlockBlobResponse = await blockBlobClient.download(0);\n            const readableStream = downloadBlockBlobResponse.readableStreamBody;\n            Logger().debug(`Sent Get Request to ${blockBlobClient.url.split('?')[0]}, destination: ${fullDstPath}, http status: ${downloadBlockBlobResponse.originalResponse._response.status}`);\n            await new Promise((resolve, reject) => {\n                const writer = fs.createWriteStream(fullDstPath);\n                readableStream.on('data', (data) => {\n                    writer.write(data);\n                });\n                readableStream.on('end', () => {\n                    writer.end(resolve);\n                });\n                readableStream.on('error', reject);\n            });\n        }\n        catch (err) {\n            if (err['statusCode'] === 403 && detectAzureTokenExpireError(err)) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return;\n            }\n            else {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.NEED_RETRY;\n            }\n            return;\n        }\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n    };\n    /**\n     * Detect if the Azure token has expired.\n     *\n     * @param {Object} err\n     *\n     * @returns {Boolean}\n     */\n    function detectAzureTokenExpireError(err) {\n        if (err['statusCode'] !== 403) {\n            return false;\n        }\n        const errstr = err.toString();\n        return (errstr.includes('Signature not valid in the specified time frame') ||\n            errstr.includes('Server failed to authenticate the request.'));\n    }\n}\nmodule.exports = AzureUtil;\n//# sourceMappingURL=azure_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2F6dXJlX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMsd0dBQXFCO0FBQzNDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLDJCQUEyQixpSkFBNEM7QUFDdkUsbUJBQW1CLGdIQUFrQztBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxxQkFBcUIsa0hBQW9DO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFlO0FBQ3pDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyw4RUFBYztBQUNoRCxlQUFlLDBHQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLHdCQUF3QixTQUFTO0FBQ3JGO0FBQ0E7QUFDQSx1REFBdUQsNENBQTRDLHlCQUF5QixXQUFXO0FBQ3ZJLHVGQUF1RiwrQkFBK0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQ0FBa0MsaUJBQWlCLFlBQVksaUJBQWlCLDREQUE0RDtBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvYXp1cmVfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFaVVJFID0gcmVxdWlyZSgnQGF6dXJlL3N0b3JhZ2UtYmxvYicpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgRW5jcnlwdGlvbk1ldGFkYXRhID0gcmVxdWlyZSgnLi9lbmNyeXB0X3V0aWwnKS5FbmNyeXB0aW9uTWV0YWRhdGE7XG5jb25zdCBGaWxlSGVhZGVyID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykuRmlsZUhlYWRlcjtcbmNvbnN0IGV4cGFuZFRpbGRlID0gcmVxdWlyZSgnZXhwYW5kLXRpbGRlJyk7XG5jb25zdCByZXN1bHRTdGF0dXMgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5yZXN1bHRTdGF0dXM7XG5jb25zdCBQcm94eVV0aWwgPSByZXF1aXJlKCcuLi9wcm94eV91dGlsJyk7XG5jb25zdCB7IGlzQnlwYXNzUHJveHkgfSA9IHJlcXVpcmUoJy4uL2h0dHAvbm9kZScpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IEVYUElSRURfVE9LRU4gPSAnRXhwaXJlZFRva2VuJztcbi8vIEF6dXJlIExvY2F0aW9uXG5mdW5jdGlvbiBBenVyZUxvY2F0aW9uKGNvbnRhaW5lck5hbWUsIHBhdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXJOYW1lOiBjb250YWluZXJOYW1lLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXp1cmUgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHttb2R1bGV9IGF6dXJlXG4gKiBAcGFyYW0ge21vZHVsZX0gZmlsZXN0cmVhbVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXp1cmVVdGlsKGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBibG9iIHNlcnZpY2UgY2xpZW50IHVzaW5nIGFuIEF6dXJlIFNBUyB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFnZUluZm9cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlQ3JlZGVudGlhbHMgPSBzdGFnZUluZm9bJ2NyZWRzJ107XG4gICAgICAgIGNvbnN0IHNhc1Rva2VuID0gc3RhZ2VDcmVkZW50aWFsc1snQVpVUkVfU0FTX1RPS0VOJ107XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBzdGFnZUluZm9bJ3N0b3JhZ2VBY2NvdW50J107XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdHJpbmcgPSBgaHR0cHM6Ly8ke2FjY291bnR9LmJsb2IuY29yZS53aW5kb3dzLm5ldCR7c2FzVG9rZW59YDtcbiAgICAgICAgbGV0IHByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5KGNvbm5lY3Rpb25Db25maWcuZ2V0UHJveHkoKSwgJ0F6dXJlIFV0aWwnKTtcbiAgICAgICAgaWYgKHByb3h5ICYmICFpc0J5cGFzc1Byb3h5KHByb3h5LCBjb25uZWN0aW9uU3RyaW5nKSkge1xuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFRoZSBkZXN0aW5hdGlvbiBob3N0IGlzOiAke1Byb3h5VXRpbC5nZXRIb3N0RnJvbVVSTChjb25uZWN0aW9uU3RyaW5nKX0gYW5kIHRoZSBwcm94eSBob3N0IGlzOiAke3Byb3h5Lmhvc3R9YCk7XG4gICAgICAgICAgICBMb2dnZXIoKS50cmFjZShgSW5pdGlhbGl6aW5nIHRoZSBwcm94eSBpbmZvcm1hdGlvbiBmb3IgdGhlIEF6dXJlIENsaWVudDogJHtQcm94eVV0aWwuZGVzY3JpYmVQcm94eShwcm94eSl9YCk7XG4gICAgICAgICAgICBwcm94eSA9IFByb3h5VXRpbC5nZXRBenVyZVByb3h5KHByb3h5KTtcbiAgICAgICAgfVxuICAgICAgICBQcm94eVV0aWwuaGlkZUVudmlyb25tZW50UHJveHkoKTtcbiAgICAgICAgY29uc3QgYmxvYlNlcnZpY2VDbGllbnQgPSBuZXcgQVpVUkUuQmxvYlNlcnZpY2VDbGllbnQoY29ubmVjdGlvblN0cmluZywgbnVsbCwge1xuICAgICAgICAgICAgcHJveHlPcHRpb25zOiBwcm94eSxcbiAgICAgICAgfSk7XG4gICAgICAgIFByb3h5VXRpbC5yZXN0b3JlRW52aXJvbm1lbnRQcm94eSgpO1xuICAgICAgICByZXR1cm4gYmxvYlNlcnZpY2VDbGllbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBjb250YWluZXIgbmFtZSBhbmQgcGF0aCBmcm9tIHRoZSBtZXRhZGF0YSdzIHN0YWdlIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YWdlTG9jYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5leHRyYWN0Q29udGFpbmVyTmFtZUFuZFBhdGggPSBmdW5jdGlvbiAoc3RhZ2VMb2NhdGlvbikge1xuICAgICAgICAvLyBleHBhbmQgJ34nIGFuZCAnfnVzZXInIGV4cHJlc3Npb25zXG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgICAgICBzdGFnZUxvY2F0aW9uID0gZXhwYW5kVGlsZGUoc3RhZ2VMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lck5hbWUgPSBzdGFnZUxvY2F0aW9uO1xuICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgLy8gc3BsaXQgc3RhZ2UgbG9jYXRpb24gYXMgYnVja2V0IG5hbWUgYW5kIHBhdGhcbiAgICAgICAgaWYgKHN0YWdlTG9jYXRpb24uaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICAgICAgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKDAsIHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpKTtcbiAgICAgICAgICAgIHBhdGggPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZyhzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSArIDEsIHN0YWdlTG9jYXRpb24ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChwYXRoICYmICFwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXp1cmVMb2NhdGlvbihjb250YWluZXJOYW1lLCBwYXRoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBmaWxlIGhlYWRlciBiYXNlZCBvbiBmaWxlIGJlaW5nIHVwbG9hZGVkIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RmlsZUhlYWRlciA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhLCBmaWxlbmFtZSkge1xuICAgICAgICBjb25zdCBzdGFnZUluZm8gPSBtZXRhWydzdGFnZUluZm8nXTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvKTtcbiAgICAgICAgY29uc3QgYXp1cmVMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdENvbnRhaW5lck5hbWVBbmRQYXRoKHN0YWdlSW5mb1snbG9jYXRpb24nXSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckNsaWVudCA9IGNsaWVudC5nZXRDb250YWluZXJDbGllbnQoYXp1cmVMb2NhdGlvbi5jb250YWluZXJOYW1lKTtcbiAgICAgICAgY29uc3QgYmxvYkNsaWVudCA9IGNvbnRhaW5lckNsaWVudC5nZXRCbG9iQ2xpZW50KGF6dXJlTG9jYXRpb24ucGF0aCArIGZpbGVuYW1lKTtcbiAgICAgICAgbGV0IGJsb2JEZXRhaWxzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgYmxvYkNsaWVudC5nZXRQcm9wZXJ0aWVzKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGJsb2JEZXRhaWxzID0gZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnJbJ2NvZGUnXSA9PT0gRVhQSVJFRF9UT0tFTikge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyWydzdGF0dXNDb2RlJ10gPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFO1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWxlSGVhZGVyKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyWydzdGF0dXNDb2RlJ10gPT09IDQwMCkge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgICAgIGxldCBlbmNyeXB0aW9uTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICBpZiAoYmxvYkRldGFpbHMubWV0YWRhdGFbJ2VuY3J5cHRpb25kYXRhJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRpb25EYXRhID0gSlNPTi5wYXJzZShibG9iRGV0YWlscy5tZXRhZGF0YVsnZW5jcnlwdGlvbmRhdGEnXSk7XG4gICAgICAgICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSBFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbkRhdGFbJ1dyYXBwZWRDb250ZW50S2V5J11bJ0VuY3J5cHRlZEtleSddLCBlbmNyeXB0aW9uRGF0YVsnQ29udGVudEVuY3J5cHRpb25JViddLCBibG9iRGV0YWlscy5tZXRhZGF0YVsnbWF0ZGVzYyddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRmlsZUhlYWRlcihibG9iRGV0YWlscy5tZXRhZGF0YVsnc2ZjZGlnZXN0J10sIGJsb2JEZXRhaWxzLmNvbnRlbnRMZW5ndGgsIGVuY3J5cHRpb25NZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGZpbGUgbWV0YWRhdGEgdGhlbiB1cGxvYWQgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4Q29uY3VycmVuY3lcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSkge1xuICAgICAgICBjb25zdCBmaWxlU3RyZWFtID0gZnMucmVhZEZpbGVTeW5jKGRhdGFGaWxlKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cGxvYWRGaWxlU3RyZWFtKGZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSwgbWF4Q29uY3VycmVuY3kpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBmaWxlIG1ldGFkYXRhIHRoZW4gdXBsb2FkIHRoZSBmaWxlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlU3RyZWFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5jcnlwdGlvbk1ldGFkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZEZpbGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAoZmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGF6dXJlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBzZmNkaWdlc3Q6IG1ldGFbJ1NIQTI1Nl9ESUdFU1QnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgYXp1cmVNZXRhZGF0YVsnZW5jcnlwdGlvbmRhdGEnXSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBFbmNyeXB0aW9uTW9kZTogJ0Z1bGxCbG9iJyxcbiAgICAgICAgICAgICAgICBXcmFwcGVkQ29udGVudEtleToge1xuICAgICAgICAgICAgICAgICAgICBLZXlJZDogJ3N5bW1LZXkxJyxcbiAgICAgICAgICAgICAgICAgICAgRW5jcnlwdGVkS2V5OiBlbmNyeXB0aW9uTWV0YWRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgICBBbGdvcml0aG06ICdBRVNfQ0JDXzI1NicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBFbmNyeXB0aW9uQWdlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgUHJvdG9jb2w6ICcxLjAnLFxuICAgICAgICAgICAgICAgICAgICBFbmNyeXB0aW9uQWxnb3JpdGhtOiAnQUVTX0NCQ18xMjgnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ29udGVudEVuY3J5cHRpb25JVjogZW5jcnlwdGlvbk1ldGFkYXRhLml2LFxuICAgICAgICAgICAgICAgIEtleVdyYXBwaW5nTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgRW5jcnlwdGlvbkxpYnJhcnk6ICdKYXZhIDUuMy4wJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhenVyZU1ldGFkYXRhWydtYXRkZXNjJ10gPSBlbmNyeXB0aW9uTWV0YWRhdGEubWF0RGVzYztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFnZUluZm8gPSBtZXRhWydzdGFnZUluZm8nXTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvKTtcbiAgICAgICAgY29uc3QgYXp1cmVMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdENvbnRhaW5lck5hbWVBbmRQYXRoKHN0YWdlSW5mb1snbG9jYXRpb24nXSk7XG4gICAgICAgIGNvbnN0IGJsb2JOYW1lID0gYXp1cmVMb2NhdGlvbi5wYXRoICsgbWV0YVsnZHN0RmlsZU5hbWUnXTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQ2xpZW50ID0gY2xpZW50LmdldENvbnRhaW5lckNsaWVudChhenVyZUxvY2F0aW9uLmNvbnRhaW5lck5hbWUpO1xuICAgICAgICBjb25zdCBibG9ja0Jsb2JDbGllbnQgPSBjb250YWluZXJDbGllbnQuZ2V0QmxvY2tCbG9iQ2xpZW50KGJsb2JOYW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGJsb2NrQmxvYkNsaWVudC51cGxvYWQoZmlsZVN0cmVhbSwgZmlsZVN0cmVhbS5sZW5ndGgsIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogYXp1cmVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBibG9iSFRUUEhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvYkNvbnRlbnRFbmNvZGluZzogJ1VURi04JyxcbiAgICAgICAgICAgICAgICAgICAgYmxvYkNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnc3RhdHVzQ29kZSddID09PSA0MDMgJiYgZGV0ZWN0QXp1cmVUb2tlbkV4cGlyZUVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSBtZXRhWyd1cGxvYWRTaXplJ107XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlVQTE9BREVEO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgdGhlIGZpbGUgYmxvYiB0aGVuIHdyaXRlIHRoZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0gZnVsbERzdFBhdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmF0aXZlRG93bmxvYWRGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZ1bGxEc3RQYXRoKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgICAgICBjb25zdCBhenVyZUxvY2F0aW9uID0gdGhpcy5leHRyYWN0Q29udGFpbmVyTmFtZUFuZFBhdGgoc3RhZ2VJbmZvWydsb2NhdGlvbiddKTtcbiAgICAgICAgY29uc3QgYmxvYk5hbWUgPSBhenVyZUxvY2F0aW9uLnBhdGggKyBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgICBjb25zdCBjb250YWluZXJDbGllbnQgPSBjbGllbnQuZ2V0Q29udGFpbmVyQ2xpZW50KGF6dXJlTG9jYXRpb24uY29udGFpbmVyTmFtZSk7XG4gICAgICAgIGNvbnN0IGJsb2NrQmxvYkNsaWVudCA9IGNvbnRhaW5lckNsaWVudC5nZXRCbG9ja0Jsb2JDbGllbnQoYmxvYk5hbWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRCbG9ja0Jsb2JSZXNwb25zZSA9IGF3YWl0IGJsb2NrQmxvYkNsaWVudC5kb3dubG9hZCgwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gZG93bmxvYWRCbG9ja0Jsb2JSZXNwb25zZS5yZWFkYWJsZVN0cmVhbUJvZHk7XG4gICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgU2VudCBHZXQgUmVxdWVzdCB0byAke2Jsb2NrQmxvYkNsaWVudC51cmwuc3BsaXQoJz8nKVswXX0sIGRlc3RpbmF0aW9uOiAke2Z1bGxEc3RQYXRofSwgaHR0cCBzdGF0dXM6ICR7ZG93bmxvYWRCbG9ja0Jsb2JSZXNwb25zZS5vcmlnaW5hbFJlc3BvbnNlLl9yZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZnVsbERzdFBhdGgpO1xuICAgICAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5lbmQocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhZGFibGVTdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnJbJ3N0YXR1c0NvZGUnXSA9PT0gNDAzICYmIGRldGVjdEF6dXJlVG9rZW5FeHBpcmVFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ET1dOTE9BREVEO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSBBenVyZSB0b2tlbiBoYXMgZXhwaXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVjdEF6dXJlVG9rZW5FeHBpcmVFcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGVyclsnc3RhdHVzQ29kZSddICE9PSA0MDMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJzdHIgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIChlcnJzdHIuaW5jbHVkZXMoJ1NpZ25hdHVyZSBub3QgdmFsaWQgaW4gdGhlIHNwZWNpZmllZCB0aW1lIGZyYW1lJykgfHxcbiAgICAgICAgICAgIGVycnN0ci5pbmNsdWRlcygnU2VydmVyIGZhaWxlZCB0byBhdXRoZW50aWNhdGUgdGhlIHJlcXVlc3QuJykpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQXp1cmVVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXp1cmVfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst AES_BLOCK_SIZE = 128;\nconst blockSize = parseInt(AES_BLOCK_SIZE / 8); // in bytes\nconst QUERY_STAGE_MASTER_KEY = 'queryStageMasterKey';\nconst BASE64 = 'base64';\nconst DEFAULT_AAD = Buffer.from('');\nconst AUTH_TAG_LENGTH_IN_BYTES = 16;\nconst AES_CBC = {\n    cipherName: function (keySizeInBytes) {\n        return `aes-${keySizeInBytes * 8}-cbc`;\n    },\n    ivSize: 16,\n};\nconst AES_ECB = {\n    cipherName: function (keySizeInBytes) {\n        return `aes-${keySizeInBytes * 8}-ecb`;\n    },\n};\nconst AES_GCM = {\n    cipherName: function (keySizeInBytes) {\n        return `aes-${keySizeInBytes * 8}-gcm`;\n    },\n    ivSize: 12,\n};\n// Material Descriptor\nfunction MaterialDescriptor(smkId, queryId, keySize) {\n    return {\n        smkId: smkId,\n        queryId: queryId,\n        keySize: keySize,\n    };\n}\n// Encryption Material\nfunction EncryptionMetadata(key, dataIv, matDesc, keyIv, dataAad, keyAad) {\n    return {\n        key: key,\n        iv: dataIv,\n        matDesc: matDesc,\n        keyIv: keyIv,\n        dataAad: dataAad,\n        keyAad: keyAad,\n    };\n}\nexports.EncryptionMetadata = EncryptionMetadata;\nfunction TempFileGenerator() {\n    this.fileSync = function (option = { dir: os.tmpdir(), prefix: '', postfix: '', extension: '' }) {\n        const randomName = crypto.randomUUID();\n        const fileName = `${option.prefix || ''}${randomName}${option.postfix || ''}${'.' + option.extension || 0}`;\n        if (!this.checkDirInTemp(option.dir)) {\n            option.dir = os.tmpdir();\n        }\n        const fullpath = path.join(option.dir, fileName);\n        fs.writeFileSync(fullpath, '');\n        const fileDescriptor = fs.openSync(fullpath);\n        return { name: fullpath, fd: fileDescriptor };\n    };\n    this.file = function (option = { dir: os.tmpdir(), prefix: '', postfix: '', extension: '' }, callback) {\n        try {\n            const { name, fd } = this.fileSync(option);\n            callback(null, name, fd);\n        }\n        catch (err) {\n            callback(err);\n        }\n    };\n    this.checkDirInTemp = function (directoryPath) {\n        if (!directoryPath || directoryPath.length === 0) {\n            return false;\n        }\n        if (directoryPath.includes(os.tmpdir())) {\n            if (fs.existsSync(directoryPath)) {\n                return true;\n            }\n            else {\n                Logger.getInstance().warn(`no such file or directory, open ${directoryPath}`);\n            }\n        }\n        else {\n            Logger.getInstance().warn(`dir option must be relative to ${os.tmpdir()}, found ${directoryPath}`);\n        }\n        return false;\n    };\n}\n/**\n * Creates an encryption utility object.\n *\n * @param {module} encrypt\n * @param {module} filestream\n * @param {module} temp\n *\n * @returns {Object}\n * @constructor\n */\nfunction EncryptUtil(encrypt, filestream, temp) {\n    const crypto = typeof encrypt !== 'undefined' ? encrypt : __webpack_require__(/*! crypto */ \"crypto\");\n    // TODO: SNOW-1814883: Replace 'fs' with 'fs/promises'\n    const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n    const tmp = typeof temp !== 'undefined' ? temp : new TempFileGenerator();\n    /**\n     * Generate a buffer with random bytes given a size.\n     *\n     * @param {Number} byteLength\n     *\n     * @returns {Buffer} of size byteLength\n     */\n    function getSecureRandom(byteLength) {\n        return crypto.randomBytes(byteLength);\n    }\n    /**\n     * Convert a material descriptor object's values to unicode.\n     *\n     * @param {Object} matDesc\n     *\n     * @returns {Object}\n     */\n    function matDescToUnicode(matDesc) {\n        matDesc['smkId'] = matDesc['smkId'].toString();\n        matDesc['keySize'] = matDesc['keySize'].toString();\n        const newMatDesc = JSON.stringify(matDesc);\n        return newMatDesc;\n    }\n    function createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv, keyIv = null, dataAad = null, keyAad = null) {\n        const matDesc = new MaterialDescriptor(encryptionMaterial.smkId, encryptionMaterial.queryId, keySize * 8);\n        return new EncryptionMetadata(encryptedKey.toString(BASE64), dataIv.toString(BASE64), matDescToUnicode(matDesc), keyIv ? keyIv.toString(BASE64) : null, dataAad ? dataAad.toString(BASE64) : null, keyAad ? keyAad.toString(BASE64) : null);\n    }\n    /**\n     * Encrypt content using AES-CBC algorithm.\n     */\n    this.encryptFileStream = async function (encryptionMaterial, content) {\n        return this.encryptDataCBC(encryptionMaterial, content);\n    };\n    this.encryptDataCBC = function (encryptionMaterial, data) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keySize = decodedKek.length;\n        const dataIv = getSecureRandom(AES_CBC.ivSize);\n        const fileKey = getSecureRandom(keySize);\n        const dataCipher = crypto.createCipheriv(AES_CBC.cipherName(keySize), fileKey, dataIv);\n        const encryptedData = performCrypto(dataCipher, data);\n        const keyCipher = crypto.createCipheriv(AES_ECB.cipherName(keySize), decodedKek, null);\n        const encryptedKey = performCrypto(keyCipher, fileKey);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv),\n            dataStream: encryptedData,\n        };\n    };\n    //TODO: SNOW-940981: Add proper usage when feature is ready\n    this.encryptDataGCM = function (encryptionMaterial, data) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keySize = decodedKek.length;\n        const dataIv = getSecureRandom(AES_GCM.ivSize);\n        const fileKey = getSecureRandom(keySize);\n        const encryptedData = this.encryptGCM(data, fileKey, dataIv, DEFAULT_AAD);\n        const keyIv = getSecureRandom(AES_GCM.ivSize);\n        const encryptedKey = this.encryptGCM(fileKey, decodedKek, keyIv, DEFAULT_AAD);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv, keyIv, DEFAULT_AAD, DEFAULT_AAD),\n            dataStream: encryptedData,\n        };\n    };\n    this.encryptGCM = function (data, key, iv, aad) {\n        const cipher = crypto.createCipheriv(AES_GCM.cipherName(key.length), key, iv, {\n            authTagLength: AUTH_TAG_LENGTH_IN_BYTES,\n        });\n        if (aad) {\n            cipher.setAAD(aad);\n        }\n        const encryptedData = performCrypto(cipher, data);\n        return Buffer.concat([encryptedData, cipher.getAuthTag()]);\n    };\n    this.decryptGCM = function (data, key, iv, aad) {\n        const decipher = crypto.createDecipheriv(AES_GCM.cipherName(key.length), key, iv, {\n            authTagLength: AUTH_TAG_LENGTH_IN_BYTES,\n        });\n        if (aad) {\n            decipher.setAAD(aad);\n        }\n        // last 16 bytes of data is the authentication tag\n        const authTag = data.slice(data.length - AUTH_TAG_LENGTH_IN_BYTES, data.length);\n        const cipherText = data.slice(0, data.length - AUTH_TAG_LENGTH_IN_BYTES);\n        decipher.setAuthTag(authTag);\n        return performCrypto(decipher, cipherText);\n    };\n    /**\n     * Encrypt file using AES algorithm.\n     */\n    this.encryptFile = async function (encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        return await this.encryptFileCBC(encryptionMaterial, inputFilePath, tmpDir, chunkSize);\n    };\n    this.encryptFileCBC = async function (encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keySize = decodedKek.length;\n        const dataIv = getSecureRandom(AES_CBC.ivSize);\n        const fileKey = getSecureRandom(keySize);\n        const dataCipher = crypto.createCipheriv(AES_CBC.cipherName(keySize), fileKey, dataIv);\n        const encryptedFilePath = await performFileStreamCrypto(dataCipher, tmpDir, inputFilePath, chunkSize);\n        const keyCipher = crypto.createCipheriv(AES_ECB.cipherName(keySize), decodedKek, null);\n        const encryptedKey = performCrypto(keyCipher, fileKey);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv),\n            dataFile: encryptedFilePath,\n        };\n    };\n    //TODO: SNOW-940981: Add proper usage when feature is ready\n    this.encryptFileGCM = async function (encryptionMaterial, inputFilePath, tmpDir = null) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const dataIv = getSecureRandom(AES_GCM.ivSize);\n        const fileKey = getSecureRandom(decodedKek.length);\n        const fileContent = await new Promise((resolve, reject) => {\n            fs.readFile(inputFilePath, (err, data) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n        const encryptedData = this.encryptGCM(fileContent, fileKey, dataIv, DEFAULT_AAD);\n        const encryptedFilePath = await writeContentToFile(tmpDir, path.basename(inputFilePath) + '#', encryptedData);\n        const keyIv = getSecureRandom(AES_GCM.ivSize);\n        const encryptedKey = this.encryptGCM(fileKey, decodedKek, keyIv, DEFAULT_AAD);\n        return {\n            encryptionMetadata: createEncryptionMetadata(encryptionMaterial, fileKey.length, encryptedKey, dataIv, keyIv, DEFAULT_AAD, DEFAULT_AAD),\n            dataFile: encryptedFilePath,\n        };\n    };\n    /**\n     * Decrypt file using AES algorithm.\n     */\n    this.decryptFile = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        return await this.decryptFileCBC(metadata, encryptionMaterial, inputFilePath, tmpDir, chunkSize);\n    };\n    this.decryptFileCBC = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keyBytes = new Buffer.from(metadata.key, BASE64);\n        const ivBytes = new Buffer.from(metadata.iv, BASE64);\n        const keyDecipher = crypto.createDecipheriv(AES_ECB.cipherName(decodedKek.length), decodedKek, null);\n        const fileKey = performCrypto(keyDecipher, keyBytes);\n        const dataDecipher = crypto.createDecipheriv(AES_CBC.cipherName(fileKey.length), fileKey, ivBytes);\n        return await performFileStreamCrypto(dataDecipher, tmpDir, inputFilePath, chunkSize);\n    };\n    //TODO: SNOW-940981: Add proper usage when feature is ready\n    this.decryptFileGCM = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null) {\n        const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n        const keyBytes = new Buffer.from(metadata.key, BASE64);\n        const keyIvBytes = new Buffer.from(metadata.keyIv, BASE64);\n        const dataIvBytes = new Buffer.from(metadata.iv, BASE64);\n        const dataAadBytes = new Buffer.from(metadata.dataAad, BASE64);\n        const keyAadBytes = new Buffer.from(metadata.keyAad, BASE64);\n        const fileKey = this.decryptGCM(keyBytes, decodedKek, keyIvBytes, keyAadBytes);\n        const fileContent = await new Promise((resolve, reject) => {\n            fs.readFile(inputFilePath, (err, data) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n        const decryptedData = this.decryptGCM(fileContent, fileKey, dataIvBytes, dataAadBytes);\n        return await writeContentToFile(tmpDir, path.basename(inputFilePath) + '#', decryptedData);\n    };\n    function performCrypto(cipherOrDecipher, data) {\n        const encryptedOrDecrypted = cipherOrDecipher.update(data);\n        const final = cipherOrDecipher.final();\n        return Buffer.concat([encryptedOrDecrypted, final]);\n    }\n    async function performFileStreamCrypto(cipherOrDecipher, tmpDir, inputFilePath, chunkSize) {\n        const outputFile = await new Promise((resolve, reject) => {\n            tmp.file({ dir: tmpDir, prefix: path.basename(inputFilePath) + '#' }, (err, path, fd) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve({ path, fd });\n                }\n            });\n        });\n        await new Promise(function (resolve) {\n            const inputStream = fs.createReadStream(inputFilePath, { highWaterMark: chunkSize });\n            const outputStream = fs.createWriteStream(outputFile.path);\n            inputStream.on('data', function (chunk) {\n                const encrypted = cipherOrDecipher.update(chunk);\n                outputStream.write(encrypted);\n            });\n            inputStream.on('close', function () {\n                outputStream.write(cipherOrDecipher.final());\n                outputStream.close(resolve);\n            });\n        });\n        await new Promise((resolve, reject) => {\n            fs.close(outputFile.fd, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        return outputFile.path;\n    }\n    async function writeContentToFile(tmpDir, prefix, content) {\n        const outputFile = await new Promise((resolve, reject) => {\n            tmp.file({ dir: tmpDir, prefix: prefix }, (err, path, fd) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve({ path, fd });\n                }\n            });\n        });\n        await new Promise((resolve, reject) => {\n            fs.writeFile(outputFile.path, content, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        await new Promise((resolve, reject) => {\n            fs.close(outputFile.fd, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        return outputFile.path;\n    }\n}\nexports.EncryptUtil = EncryptUtil;\n//# sourceMappingURL=encrypt_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2VuY3J5cHRfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EseUNBQXlDLDBEQUEwRDtBQUNuRztBQUNBLDRCQUE0QixvQkFBb0IsRUFBRSxXQUFXLEVBQUUscUJBQXFCLEVBQUUsMEJBQTBCLENBQUUsQ0FBQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxQ0FBcUMsMERBQTBEO0FBQy9GO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGNBQWM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFlBQVksVUFBVSxjQUFjO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFPLENBQUMsc0JBQVE7QUFDOUU7QUFDQSxnRUFBZ0UsbUJBQU8sQ0FBQyxjQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUF5RDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLHFFQUFxRSwwQkFBMEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2VuY3J5cHRfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgQUVTX0JMT0NLX1NJWkUgPSAxMjg7XG5jb25zdCBibG9ja1NpemUgPSBwYXJzZUludChBRVNfQkxPQ0tfU0laRSAvIDgpOyAvLyBpbiBieXRlc1xuY29uc3QgUVVFUllfU1RBR0VfTUFTVEVSX0tFWSA9ICdxdWVyeVN0YWdlTWFzdGVyS2V5JztcbmNvbnN0IEJBU0U2NCA9ICdiYXNlNjQnO1xuY29uc3QgREVGQVVMVF9BQUQgPSBCdWZmZXIuZnJvbSgnJyk7XG5jb25zdCBBVVRIX1RBR19MRU5HVEhfSU5fQllURVMgPSAxNjtcbmNvbnN0IEFFU19DQkMgPSB7XG4gICAgY2lwaGVyTmFtZTogZnVuY3Rpb24gKGtleVNpemVJbkJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBgYWVzLSR7a2V5U2l6ZUluQnl0ZXMgKiA4fS1jYmNgO1xuICAgIH0sXG4gICAgaXZTaXplOiAxNixcbn07XG5jb25zdCBBRVNfRUNCID0ge1xuICAgIGNpcGhlck5hbWU6IGZ1bmN0aW9uIChrZXlTaXplSW5CeXRlcykge1xuICAgICAgICByZXR1cm4gYGFlcy0ke2tleVNpemVJbkJ5dGVzICogOH0tZWNiYDtcbiAgICB9LFxufTtcbmNvbnN0IEFFU19HQ00gPSB7XG4gICAgY2lwaGVyTmFtZTogZnVuY3Rpb24gKGtleVNpemVJbkJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBgYWVzLSR7a2V5U2l6ZUluQnl0ZXMgKiA4fS1nY21gO1xuICAgIH0sXG4gICAgaXZTaXplOiAxMixcbn07XG4vLyBNYXRlcmlhbCBEZXNjcmlwdG9yXG5mdW5jdGlvbiBNYXRlcmlhbERlc2NyaXB0b3Ioc21rSWQsIHF1ZXJ5SWQsIGtleVNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzbWtJZDogc21rSWQsXG4gICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5SWQsXG4gICAgICAgIGtleVNpemU6IGtleVNpemUsXG4gICAgfTtcbn1cbi8vIEVuY3J5cHRpb24gTWF0ZXJpYWxcbmZ1bmN0aW9uIEVuY3J5cHRpb25NZXRhZGF0YShrZXksIGRhdGFJdiwgbWF0RGVzYywga2V5SXYsIGRhdGFBYWQsIGtleUFhZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBpdjogZGF0YUl2LFxuICAgICAgICBtYXREZXNjOiBtYXREZXNjLFxuICAgICAgICBrZXlJdjoga2V5SXYsXG4gICAgICAgIGRhdGFBYWQ6IGRhdGFBYWQsXG4gICAgICAgIGtleUFhZDoga2V5QWFkLFxuICAgIH07XG59XG5leHBvcnRzLkVuY3J5cHRpb25NZXRhZGF0YSA9IEVuY3J5cHRpb25NZXRhZGF0YTtcbmZ1bmN0aW9uIFRlbXBGaWxlR2VuZXJhdG9yKCkge1xuICAgIHRoaXMuZmlsZVN5bmMgPSBmdW5jdGlvbiAob3B0aW9uID0geyBkaXI6IG9zLnRtcGRpcigpLCBwcmVmaXg6ICcnLCBwb3N0Zml4OiAnJywgZXh0ZW5zaW9uOiAnJyB9KSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbU5hbWUgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGAke29wdGlvbi5wcmVmaXggfHwgJyd9JHtyYW5kb21OYW1lfSR7b3B0aW9uLnBvc3RmaXggfHwgJyd9JHsnLicgKyBvcHRpb24uZXh0ZW5zaW9uIHx8ICcnfWA7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0RpckluVGVtcChvcHRpb24uZGlyKSkge1xuICAgICAgICAgICAgb3B0aW9uLmRpciA9IG9zLnRtcGRpcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gcGF0aC5qb2luKG9wdGlvbi5kaXIsIGZpbGVOYW1lKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmdWxscGF0aCwgJycpO1xuICAgICAgICBjb25zdCBmaWxlRGVzY3JpcHRvciA9IGZzLm9wZW5TeW5jKGZ1bGxwYXRoKTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogZnVsbHBhdGgsIGZkOiBmaWxlRGVzY3JpcHRvciB9O1xuICAgIH07XG4gICAgdGhpcy5maWxlID0gZnVuY3Rpb24gKG9wdGlvbiA9IHsgZGlyOiBvcy50bXBkaXIoKSwgcHJlZml4OiAnJywgcG9zdGZpeDogJycsIGV4dGVuc2lvbjogJycgfSwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZmQgfSA9IHRoaXMuZmlsZVN5bmMob3B0aW9uKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG5hbWUsIGZkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNoZWNrRGlySW5UZW1wID0gZnVuY3Rpb24gKGRpcmVjdG9yeVBhdGgpIHtcbiAgICAgICAgaWYgKCFkaXJlY3RvcnlQYXRoIHx8IGRpcmVjdG9yeVBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdG9yeVBhdGguaW5jbHVkZXMob3MudG1wZGlyKCkpKSB7XG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhkaXJlY3RvcnlQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2Fybihgbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSwgb3BlbiAke2RpcmVjdG9yeVBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBkaXIgb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gJHtvcy50bXBkaXIoKX0sIGZvdW5kICR7ZGlyZWN0b3J5UGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBlbmNyeXB0aW9uIHV0aWxpdHkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlfSBlbmNyeXB0XG4gKiBAcGFyYW0ge21vZHVsZX0gZmlsZXN0cmVhbVxuICogQHBhcmFtIHttb2R1bGV9IHRlbXBcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVuY3J5cHRVdGlsKGVuY3J5cHQsIGZpbGVzdHJlYW0sIHRlbXApIHtcbiAgICBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZW5jcnlwdCAhPT0gJ3VuZGVmaW5lZCcgPyBlbmNyeXB0IDogcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgLy8gVE9ETzogU05PVy0xODE0ODgzOiBSZXBsYWNlICdmcycgd2l0aCAnZnMvcHJvbWlzZXMnXG4gICAgY29uc3QgZnMgPSB0eXBlb2YgZmlsZXN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlc3RyZWFtIDogcmVxdWlyZSgnZnMnKTtcbiAgICBjb25zdCB0bXAgPSB0eXBlb2YgdGVtcCAhPT0gJ3VuZGVmaW5lZCcgPyB0ZW1wIDogbmV3IFRlbXBGaWxlR2VuZXJhdG9yKCk7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBidWZmZXIgd2l0aCByYW5kb20gYnl0ZXMgZ2l2ZW4gYSBzaXplLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVMZW5ndGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IG9mIHNpemUgYnl0ZUxlbmd0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNlY3VyZVJhbmRvbShieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBtYXRlcmlhbCBkZXNjcmlwdG9yIG9iamVjdCdzIHZhbHVlcyB0byB1bmljb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hdERlc2NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0RGVzY1RvVW5pY29kZShtYXREZXNjKSB7XG4gICAgICAgIG1hdERlc2NbJ3Nta0lkJ10gPSBtYXREZXNjWydzbWtJZCddLnRvU3RyaW5nKCk7XG4gICAgICAgIG1hdERlc2NbJ2tleVNpemUnXSA9IG1hdERlc2NbJ2tleVNpemUnXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuZXdNYXREZXNjID0gSlNPTi5zdHJpbmdpZnkobWF0RGVzYyk7XG4gICAgICAgIHJldHVybiBuZXdNYXREZXNjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbk1hdGVyaWFsLCBrZXlTaXplLCBlbmNyeXB0ZWRLZXksIGRhdGFJdiwga2V5SXYgPSBudWxsLCBkYXRhQWFkID0gbnVsbCwga2V5QWFkID0gbnVsbCkge1xuICAgICAgICBjb25zdCBtYXREZXNjID0gbmV3IE1hdGVyaWFsRGVzY3JpcHRvcihlbmNyeXB0aW9uTWF0ZXJpYWwuc21rSWQsIGVuY3J5cHRpb25NYXRlcmlhbC5xdWVyeUlkLCBrZXlTaXplICogOCk7XG4gICAgICAgIHJldHVybiBuZXcgRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRlZEtleS50b1N0cmluZyhCQVNFNjQpLCBkYXRhSXYudG9TdHJpbmcoQkFTRTY0KSwgbWF0RGVzY1RvVW5pY29kZShtYXREZXNjKSwga2V5SXYgPyBrZXlJdi50b1N0cmluZyhCQVNFNjQpIDogbnVsbCwgZGF0YUFhZCA/IGRhdGFBYWQudG9TdHJpbmcoQkFTRTY0KSA6IG51bGwsIGtleUFhZCA/IGtleUFhZC50b1N0cmluZyhCQVNFNjQpIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgY29udGVudCB1c2luZyBBRVMtQ0JDIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICB0aGlzLmVuY3J5cHRGaWxlU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24gKGVuY3J5cHRpb25NYXRlcmlhbCwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0RGF0YUNCQyhlbmNyeXB0aW9uTWF0ZXJpYWwsIGNvbnRlbnQpO1xuICAgIH07XG4gICAgdGhpcy5lbmNyeXB0RGF0YUNCQyA9IGZ1bmN0aW9uIChlbmNyeXB0aW9uTWF0ZXJpYWwsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZEtlayA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25NYXRlcmlhbFtRVUVSWV9TVEFHRV9NQVNURVJfS0VZXSwgQkFTRTY0KTtcbiAgICAgICAgY29uc3Qga2V5U2l6ZSA9IGRlY29kZWRLZWsubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXRhSXYgPSBnZXRTZWN1cmVSYW5kb20oQUVTX0NCQy5pdlNpemUpO1xuICAgICAgICBjb25zdCBmaWxlS2V5ID0gZ2V0U2VjdXJlUmFuZG9tKGtleVNpemUpO1xuICAgICAgICBjb25zdCBkYXRhQ2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19DQkMuY2lwaGVyTmFtZShrZXlTaXplKSwgZmlsZUtleSwgZGF0YUl2KTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHBlcmZvcm1DcnlwdG8oZGF0YUNpcGhlciwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGtleUNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihBRVNfRUNCLmNpcGhlck5hbWUoa2V5U2l6ZSksIGRlY29kZWRLZWssIG51bGwpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRLZXkgPSBwZXJmb3JtQ3J5cHRvKGtleUNpcGhlciwgZmlsZUtleSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNyeXB0aW9uTWV0YWRhdGE6IGNyZWF0ZUVuY3J5cHRpb25NZXRhZGF0YShlbmNyeXB0aW9uTWF0ZXJpYWwsIGtleVNpemUsIGVuY3J5cHRlZEtleSwgZGF0YUl2KSxcbiAgICAgICAgICAgIGRhdGFTdHJlYW06IGVuY3J5cHRlZERhdGEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvL1RPRE86IFNOT1ctOTQwOTgxOiBBZGQgcHJvcGVyIHVzYWdlIHdoZW4gZmVhdHVyZSBpcyByZWFkeVxuICAgIHRoaXMuZW5jcnlwdERhdGFHQ00gPSBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRLZWsgPSBCdWZmZXIuZnJvbShlbmNyeXB0aW9uTWF0ZXJpYWxbUVVFUllfU1RBR0VfTUFTVEVSX0tFWV0sIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBkZWNvZGVkS2VrLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YUl2ID0gZ2V0U2VjdXJlUmFuZG9tKEFFU19HQ00uaXZTaXplKTtcbiAgICAgICAgY29uc3QgZmlsZUtleSA9IGdldFNlY3VyZVJhbmRvbShrZXlTaXplKTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZW5jcnlwdEdDTShkYXRhLCBmaWxlS2V5LCBkYXRhSXYsIERFRkFVTFRfQUFEKTtcbiAgICAgICAgY29uc3Qga2V5SXYgPSBnZXRTZWN1cmVSYW5kb20oQUVTX0dDTS5pdlNpemUpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRLZXkgPSB0aGlzLmVuY3J5cHRHQ00oZmlsZUtleSwgZGVjb2RlZEtlaywga2V5SXYsIERFRkFVTFRfQUFEKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YTogY3JlYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRpb25NYXRlcmlhbCwga2V5U2l6ZSwgZW5jcnlwdGVkS2V5LCBkYXRhSXYsIGtleUl2LCBERUZBVUxUX0FBRCwgREVGQVVMVF9BQUQpLFxuICAgICAgICAgICAgZGF0YVN0cmVhbTogZW5jcnlwdGVkRGF0YSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMuZW5jcnlwdEdDTSA9IGZ1bmN0aW9uIChkYXRhLCBrZXksIGl2LCBhYWQpIHtcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19HQ00uY2lwaGVyTmFtZShrZXkubGVuZ3RoKSwga2V5LCBpdiwge1xuICAgICAgICAgICAgYXV0aFRhZ0xlbmd0aDogQVVUSF9UQUdfTEVOR1RIX0lOX0JZVEVTLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFhZCkge1xuICAgICAgICAgICAgY2lwaGVyLnNldEFBRChhYWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBwZXJmb3JtQ3J5cHRvKGNpcGhlciwgZGF0YSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmNyeXB0ZWREYXRhLCBjaXBoZXIuZ2V0QXV0aFRhZygpXSk7XG4gICAgfTtcbiAgICB0aGlzLmRlY3J5cHRHQ00gPSBmdW5jdGlvbiAoZGF0YSwga2V5LCBpdiwgYWFkKSB7XG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoQUVTX0dDTS5jaXBoZXJOYW1lKGtleS5sZW5ndGgpLCBrZXksIGl2LCB7XG4gICAgICAgICAgICBhdXRoVGFnTGVuZ3RoOiBBVVRIX1RBR19MRU5HVEhfSU5fQllURVMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWFkKSB7XG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBQUQoYWFkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsYXN0IDE2IGJ5dGVzIG9mIGRhdGEgaXMgdGhlIGF1dGhlbnRpY2F0aW9uIHRhZ1xuICAgICAgICBjb25zdCBhdXRoVGFnID0gZGF0YS5zbGljZShkYXRhLmxlbmd0aCAtIEFVVEhfVEFHX0xFTkdUSF9JTl9CWVRFUywgZGF0YS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjaXBoZXJUZXh0ID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIEFVVEhfVEFHX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcoYXV0aFRhZyk7XG4gICAgICAgIHJldHVybiBwZXJmb3JtQ3J5cHRvKGRlY2lwaGVyLCBjaXBoZXJUZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuY3J5cHQgZmlsZSB1c2luZyBBRVMgYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIHRoaXMuZW5jcnlwdEZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsLCBjaHVua1NpemUgPSBibG9ja1NpemUgKiA0ICogMTAyNCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmNyeXB0RmlsZUNCQyhlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsIHRtcERpciwgY2h1bmtTaXplKTtcbiAgICB9O1xuICAgIHRoaXMuZW5jcnlwdEZpbGVDQkMgPSBhc3luYyBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsLCBjaHVua1NpemUgPSBibG9ja1NpemUgKiA0ICogMTAyNCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBrZXlTaXplID0gZGVjb2RlZEtlay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRhdGFJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfQ0JDLml2U2l6ZSk7XG4gICAgICAgIGNvbnN0IGZpbGVLZXkgPSBnZXRTZWN1cmVSYW5kb20oa2V5U2l6ZSk7XG4gICAgICAgIGNvbnN0IGRhdGFDaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0NCQy5jaXBoZXJOYW1lKGtleVNpemUpLCBmaWxlS2V5LCBkYXRhSXYpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRGaWxlUGF0aCA9IGF3YWl0IHBlcmZvcm1GaWxlU3RyZWFtQ3J5cHRvKGRhdGFDaXBoZXIsIHRtcERpciwgaW5wdXRGaWxlUGF0aCwgY2h1bmtTaXplKTtcbiAgICAgICAgY29uc3Qga2V5Q2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19FQ0IuY2lwaGVyTmFtZShrZXlTaXplKSwgZGVjb2RlZEtlaywgbnVsbCk7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZEtleSA9IHBlcmZvcm1DcnlwdG8oa2V5Q2lwaGVyLCBmaWxlS2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YTogY3JlYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRpb25NYXRlcmlhbCwga2V5U2l6ZSwgZW5jcnlwdGVkS2V5LCBkYXRhSXYpLFxuICAgICAgICAgICAgZGF0YUZpbGU6IGVuY3J5cHRlZEZpbGVQYXRoLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy9UT0RPOiBTTk9XLTk0MDk4MTogQWRkIHByb3BlciB1c2FnZSB3aGVuIGZlYXR1cmUgaXMgcmVhZHlcbiAgICB0aGlzLmVuY3J5cHRGaWxlR0NNID0gYXN5bmMgZnVuY3Rpb24gKGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCwgdG1wRGlyID0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBkYXRhSXYgPSBnZXRTZWN1cmVSYW5kb20oQUVTX0dDTS5pdlNpemUpO1xuICAgICAgICBjb25zdCBmaWxlS2V5ID0gZ2V0U2VjdXJlUmFuZG9tKGRlY29kZWRLZWsubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmcy5yZWFkRmlsZShpbnB1dEZpbGVQYXRoLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gdGhpcy5lbmNyeXB0R0NNKGZpbGVDb250ZW50LCBmaWxlS2V5LCBkYXRhSXYsIERFRkFVTFRfQUFEKTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkRmlsZVBhdGggPSBhd2FpdCB3cml0ZUNvbnRlbnRUb0ZpbGUodG1wRGlyLCBwYXRoLmJhc2VuYW1lKGlucHV0RmlsZVBhdGgpICsgJyMnLCBlbmNyeXB0ZWREYXRhKTtcbiAgICAgICAgY29uc3Qga2V5SXYgPSBnZXRTZWN1cmVSYW5kb20oQUVTX0dDTS5pdlNpemUpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRLZXkgPSB0aGlzLmVuY3J5cHRHQ00oZmlsZUtleSwgZGVjb2RlZEtlaywga2V5SXYsIERFRkFVTFRfQUFEKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YTogY3JlYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRpb25NYXRlcmlhbCwgZmlsZUtleS5sZW5ndGgsIGVuY3J5cHRlZEtleSwgZGF0YUl2LCBrZXlJdiwgREVGQVVMVF9BQUQsIERFRkFVTFRfQUFEKSxcbiAgICAgICAgICAgIGRhdGFGaWxlOiBlbmNyeXB0ZWRGaWxlUGF0aCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY3J5cHQgZmlsZSB1c2luZyBBRVMgYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIHRoaXMuZGVjcnlwdEZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YWRhdGEsIGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCwgdG1wRGlyID0gbnVsbCwgY2h1bmtTaXplID0gYmxvY2tTaXplICogNCAqIDEwMjQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVjcnlwdEZpbGVDQkMobWV0YWRhdGEsIGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCwgdG1wRGlyLCBjaHVua1NpemUpO1xuICAgIH07XG4gICAgdGhpcy5kZWNyeXB0RmlsZUNCQyA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhZGF0YSwgZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsLCBjaHVua1NpemUgPSBibG9ja1NpemUgKiA0ICogMTAyNCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBrZXlCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5rZXksIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGl2Qnl0ZXMgPSBuZXcgQnVmZmVyLmZyb20obWV0YWRhdGEuaXYsIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGtleURlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoQUVTX0VDQi5jaXBoZXJOYW1lKGRlY29kZWRLZWsubGVuZ3RoKSwgZGVjb2RlZEtlaywgbnVsbCk7XG4gICAgICAgIGNvbnN0IGZpbGVLZXkgPSBwZXJmb3JtQ3J5cHRvKGtleURlY2lwaGVyLCBrZXlCeXRlcyk7XG4gICAgICAgIGNvbnN0IGRhdGFEZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KEFFU19DQkMuY2lwaGVyTmFtZShmaWxlS2V5Lmxlbmd0aCksIGZpbGVLZXksIGl2Qnl0ZXMpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybUZpbGVTdHJlYW1DcnlwdG8oZGF0YURlY2lwaGVyLCB0bXBEaXIsIGlucHV0RmlsZVBhdGgsIGNodW5rU2l6ZSk7XG4gICAgfTtcbiAgICAvL1RPRE86IFNOT1ctOTQwOTgxOiBBZGQgcHJvcGVyIHVzYWdlIHdoZW4gZmVhdHVyZSBpcyByZWFkeVxuICAgIHRoaXMuZGVjcnlwdEZpbGVHQ00gPSBhc3luYyBmdW5jdGlvbiAobWV0YWRhdGEsIGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCwgdG1wRGlyID0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBrZXlCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5rZXksIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGtleUl2Qnl0ZXMgPSBuZXcgQnVmZmVyLmZyb20obWV0YWRhdGEua2V5SXYsIEJBU0U2NCk7XG4gICAgICAgIGNvbnN0IGRhdGFJdkJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLml2LCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBkYXRhQWFkQnl0ZXMgPSBuZXcgQnVmZmVyLmZyb20obWV0YWRhdGEuZGF0YUFhZCwgQkFTRTY0KTtcbiAgICAgICAgY29uc3Qga2V5QWFkQnl0ZXMgPSBuZXcgQnVmZmVyLmZyb20obWV0YWRhdGEua2V5QWFkLCBCQVNFNjQpO1xuICAgICAgICBjb25zdCBmaWxlS2V5ID0gdGhpcy5kZWNyeXB0R0NNKGtleUJ5dGVzLCBkZWNvZGVkS2VrLCBrZXlJdkJ5dGVzLCBrZXlBYWRCeXRlcyk7XG4gICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMucmVhZEZpbGUoaW5wdXRGaWxlUGF0aCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IHRoaXMuZGVjcnlwdEdDTShmaWxlQ29udGVudCwgZmlsZUtleSwgZGF0YUl2Qnl0ZXMsIGRhdGFBYWRCeXRlcyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3cml0ZUNvbnRlbnRUb0ZpbGUodG1wRGlyLCBwYXRoLmJhc2VuYW1lKGlucHV0RmlsZVBhdGgpICsgJyMnLCBkZWNyeXB0ZWREYXRhKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBlcmZvcm1DcnlwdG8oY2lwaGVyT3JEZWNpcGhlciwgZGF0YSkge1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWRPckRlY3J5cHRlZCA9IGNpcGhlck9yRGVjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBjb25zdCBmaW5hbCA9IGNpcGhlck9yRGVjaXBoZXIuZmluYWwoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY3J5cHRlZE9yRGVjcnlwdGVkLCBmaW5hbF0pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJmb3JtRmlsZVN0cmVhbUNyeXB0byhjaXBoZXJPckRlY2lwaGVyLCB0bXBEaXIsIGlucHV0RmlsZVBhdGgsIGNodW5rU2l6ZSkge1xuICAgICAgICBjb25zdCBvdXRwdXRGaWxlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdG1wLmZpbGUoeyBkaXI6IHRtcERpciwgcHJlZml4OiBwYXRoLmJhc2VuYW1lKGlucHV0RmlsZVBhdGgpICsgJyMnIH0sIChlcnIsIHBhdGgsIGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBwYXRoLCBmZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oaW5wdXRGaWxlUGF0aCwgeyBoaWdoV2F0ZXJNYXJrOiBjaHVua1NpemUgfSk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXRwdXRGaWxlLnBhdGgpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBjaXBoZXJPckRlY2lwaGVyLnVwZGF0ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKGVuY3J5cHRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoY2lwaGVyT3JEZWNpcGhlci5maW5hbCgpKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW0uY2xvc2UocmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZzLmNsb3NlKG91dHB1dEZpbGUuZmQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEZpbGUucGF0aDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250ZW50VG9GaWxlKHRtcERpciwgcHJlZml4LCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEZpbGUgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0bXAuZmlsZSh7IGRpcjogdG1wRGlyLCBwcmVmaXg6IHByZWZpeCB9LCAoZXJyLCBwYXRoLCBmZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgcGF0aCwgZmQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGUob3V0cHV0RmlsZS5wYXRoLCBjb250ZW50LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZzLmNsb3NlKG91dHB1dEZpbGUuZmQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEZpbGUucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLkVuY3J5cHRVdGlsID0gRW5jcnlwdFV0aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNyeXB0X3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable camelcase */\nconst Types = [\n    {\n        name: 'GZIP',\n        file_extension: '.gz',\n        mime_type: 'application',\n        mime_subtypes: ['gzip', 'x-gzip'],\n        is_supported: true,\n    },\n    {\n        name: 'DEFLATE',\n        file_extension: '.deflate',\n        mime_type: 'application',\n        mime_subtypes: ['zlib', 'deflate'],\n        is_supported: true,\n    },\n    {\n        name: 'RAW_DEFLATE',\n        file_extension: '.raw_deflate',\n        mime_type: 'application',\n        mime_subtypes: ['raw_deflate'],\n        is_supported: true,\n    },\n    {\n        name: 'BZIP2',\n        file_extension: '.bz2',\n        mime_type: 'application',\n        mime_subtypes: ['bzip2', 'x-bzip2', 'x-bz2', 'x-bzip', 'bz2'],\n        is_supported: true,\n    },\n    {\n        name: 'LZIP',\n        file_extension: '.lz',\n        mime_type: 'application',\n        mime_subtypes: ['lzip', 'x-lzip'],\n        is_supported: false,\n    },\n    {\n        name: 'LZMA',\n        file_extension: '.lzma',\n        mime_type: 'application',\n        mime_subtypes: ['lzma', 'x-lzma'],\n        is_supported: false,\n    },\n    {\n        name: 'LZO',\n        file_extension: '.lzo',\n        mime_type: 'application',\n        mime_subtypes: ['lzo', 'x-lzo'],\n        is_supported: false,\n    },\n    {\n        name: 'XZ',\n        file_extension: '.xz',\n        mime_type: 'application',\n        mime_subtypes: ['xz', 'x-xz'],\n        is_supported: false,\n    },\n    {\n        name: 'COMPRESS',\n        file_extension: '.Z',\n        mime_type: 'application',\n        mime_subtypes: ['compress', 'x-compress'],\n        is_supported: false,\n    },\n    {\n        name: 'PARQUET',\n        file_extension: '.parquet',\n        mime_type: 'snowflake',\n        mime_subtypes: ['parquet'],\n        is_supported: true,\n    },\n    {\n        name: 'ZSTD',\n        file_extension: '.zst',\n        mime_type: 'application',\n        mime_subtypes: ['zstd', 'x-zstd'],\n        is_supported: true,\n    },\n    {\n        name: 'BROTLI',\n        file_extension: '.br',\n        mime_type: 'application',\n        mime_subtypes: ['br', 'x-br'],\n        is_supported: true,\n    },\n    {\n        name: 'ORC',\n        file_extension: '.orc',\n        mime_type: 'snowflake',\n        mime_subtypes: ['orc'],\n        is_supported: true,\n    },\n];\n/* eslint-enable camelcase */\nconst subtypeToMeta = [];\nfor (const type of Types) {\n    for (const ms of type['mime_subtypes']) {\n        subtypeToMeta[ms] = type;\n    }\n}\n/**\n * Return the file compression type based on subtype.\n *\n * @param {String} subtype\n *\n * @returns {Object} the file compression object\n */\nexports.lookupByMimeSubType = function lookupByMimeSubType(subtype) {\n    return subtypeToMeta[subtype.toLowerCase()];\n};\n/**\n * Return the file compression type based on encoding.\n *\n * @param {String} encoding\n *\n * @returns {Object} the file compression object\n */\nexports.lookupByEncoding = function lookupByEncoding(encoding) {\n    encoding = encoding.substring(encoding.indexOf('/') + 1);\n    return subtypeToMeta[encoding];\n};\n//# sourceMappingURL=file_compression_type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfY29tcHJlc3Npb25fdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfY29tcHJlc3Npb25fdHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuY29uc3QgVHlwZXMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnR1pJUCcsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLmd6JyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ2d6aXAnLCAneC1nemlwJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0RFRkxBVEUnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5kZWZsYXRlJyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ3psaWInLCAnZGVmbGF0ZSddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdSQVdfREVGTEFURScsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLnJhd19kZWZsYXRlJyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ3Jhd19kZWZsYXRlJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0JaSVAyJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcuYnoyJyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ2J6aXAyJywgJ3gtYnppcDInLCAneC1iejInLCAneC1iemlwJywgJ2J6MiddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdMWklQJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcubHonLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnbHppcCcsICd4LWx6aXAnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0xaTUEnLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5sem1hJyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ2x6bWEnLCAneC1sem1hJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdMWk8nLFxuICAgICAgICBmaWxlX2V4dGVuc2lvbjogJy5sem8nLFxuICAgICAgICBtaW1lX3R5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsnbHpvJywgJ3gtbHpvJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdYWicsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLnh6JyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ3h6JywgJ3gteHonXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0NPTVBSRVNTJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcuWicsXG4gICAgICAgIG1pbWVfdHlwZTogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgbWltZV9zdWJ0eXBlczogWydjb21wcmVzcycsICd4LWNvbXByZXNzJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdQQVJRVUVUJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcucGFycXVldCcsXG4gICAgICAgIG1pbWVfdHlwZTogJ3Nub3dmbGFrZScsXG4gICAgICAgIG1pbWVfc3VidHlwZXM6IFsncGFycXVldCddLFxuICAgICAgICBpc19zdXBwb3J0ZWQ6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdaU1REJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcuenN0JyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ3pzdGQnLCAneC16c3RkJ10sXG4gICAgICAgIGlzX3N1cHBvcnRlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0JST1RMSScsXG4gICAgICAgIGZpbGVfZXh0ZW5zaW9uOiAnLmJyJyxcbiAgICAgICAgbWltZV90eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICBtaW1lX3N1YnR5cGVzOiBbJ2JyJywgJ3gtYnInXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnT1JDJyxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcub3JjJyxcbiAgICAgICAgbWltZV90eXBlOiAnc25vd2ZsYWtlJyxcbiAgICAgICAgbWltZV9zdWJ0eXBlczogWydvcmMnXSxcbiAgICAgICAgaXNfc3VwcG9ydGVkOiB0cnVlLFxuICAgIH0sXG5dO1xuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmNvbnN0IHN1YnR5cGVUb01ldGEgPSBbXTtcbmZvciAoY29uc3QgdHlwZSBvZiBUeXBlcykge1xuICAgIGZvciAoY29uc3QgbXMgb2YgdHlwZVsnbWltZV9zdWJ0eXBlcyddKSB7XG4gICAgICAgIHN1YnR5cGVUb01ldGFbbXNdID0gdHlwZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybiB0aGUgZmlsZSBjb21wcmVzc2lvbiB0eXBlIGJhc2VkIG9uIHN1YnR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN1YnR5cGVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgZmlsZSBjb21wcmVzc2lvbiBvYmplY3RcbiAqL1xuZXhwb3J0cy5sb29rdXBCeU1pbWVTdWJUeXBlID0gZnVuY3Rpb24gbG9va3VwQnlNaW1lU3ViVHlwZShzdWJ0eXBlKSB7XG4gICAgcmV0dXJuIHN1YnR5cGVUb01ldGFbc3VidHlwZS50b0xvd2VyQ2FzZSgpXTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgZmlsZSBjb21wcmVzc2lvbiB0eXBlIGJhc2VkIG9uIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBmaWxlIGNvbXByZXNzaW9uIG9iamVjdFxuICovXG5leHBvcnRzLmxvb2t1cEJ5RW5jb2RpbmcgPSBmdW5jdGlvbiBsb29rdXBCeUVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZy5zdWJzdHJpbmcoZW5jb2RpbmcuaW5kZXhPZignLycpICsgMSk7XG4gICAgcmV0dXJuIHN1YnR5cGVUb01ldGFbZW5jb2RpbmddO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGVfY29tcHJlc3Npb25fdHlwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst statement = __webpack_require__(/*! ../connection/statement */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/connection/statement.js\");\nconst fileCompressionType = __webpack_require__(/*! ./file_compression_type */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_compression_type.js\");\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst SnowflakeRemoteStorageUtil = (__webpack_require__(/*! ./remote_storage_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js\").RemoteStorageUtil);\nconst LocalUtil = (__webpack_require__(/*! ./local_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js\").LocalUtil);\nconst SnowflakeFileEncryptionMaterial = (__webpack_require__(/*! ./remote_storage_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js\").SnowflakeFileEncryptionMaterial);\nconst SnowflakeS3Util = __webpack_require__(/*! ./s3_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js\");\nconst { FileUtil, getMatchingFilePaths } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst SnowflakeFileUtil = new FileUtil();\nconst SnowflakeLocalUtil = new LocalUtil();\nconst S3_FS = 'S3';\nconst AZURE_FS = 'AZURE';\nconst GCS_FS = 'GCS';\nconst LOCAL_FS = 'LOCAL_FS';\nconst CMD_TYPE_UPLOAD = 'UPLOAD';\nconst CMD_TYPE_DOWNLOAD = 'DOWNLOAD';\nconst FILE_PROTOCOL = 'file://';\nconst INJECT_WAIT_IN_PUT = 0;\nconst RESULT_TEXT_COLUMN_DESC = function (name) {\n    return {\n        name: name,\n        type: 'text',\n        length: 16777216,\n        precision: null,\n        scale: null,\n        nullable: false,\n    };\n};\nconst RESULT_FIXED_COLUMN_DESC = function (name) {\n    return {\n        name: name,\n        type: 'fixed',\n        length: 5,\n        precision: 0,\n        scale: 0,\n        nullable: false,\n    };\n};\n/**\n * Creates a file transfer agent.\n *\n * @param {Object} context\n *\n * @returns {Object}\n * @constructor\n */\nfunction FileTransferAgent(context) {\n    const remoteStorageUtil = new SnowflakeRemoteStorageUtil(context.connectionConfig);\n    const response = context.fileMetadata;\n    const command = context.sqlText;\n    const cwd = context.cwd;\n    let commandType;\n    const encryptionMaterial = [];\n    let fileName;\n    const fileStream = context.fileStream ? context.fileStream : null;\n    let autoCompress;\n    let sourceCompression;\n    let parallel;\n    let stageInfo;\n    let stageLocationType;\n    let presignedUrls;\n    let overwrite;\n    let useAccelerateEndpoint = false;\n    let srcFiles;\n    const srcFilesToEncryptionMaterial = {};\n    let localLocation;\n    const results = [];\n    // Store info of files retrieved\n    const filesToPut = [];\n    // Store metadata of files retrieved\n    const fileMetadata = [];\n    const smallFileMetas = [];\n    const largeFileMetas = [];\n    /**\n     * Execute PUT or GET command.\n     *\n     * @returns {null}\n     */\n    this.execute = async function () {\n        if (fileStream) {\n            const data = response['data'];\n            commandType = data['command'];\n            autoCompress = data['autoCompress'];\n            sourceCompression = data['sourceCompression'];\n            parallel = data['parallel'];\n            stageInfo = data['stageInfo'];\n            stageLocationType = stageInfo['locationType'];\n            presignedUrls = data['presignedUrls'];\n            overwrite = data['overwrite'];\n            if (commandType !== CMD_TYPE_UPLOAD) {\n                throw new Error('Incorrect UploadFileStream command');\n            }\n            const currFileObj = {};\n            currFileObj['srcFileName'] = data.src_locations[0];\n            currFileObj['srcFilePath'] = '';\n            currFileObj['srcFileSize'] = fileStream.length;\n            filesToPut.push(currFileObj);\n            initEncryptionMaterial();\n            initFileMetadata();\n            await transferAccelerateConfig();\n            await updateFileMetasWithPresignedUrl();\n            if (fileMetadata.length !== 1) {\n                throw new Error('UploadFileStream only allow 1 file');\n            }\n            //upload\n            const storageClient = getStorageClient(stageLocationType);\n            const client = storageClient.createClient(stageInfo, false);\n            const meta = fileMetadata[0];\n            meta['parallel'] = parallel;\n            meta['client'] = client;\n            meta['fileStream'] = fileStream;\n            //for digest\n            const hash = crypto.createHash('sha256').update(fileStream).digest('base64');\n            meta['SHA256_DIGEST'] = hash;\n            meta['uploadSize'] = fileStream.length;\n            meta['dstCompressionType'] = fileCompressionType.lookupByEncoding(sourceCompression);\n            meta['requireCompress'] = false;\n            meta['dstFileName'] = meta['srcFileName'];\n            await storageClient.uploadOneFileStream(meta);\n        }\n        else {\n            parseCommand();\n            initFileMetadata();\n            if (commandType === CMD_TYPE_UPLOAD) {\n                if (filesToPut.length === 0) {\n                    throw new Error('No file found for: ' + fileName);\n                }\n                processFileCompressionType();\n            }\n            if (commandType === CMD_TYPE_DOWNLOAD) {\n                if (!fs.existsSync(localLocation)) {\n                    fs.mkdirSync(localLocation);\n                }\n            }\n            if (stageLocationType === LOCAL_FS) {\n                process.umask(0);\n                if (!fs.existsSync(stageInfo['location'])) {\n                    fs.mkdirSync(stageInfo['location'], { mode: 0o777, recursive: true });\n                }\n            }\n            await transferAccelerateConfig();\n            await updateFileMetasWithPresignedUrl();\n            for (const meta of fileMetadata) {\n                if (meta['srcFileSize'] > SnowflakeS3Util.DATA_SIZE_THRESHOLD) {\n                    // Add to large file metas\n                    meta['parallel'] = parallel;\n                    largeFileMetas.push(meta);\n                }\n                else {\n                    // Add to small file metas and set parallel to 1\n                    meta['parallel'] = 1;\n                    smallFileMetas.push(meta);\n                }\n            }\n            if (commandType === CMD_TYPE_UPLOAD) {\n                await upload(largeFileMetas, smallFileMetas);\n            }\n            if (commandType === CMD_TYPE_DOWNLOAD) {\n                await download(largeFileMetas, smallFileMetas);\n            }\n        }\n    };\n    /**\n     * Generate the rowset and rowset types using the file metadatas.\n     *\n     * @returns {Object}\n     */\n    this.result = function () {\n        const rowset = [];\n        if (commandType === CMD_TYPE_UPLOAD) {\n            let srcFileSize;\n            let dstFileSize;\n            let srcCompressionType;\n            let dstCompressionType;\n            let errorDetails;\n            if (results) {\n                for (const meta of results) {\n                    if (meta['resultStatus'] === 'ERROR') {\n                        errorDetails = meta['errorDetails'];\n                        if (!errorDetails) {\n                            errorDetails = `Unknown error during PUT of file: ${meta['srcFilePath']}`;\n                        }\n                        throw new Error(errorDetails);\n                    }\n                    if (meta['srcCompressionType']) {\n                        srcCompressionType = meta['srcCompressionType']['name'];\n                    }\n                    else {\n                        srcCompressionType = null;\n                    }\n                    if (meta['dstCompressionType']) {\n                        dstCompressionType = meta['dstCompressionType']['name'];\n                    }\n                    else {\n                        dstCompressionType = null;\n                    }\n                    errorDetails = meta['errorDetails'];\n                    srcFileSize = meta['srcFileSize'].toString();\n                    dstFileSize = meta['dstFileSize'].toString();\n                    rowset.push([\n                        meta['srcFileName'],\n                        meta['dstFileName'],\n                        srcFileSize,\n                        dstFileSize,\n                        srcCompressionType,\n                        dstCompressionType,\n                        meta['resultStatus'],\n                        errorDetails,\n                    ]);\n                }\n            }\n            return {\n                rowset: rowset,\n                rowtype: [\n                    RESULT_TEXT_COLUMN_DESC('source'),\n                    RESULT_TEXT_COLUMN_DESC('target'),\n                    RESULT_FIXED_COLUMN_DESC('sourceSize'),\n                    RESULT_FIXED_COLUMN_DESC('targetSize'),\n                    RESULT_TEXT_COLUMN_DESC('sourceCompression'),\n                    RESULT_TEXT_COLUMN_DESC('targetCompression'),\n                    RESULT_TEXT_COLUMN_DESC('status'),\n                    RESULT_TEXT_COLUMN_DESC('message'),\n                ],\n            };\n        }\n        else if (commandType === CMD_TYPE_DOWNLOAD) {\n            let dstFileSize;\n            let errorDetails;\n            if (results) {\n                for (const meta of results) {\n                    errorDetails = meta['errorDetails'];\n                    dstFileSize = meta['dstFileSize'];\n                    rowset.push([meta['dstFileName'], dstFileSize, meta['resultStatus'], errorDetails]);\n                }\n            }\n            return {\n                rowset: rowset,\n                rowtype: [\n                    RESULT_TEXT_COLUMN_DESC('file'),\n                    RESULT_FIXED_COLUMN_DESC('size'),\n                    RESULT_TEXT_COLUMN_DESC('status'),\n                    RESULT_TEXT_COLUMN_DESC('message'),\n                ],\n            };\n        }\n    };\n    /**\n     * Upload files in the metadata list.\n     *\n     * @returns {null}\n     */\n    async function upload(largeFileMetas, smallFileMetas) {\n        const storageClient = getStorageClient(stageLocationType);\n        const client = storageClient.createClient(stageInfo, false);\n        for (const meta of smallFileMetas) {\n            meta['client'] = client;\n        }\n        for (const meta of largeFileMetas) {\n            meta['client'] = client;\n        }\n        if (smallFileMetas.length > 0) {\n            //await uploadFilesinParallel(smallFileMetas);\n            await uploadFilesinSequential(smallFileMetas);\n        }\n        if (largeFileMetas.length > 0) {\n            await uploadFilesinSequential(largeFileMetas);\n        }\n    }\n    /**\n     * Upload a file sequentially.\n     *\n     * @param {Object} fileMeta\n     *\n     * @returns {null}\n     */\n    async function uploadFilesinSequential(fileMeta) {\n        let index = 0;\n        const fileMetaLen = fileMeta.length;\n        while (index < fileMetaLen) {\n            const result = await uploadOneFile(fileMeta[index]);\n            if (result['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                const client = renewExpiredClient();\n                for (let index2 = index; index2 < fileMetaLen; index2++) {\n                    fileMeta[index2]['client'] = client;\n                }\n                continue;\n            }\n            else if (result['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                await updateFileMetasWithPresignedUrl();\n                continue;\n            }\n            results.push(result);\n            if (result['resultStatus'] === resultStatus.ERROR) {\n                break;\n            }\n            index += 1;\n            if (INJECT_WAIT_IN_PUT > 0) {\n                await new Promise((resolve) => setTimeout(resolve, INJECT_WAIT_IN_PUT));\n            }\n        }\n    }\n    /**\n     * Generate a temporary directory for the file then upload.\n     *\n     * @param {Object} meta\n     *\n     * @returns {Object}\n     */\n    async function uploadOneFile(meta) {\n        meta['realSrcFilePath'] = meta['srcFilePath'];\n        const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'tmp'));\n        meta['tmpDir'] = tmpDir;\n        try {\n            if (meta['requireCompress']) {\n                const result = await SnowflakeFileUtil.compressFileWithGZIP(meta['srcFilePath'], meta['tmpDir']);\n                meta['realSrcFilePath'] = result.name;\n            }\n            const result = await SnowflakeFileUtil.getDigestAndSizeForFile(meta['realSrcFilePath']);\n            const sha256Digest = result.digest;\n            const uploadSize = result.size;\n            meta['SHA256_DIGEST'] = sha256Digest;\n            meta['uploadSize'] = uploadSize;\n            const storageClient = getStorageClient(meta['stageLocationType']);\n            await storageClient.uploadOneFileWithRetry(meta);\n        }\n        catch (err) {\n            meta['dstFileSize'] = 0;\n            if (meta['resultStatus']) {\n                meta['resultStatus'] = resultStatus.ERROR;\n            }\n            meta['errorDetails'] = err.toString();\n            meta['errorDetails'] += ` file=${meta['srcFileName']}, real file=${meta['realSrcFilePath']}`;\n        }\n        finally {\n            // Remove all files inside tmp folder\n            const matchingFileNames = getMatchingFilePaths(meta['tmpDir'], meta['srcFileName'] + '*');\n            for (const matchingFileName of matchingFileNames) {\n                await new Promise((resolve, reject) => {\n                    fs.unlink(matchingFileName, (err) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        resolve();\n                    });\n                });\n            }\n            // Delete tmp folder\n            fs.rmdir(meta['tmpDir'], (err) => {\n                if (err) {\n                    throw err;\n                }\n            });\n        }\n        return meta;\n    }\n    /**\n     * Download files in the metadata list.\n     *\n     * @returns {null}\n     */\n    async function download(largeFileMetas, smallFileMetas) {\n        const storageClient = getStorageClient(stageLocationType);\n        const client = storageClient.createClient(stageInfo, false);\n        for (const meta of smallFileMetas) {\n            meta['client'] = client;\n        }\n        for (const meta of largeFileMetas) {\n            meta['client'] = client;\n        }\n        if (smallFileMetas.length > 0) {\n            //await downloadFilesinParallel(smallFileMetas);\n            await downloadFilesinSequential(smallFileMetas);\n        }\n        if (largeFileMetas.length > 0) {\n            await downloadFilesinSequential(largeFileMetas);\n        }\n    }\n    /**\n     * Download a file sequentially.\n     *\n     * @param {Object} fileMeta\n     *\n     * @returns {null}\n     */\n    async function downloadFilesinSequential(fileMeta) {\n        let index = 0;\n        const fileMetaLen = fileMeta.length;\n        while (index < fileMetaLen) {\n            const result = await downloadOneFile(fileMeta[index]);\n            if (result['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                const client = renewExpiredClient();\n                for (let index2 = index; index2 < fileMetaLen; index2++) {\n                    fileMeta[index2]['client'] = client;\n                }\n                continue;\n            }\n            else if (result['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                await updateFileMetasWithPresignedUrl();\n                continue;\n            }\n            results.push(result);\n            index += 1;\n            if (INJECT_WAIT_IN_PUT > 0) {\n                await new Promise((resolve) => setTimeout(resolve, INJECT_WAIT_IN_PUT));\n            }\n        }\n    }\n    /**\n     * Download a file and place into the target directory.\n     *\n     * @param {Object} meta\n     *\n     * @returns {Object}\n     */\n    async function downloadOneFile(meta) {\n        meta['tmpDir'] = await new Promise((resolve, reject) => {\n            fs.mkdtemp(path.join(os.tmpdir(), 'tmp'), (err, dir) => {\n                if (err) {\n                    reject(err);\n                }\n                resolve(dir);\n            });\n        });\n        try {\n            const storageClient = getStorageClient(meta['stageLocationType']);\n            await storageClient.downloadOneFile(meta);\n        }\n        catch (err) {\n            meta['dstFileSize'] = -1;\n            if (meta['resultStatus']) {\n                meta['resultStatus'] = resultStatus.ERROR;\n            }\n            meta['errorDetails'] = err.toString();\n            meta['errorDetails'] += ` file=${meta['dstFileName']}`;\n        }\n        return meta;\n    }\n    /**\n     * Determine whether to acceleration configuration for S3 clients.\n     *\n     * @returns {null}\n     */\n    async function transferAccelerateConfig() {\n        if (stageLocationType === S3_FS) {\n            const client = remoteStorageUtil.createClient(stageInfo, false);\n            const s3location = SnowflakeS3Util.extractBucketNameAndPath(stageInfo['location']);\n            await client\n                .getBucketAccelerateConfiguration({ Bucket: s3location.bucketName })\n                .then(function (data) {\n                useAccelerateEndpoint = data['Status'] === 'Enabled';\n            })\n                .catch(function (err) {\n                if (err['code'] === 'AccessDenied') {\n                    return;\n                }\n            });\n        }\n    }\n    /**\n     * Update presigned URLs of file metadata when using GCS client.\n     *\n     * @returns {null}\n     */\n    async function updateFileMetasWithPresignedUrl() {\n        const storageClient = getStorageClient(stageLocationType);\n        // presigned url only applies to remote storage\n        if (storageClient === remoteStorageUtil) {\n            // presigned url only applies to GCS\n            if (stageLocationType === GCS_FS) {\n                if (commandType === CMD_TYPE_UPLOAD) {\n                    const filePathToReplace = getFileNameFromPutCommand(command);\n                    for (const meta of fileMetadata) {\n                        const fileNameToReplaceWith = meta['dstFileName'];\n                        let commandWithSingleFile = command;\n                        commandWithSingleFile = commandWithSingleFile.replace(filePathToReplace, fileNameToReplaceWith);\n                        const options = { sqlText: commandWithSingleFile };\n                        const newContext = statement.createContext(options, context.services, context.connectionConfig);\n                        const ret = await statement.sendRequest(newContext);\n                        meta['stageInfo'] = ret['data']['data']['stageInfo'];\n                        meta['presignedUrl'] = meta['stageInfo']['presignedUrl'];\n                    }\n                }\n                else if (commandType === CMD_TYPE_DOWNLOAD) {\n                    for (let index = 0; index < fileMetadata.length; index++) {\n                        fileMetadata[index]['presignedUrl'] = presignedUrls[index];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns the local file path.\n     *\n     * @param {String} command\n     *\n     * @returns {String}\n     */\n    function getFileNameFromPutCommand(command) {\n        // Extract file path from PUT command:\n        // E.g. \"PUT file://C:<path-to-file> @DB.SCHEMA.%TABLE;\"\n        const startIndex = command.indexOf(FILE_PROTOCOL) + FILE_PROTOCOL.length;\n        const spaceIndex = command.substring(startIndex).indexOf(' ');\n        const quoteIndex = command.substring(startIndex).indexOf(\"'\");\n        let endIndex = spaceIndex;\n        if (quoteIndex !== -1 && quoteIndex < spaceIndex) {\n            endIndex = quoteIndex;\n        }\n        const filePath = command.substring(startIndex, startIndex + endIndex);\n        return filePath;\n    }\n    /**\n     * Get the storage client based on stage location type.\n     *\n     * @param {String} stageLocationType\n     *\n     * @returns {Object}\n     */\n    function getStorageClient(stageLocationType) {\n        if (stageLocationType === LOCAL_FS) {\n            return SnowflakeLocalUtil;\n        }\n        else if (stageLocationType === S3_FS ||\n            stageLocationType === AZURE_FS ||\n            stageLocationType === GCS_FS) {\n            return remoteStorageUtil;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Parse the command and get list of files to upload/download.\n     *\n     * @returns {null}\n     */\n    function parseCommand() {\n        const data = response['data'];\n        commandType = data['command'];\n        if (commandType === CMD_TYPE_UPLOAD) {\n            const src = data['src_locations'][0];\n            // Get root directory of file path\n            let root = path.dirname(src);\n            // If cwd exists and root is relative . then replace with context's cwd\n            // Used for VS Code extension where extension cwd differs from user workspace dir\n            if (cwd && !path.isAbsolute(src)) {\n                const absolutePath = path.resolve(cwd, src);\n                root = path.dirname(absolutePath);\n            }\n            let dir;\n            // Check root directory exists\n            if (fs.existsSync(root)) {\n                // Check the root path is a directory\n                dir = fs.statSync(root);\n                if (dir.isDirectory()) {\n                    // Get file name to upload\n                    fileName = path.basename(src);\n                    // Full path name of the file\n                    const fileNameFullPath = path.join(root, fileName);\n                    // If file name has a wildcard\n                    if (fileName.includes('*')) {\n                        // Get all file names that matches the wildcard\n                        const matchingFileNames = getMatchingFilePaths(root, fileName);\n                        for (const matchingFileName of matchingFileNames) {\n                            initEncryptionMaterial();\n                            const fileInfo = fs.statSync(matchingFileName);\n                            const currFileObj = {};\n                            currFileObj['srcFileName'] = path.basename(matchingFileName);\n                            currFileObj['srcFilePath'] = matchingFileName;\n                            currFileObj['srcFileSize'] = fileInfo.size;\n                            filesToPut.push(currFileObj);\n                        }\n                    }\n                    else {\n                        // No wildcard, get single file\n                        if (fs.existsSync(root)) {\n                            initEncryptionMaterial();\n                            const fileInfo = fs.statSync(fileNameFullPath);\n                            const currFileObj = {};\n                            currFileObj['srcFileName'] = fileName;\n                            currFileObj['srcFilePath'] = fileNameFullPath;\n                            currFileObj['srcFileSize'] = fileInfo.size;\n                            filesToPut.push(currFileObj);\n                        }\n                    }\n                }\n            }\n            else {\n                throw new Error(dir + ' is not a directory');\n            }\n            autoCompress = data['autoCompress'];\n            sourceCompression = data['sourceCompression'];\n        }\n        else if (commandType === CMD_TYPE_DOWNLOAD) {\n            initEncryptionMaterial();\n            srcFiles = data['src_locations'];\n            if (srcFiles.length === encryptionMaterial.length) {\n                for (const idx in srcFiles) {\n                    srcFilesToEncryptionMaterial[srcFiles[idx]] = encryptionMaterial[idx];\n                }\n            }\n            else if (encryptionMaterial.length !== 0) {\n                // some encryption material exists. Zero means no encryption\n                throw new Error(\"The number of downloading files doesn't match\");\n            }\n            localLocation = expandTilde(data['localLocation']);\n            // If cwd exists and root is relative . then replace with context's cwd\n            // Used for VS Code extension where extension cwd differs from user workspace dir\n            if (cwd && !path.isAbsolute(localLocation)) {\n                const absolutePath = path.resolve(cwd, localLocation);\n                localLocation = absolutePath;\n            }\n            const dir = fs.statSync(localLocation);\n            if (!dir.isDirectory()) {\n                throw new Error('The local path is not a directory: ' + localLocation);\n            }\n        }\n        parallel = data['parallel'];\n        stageInfo = data['stageInfo'];\n        stageLocationType = stageInfo['locationType'];\n        presignedUrls = data['presignedUrls'];\n        overwrite = data['overwrite'];\n    }\n    /**\n     * Generate encryption material for each metadata.\n     *\n     * @returns {null}\n     */\n    function initEncryptionMaterial() {\n        if (response['data'] && response['data']['encryptionMaterial']) {\n            const rootNode = response['data']['encryptionMaterial'];\n            if (commandType === CMD_TYPE_UPLOAD) {\n                encryptionMaterial.push(new SnowflakeFileEncryptionMaterial(rootNode['queryStageMasterKey'], rootNode['queryId'], rootNode['smkId']));\n            }\n            else if (commandType === CMD_TYPE_DOWNLOAD) {\n                for (const elem in rootNode) {\n                    encryptionMaterial.push(new SnowflakeFileEncryptionMaterial(rootNode[elem]['queryStageMasterKey'], rootNode[elem]['queryId'], rootNode[elem]['smkId']));\n                }\n            }\n        }\n    }\n    /**\n     * Generate metadata for files to upload/download.\n     *\n     * @returns {null}\n     */\n    function initFileMetadata() {\n        if (commandType === CMD_TYPE_UPLOAD) {\n            for (const file of filesToPut) {\n                const currFileObj = {};\n                currFileObj['srcFilePath'] = file['srcFilePath'];\n                currFileObj['srcFileName'] = file['srcFileName'];\n                currFileObj['srcFileSize'] = file['srcFileSize'];\n                currFileObj['stageLocationType'] = stageLocationType;\n                currFileObj['stageInfo'] = stageInfo;\n                currFileObj['overwrite'] = overwrite;\n                fileMetadata.push(currFileObj);\n            }\n        }\n        else if (commandType === CMD_TYPE_DOWNLOAD) {\n            for (const fileName of srcFiles) {\n                const currFileObj = {};\n                currFileObj['srcFileName'] = fileName;\n                currFileObj['dstFileName'] = fileName;\n                currFileObj['stageLocationType'] = stageLocationType;\n                currFileObj['stageInfo'] = stageInfo;\n                currFileObj['useAccelerateEndpoint'] = useAccelerateEndpoint;\n                currFileObj['localLocation'] = localLocation;\n                currFileObj['encryptionMaterial'] = srcFilesToEncryptionMaterial[fileName];\n                fileMetadata.push(currFileObj);\n            }\n        }\n        if (encryptionMaterial.length > 0) {\n            let i = 0;\n            for (const file of fileMetadata) {\n                file['encryptionMaterial'] = encryptionMaterial[i];\n                i++;\n            }\n        }\n    }\n    /**\n     * Get the compression type of the file.\n     *\n     * @returns {null}\n     */\n    function processFileCompressionType() {\n        let userSpecifiedSourceCompression;\n        let autoDetect;\n        if (sourceCompression === 'auto_detect') {\n            autoDetect = true;\n        }\n        else if (sourceCompression === typeof 'undefined') {\n            autoDetect = false;\n        }\n        else {\n            userSpecifiedSourceCompression = fileCompressionType.lookupByMimeSubType(sourceCompression);\n            if (userSpecifiedSourceCompression === typeof 'undefined' ||\n                !userSpecifiedSourceCompression['is_supported']) {\n                throw new Error(sourceCompression + ' is not a supported compression type');\n            }\n            autoDetect = false;\n        }\n        for (const meta of fileMetadata) {\n            const fileName = meta['srcFileName'];\n            const filePath = meta['srcFilePath'];\n            let currentFileCompressionType;\n            let encoding;\n            if (autoDetect) {\n                encoding = mime.lookup(fileName);\n                if (!encoding) {\n                    const test = Buffer.alloc(4);\n                    const fd = fs.openSync(filePath, 'r+');\n                    fs.readSync(fd, test, 0, 4, 0);\n                    fs.closeSync(fd);\n                    if (fileName.substring(fileName.lastIndexOf('.')) === '.br') {\n                        encoding = 'br';\n                    }\n                    else if (fileName.substring(fileName.lastIndexOf('.')) === '.deflate') {\n                        encoding = 'deflate';\n                    }\n                    else if (fileName.substring(fileName.lastIndexOf('.')) === '.raw_deflate') {\n                        encoding = 'raw_deflate';\n                    }\n                    else if (Buffer.from(test.toString()).slice(0, 3) === Buffer.from('ORC')) {\n                        encoding = 'orc';\n                    }\n                    else if (Buffer.from(test.toString()) === Buffer.from('PAR1')) {\n                        encoding = 'parquet';\n                    }\n                    else if (test.toString('hex') === '28fd2ffd' ||\n                        fileName.substring(fileName.lastIndexOf('.')) === '.zst') {\n                        encoding = 'zstd';\n                    }\n                }\n                if (encoding) {\n                    currentFileCompressionType = fileCompressionType.lookupByEncoding(encoding);\n                }\n                // else {} No file encoding detected\n                if (currentFileCompressionType && !currentFileCompressionType['is_supported']) {\n                    throw new Error(encoding + ' is not a a supported compression type');\n                }\n            }\n            else {\n                currentFileCompressionType = userSpecifiedSourceCompression;\n            }\n            if (currentFileCompressionType) {\n                if (currentFileCompressionType['is_supported']) {\n                    meta['dstCompressionType'] = currentFileCompressionType;\n                    meta['requireCompress'] = false;\n                    meta['dstFileName'] = meta['srcFileName'];\n                }\n                else {\n                    throw new Error(encoding + ' is not a a supported compression type');\n                }\n            }\n            else {\n                meta['requireCompress'] = autoCompress;\n                meta['srcCompressionType'] = null;\n                // If requireCompress is true, destination file extension is changed to zip\n                if (autoCompress) {\n                    // Compress with gzip\n                    meta['dstCompressionType'] = fileCompressionType.lookupByMimeSubType('GZIP');\n                    meta['dstFileName'] = meta['srcFileName'] + meta['dstCompressionType']['file_extension'];\n                }\n                else {\n                    meta['dstFileName'] = meta['srcFileName'];\n                    meta['dstCompressionType'] = null;\n                }\n            }\n        }\n    }\n}\n//TODO SNOW-992387: Create a function to renew expired client\nfunction renewExpiredClient() { }\nmodule.exports = FileTransferAgent;\n//# sourceMappingURL=file_transfer_agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2ZpbGVfdHJhbnNmZXJfYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLDREQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMseUhBQXlCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLG1DQUFtQyw4SkFBa0Q7QUFDckYsa0JBQWtCLG9JQUFpQztBQUNuRCx3Q0FBd0MsNEtBQWdFO0FBQ3hHLHdCQUF3QixtQkFBTyxDQUFDLDZGQUFXO0FBQzNDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyw4RUFBYztBQUNqRSxxQkFBcUIsa0hBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw4QkFBOEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysb0JBQW9CO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CLGNBQWMsd0JBQXdCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9maWxlX3RyYW5zZmVyX2FnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHN0YXRlbWVudCA9IHJlcXVpcmUoJy4uL2Nvbm5lY3Rpb24vc3RhdGVtZW50Jyk7XG5jb25zdCBmaWxlQ29tcHJlc3Npb25UeXBlID0gcmVxdWlyZSgnLi9maWxlX2NvbXByZXNzaW9uX3R5cGUnKTtcbmNvbnN0IGV4cGFuZFRpbGRlID0gcmVxdWlyZSgnZXhwYW5kLXRpbGRlJyk7XG5jb25zdCBTbm93Zmxha2VSZW1vdGVTdG9yYWdlVXRpbCA9IHJlcXVpcmUoJy4vcmVtb3RlX3N0b3JhZ2VfdXRpbCcpLlJlbW90ZVN0b3JhZ2VVdGlsO1xuY29uc3QgTG9jYWxVdGlsID0gcmVxdWlyZSgnLi9sb2NhbF91dGlsJykuTG9jYWxVdGlsO1xuY29uc3QgU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbCA9IHJlcXVpcmUoJy4vcmVtb3RlX3N0b3JhZ2VfdXRpbCcpLlNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWw7XG5jb25zdCBTbm93Zmxha2VTM1V0aWwgPSByZXF1aXJlKCcuL3MzX3V0aWwnKTtcbmNvbnN0IHsgRmlsZVV0aWwsIGdldE1hdGNoaW5nRmlsZVBhdGhzIH0gPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKTtcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLnJlc3VsdFN0YXR1cztcbmNvbnN0IFNub3dmbGFrZUZpbGVVdGlsID0gbmV3IEZpbGVVdGlsKCk7XG5jb25zdCBTbm93Zmxha2VMb2NhbFV0aWwgPSBuZXcgTG9jYWxVdGlsKCk7XG5jb25zdCBTM19GUyA9ICdTMyc7XG5jb25zdCBBWlVSRV9GUyA9ICdBWlVSRSc7XG5jb25zdCBHQ1NfRlMgPSAnR0NTJztcbmNvbnN0IExPQ0FMX0ZTID0gJ0xPQ0FMX0ZTJztcbmNvbnN0IENNRF9UWVBFX1VQTE9BRCA9ICdVUExPQUQnO1xuY29uc3QgQ01EX1RZUEVfRE9XTkxPQUQgPSAnRE9XTkxPQUQnO1xuY29uc3QgRklMRV9QUk9UT0NPTCA9ICdmaWxlOi8vJztcbmNvbnN0IElOSkVDVF9XQUlUX0lOX1BVVCA9IDA7XG5jb25zdCBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBsZW5ndGg6IDE2Nzc3MjE2LFxuICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgfTtcbn07XG5jb25zdCBSRVNVTFRfRklYRURfQ09MVU1OX0RFU0MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdmaXhlZCcsXG4gICAgICAgIGxlbmd0aDogNSxcbiAgICAgICAgcHJlY2lzaW9uOiAwLFxuICAgICAgICBzY2FsZTogMCxcbiAgICAgICAgbnVsbGFibGU6IGZhbHNlLFxuICAgIH07XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgZmlsZSB0cmFuc2ZlciBhZ2VudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmlsZVRyYW5zZmVyQWdlbnQoY29udGV4dCkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JhZ2VVdGlsID0gbmV3IFNub3dmbGFrZVJlbW90ZVN0b3JhZ2VVdGlsKGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBjb250ZXh0LmZpbGVNZXRhZGF0YTtcbiAgICBjb25zdCBjb21tYW5kID0gY29udGV4dC5zcWxUZXh0O1xuICAgIGNvbnN0IGN3ZCA9IGNvbnRleHQuY3dkO1xuICAgIGxldCBjb21tYW5kVHlwZTtcbiAgICBjb25zdCBlbmNyeXB0aW9uTWF0ZXJpYWwgPSBbXTtcbiAgICBsZXQgZmlsZU5hbWU7XG4gICAgY29uc3QgZmlsZVN0cmVhbSA9IGNvbnRleHQuZmlsZVN0cmVhbSA/IGNvbnRleHQuZmlsZVN0cmVhbSA6IG51bGw7XG4gICAgbGV0IGF1dG9Db21wcmVzcztcbiAgICBsZXQgc291cmNlQ29tcHJlc3Npb247XG4gICAgbGV0IHBhcmFsbGVsO1xuICAgIGxldCBzdGFnZUluZm87XG4gICAgbGV0IHN0YWdlTG9jYXRpb25UeXBlO1xuICAgIGxldCBwcmVzaWduZWRVcmxzO1xuICAgIGxldCBvdmVyd3JpdGU7XG4gICAgbGV0IHVzZUFjY2VsZXJhdGVFbmRwb2ludCA9IGZhbHNlO1xuICAgIGxldCBzcmNGaWxlcztcbiAgICBjb25zdCBzcmNGaWxlc1RvRW5jcnlwdGlvbk1hdGVyaWFsID0ge307XG4gICAgbGV0IGxvY2FsTG9jYXRpb247XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIC8vIFN0b3JlIGluZm8gb2YgZmlsZXMgcmV0cmlldmVkXG4gICAgY29uc3QgZmlsZXNUb1B1dCA9IFtdO1xuICAgIC8vIFN0b3JlIG1ldGFkYXRhIG9mIGZpbGVzIHJldHJpZXZlZFxuICAgIGNvbnN0IGZpbGVNZXRhZGF0YSA9IFtdO1xuICAgIGNvbnN0IHNtYWxsRmlsZU1ldGFzID0gW107XG4gICAgY29uc3QgbGFyZ2VGaWxlTWV0YXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIFBVVCBvciBHRVQgY29tbWFuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZXhlY3V0ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZpbGVTdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICAgICAgY29tbWFuZFR5cGUgPSBkYXRhWydjb21tYW5kJ107XG4gICAgICAgICAgICBhdXRvQ29tcHJlc3MgPSBkYXRhWydhdXRvQ29tcHJlc3MnXTtcbiAgICAgICAgICAgIHNvdXJjZUNvbXByZXNzaW9uID0gZGF0YVsnc291cmNlQ29tcHJlc3Npb24nXTtcbiAgICAgICAgICAgIHBhcmFsbGVsID0gZGF0YVsncGFyYWxsZWwnXTtcbiAgICAgICAgICAgIHN0YWdlSW5mbyA9IGRhdGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICAgICAgc3RhZ2VMb2NhdGlvblR5cGUgPSBzdGFnZUluZm9bJ2xvY2F0aW9uVHlwZSddO1xuICAgICAgICAgICAgcHJlc2lnbmVkVXJscyA9IGRhdGFbJ3ByZXNpZ25lZFVybHMnXTtcbiAgICAgICAgICAgIG92ZXJ3cml0ZSA9IGRhdGFbJ292ZXJ3cml0ZSddO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlICE9PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBVcGxvYWRGaWxlU3RyZWFtIGNvbW1hbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJGaWxlT2JqID0ge307XG4gICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZU5hbWUnXSA9IGRhdGEuc3JjX2xvY2F0aW9uc1swXTtcbiAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlUGF0aCddID0gJyc7XG4gICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVNpemUnXSA9IGZpbGVTdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgZmlsZXNUb1B1dC5wdXNoKGN1cnJGaWxlT2JqKTtcbiAgICAgICAgICAgIGluaXRFbmNyeXB0aW9uTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIGluaXRGaWxlTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIGF3YWl0IHRyYW5zZmVyQWNjZWxlcmF0ZUNvbmZpZygpO1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlRmlsZU1ldGFzV2l0aFByZXNpZ25lZFVybCgpO1xuICAgICAgICAgICAgaWYgKGZpbGVNZXRhZGF0YS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwbG9hZEZpbGVTdHJlYW0gb25seSBhbGxvdyAxIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBsb2FkXG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChzdGFnZUxvY2F0aW9uVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBzdG9yYWdlQ2xpZW50LmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBmaWxlTWV0YWRhdGFbMF07XG4gICAgICAgICAgICBtZXRhWydwYXJhbGxlbCddID0gcGFyYWxsZWw7XG4gICAgICAgICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgICAgIG1ldGFbJ2ZpbGVTdHJlYW0nXSA9IGZpbGVTdHJlYW07XG4gICAgICAgICAgICAvL2ZvciBkaWdlc3RcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGZpbGVTdHJlYW0pLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgICAgICAgICBtZXRhWydTSEEyNTZfRElHRVNUJ10gPSBoYXNoO1xuICAgICAgICAgICAgbWV0YVsndXBsb2FkU2l6ZSddID0gZmlsZVN0cmVhbS5sZW5ndGg7XG4gICAgICAgICAgICBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSA9IGZpbGVDb21wcmVzc2lvblR5cGUubG9va3VwQnlFbmNvZGluZyhzb3VyY2VDb21wcmVzc2lvbik7XG4gICAgICAgICAgICBtZXRhWydyZXF1aXJlQ29tcHJlc3MnXSA9IGZhbHNlO1xuICAgICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSA9IG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgICAgICBhd2FpdCBzdG9yYWdlQ2xpZW50LnVwbG9hZE9uZUZpbGVTdHJlYW0obWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZUNvbW1hbmQoKTtcbiAgICAgICAgICAgIGluaXRGaWxlTWV0YWRhdGEoKTtcbiAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfVVBMT0FEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVzVG9QdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZmlsZSBmb3VuZCBmb3I6ICcgKyBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NGaWxlQ29tcHJlc3Npb25UeXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGxvY2FsTG9jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhsb2NhbExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IExPQ0FMX0ZTKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy51bWFzaygwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc3RhZ2VJbmZvWydsb2NhdGlvbiddKSkge1xuICAgICAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMoc3RhZ2VJbmZvWydsb2NhdGlvbiddLCB7IG1vZGU6IDBvNzc3LCByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdHJhbnNmZXJBY2NlbGVyYXRlQ29uZmlnKCk7XG4gICAgICAgICAgICBhd2FpdCB1cGRhdGVGaWxlTWV0YXNXaXRoUHJlc2lnbmVkVXJsKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgZmlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFbJ3NyY0ZpbGVTaXplJ10gPiBTbm93Zmxha2VTM1V0aWwuREFUQV9TSVpFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gbGFyZ2UgZmlsZSBtZXRhc1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydwYXJhbGxlbCddID0gcGFyYWxsZWw7XG4gICAgICAgICAgICAgICAgICAgIGxhcmdlRmlsZU1ldGFzLnB1c2gobWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gc21hbGwgZmlsZSBtZXRhcyBhbmQgc2V0IHBhcmFsbGVsIHRvIDFcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncGFyYWxsZWwnXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsRmlsZU1ldGFzLnB1c2gobWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWQobGFyZ2VGaWxlTWV0YXMsIHNtYWxsRmlsZU1ldGFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfRE9XTkxPQUQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkb3dubG9hZChsYXJnZUZpbGVNZXRhcywgc21hbGxGaWxlTWV0YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgcm93c2V0IGFuZCByb3dzZXQgdHlwZXMgdXNpbmcgdGhlIGZpbGUgbWV0YWRhdGFzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgcm93c2V0ID0gW107XG4gICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfVVBMT0FEKSB7XG4gICAgICAgICAgICBsZXQgc3JjRmlsZVNpemU7XG4gICAgICAgICAgICBsZXQgZHN0RmlsZVNpemU7XG4gICAgICAgICAgICBsZXQgc3JjQ29tcHJlc3Npb25UeXBlO1xuICAgICAgICAgICAgbGV0IGRzdENvbXByZXNzaW9uVHlwZTtcbiAgICAgICAgICAgIGxldCBlcnJvckRldGFpbHM7XG4gICAgICAgICAgICBpZiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzID0gbWV0YVsnZXJyb3JEZXRhaWxzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yRGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRGV0YWlscyA9IGBVbmtub3duIGVycm9yIGR1cmluZyBQVVQgb2YgZmlsZTogJHttZXRhWydzcmNGaWxlUGF0aCddfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YVsnc3JjQ29tcHJlc3Npb25UeXBlJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0NvbXByZXNzaW9uVHlwZSA9IG1ldGFbJ3NyY0NvbXByZXNzaW9uVHlwZSddWyduYW1lJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNDb21wcmVzc2lvblR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHN0Q29tcHJlc3Npb25UeXBlID0gbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ11bJ25hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdENvbXByZXNzaW9uVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzID0gbWV0YVsnZXJyb3JEZXRhaWxzJ107XG4gICAgICAgICAgICAgICAgICAgIHNyY0ZpbGVTaXplID0gbWV0YVsnc3JjRmlsZVNpemUnXS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBkc3RGaWxlU2l6ZSA9IG1ldGFbJ2RzdEZpbGVTaXplJ10udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgcm93c2V0LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsnc3JjRmlsZU5hbWUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVOYW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNGaWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdEZpbGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjQ29tcHJlc3Npb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0Q29tcHJlc3Npb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckRldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93c2V0OiByb3dzZXQsXG4gICAgICAgICAgICAgICAgcm93dHlwZTogW1xuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnc291cmNlJyksXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCd0YXJnZXQnKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX0ZJWEVEX0NPTFVNTl9ERVNDKCdzb3VyY2VTaXplJyksXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9GSVhFRF9DT0xVTU5fREVTQygndGFyZ2V0U2l6ZScpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnc291cmNlQ29tcHJlc3Npb24nKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3RhcmdldENvbXByZXNzaW9uJyksXG4gICAgICAgICAgICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdzdGF0dXMnKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ21lc3NhZ2UnKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfRE9XTkxPQUQpIHtcbiAgICAgICAgICAgIGxldCBkc3RGaWxlU2l6ZTtcbiAgICAgICAgICAgIGxldCBlcnJvckRldGFpbHM7XG4gICAgICAgICAgICBpZiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGV0YWlscyA9IG1ldGFbJ2Vycm9yRGV0YWlscyddO1xuICAgICAgICAgICAgICAgICAgICBkc3RGaWxlU2l6ZSA9IG1ldGFbJ2RzdEZpbGVTaXplJ107XG4gICAgICAgICAgICAgICAgICAgIHJvd3NldC5wdXNoKFttZXRhWydkc3RGaWxlTmFtZSddLCBkc3RGaWxlU2l6ZSwgbWV0YVsncmVzdWx0U3RhdHVzJ10sIGVycm9yRGV0YWlsc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93c2V0OiByb3dzZXQsXG4gICAgICAgICAgICAgICAgcm93dHlwZTogW1xuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnZmlsZScpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfRklYRURfQ09MVU1OX0RFU0MoJ3NpemUnKSxcbiAgICAgICAgICAgICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3N0YXR1cycpLFxuICAgICAgICAgICAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnbWVzc2FnZScpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGxvYWQgZmlsZXMgaW4gdGhlIG1ldGFkYXRhIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB1cGxvYWQobGFyZ2VGaWxlTWV0YXMsIHNtYWxsRmlsZU1ldGFzKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDbGllbnQgPSBnZXRTdG9yYWdlQ2xpZW50KHN0YWdlTG9jYXRpb25UeXBlKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gc3RvcmFnZUNsaWVudC5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvLCBmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBzbWFsbEZpbGVNZXRhcykge1xuICAgICAgICAgICAgbWV0YVsnY2xpZW50J10gPSBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIGxhcmdlRmlsZU1ldGFzKSB7XG4gICAgICAgICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc21hbGxGaWxlTWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy9hd2FpdCB1cGxvYWRGaWxlc2luUGFyYWxsZWwoc21hbGxGaWxlTWV0YXMpO1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkRmlsZXNpblNlcXVlbnRpYWwoc21hbGxGaWxlTWV0YXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXJnZUZpbGVNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRGaWxlc2luU2VxdWVudGlhbChsYXJnZUZpbGVNZXRhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGEgZmlsZSBzZXF1ZW50aWFsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZU1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGVzaW5TZXF1ZW50aWFsKGZpbGVNZXRhKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGZpbGVNZXRhTGVuID0gZmlsZU1ldGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBmaWxlTWV0YUxlbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkT25lRmlsZShmaWxlTWV0YVtpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHJlbmV3RXhwaXJlZENsaWVudCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4MiA9IGluZGV4OyBpbmRleDIgPCBmaWxlTWV0YUxlbjsgaW5kZXgyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU1ldGFbaW5kZXgyXVsnY2xpZW50J10gPSBjbGllbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0WydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1BSRVNJR05FRF9VUkwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVGaWxlTWV0YXNXaXRoUHJlc2lnbmVkVXJsKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuRVJST1IpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAoSU5KRUNUX1dBSVRfSU5fUFVUID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIElOSkVDVF9XQUlUX0lOX1BVVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeSBmb3IgdGhlIGZpbGUgdGhlbiB1cGxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB1cGxvYWRPbmVGaWxlKG1ldGEpIHtcbiAgICAgICAgbWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10gPSBtZXRhWydzcmNGaWxlUGF0aCddO1xuICAgICAgICBjb25zdCB0bXBEaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0bXAnKSk7XG4gICAgICAgIG1ldGFbJ3RtcERpciddID0gdG1wRGlyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG1ldGFbJ3JlcXVpcmVDb21wcmVzcyddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU25vd2ZsYWtlRmlsZVV0aWwuY29tcHJlc3NGaWxlV2l0aEdaSVAobWV0YVsnc3JjRmlsZVBhdGgnXSwgbWV0YVsndG1wRGlyJ10pO1xuICAgICAgICAgICAgICAgIG1ldGFbJ3JlYWxTcmNGaWxlUGF0aCddID0gcmVzdWx0Lm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTbm93Zmxha2VGaWxlVXRpbC5nZXREaWdlc3RBbmRTaXplRm9yRmlsZShtZXRhWydyZWFsU3JjRmlsZVBhdGgnXSk7XG4gICAgICAgICAgICBjb25zdCBzaGEyNTZEaWdlc3QgPSByZXN1bHQuZGlnZXN0O1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkU2l6ZSA9IHJlc3VsdC5zaXplO1xuICAgICAgICAgICAgbWV0YVsnU0hBMjU2X0RJR0VTVCddID0gc2hhMjU2RGlnZXN0O1xuICAgICAgICAgICAgbWV0YVsndXBsb2FkU2l6ZSddID0gdXBsb2FkU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VDbGllbnQgPSBnZXRTdG9yYWdlQ2xpZW50KG1ldGFbJ3N0YWdlTG9jYXRpb25UeXBlJ10pO1xuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZUNsaWVudC51cGxvYWRPbmVGaWxlV2l0aFJldHJ5KG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSAwO1xuICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhWydlcnJvckRldGFpbHMnXSA9IGVyci50b1N0cmluZygpO1xuICAgICAgICAgICAgbWV0YVsnZXJyb3JEZXRhaWxzJ10gKz0gYCBmaWxlPSR7bWV0YVsnc3JjRmlsZU5hbWUnXX0sIHJlYWwgZmlsZT0ke21ldGFbJ3JlYWxTcmNGaWxlUGF0aCddfWA7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGZpbGVzIGluc2lkZSB0bXAgZm9sZGVyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ0ZpbGVOYW1lcyA9IGdldE1hdGNoaW5nRmlsZVBhdGhzKG1ldGFbJ3RtcERpciddLCBtZXRhWydzcmNGaWxlTmFtZSddICsgJyonKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2hpbmdGaWxlTmFtZSBvZiBtYXRjaGluZ0ZpbGVOYW1lcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZnMudW5saW5rKG1hdGNoaW5nRmlsZU5hbWUsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxldGUgdG1wIGZvbGRlclxuICAgICAgICAgICAgZnMucm1kaXIobWV0YVsndG1wRGlyJ10sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgZmlsZXMgaW4gdGhlIG1ldGFkYXRhIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBkb3dubG9hZChsYXJnZUZpbGVNZXRhcywgc21hbGxGaWxlTWV0YXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNsaWVudCA9IGdldFN0b3JhZ2VDbGllbnQoc3RhZ2VMb2NhdGlvblR5cGUpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBzdG9yYWdlQ2xpZW50LmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIGZhbHNlKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIHNtYWxsRmlsZU1ldGFzKSB7XG4gICAgICAgICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbGFyZ2VGaWxlTWV0YXMpIHtcbiAgICAgICAgICAgIG1ldGFbJ2NsaWVudCddID0gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbWFsbEZpbGVNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvL2F3YWl0IGRvd25sb2FkRmlsZXNpblBhcmFsbGVsKHNtYWxsRmlsZU1ldGFzKTtcbiAgICAgICAgICAgIGF3YWl0IGRvd25sb2FkRmlsZXNpblNlcXVlbnRpYWwoc21hbGxGaWxlTWV0YXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXJnZUZpbGVNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBkb3dubG9hZEZpbGVzaW5TZXF1ZW50aWFsKGxhcmdlRmlsZU1ldGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhIGZpbGUgc2VxdWVudGlhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVNZXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGVzaW5TZXF1ZW50aWFsKGZpbGVNZXRhKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGZpbGVNZXRhTGVuID0gZmlsZU1ldGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBmaWxlTWV0YUxlbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG93bmxvYWRPbmVGaWxlKGZpbGVNZXRhW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0WydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gcmVuZXdFeHBpcmVkQ2xpZW50KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXgyID0gaW5kZXg7IGluZGV4MiA8IGZpbGVNZXRhTGVuOyBpbmRleDIrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWxlTWV0YVtpbmRleDJdWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHRbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfUFJFU0lHTkVEX1VSTCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZUZpbGVNZXRhc1dpdGhQcmVzaWduZWRVcmwoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmIChJTkpFQ1RfV0FJVF9JTl9QVVQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgSU5KRUNUX1dBSVRfSU5fUFVUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYSBmaWxlIGFuZCBwbGFjZSBpbnRvIHRoZSB0YXJnZXQgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRPbmVGaWxlKG1ldGEpIHtcbiAgICAgICAgbWV0YVsndG1wRGlyJ10gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3RtcCcpLCAoZXJyLCBkaXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKGRpcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChtZXRhWydzdGFnZUxvY2F0aW9uVHlwZSddKTtcbiAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2VDbGllbnQuZG93bmxvYWRPbmVGaWxlKG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSAtMTtcbiAgICAgICAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSkge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YVsnZXJyb3JEZXRhaWxzJ10gPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG1ldGFbJ2Vycm9yRGV0YWlscyddICs9IGAgZmlsZT0ke21ldGFbJ2RzdEZpbGVOYW1lJ119YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdG8gYWNjZWxlcmF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIFMzIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB0cmFuc2ZlckFjY2VsZXJhdGVDb25maWcoKSB7XG4gICAgICAgIGlmIChzdGFnZUxvY2F0aW9uVHlwZSA9PT0gUzNfRlMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHJlbW90ZVN0b3JhZ2VVdGlsLmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHMzbG9jYXRpb24gPSBTbm93Zmxha2VTM1V0aWwuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKHN0YWdlSW5mb1snbG9jYXRpb24nXSk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnRcbiAgICAgICAgICAgICAgICAuZ2V0QnVja2V0QWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb24oeyBCdWNrZXQ6IHMzbG9jYXRpb24uYnVja2V0TmFtZSB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdXNlQWNjZWxlcmF0ZUVuZHBvaW50ID0gZGF0YVsnU3RhdHVzJ10gPT09ICdFbmFibGVkJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyWydjb2RlJ10gPT09ICdBY2Nlc3NEZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcHJlc2lnbmVkIFVSTHMgb2YgZmlsZSBtZXRhZGF0YSB3aGVuIHVzaW5nIEdDUyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGVGaWxlTWV0YXNXaXRoUHJlc2lnbmVkVXJsKCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChzdGFnZUxvY2F0aW9uVHlwZSk7XG4gICAgICAgIC8vIHByZXNpZ25lZCB1cmwgb25seSBhcHBsaWVzIHRvIHJlbW90ZSBzdG9yYWdlXG4gICAgICAgIGlmIChzdG9yYWdlQ2xpZW50ID09PSByZW1vdGVTdG9yYWdlVXRpbCkge1xuICAgICAgICAgICAgLy8gcHJlc2lnbmVkIHVybCBvbmx5IGFwcGxpZXMgdG8gR0NTXG4gICAgICAgICAgICBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IEdDU19GUykge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfVVBMT0FEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoVG9SZXBsYWNlID0gZ2V0RmlsZU5hbWVGcm9tUHV0Q29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIGZpbGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWVUb1JlcGxhY2VXaXRoID0gbWV0YVsnZHN0RmlsZU5hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kV2l0aFNpbmdsZUZpbGUgPSBjb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZFdpdGhTaW5nbGVGaWxlID0gY29tbWFuZFdpdGhTaW5nbGVGaWxlLnJlcGxhY2UoZmlsZVBhdGhUb1JlcGxhY2UsIGZpbGVOYW1lVG9SZXBsYWNlV2l0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0geyBzcWxUZXh0OiBjb21tYW5kV2l0aFNpbmdsZUZpbGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBzdGF0ZW1lbnQuY3JlYXRlQ29udGV4dChvcHRpb25zLCBjb250ZXh0LnNlcnZpY2VzLCBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gYXdhaXQgc3RhdGVtZW50LnNlbmRSZXF1ZXN0KG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsnc3RhZ2VJbmZvJ10gPSByZXRbJ2RhdGEnXVsnZGF0YSddWydzdGFnZUluZm8nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ3ByZXNpZ25lZFVybCddID0gbWV0YVsnc3RhZ2VJbmZvJ11bJ3ByZXNpZ25lZFVybCddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZmlsZU1ldGFkYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU1ldGFkYXRhW2luZGV4XVsncHJlc2lnbmVkVXJsJ10gPSBwcmVzaWduZWRVcmxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBmaWxlIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tbWFuZFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaWxlTmFtZUZyb21QdXRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBmaWxlIHBhdGggZnJvbSBQVVQgY29tbWFuZDpcbiAgICAgICAgLy8gRS5nLiBcIlBVVCBmaWxlOi8vQzo8cGF0aC10by1maWxlPiBAREIuU0NIRU1BLiVUQUJMRTtcIlxuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gY29tbWFuZC5pbmRleE9mKEZJTEVfUFJPVE9DT0wpICsgRklMRV9QUk9UT0NPTC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNwYWNlSW5kZXggPSBjb21tYW5kLnN1YnN0cmluZyhzdGFydEluZGV4KS5pbmRleE9mKCcgJyk7XG4gICAgICAgIGNvbnN0IHF1b3RlSW5kZXggPSBjb21tYW5kLnN1YnN0cmluZyhzdGFydEluZGV4KS5pbmRleE9mKFwiJ1wiKTtcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gc3BhY2VJbmRleDtcbiAgICAgICAgaWYgKHF1b3RlSW5kZXggIT09IC0xICYmIHF1b3RlSW5kZXggPCBzcGFjZUluZGV4KSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IHF1b3RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBjb21tYW5kLnN1YnN0cmluZyhzdGFydEluZGV4LCBzdGFydEluZGV4ICsgZW5kSW5kZXgpO1xuICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RvcmFnZSBjbGllbnQgYmFzZWQgb24gc3RhZ2UgbG9jYXRpb24gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGFnZUxvY2F0aW9uVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdG9yYWdlQ2xpZW50KHN0YWdlTG9jYXRpb25UeXBlKSB7XG4gICAgICAgIGlmIChzdGFnZUxvY2F0aW9uVHlwZSA9PT0gTE9DQUxfRlMpIHtcbiAgICAgICAgICAgIHJldHVybiBTbm93Zmxha2VMb2NhbFV0aWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IFMzX0ZTIHx8XG4gICAgICAgICAgICBzdGFnZUxvY2F0aW9uVHlwZSA9PT0gQVpVUkVfRlMgfHxcbiAgICAgICAgICAgIHN0YWdlTG9jYXRpb25UeXBlID09PSBHQ1NfRlMpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGVTdG9yYWdlVXRpbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBjb21tYW5kIGFuZCBnZXQgbGlzdCBvZiBmaWxlcyB0byB1cGxvYWQvZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUNvbW1hbmQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBjb21tYW5kVHlwZSA9IGRhdGFbJ2NvbW1hbmQnXTtcbiAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IGRhdGFbJ3NyY19sb2NhdGlvbnMnXVswXTtcbiAgICAgICAgICAgIC8vIEdldCByb290IGRpcmVjdG9yeSBvZiBmaWxlIHBhdGhcbiAgICAgICAgICAgIGxldCByb290ID0gcGF0aC5kaXJuYW1lKHNyYyk7XG4gICAgICAgICAgICAvLyBJZiBjd2QgZXhpc3RzIGFuZCByb290IGlzIHJlbGF0aXZlIC4gdGhlbiByZXBsYWNlIHdpdGggY29udGV4dCdzIGN3ZFxuICAgICAgICAgICAgLy8gVXNlZCBmb3IgVlMgQ29kZSBleHRlbnNpb24gd2hlcmUgZXh0ZW5zaW9uIGN3ZCBkaWZmZXJzIGZyb20gdXNlciB3b3Jrc3BhY2UgZGlyXG4gICAgICAgICAgICBpZiAoY3dkICYmICFwYXRoLmlzQWJzb2x1dGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZShjd2QsIHNyYyk7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHBhdGguZGlybmFtZShhYnNvbHV0ZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgICAgIC8vIENoZWNrIHJvb3QgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocm9vdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcm9vdCBwYXRoIGlzIGEgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgZGlyID0gZnMuc3RhdFN5bmMocm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpci5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBmaWxlIG5hbWUgdG8gdXBsb2FkXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZShzcmMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGdWxsIHBhdGggbmFtZSBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZUZ1bGxQYXRoID0gcGF0aC5qb2luKHJvb3QsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZmlsZSBuYW1lIGhhcyBhIHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZS5pbmNsdWRlcygnKicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYWxsIGZpbGUgbmFtZXMgdGhhdCBtYXRjaGVzIHRoZSB3aWxkY2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdGaWxlTmFtZXMgPSBnZXRNYXRjaGluZ0ZpbGVQYXRocyhyb290LCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoaW5nRmlsZU5hbWUgb2YgbWF0Y2hpbmdGaWxlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZUluZm8gPSBmcy5zdGF0U3luYyhtYXRjaGluZ0ZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyRmlsZU9iaiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlTmFtZSddID0gcGF0aC5iYXNlbmFtZShtYXRjaGluZ0ZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVBhdGgnXSA9IG1hdGNoaW5nRmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVTaXplJ10gPSBmaWxlSW5mby5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzVG9QdXQucHVzaChjdXJyRmlsZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB3aWxkY2FyZCwgZ2V0IHNpbmdsZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhyb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRFbmNyeXB0aW9uTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGZzLnN0YXRTeW5jKGZpbGVOYW1lRnVsbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJGaWxlT2JqID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVOYW1lJ10gPSBmaWxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVBhdGgnXSA9IGZpbGVOYW1lRnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVTaXplJ10gPSBmaWxlSW5mby5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzVG9QdXQucHVzaChjdXJyRmlsZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGlyICsgJyBpcyBub3QgYSBkaXJlY3RvcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9Db21wcmVzcyA9IGRhdGFbJ2F1dG9Db21wcmVzcyddO1xuICAgICAgICAgICAgc291cmNlQ29tcHJlc3Npb24gPSBkYXRhWydzb3VyY2VDb21wcmVzc2lvbiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgICAgaW5pdEVuY3J5cHRpb25NYXRlcmlhbCgpO1xuICAgICAgICAgICAgc3JjRmlsZXMgPSBkYXRhWydzcmNfbG9jYXRpb25zJ107XG4gICAgICAgICAgICBpZiAoc3JjRmlsZXMubGVuZ3RoID09PSBlbmNyeXB0aW9uTWF0ZXJpYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gc3JjRmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjRmlsZXNUb0VuY3J5cHRpb25NYXRlcmlhbFtzcmNGaWxlc1tpZHhdXSA9IGVuY3J5cHRpb25NYXRlcmlhbFtpZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuY3J5cHRpb25NYXRlcmlhbC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lIGVuY3J5cHRpb24gbWF0ZXJpYWwgZXhpc3RzLiBaZXJvIG1lYW5zIG5vIGVuY3J5cHRpb25cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbnVtYmVyIG9mIGRvd25sb2FkaW5nIGZpbGVzIGRvZXNuJ3QgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbExvY2F0aW9uID0gZXhwYW5kVGlsZGUoZGF0YVsnbG9jYWxMb2NhdGlvbiddKTtcbiAgICAgICAgICAgIC8vIElmIGN3ZCBleGlzdHMgYW5kIHJvb3QgaXMgcmVsYXRpdmUgLiB0aGVuIHJlcGxhY2Ugd2l0aCBjb250ZXh0J3MgY3dkXG4gICAgICAgICAgICAvLyBVc2VkIGZvciBWUyBDb2RlIGV4dGVuc2lvbiB3aGVyZSBleHRlbnNpb24gY3dkIGRpZmZlcnMgZnJvbSB1c2VyIHdvcmtzcGFjZSBkaXJcbiAgICAgICAgICAgIGlmIChjd2QgJiYgIXBhdGguaXNBYnNvbHV0ZShsb2NhbExvY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZShjd2QsIGxvY2FsTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGxvY2FsTG9jYXRpb24gPSBhYnNvbHV0ZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBmcy5zdGF0U3luYyhsb2NhbExvY2F0aW9uKTtcbiAgICAgICAgICAgIGlmICghZGlyLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsb2NhbCBwYXRoIGlzIG5vdCBhIGRpcmVjdG9yeTogJyArIGxvY2FsTG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmFsbGVsID0gZGF0YVsncGFyYWxsZWwnXTtcbiAgICAgICAgc3RhZ2VJbmZvID0gZGF0YVsnc3RhZ2VJbmZvJ107XG4gICAgICAgIHN0YWdlTG9jYXRpb25UeXBlID0gc3RhZ2VJbmZvWydsb2NhdGlvblR5cGUnXTtcbiAgICAgICAgcHJlc2lnbmVkVXJscyA9IGRhdGFbJ3ByZXNpZ25lZFVybHMnXTtcbiAgICAgICAgb3ZlcndyaXRlID0gZGF0YVsnb3ZlcndyaXRlJ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGVuY3J5cHRpb24gbWF0ZXJpYWwgZm9yIGVhY2ggbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCkge1xuICAgICAgICBpZiAocmVzcG9uc2VbJ2RhdGEnXSAmJiByZXNwb25zZVsnZGF0YSddWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSByZXNwb25zZVsnZGF0YSddWydlbmNyeXB0aW9uTWF0ZXJpYWwnXTtcbiAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfVVBMT0FEKSB7XG4gICAgICAgICAgICAgICAgZW5jcnlwdGlvbk1hdGVyaWFsLnB1c2gobmV3IFNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWwocm9vdE5vZGVbJ3F1ZXJ5U3RhZ2VNYXN0ZXJLZXknXSwgcm9vdE5vZGVbJ3F1ZXJ5SWQnXSwgcm9vdE5vZGVbJ3Nta0lkJ10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBpbiByb290Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNyeXB0aW9uTWF0ZXJpYWwucHVzaChuZXcgU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbChyb290Tm9kZVtlbGVtXVsncXVlcnlTdGFnZU1hc3RlcktleSddLCByb290Tm9kZVtlbGVtXVsncXVlcnlJZCddLCByb290Tm9kZVtlbGVtXVsnc21rSWQnXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBtZXRhZGF0YSBmb3IgZmlsZXMgdG8gdXBsb2FkL2Rvd25sb2FkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdEZpbGVNZXRhZGF0YSgpIHtcbiAgICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlc1RvUHV0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVBhdGgnXSA9IGZpbGVbJ3NyY0ZpbGVQYXRoJ107XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVOYW1lJ10gPSBmaWxlWydzcmNGaWxlTmFtZSddO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlU2l6ZSddID0gZmlsZVsnc3JjRmlsZVNpemUnXTtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3RhZ2VMb2NhdGlvblR5cGUnXSA9IHN0YWdlTG9jYXRpb25UeXBlO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzdGFnZUluZm8nXSA9IHN0YWdlSW5mbztcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnb3ZlcndyaXRlJ10gPSBvdmVyd3JpdGU7XG4gICAgICAgICAgICAgICAgZmlsZU1ldGFkYXRhLnB1c2goY3VyckZpbGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlTmFtZSBvZiBzcmNGaWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJGaWxlT2JqID0ge307XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVOYW1lJ10gPSBmaWxlTmFtZTtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnZHN0RmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzdGFnZUxvY2F0aW9uVHlwZSddID0gc3RhZ2VMb2NhdGlvblR5cGU7XG4gICAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3N0YWdlSW5mbyddID0gc3RhZ2VJbmZvO1xuICAgICAgICAgICAgICAgIGN1cnJGaWxlT2JqWyd1c2VBY2NlbGVyYXRlRW5kcG9pbnQnXSA9IHVzZUFjY2VsZXJhdGVFbmRwb2ludDtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnbG9jYWxMb2NhdGlvbiddID0gbG9jYWxMb2NhdGlvbjtcbiAgICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnZW5jcnlwdGlvbk1hdGVyaWFsJ10gPSBzcmNGaWxlc1RvRW5jcnlwdGlvbk1hdGVyaWFsW2ZpbGVOYW1lXTtcbiAgICAgICAgICAgICAgICBmaWxlTWV0YWRhdGEucHVzaChjdXJyRmlsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY3J5cHRpb25NYXRlcmlhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgZmlsZVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10gPSBlbmNyeXB0aW9uTWF0ZXJpYWxbaV07XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29tcHJlc3Npb24gdHlwZSBvZiB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NGaWxlQ29tcHJlc3Npb25UeXBlKCkge1xuICAgICAgICBsZXQgdXNlclNwZWNpZmllZFNvdXJjZUNvbXByZXNzaW9uO1xuICAgICAgICBsZXQgYXV0b0RldGVjdDtcbiAgICAgICAgaWYgKHNvdXJjZUNvbXByZXNzaW9uID09PSAnYXV0b19kZXRlY3QnKSB7XG4gICAgICAgICAgICBhdXRvRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2VDb21wcmVzc2lvbiA9PT0gdHlwZW9mICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhdXRvRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2VyU3BlY2lmaWVkU291cmNlQ29tcHJlc3Npb24gPSBmaWxlQ29tcHJlc3Npb25UeXBlLmxvb2t1cEJ5TWltZVN1YlR5cGUoc291cmNlQ29tcHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHVzZXJTcGVjaWZpZWRTb3VyY2VDb21wcmVzc2lvbiA9PT0gdHlwZW9mICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgIXVzZXJTcGVjaWZpZWRTb3VyY2VDb21wcmVzc2lvblsnaXNfc3VwcG9ydGVkJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc291cmNlQ29tcHJlc3Npb24gKyAnIGlzIG5vdCBhIHN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIGZpbGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBtZXRhWydzcmNGaWxlUGF0aCddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlO1xuICAgICAgICAgICAgbGV0IGVuY29kaW5nO1xuICAgICAgICAgICAgaWYgKGF1dG9EZXRlY3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IG1pbWUubG9va3VwKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZkID0gZnMub3BlblN5bmMoZmlsZVBhdGgsICdyKycpO1xuICAgICAgICAgICAgICAgICAgICBmcy5yZWFkU3luYyhmZCwgdGVzdCwgMCwgNCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSkgPT09ICcuYnInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdicic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsZU5hbWUuc3Vic3RyaW5nKGZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJykpID09PSAnLmRlZmxhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdkZWZsYXRlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSkgPT09ICcucmF3X2RlZmxhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdyYXdfZGVmbGF0ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQnVmZmVyLmZyb20odGVzdC50b1N0cmluZygpKS5zbGljZSgwLCAzKSA9PT0gQnVmZmVyLmZyb20oJ09SQycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdvcmMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5mcm9tKHRlc3QudG9TdHJpbmcoKSkgPT09IEJ1ZmZlci5mcm9tKCdQQVIxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ3BhcnF1ZXQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRlc3QudG9TdHJpbmcoJ2hleCcpID09PSAnMjhmZDJmZmQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSkgPT09ICcuenN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSAnenN0ZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlID0gZmlsZUNvbXByZXNzaW9uVHlwZS5sb29rdXBCeUVuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB7fSBObyBmaWxlIGVuY29kaW5nIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlICYmICFjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZVsnaXNfc3VwcG9ydGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVuY29kaW5nICsgJyBpcyBub3QgYSBhIHN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGUgPSB1c2VyU3BlY2lmaWVkU291cmNlQ29tcHJlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGVbJ2lzX3N1cHBvcnRlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdENvbXByZXNzaW9uVHlwZSddID0gY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGU7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3JlcXVpcmVDb21wcmVzcyddID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVOYW1lJ10gPSBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVuY29kaW5nICsgJyBpcyBub3QgYSBhIHN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVxdWlyZUNvbXByZXNzJ10gPSBhdXRvQ29tcHJlc3M7XG4gICAgICAgICAgICAgICAgbWV0YVsnc3JjQ29tcHJlc3Npb25UeXBlJ10gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIElmIHJlcXVpcmVDb21wcmVzcyBpcyB0cnVlLCBkZXN0aW5hdGlvbiBmaWxlIGV4dGVuc2lvbiBpcyBjaGFuZ2VkIHRvIHppcFxuICAgICAgICAgICAgICAgIGlmIChhdXRvQ29tcHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlc3Mgd2l0aCBnemlwXG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdENvbXByZXNzaW9uVHlwZSddID0gZmlsZUNvbXByZXNzaW9uVHlwZS5sb29rdXBCeU1pbWVTdWJUeXBlKCdHWklQJyk7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVOYW1lJ10gPSBtZXRhWydzcmNGaWxlTmFtZSddICsgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ11bJ2ZpbGVfZXh0ZW5zaW9uJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydkc3RGaWxlTmFtZSddID0gbWV0YVsnc3JjRmlsZU5hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ10gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vVE9ETyBTTk9XLTk5MjM4NzogQ3JlYXRlIGEgZnVuY3Rpb24gdG8gcmVuZXcgZXhwaXJlZCBjbGllbnRcbmZ1bmN0aW9uIHJlbmV3RXhwaXJlZENsaWVudCgpIHsgfVxubW9kdWxlLmV4cG9ydHMgPSBGaWxlVHJhbnNmZXJBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGVfdHJhbnNmZXJfYWdlbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/file_transfer_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").FileHeader);\nconst getProxyAgent = (__webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\").getProxyAgent);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst { lstrip } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst GCS_METADATA_PREFIX = 'x-goog-meta-';\nconst SFC_DIGEST = 'sfc-digest';\nconst MATDESC_KEY = 'matdesc';\nconst ENCRYPTIONDATAPROP = 'encryptiondata';\nconst GCS_METADATA_SFC_DIGEST = GCS_METADATA_PREFIX + SFC_DIGEST;\nconst GCS_METADATA_MATDESC_KEY = GCS_METADATA_PREFIX + MATDESC_KEY;\nconst GCS_METADATA_ENCRYPTIONDATAPROP = GCS_METADATA_PREFIX + ENCRYPTIONDATAPROP;\nconst GCS_FILE_HEADER_DIGEST = 'gcs-file-header-digest';\nconst GCS_FILE_HEADER_CONTENT_LENGTH = 'gcs-file-header-content-length';\nconst GCS_FILE_HEADER_ENCRYPTION_METADATA = 'gcs-file-header-encryption-metadata';\nconst HTTP_HEADER_CONTENT_ENCODING = 'Content-Encoding';\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst { Storage } = __webpack_require__(/*! @google-cloud/storage */ \"(rsc)/./node_modules/@google-cloud/storage/build/cjs/src/index.js\");\nconst EXPIRED_TOKEN = 'ExpiredToken';\nconst ERRORNO_WSAECONNABORTED = 10053; // network connection was aborted\n/**\n * @typedef {object} GCSLocation\n * @property {string} bucketName\n * @property {string} path\n */\nfunction GCSLocation(bucketName, path) {\n    return {\n        bucketName: bucketName,\n        path: path,\n    };\n}\n/**\n * Creates an GCS utility object.\n * @param {module} connectionConfig\n * @param {module} httpClient\n * @param {module} fileStream\n *\n * @returns {Object}\n * @constructor\n */\nfunction GCSUtil(connectionConfig, httpClient) {\n    let axios = httpClient;\n    let isProxyEnabled = false;\n    /**\n     * Retrieve the GCS token from the stage info metadata.\n     *\n     * @param {Object} stageInfo\n     *\n     * @returns {String}\n     */\n    this.createClient = function (stageInfo) {\n        const stageCredentials = stageInfo['creds'];\n        const gcsToken = stageCredentials['GCS_ACCESS_TOKEN'];\n        //TODO: SNOW-1789759 the value is hardcoded now, but it should be server driven\n        const endPoint = this.getGCSCustomEndPoint(stageInfo);\n        let client;\n        if (gcsToken) {\n            const interceptors = [];\n            interceptors.push({\n                request: (requestConfig) => {\n                    requestConfig.headers = requestConfig.headers || {};\n                    Object.assign(requestConfig.headers, { Authorization: `Bearer ${gcsToken}` });\n                    return requestConfig;\n                },\n            });\n            const storage = Util.exists(endPoint)\n                ? new Storage({ interceptors_: interceptors, apiEndpoint: endPoint })\n                : new Storage({ interceptors_: interceptors });\n            client = { gcsToken: gcsToken, gcsClient: storage };\n        }\n        else {\n            client = null;\n        }\n        this.setupHttpClient(endPoint);\n        return client;\n    };\n    /**\n     * Extract the bucket name and path from the metadata's stage location.\n     *\n     * @param {String} stageLocation\n     *\n     * @returns {GCSLocation}\n     */\n    this.extractBucketNameAndPath = function (stageLocation) {\n        let containerName = stageLocation;\n        let path = '';\n        // split stage location as bucket name and path\n        if (stageLocation.includes('/')) {\n            containerName = stageLocation.substring(0, stageLocation.indexOf('/'));\n            path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n            if (path && !path.endsWith('/')) {\n                path += '/';\n            }\n        }\n        return GCSLocation(containerName, path);\n    };\n    /**\n     * Create file header based on file being uploaded or not.\n     *\n     * @param {Object} meta\n     * @param {String} filename\n     *\n     * @returns {Object}\n     */\n    this.getFileHeader = async function (meta, filename) {\n        if (meta['resultStatus'] === resultStatus.UPLOADED ||\n            meta['resultStatus'] === resultStatus.DOWNLOADED) {\n            return FileHeader(meta[GCS_FILE_HEADER_DIGEST], meta[GCS_FILE_HEADER_CONTENT_LENGTH], meta[GCS_FILE_HEADER_ENCRYPTION_METADATA]);\n        }\n        else {\n            if (meta['presignedUrl']) {\n                await axios.get(meta['presignedUrl']).catch((err) => {\n                    if ([401, 403, 404].includes(err.response.status)) {\n                        meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                    }\n                });\n            }\n            else {\n                const url = this.generateFileURL(meta.stageInfo, lstrip(filename, '/'));\n                const accessToken = meta['client'].gcsToken;\n                const gcsHeaders = { Authorization: `Bearer ${accessToken}` };\n                let encryptionMetadata;\n                let digest;\n                let contentLength;\n                let encryptionDataProp;\n                let matDescKey;\n                try {\n                    if (this.shouldUseJsonApi(meta)) {\n                        const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n                        const metadata = await meta['client'].gcsClient\n                            .bucket(gcsLocation.bucketName)\n                            .file(gcsLocation.path + filename)\n                            .getMetadata();\n                        digest = metadata[0].metadata[SFC_DIGEST];\n                        contentLength = metadata[0].size;\n                        encryptionDataProp = metadata[0].metadata[ENCRYPTIONDATAPROP];\n                        matDescKey = metadata[0].metadata[MATDESC_KEY];\n                    }\n                    else {\n                        const response = await axios.head(url, { headers: gcsHeaders });\n                        digest = response.headers[GCS_METADATA_SFC_DIGEST];\n                        contentLength = response.headers['content-length'];\n                        encryptionDataProp = response.headers[GCS_METADATA_ENCRYPTIONDATAPROP];\n                        matDescKey = response.headers[GCS_METADATA_MATDESC_KEY];\n                    }\n                    if (encryptionDataProp) {\n                        const encryptionData = JSON.parse(encryptionDataProp);\n                        if (encryptionData) {\n                            encryptionMetadata = EncryptionMetadata(encryptionData['WrappedContentKey']['EncryptedKey'], encryptionData['ContentEncryptionIV'], matDescKey ? matDescKey : null);\n                        }\n                    }\n                    meta['resultStatus'] = resultStatus.UPLOADED;\n                    return FileHeader(digest, contentLength, encryptionMetadata);\n                }\n                catch (err) {\n                    const errCode = !isNaN(err['code']) && !isNaN(parseInt(err['code']))\n                        ? err['code']\n                        : err.response.status;\n                    if ([403, 408, 429, 500, 503].includes(errCode)) {\n                        meta['lastError'] = err;\n                        meta['resultStatus'] = resultStatus.NEED_RETRY;\n                        return;\n                    }\n                    if (errCode === 404) {\n                        meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                    }\n                    else if (errCode === 401) {\n                        meta['lastError'] = err;\n                        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                    }\n                    else {\n                        meta['lastError'] = err;\n                        meta['resultStatus'] = resultStatus.ERROR;\n                        throw err;\n                    }\n                }\n            }\n        }\n        return FileHeader(null, null, null);\n    };\n    /**\n     * Create the file metadata then upload the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     * @param {Number} maxConcurrency\n     *\n     * @returns {null}\n     */\n    this.uploadFile = async function (dataFile, meta, encryptionMetadata, maxConcurrency) {\n        const fileStream = fs.readFileSync(dataFile);\n        await this.uploadFileStream(fileStream, meta, encryptionMetadata, maxConcurrency);\n    };\n    /**\n     * Create the file metadata then upload the file stream.\n     *\n     * @param {String} fileStream\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     *\n     * @returns {null}\n     */\n    this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n        let uploadUrl = meta['presignedUrl'];\n        let accessToken = null;\n        if (!uploadUrl) {\n            const tempFilename = meta['dstFileName'].substring(meta['dstFileName'].indexOf('/') + 1, meta['dstFileName'].length);\n            uploadUrl = this.generateFileURL(meta.stageInfo, tempFilename);\n            accessToken = meta['client'].gcsToken;\n        }\n        let contentEncoding = '';\n        if (meta['dstCompressionType']) {\n            contentEncoding = meta['dstCompressionType']['name'];\n            contentEncoding = contentEncoding.toLowerCase();\n        }\n        // We set the contentEncoding to blank for the following file types\n        if (['gzip', 'bzip2', 'brotli', 'deflate', 'raw_deflate', 'zstd'].includes(contentEncoding)) {\n            contentEncoding = '';\n        }\n        const gcsHeaders = {\n            [HTTP_HEADER_CONTENT_ENCODING]: contentEncoding,\n            [GCS_METADATA_SFC_DIGEST]: meta['SHA256_DIGEST'],\n        };\n        if (accessToken) {\n            gcsHeaders['Authorization'] = `Bearer ${accessToken}`;\n        }\n        if (encryptionMetadata) {\n            gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP] = JSON.stringify({\n                EncryptionMode: 'FullBlob',\n                WrappedContentKey: {\n                    KeyId: 'symmKey1',\n                    EncryptedKey: encryptionMetadata.key,\n                    Algorithm: 'AES_CBC_256',\n                },\n                EncryptionAgent: {\n                    Protocol: '1.0',\n                    EncryptionAlgorithm: 'AES_CBC_256',\n                },\n                ContentEncryptionIV: encryptionMetadata.iv,\n                KeyWrappingMetadata: {\n                    EncryptionLibrary: 'Java 5.3.0',\n                },\n            });\n            gcsHeaders[GCS_METADATA_MATDESC_KEY] = encryptionMetadata.matDesc;\n        }\n        try {\n            if (this.shouldUseJsonApi(meta)) {\n                const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n                await meta['client'].gcsClient\n                    .bucket(gcsLocation.bucketName)\n                    .file(gcsLocation.path + meta['dstFileName'])\n                    .save(fileStream, {\n                    resumable: false,\n                    metadata: {\n                        metadata: {\n                            [ENCRYPTIONDATAPROP]: gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP],\n                            [MATDESC_KEY]: gcsHeaders[GCS_METADATA_MATDESC_KEY],\n                            [SFC_DIGEST]: gcsHeaders[GCS_METADATA_SFC_DIGEST],\n                        },\n                    },\n                });\n            }\n            else {\n                // Set maxBodyLength to allow large file uploading\n                await axios.put(uploadUrl, fileStream, { maxBodyLength: Infinity, headers: gcsHeaders });\n            }\n        }\n        catch (err) {\n            if ([403, 408, 429, 500, 503].includes(err['code'])) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.NEED_RETRY;\n            }\n            else if (!accessToken &&\n                err['code'] === 400 &&\n                (!meta['lastError'] || meta['lastError']['code'] !== 400)) {\n                // Only attempt to renew urls if this isn't the second time this happens\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_PRESIGNED_URL;\n            }\n            else if (accessToken && err['code'] === 401) {\n                meta['lastError'] = err;\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            return;\n        }\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n        meta[GCS_FILE_HEADER_DIGEST] = gcsHeaders[GCS_METADATA_SFC_DIGEST];\n        meta[GCS_FILE_HEADER_CONTENT_LENGTH] = meta['uploadSize'];\n        meta[GCS_FILE_HEADER_ENCRYPTION_METADATA] = gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP];\n    };\n    /**\n     * Download the file.\n     *\n     * @param {Object} meta\n     * @param fullDstPath\n     *\n     * @returns {null}\n     */\n    this.nativeDownloadFile = async function (meta, fullDstPath) {\n        let downloadUrl = meta['presignedUrl'];\n        let accessToken = null;\n        let gcsHeaders = {};\n        if (!downloadUrl) {\n            downloadUrl = this.generateFileURL(meta.stageInfo, lstrip(meta['srcFileName'], '/'));\n            accessToken = meta['client'].gcsToken;\n            gcsHeaders = { Authorization: `Bearer ${accessToken}` };\n        }\n        let encryptionDataprop;\n        let matDescKey;\n        let sfcDigest;\n        let size;\n        try {\n            if (this.shouldUseJsonApi(meta)) {\n                const { bucketName, path } = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n                Logger().debug(`Use GCP client to download the file.`);\n                Logger().debug(`Send Get Request to the Bucket: ${bucketName}, GET request: ${path}`);\n                await meta['client'].gcsClient\n                    .bucket(bucketName)\n                    .file(path + meta['srcFileName'])\n                    .download({\n                    destination: fullDstPath,\n                });\n                const metadata = await meta['client'].gcsClient\n                    .bucket(bucketName)\n                    .file(path + meta['srcFileName'])\n                    .getMetadata();\n                encryptionDataprop = metadata[0].metadata[ENCRYPTIONDATAPROP];\n                matDescKey = metadata[0].metadata[MATDESC_KEY];\n                sfcDigest = metadata[0].metadata[SFC_DIGEST];\n                size = metadata[0].size;\n            }\n            else {\n                Logger().debug(`Downloading file from GCS using Axios`);\n                let response;\n                await axios\n                    .get(downloadUrl, {\n                    headers: gcsHeaders,\n                    responseType: 'stream',\n                })\n                    .then(async (res) => {\n                    response = res;\n                    await new Promise((resolve, reject) => {\n                        const writer = fs.createWriteStream(fullDstPath);\n                        response.data.pipe(writer);\n                        writer.on('error', (err) => {\n                            writer.close();\n                            reject(err);\n                        });\n                        writer.on('close', () => {\n                            resolve();\n                        });\n                    });\n                });\n                Logger().debug(`Sent Get Request to ${downloadUrl}, destination: ${fullDstPath}, http status: ${response.status}`);\n                encryptionDataprop = response.headers[GCS_METADATA_ENCRYPTIONDATAPROP];\n                matDescKey = response.headers[GCS_METADATA_MATDESC_KEY];\n                sfcDigest = response.headers[GCS_METADATA_SFC_DIGEST];\n                size = response.headers['content-length'];\n            }\n        }\n        catch (err) {\n            if (err['code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            else {\n                meta['lastError'] = err;\n                if (err['code'] === ERRORNO_WSAECONNABORTED) {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n                }\n                else {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY;\n                }\n            }\n            return;\n        }\n        let encryptionData;\n        if (encryptionDataprop) {\n            encryptionData = JSON.parse(encryptionDataprop);\n        }\n        let encryptionMetadata;\n        if (encryptionData) {\n            encryptionMetadata = EncryptionMetadata(encryptionData['WrappedContentKey']['EncryptedKey'], encryptionData['ContentEncryptionIV'], matDescKey);\n        }\n        const fileInfo = fs.statSync(fullDstPath);\n        meta['srcFileSize'] = fileInfo.size;\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n        meta[GCS_FILE_HEADER_DIGEST] = sfcDigest;\n        meta[GCS_FILE_HEADER_CONTENT_LENGTH] = size;\n        meta[GCS_FILE_HEADER_ENCRYPTION_METADATA] = encryptionMetadata;\n    };\n    /**\n     * Generate file URL based on bucket.\n     *\n     * @param {Object} stageInfo\n     * @param {String} filename\n     *\n     * @returns {String}\n     */\n    this.generateFileURL = function (stageInfo, filename) {\n        const gcsLocation = this.extractBucketNameAndPath(stageInfo.location);\n        const fullFilePath = `${gcsLocation.path}${filename}`;\n        const endPoint = this.getGCSCustomEndPoint(stageInfo);\n        let link;\n        if (stageInfo['useVirtualUrl']) {\n            link = `${endPoint}/${fullFilePath}`;\n        }\n        else {\n            link = `${endPoint != null ? endPoint : 'https://storage.googleapis.com'}/${gcsLocation.bucketName}/${fullFilePath}`;\n        }\n        return link.startsWith('https://') ? link : `https://${link}`;\n    };\n    this.getGCSCustomEndPoint = function (stageInfo) {\n        //TODO: SNOW-1789759 hardcoded region will be replaced in the future\n        const isRegionalUrlEnabled = stageInfo.region.toLowerCase() === 'me-central2' || stageInfo.useRegionalUrl;\n        let endPoint = null;\n        if (stageInfo['endPoint']) {\n            endPoint = stageInfo['endPoint'];\n        }\n        else if (stageInfo['useVirtualUrl']) {\n            const bucket = this.extractBucketNameAndPath(stageInfo.location).bucketName;\n            endPoint = `https://${bucket}.storage.googleapis.com`;\n        }\n        else if (isRegionalUrlEnabled) {\n            endPoint = `storage.${stageInfo.region.toLowerCase()}.rep.googleapis.com`;\n        }\n        return endPoint;\n    };\n    this.setupHttpClient = function (endPoint) {\n        if (typeof httpClient === 'undefined') {\n            const proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'GCS Util');\n            //When http_proxy is enabled, the driver should use Axios for HTTPS requests to avoid relying on HTTP_PROXY in GCS.\n            if (proxy || Util.getEnvVar('http_proxy')) {\n                isProxyEnabled = true;\n                const proxyAgent = getProxyAgent({\n                    proxyOptions: proxy,\n                    connectionConfig,\n                    parsedUrl: new URL(connectionConfig.accessUrl),\n                    destination: endPoint || 'storage.googleapis.com',\n                });\n                axios = (__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\").create)({\n                    proxy: false,\n                    httpAgent: proxyAgent,\n                    httpsAgent: proxyAgent,\n                });\n            }\n            else {\n                axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n            }\n        }\n    };\n    this.shouldUseJsonApi = function (meta) {\n        const accessToken = meta['client'].gcsToken;\n        const useVirtualUrl = meta['stageInfo']['useVirtualUrl'];\n        return (!!accessToken &&\n            process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL !== 'true' &&\n            !isProxyEnabled &&\n            !useVirtualUrl);\n    };\n}\nmodule.exports = GCSUtil;\n//# sourceMappingURL=gcs_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2djc191dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsMkJBQTJCLGlKQUE0QztBQUN2RSxtQkFBbUIsZ0hBQWtDO0FBQ3JELHNCQUFzQixtSEFBcUM7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQWU7QUFDekMsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsb0VBQVM7QUFDcEMsZUFBZSwwR0FBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrSEFBb0M7QUFDekQsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDbkQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5QkFBeUIsU0FBUyxHQUFHO0FBQ2hHO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxvREFBb0Q7QUFDcEYsZ0NBQWdDLDZCQUE2QjtBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QixZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxxQkFBcUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw4Q0FBOEM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCLFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0Esa0VBQWtFLFdBQVcsaUJBQWlCLEtBQUs7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixzREFBc0QsWUFBWSxpQkFBaUIsWUFBWSxpQkFBaUIsZ0JBQWdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQixFQUFFLFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsR0FBRyxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQStELEdBQUcsdUJBQXVCLEdBQUcsYUFBYTtBQUMvSDtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0IsMkZBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsNkRBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9nY3NfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IEVuY3J5cHRpb25NZXRhZGF0YSA9IHJlcXVpcmUoJy4vZW5jcnlwdF91dGlsJykuRW5jcnlwdGlvbk1ldGFkYXRhO1xuY29uc3QgRmlsZUhlYWRlciA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLkZpbGVIZWFkZXI7XG5jb25zdCBnZXRQcm94eUFnZW50ID0gcmVxdWlyZSgnLi4vaHR0cC9ub2RlJykuZ2V0UHJveHlBZ2VudDtcbmNvbnN0IFByb3h5VXRpbCA9IHJlcXVpcmUoJy4uL3Byb3h5X3V0aWwnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB7IGxzdHJpcCB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IEdDU19NRVRBREFUQV9QUkVGSVggPSAneC1nb29nLW1ldGEtJztcbmNvbnN0IFNGQ19ESUdFU1QgPSAnc2ZjLWRpZ2VzdCc7XG5jb25zdCBNQVRERVNDX0tFWSA9ICdtYXRkZXNjJztcbmNvbnN0IEVOQ1JZUFRJT05EQVRBUFJPUCA9ICdlbmNyeXB0aW9uZGF0YSc7XG5jb25zdCBHQ1NfTUVUQURBVEFfU0ZDX0RJR0VTVCA9IEdDU19NRVRBREFUQV9QUkVGSVggKyBTRkNfRElHRVNUO1xuY29uc3QgR0NTX01FVEFEQVRBX01BVERFU0NfS0VZID0gR0NTX01FVEFEQVRBX1BSRUZJWCArIE1BVERFU0NfS0VZO1xuY29uc3QgR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUCA9IEdDU19NRVRBREFUQV9QUkVGSVggKyBFTkNSWVBUSU9OREFUQVBST1A7XG5jb25zdCBHQ1NfRklMRV9IRUFERVJfRElHRVNUID0gJ2djcy1maWxlLWhlYWRlci1kaWdlc3QnO1xuY29uc3QgR0NTX0ZJTEVfSEVBREVSX0NPTlRFTlRfTEVOR1RIID0gJ2djcy1maWxlLWhlYWRlci1jb250ZW50LWxlbmd0aCc7XG5jb25zdCBHQ1NfRklMRV9IRUFERVJfRU5DUllQVElPTl9NRVRBREFUQSA9ICdnY3MtZmlsZS1oZWFkZXItZW5jcnlwdGlvbi1tZXRhZGF0YSc7XG5jb25zdCBIVFRQX0hFQURFUl9DT05URU5UX0VOQ09ESU5HID0gJ0NvbnRlbnQtRW5jb2RpbmcnO1xuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuY29uc3QgeyBTdG9yYWdlIH0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL3N0b3JhZ2UnKTtcbmNvbnN0IEVYUElSRURfVE9LRU4gPSAnRXhwaXJlZFRva2VuJztcbmNvbnN0IEVSUk9STk9fV1NBRUNPTk5BQk9SVEVEID0gMTAwNTM7IC8vIG5ldHdvcmsgY29ubmVjdGlvbiB3YXMgYWJvcnRlZFxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBHQ1NMb2NhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJ1Y2tldE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoXG4gKi9cbmZ1bmN0aW9uIEdDU0xvY2F0aW9uKGJ1Y2tldE5hbWUsIHBhdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBidWNrZXROYW1lOiBidWNrZXROYW1lLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gR0NTIHV0aWxpdHkgb2JqZWN0LlxuICogQHBhcmFtIHttb2R1bGV9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7bW9kdWxlfSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge21vZHVsZX0gZmlsZVN0cmVhbVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gR0NTVXRpbChjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50KSB7XG4gICAgbGV0IGF4aW9zID0gaHR0cENsaWVudDtcbiAgICBsZXQgaXNQcm94eUVuYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgR0NTIHRva2VuIGZyb20gdGhlIHN0YWdlIGluZm8gbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhZ2VJbmZvXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKHN0YWdlSW5mbykge1xuICAgICAgICBjb25zdCBzdGFnZUNyZWRlbnRpYWxzID0gc3RhZ2VJbmZvWydjcmVkcyddO1xuICAgICAgICBjb25zdCBnY3NUb2tlbiA9IHN0YWdlQ3JlZGVudGlhbHNbJ0dDU19BQ0NFU1NfVE9LRU4nXTtcbiAgICAgICAgLy9UT0RPOiBTTk9XLTE3ODk3NTkgdGhlIHZhbHVlIGlzIGhhcmRjb2RlZCBub3csIGJ1dCBpdCBzaG91bGQgYmUgc2VydmVyIGRyaXZlblxuICAgICAgICBjb25zdCBlbmRQb2ludCA9IHRoaXMuZ2V0R0NTQ3VzdG9tRW5kUG9pbnQoc3RhZ2VJbmZvKTtcbiAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgaWYgKGdjc1Rva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBbXTtcbiAgICAgICAgICAgIGludGVyY2VwdG9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiAocmVxdWVzdENvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q29uZmlnLmhlYWRlcnMgPSByZXF1ZXN0Q29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVxdWVzdENvbmZpZy5oZWFkZXJzLCB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtnY3NUb2tlbn1gIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdENvbmZpZztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlID0gVXRpbC5leGlzdHMoZW5kUG9pbnQpXG4gICAgICAgICAgICAgICAgPyBuZXcgU3RvcmFnZSh7IGludGVyY2VwdG9yc186IGludGVyY2VwdG9ycywgYXBpRW5kcG9pbnQ6IGVuZFBvaW50IH0pXG4gICAgICAgICAgICAgICAgOiBuZXcgU3RvcmFnZSh7IGludGVyY2VwdG9yc186IGludGVyY2VwdG9ycyB9KTtcbiAgICAgICAgICAgIGNsaWVudCA9IHsgZ2NzVG9rZW46IGdjc1Rva2VuLCBnY3NDbGllbnQ6IHN0b3JhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR1cEh0dHBDbGllbnQoZW5kUG9pbnQpO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgYnVja2V0IG5hbWUgYW5kIHBhdGggZnJvbSB0aGUgbWV0YWRhdGEncyBzdGFnZSBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGFnZUxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7R0NTTG9jYXRpb259XG4gICAgICovXG4gICAgdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGggPSBmdW5jdGlvbiAoc3RhZ2VMb2NhdGlvbikge1xuICAgICAgICBsZXQgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb247XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIC8vIHNwbGl0IHN0YWdlIGxvY2F0aW9uIGFzIGJ1Y2tldCBuYW1lIGFuZCBwYXRoXG4gICAgICAgIGlmIChzdGFnZUxvY2F0aW9uLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lck5hbWUgPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZygwLCBzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICBwYXRoID0gc3RhZ2VMb2NhdGlvbi5zdWJzdHJpbmcoc3RhZ2VMb2NhdGlvbi5pbmRleE9mKCcvJykgKyAxLCBzdGFnZUxvY2F0aW9uLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAocGF0aCAmJiAhcGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdDU0xvY2F0aW9uKGNvbnRhaW5lck5hbWUsIHBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZpbGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgYmVpbmcgdXBsb2FkZWQgb3Igbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRGaWxlSGVhZGVyID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZpbGVuYW1lKSB7XG4gICAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlVQTE9BREVEIHx8XG4gICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQpIHtcbiAgICAgICAgICAgIHJldHVybiBGaWxlSGVhZGVyKG1ldGFbR0NTX0ZJTEVfSEVBREVSX0RJR0VTVF0sIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSwgbWV0YVtHQ1NfRklMRV9IRUFERVJfRU5DUllQVElPTl9NRVRBREFUQV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1ldGFbJ3ByZXNpZ25lZFVybCddKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXhpb3MuZ2V0KG1ldGFbJ3ByZXNpZ25lZFVybCddKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbNDAxLCA0MDMsIDQwNF0uaW5jbHVkZXMoZXJyLnJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmdlbmVyYXRlRmlsZVVSTChtZXRhLnN0YWdlSW5mbywgbHN0cmlwKGZpbGVuYW1lLCAnLycpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IG1ldGFbJ2NsaWVudCddLmdjc1Rva2VuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdjc0hlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH07XG4gICAgICAgICAgICAgICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgZGlnZXN0O1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBlbmNyeXB0aW9uRGF0YVByb3A7XG4gICAgICAgICAgICAgICAgbGV0IG1hdERlc2NLZXk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlSnNvbkFwaShtZXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2NzTG9jYXRpb24gPSB0aGlzLmV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFbJ2NsaWVudCddLmdjc0NsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5idWNrZXQoZ2NzTG9jYXRpb24uYnVja2V0TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsZShnY3NMb2NhdGlvbi5wYXRoICsgZmlsZW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdlc3QgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtTRkNfRElHRVNUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBtZXRhZGF0YVswXS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGlvbkRhdGFQcm9wID0gbWV0YWRhdGFbMF0ubWV0YWRhdGFbRU5DUllQVElPTkRBVEFQUk9QXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdERlc2NLZXkgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtNQVRERVNDX0tFWV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmhlYWQodXJsLCB7IGhlYWRlcnM6IGdjc0hlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdlc3QgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9TRkNfRElHRVNUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGlvbkRhdGFQcm9wID0gcmVzcG9uc2UuaGVhZGVyc1tHQ1NfTUVUQURBVEFfRU5DUllQVElPTkRBVEFQUk9QXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdERlc2NLZXkgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9NQVRERVNDX0tFWV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuY3J5cHRpb25EYXRhUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jcnlwdGlvbkRhdGEgPSBKU09OLnBhcnNlKGVuY3J5cHRpb25EYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5jcnlwdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSBFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbkRhdGFbJ1dyYXBwZWRDb250ZW50S2V5J11bJ0VuY3J5cHRlZEtleSddLCBlbmNyeXB0aW9uRGF0YVsnQ29udGVudEVuY3J5cHRpb25JViddLCBtYXREZXNjS2V5ID8gbWF0RGVzY0tleSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlVQTE9BREVEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmlsZUhlYWRlcihkaWdlc3QsIGNvbnRlbnRMZW5ndGgsIGVuY3J5cHRpb25NZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyQ29kZSA9ICFpc05hTihlcnJbJ2NvZGUnXSkgJiYgIWlzTmFOKHBhcnNlSW50KGVyclsnY29kZSddKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyWydjb2RlJ11cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZXJyLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKFs0MDMsIDQwOCwgNDI5LCA1MDAsIDUwM10uaW5jbHVkZXMoZXJyQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5OT1RfRk9VTkRfRklMRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaWxlSGVhZGVyKG51bGwsIG51bGwsIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBmaWxlIG1ldGFkYXRhIHRoZW4gdXBsb2FkIHRoZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5jcnlwdGlvbk1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heENvbmN1cnJlbmN5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZEZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZGF0YUZpbGUsIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSwgbWF4Q29uY3VycmVuY3kpIHtcbiAgICAgICAgY29uc3QgZmlsZVN0cmVhbSA9IGZzLnJlYWRGaWxlU3luYyhkYXRhRmlsZSk7XG4gICAgICAgIGF3YWl0IHRoaXMudXBsb2FkRmlsZVN0cmVhbShmaWxlU3RyZWFtLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEsIG1heENvbmN1cnJlbmN5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZVN0cmVhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGxvYWRGaWxlU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgICBsZXQgdXBsb2FkVXJsID0gbWV0YVsncHJlc2lnbmVkVXJsJ107XG4gICAgICAgIGxldCBhY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIGlmICghdXBsb2FkVXJsKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wRmlsZW5hbWUgPSBtZXRhWydkc3RGaWxlTmFtZSddLnN1YnN0cmluZyhtZXRhWydkc3RGaWxlTmFtZSddLmluZGV4T2YoJy8nKSArIDEsIG1ldGFbJ2RzdEZpbGVOYW1lJ10ubGVuZ3RoKTtcbiAgICAgICAgICAgIHVwbG9hZFVybCA9IHRoaXMuZ2VuZXJhdGVGaWxlVVJMKG1ldGEuc3RhZ2VJbmZvLCB0ZW1wRmlsZW5hbWUpO1xuICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBtZXRhWydjbGllbnQnXS5nY3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudEVuY29kaW5nID0gJyc7XG4gICAgICAgIGlmIChtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSkge1xuICAgICAgICAgICAgY29udGVudEVuY29kaW5nID0gbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ11bJ25hbWUnXTtcbiAgICAgICAgICAgIGNvbnRlbnRFbmNvZGluZyA9IGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHNldCB0aGUgY29udGVudEVuY29kaW5nIHRvIGJsYW5rIGZvciB0aGUgZm9sbG93aW5nIGZpbGUgdHlwZXNcbiAgICAgICAgaWYgKFsnZ3ppcCcsICdiemlwMicsICdicm90bGknLCAnZGVmbGF0ZScsICdyYXdfZGVmbGF0ZScsICd6c3RkJ10uaW5jbHVkZXMoY29udGVudEVuY29kaW5nKSkge1xuICAgICAgICAgICAgY29udGVudEVuY29kaW5nID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2NzSGVhZGVycyA9IHtcbiAgICAgICAgICAgIFtIVFRQX0hFQURFUl9DT05URU5UX0VOQ09ESU5HXTogY29udGVudEVuY29kaW5nLFxuICAgICAgICAgICAgW0dDU19NRVRBREFUQV9TRkNfRElHRVNUXTogbWV0YVsnU0hBMjU2X0RJR0VTVCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIGdjc0hlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNyeXB0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUF0gPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgRW5jcnlwdGlvbk1vZGU6ICdGdWxsQmxvYicsXG4gICAgICAgICAgICAgICAgV3JhcHBlZENvbnRlbnRLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgS2V5SWQ6ICdzeW1tS2V5MScsXG4gICAgICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleTogZW5jcnlwdGlvbk1ldGFkYXRhLmtleSxcbiAgICAgICAgICAgICAgICAgICAgQWxnb3JpdGhtOiAnQUVTX0NCQ18yNTYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgRW5jcnlwdGlvbkFnZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIFByb3RvY29sOiAnMS4wJyxcbiAgICAgICAgICAgICAgICAgICAgRW5jcnlwdGlvbkFsZ29yaXRobTogJ0FFU19DQkNfMjU2JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENvbnRlbnRFbmNyeXB0aW9uSVY6IGVuY3J5cHRpb25NZXRhZGF0YS5pdixcbiAgICAgICAgICAgICAgICBLZXlXcmFwcGluZ01ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIEVuY3J5cHRpb25MaWJyYXJ5OiAnSmF2YSA1LjMuMCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfTUFUREVTQ19LRVldID0gZW5jcnlwdGlvbk1ldGFkYXRhLm1hdERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFVzZUpzb25BcGkobWV0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnY3NMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZXRhWydjbGllbnQnXS5nY3NDbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLmJ1Y2tldChnY3NMb2NhdGlvbi5idWNrZXROYW1lKVxuICAgICAgICAgICAgICAgICAgICAuZmlsZShnY3NMb2NhdGlvbi5wYXRoICsgbWV0YVsnZHN0RmlsZU5hbWUnXSlcbiAgICAgICAgICAgICAgICAgICAgLnNhdmUoZmlsZVN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICByZXN1bWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbRU5DUllQVElPTkRBVEFQUk9QXTogZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfRU5DUllQVElPTkRBVEFQUk9QXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTUFUREVTQ19LRVldOiBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9NQVRERVNDX0tFWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1NGQ19ESUdFU1RdOiBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9TRkNfRElHRVNUXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbWF4Qm9keUxlbmd0aCB0byBhbGxvdyBsYXJnZSBmaWxlIHVwbG9hZGluZ1xuICAgICAgICAgICAgICAgIGF3YWl0IGF4aW9zLnB1dCh1cGxvYWRVcmwsIGZpbGVTdHJlYW0sIHsgbWF4Qm9keUxlbmd0aDogSW5maW5pdHksIGhlYWRlcnM6IGdjc0hlYWRlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKFs0MDMsIDQwOCwgNDI5LCA1MDAsIDUwM10uaW5jbHVkZXMoZXJyWydjb2RlJ10pKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFhY2Nlc3NUb2tlbiAmJlxuICAgICAgICAgICAgICAgIGVyclsnY29kZSddID09PSA0MDAgJiZcbiAgICAgICAgICAgICAgICAoIW1ldGFbJ2xhc3RFcnJvciddIHx8IG1ldGFbJ2xhc3RFcnJvciddWydjb2RlJ10gIT09IDQwMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGF0dGVtcHQgdG8gcmVuZXcgdXJscyBpZiB0aGlzIGlzbid0IHRoZSBzZWNvbmQgdGltZSB0aGlzIGhhcHBlbnNcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXNzVG9rZW4gJiYgZXJyWydjb2RlJ10gPT09IDQwMSkge1xuICAgICAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSBtZXRhWyd1cGxvYWRTaXplJ107XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlVQTE9BREVEO1xuICAgICAgICBtZXRhW0dDU19GSUxFX0hFQURFUl9ESUdFU1RdID0gZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfU0ZDX0RJR0VTVF07XG4gICAgICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IG1ldGFbJ3VwbG9hZFNpemUnXTtcbiAgICAgICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfRU5DUllQVElPTl9NRVRBREFUQV0gPSBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9FTkNSWVBUSU9OREFUQVBST1BdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSBmdWxsRHN0UGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy5uYXRpdmVEb3dubG9hZEZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YSwgZnVsbERzdFBhdGgpIHtcbiAgICAgICAgbGV0IGRvd25sb2FkVXJsID0gbWV0YVsncHJlc2lnbmVkVXJsJ107XG4gICAgICAgIGxldCBhY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIGxldCBnY3NIZWFkZXJzID0ge307XG4gICAgICAgIGlmICghZG93bmxvYWRVcmwpIHtcbiAgICAgICAgICAgIGRvd25sb2FkVXJsID0gdGhpcy5nZW5lcmF0ZUZpbGVVUkwobWV0YS5zdGFnZUluZm8sIGxzdHJpcChtZXRhWydzcmNGaWxlTmFtZSddLCAnLycpKTtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gbWV0YVsnY2xpZW50J10uZ2NzVG9rZW47XG4gICAgICAgICAgICBnY3NIZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmNyeXB0aW9uRGF0YXByb3A7XG4gICAgICAgIGxldCBtYXREZXNjS2V5O1xuICAgICAgICBsZXQgc2ZjRGlnZXN0O1xuICAgICAgICBsZXQgc2l6ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFVzZUpzb25BcGkobWV0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJ1Y2tldE5hbWUsIHBhdGggfSA9IHRoaXMuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgVXNlIEdDUCBjbGllbnQgdG8gZG93bmxvYWQgdGhlIGZpbGUuYCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFNlbmQgR2V0IFJlcXVlc3QgdG8gdGhlIEJ1Y2tldDogJHtidWNrZXROYW1lfSwgR0VUIHJlcXVlc3Q6ICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZXRhWydjbGllbnQnXS5nY3NDbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLmJ1Y2tldChidWNrZXROYW1lKVxuICAgICAgICAgICAgICAgICAgICAuZmlsZShwYXRoICsgbWV0YVsnc3JjRmlsZU5hbWUnXSlcbiAgICAgICAgICAgICAgICAgICAgLmRvd25sb2FkKHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IGZ1bGxEc3RQYXRoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgbWV0YVsnY2xpZW50J10uZ2NzQ2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC5idWNrZXQoYnVja2V0TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbGUocGF0aCArIG1ldGFbJ3NyY0ZpbGVOYW1lJ10pXG4gICAgICAgICAgICAgICAgICAgIC5nZXRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgICAgIGVuY3J5cHRpb25EYXRhcHJvcCA9IG1ldGFkYXRhWzBdLm1ldGFkYXRhW0VOQ1JZUFRJT05EQVRBUFJPUF07XG4gICAgICAgICAgICAgICAgbWF0RGVzY0tleSA9IG1ldGFkYXRhWzBdLm1ldGFkYXRhW01BVERFU0NfS0VZXTtcbiAgICAgICAgICAgICAgICBzZmNEaWdlc3QgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtTRkNfRElHRVNUXTtcbiAgICAgICAgICAgICAgICBzaXplID0gbWV0YWRhdGFbMF0uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBEb3dubG9hZGluZyBmaWxlIGZyb20gR0NTIHVzaW5nIEF4aW9zYCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGF3YWl0IGF4aW9zXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoZG93bmxvYWRVcmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZ2NzSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnc3RyZWFtJyxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmdWxsRHN0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLnBpcGUod3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBTZW50IEdldCBSZXF1ZXN0IHRvICR7ZG93bmxvYWRVcmx9LCBkZXN0aW5hdGlvbjogJHtmdWxsRHN0UGF0aH0sIGh0dHAgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICBlbmNyeXB0aW9uRGF0YXByb3AgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9FTkNSWVBUSU9OREFUQVBST1BdO1xuICAgICAgICAgICAgICAgIG1hdERlc2NLZXkgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9NQVRERVNDX0tFWV07XG4gICAgICAgICAgICAgICAgc2ZjRGlnZXN0ID0gcmVzcG9uc2UuaGVhZGVyc1tHQ1NfTUVUQURBVEFfU0ZDX0RJR0VTVF07XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnY29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyWydjb2RlJ10gPT09IEVSUk9STk9fV1NBRUNPTk5BQk9SVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUllfV0lUSF9MT1dFUl9DT05DVVJSRU5DWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUlk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmNyeXB0aW9uRGF0YTtcbiAgICAgICAgaWYgKGVuY3J5cHRpb25EYXRhcHJvcCkge1xuICAgICAgICAgICAgZW5jcnlwdGlvbkRhdGEgPSBKU09OLnBhcnNlKGVuY3J5cHRpb25EYXRhcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgaWYgKGVuY3J5cHRpb25EYXRhKSB7XG4gICAgICAgICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSBFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbkRhdGFbJ1dyYXBwZWRDb250ZW50S2V5J11bJ0VuY3J5cHRlZEtleSddLCBlbmNyeXB0aW9uRGF0YVsnQ29udGVudEVuY3J5cHRpb25JViddLCBtYXREZXNjS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlSW5mbyA9IGZzLnN0YXRTeW5jKGZ1bGxEc3RQYXRoKTtcbiAgICAgICAgbWV0YVsnc3JjRmlsZVNpemUnXSA9IGZpbGVJbmZvLnNpemU7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG4gICAgICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0RJR0VTVF0gPSBzZmNEaWdlc3Q7XG4gICAgICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IHNpemU7XG4gICAgICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0VOQ1JZUFRJT05fTUVUQURBVEFdID0gZW5jcnlwdGlvbk1ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZmlsZSBVUkwgYmFzZWQgb24gYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWdlSW5mb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdlbmVyYXRlRmlsZVVSTCA9IGZ1bmN0aW9uIChzdGFnZUluZm8sIGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IGdjc0xvY2F0aW9uID0gdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgoc3RhZ2VJbmZvLmxvY2F0aW9uKTtcbiAgICAgICAgY29uc3QgZnVsbEZpbGVQYXRoID0gYCR7Z2NzTG9jYXRpb24ucGF0aH0ke2ZpbGVuYW1lfWA7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gdGhpcy5nZXRHQ1NDdXN0b21FbmRQb2ludChzdGFnZUluZm8pO1xuICAgICAgICBsZXQgbGluaztcbiAgICAgICAgaWYgKHN0YWdlSW5mb1sndXNlVmlydHVhbFVybCddKSB7XG4gICAgICAgICAgICBsaW5rID0gYCR7ZW5kUG9pbnR9LyR7ZnVsbEZpbGVQYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5rID0gYCR7ZW5kUG9pbnQgIT0gbnVsbCA/IGVuZFBvaW50IDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbSd9LyR7Z2NzTG9jYXRpb24uYnVja2V0TmFtZX0vJHtmdWxsRmlsZVBhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluay5zdGFydHNXaXRoKCdodHRwczovLycpID8gbGluayA6IGBodHRwczovLyR7bGlua31gO1xuICAgIH07XG4gICAgdGhpcy5nZXRHQ1NDdXN0b21FbmRQb2ludCA9IGZ1bmN0aW9uIChzdGFnZUluZm8pIHtcbiAgICAgICAgLy9UT0RPOiBTTk9XLTE3ODk3NTkgaGFyZGNvZGVkIHJlZ2lvbiB3aWxsIGJlIHJlcGxhY2VkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgY29uc3QgaXNSZWdpb25hbFVybEVuYWJsZWQgPSBzdGFnZUluZm8ucmVnaW9uLnRvTG93ZXJDYXNlKCkgPT09ICdtZS1jZW50cmFsMicgfHwgc3RhZ2VJbmZvLnVzZVJlZ2lvbmFsVXJsO1xuICAgICAgICBsZXQgZW5kUG9pbnQgPSBudWxsO1xuICAgICAgICBpZiAoc3RhZ2VJbmZvWydlbmRQb2ludCddKSB7XG4gICAgICAgICAgICBlbmRQb2ludCA9IHN0YWdlSW5mb1snZW5kUG9pbnQnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFnZUluZm9bJ3VzZVZpcnR1YWxVcmwnXSkge1xuICAgICAgICAgICAgY29uc3QgYnVja2V0ID0gdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgoc3RhZ2VJbmZvLmxvY2F0aW9uKS5idWNrZXROYW1lO1xuICAgICAgICAgICAgZW5kUG9pbnQgPSBgaHR0cHM6Ly8ke2J1Y2tldH0uc3RvcmFnZS5nb29nbGVhcGlzLmNvbWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdpb25hbFVybEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGVuZFBvaW50ID0gYHN0b3JhZ2UuJHtzdGFnZUluZm8ucmVnaW9uLnRvTG93ZXJDYXNlKCl9LnJlcC5nb29nbGVhcGlzLmNvbWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZFBvaW50O1xuICAgIH07XG4gICAgdGhpcy5zZXR1cEh0dHBDbGllbnQgPSBmdW5jdGlvbiAoZW5kUG9pbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBodHRwQ2xpZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgcHJveHkgPSBQcm94eVV0aWwuZ2V0UHJveHkoY29ubmVjdGlvbkNvbmZpZy5nZXRQcm94eSgpLCAnR0NTIFV0aWwnKTtcbiAgICAgICAgICAgIC8vV2hlbiBodHRwX3Byb3h5IGlzIGVuYWJsZWQsIHRoZSBkcml2ZXIgc2hvdWxkIHVzZSBBeGlvcyBmb3IgSFRUUFMgcmVxdWVzdHMgdG8gYXZvaWQgcmVseWluZyBvbiBIVFRQX1BST1hZIGluIEdDUy5cbiAgICAgICAgICAgIGlmIChwcm94eSB8fCBVdGlsLmdldEVudlZhcignaHR0cF9wcm94eScpKSB7XG4gICAgICAgICAgICAgICAgaXNQcm94eUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5QWdlbnQgPSBnZXRQcm94eUFnZW50KHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlPcHRpb25zOiBwcm94eSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkVXJsOiBuZXcgVVJMKGNvbm5lY3Rpb25Db25maWcuYWNjZXNzVXJsKSxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IGVuZFBvaW50IHx8ICdzdG9yYWdlLmdvb2dsZWFwaXMuY29tJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJykuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBodHRwQWdlbnQ6IHByb3h5QWdlbnQsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBzQWdlbnQ6IHByb3h5QWdlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2hvdWxkVXNlSnNvbkFwaSA9IGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gbWV0YVsnY2xpZW50J10uZ2NzVG9rZW47XG4gICAgICAgIGNvbnN0IHVzZVZpcnR1YWxVcmwgPSBtZXRhWydzdGFnZUluZm8nXVsndXNlVmlydHVhbFVybCddO1xuICAgICAgICByZXR1cm4gKCEhYWNjZXNzVG9rZW4gJiZcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LlNOT1dGTEFLRV9GT1JDRV9HQ1BfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTCAhPT0gJ3RydWUnICYmXG4gICAgICAgICAgICAhaXNQcm94eUVuYWJsZWQgJiZcbiAgICAgICAgICAgICF1c2VWaXJ0dWFsVXJsKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBHQ1NVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2NzX3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\n/**\n * Creates a local utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction LocalUtil() {\n    this.createClient = function () {\n        return null;\n    };\n    /**\n     * Write file to upload.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFileWithRetry = async function (meta) {\n        await new Promise(function (resolve) {\n            // Create stream object for reader and writer\n            const reader = fs.createReadStream(meta['realSrcFilePath']);\n            // Create directory if doesn't exist\n            if (!fs.existsSync(meta['stageInfo']['location'])) {\n                fs.mkdirSync(meta['stageInfo']['location'], { recursive: true });\n            }\n            let output = path.join(meta['stageInfo']['location'], meta['dstFileName']);\n            // expand '~' and '~user' expressions\n            if (process.platform !== 'win32') {\n                output = expandTilde(output);\n            }\n            const writer = fs.createWriteStream(output);\n            // Write file\n            const result = reader.pipe(writer);\n            result.on('finish', function () {\n                resolve();\n            });\n        });\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n    };\n    /**\n     * Write file to download.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.downloadOneFile = async function (meta) {\n        let output;\n        await new Promise(function (resolve) {\n            const srcFilePath = expandTilde(meta['stageInfo']['location']);\n            // Create stream object for reader and writer\n            const realSrcFilePath = path.join(srcFilePath, meta['srcFileName']);\n            const reader = fs.createReadStream(realSrcFilePath);\n            // Create directory if doesn't exist\n            if (!fs.existsSync(meta['localLocation'])) {\n                fs.mkdirSync(meta['localLocation'], { recursive: true });\n            }\n            output = path.join(meta['localLocation'], meta['dstFileName']);\n            const writer = fs.createWriteStream(output);\n            // Write file\n            const result = reader.pipe(writer);\n            result.on('finish', function () {\n                resolve();\n            });\n        });\n        const fileStat = fs.statSync(output);\n        meta['dstFileSize'] = fileStat.size;\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n    };\n}\nexports.LocalUtil = LocalUtil;\n//# sourceMappingURL=local_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2xvY2FsX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWM7QUFDMUMscUJBQXFCLGtIQUFvQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2xvY2FsX3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZXhwYW5kVGlsZGUgPSByZXF1aXJlKCdleHBhbmQtdGlsZGUnKTtcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLnJlc3VsdFN0YXR1cztcbi8qKlxuICogQ3JlYXRlcyBhIGxvY2FsIHV0aWxpdHkgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9jYWxVdGlsKCkge1xuICAgIHRoaXMuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlIGZpbGUgdG8gdXBsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkT25lRmlsZVdpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIG9iamVjdCBmb3IgcmVhZGVyIGFuZCB3cml0ZXJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0obWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10pO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pKSB7XG4gICAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBwYXRoLmpvaW4obWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10sIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuICAgICAgICAgICAgLy8gZXhwYW5kICd+JyBhbmQgJ351c2VyJyBleHByZXNzaW9uc1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBleHBhbmRUaWxkZShvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0KTtcbiAgICAgICAgICAgIC8vIFdyaXRlIGZpbGVcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRlci5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICByZXN1bHQub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSBtZXRhWyd1cGxvYWRTaXplJ107XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlVQTE9BREVEO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgZmlsZSB0byBkb3dubG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRvd25sb2FkT25lRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBjb25zdCBzcmNGaWxlUGF0aCA9IGV4cGFuZFRpbGRlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzdHJlYW0gb2JqZWN0IGZvciByZWFkZXIgYW5kIHdyaXRlclxuICAgICAgICAgICAgY29uc3QgcmVhbFNyY0ZpbGVQYXRoID0gcGF0aC5qb2luKHNyY0ZpbGVQYXRoLCBtZXRhWydzcmNGaWxlTmFtZSddKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocmVhbFNyY0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG1ldGFbJ2xvY2FsTG9jYXRpb24nXSkpIHtcbiAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMobWV0YVsnbG9jYWxMb2NhdGlvbiddLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IHBhdGguam9pbihtZXRhWydsb2NhbExvY2F0aW9uJ10sIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0KTtcbiAgICAgICAgICAgIC8vIFdyaXRlIGZpbGVcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRlci5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICByZXN1bHQub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gZnMuc3RhdFN5bmMob3V0cHV0KTtcbiAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IGZpbGVTdGF0LnNpemU7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuTG9jYWxVdGlsID0gTG9jYWxVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/local_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst SnowflakeS3Util = (__webpack_require__(/*! ./s3_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js\").S3Util);\nconst SnowflakeAzureUtil = __webpack_require__(/*! ./azure_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/azure_util.js\");\nconst SnowflakeGCSUtil = __webpack_require__(/*! ./gcs_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/gcs_util.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\nconst SnowflakeEncryptionUtil = new ((__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptUtil))();\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst DEFAULT_CONCURRENCY = 1;\nconst DEFAULT_MAX_RETRY = 5;\n// File Encryption Material\nfunction SnowflakeFileEncryptionMaterial(key, qid, smkid) {\n    const smkidString = '' + smkid;\n    return {\n        queryStageMasterKey: key, // query stage master key\n        queryId: qid, // query id\n        smkId: smkidString, // SMK id\n    };\n}\nexports.SnowflakeFileEncryptionMaterial = SnowflakeFileEncryptionMaterial;\n/**\n * Creates a remote storage utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction RemoteStorageUtil(connectionConfig) {\n    let client = null;\n    /**\n     * Get storage type based on location type.\n     *\n     * @param {String} type\n     *\n     * @returns {Object}\n     */\n    this.getForStorageType = function (type) {\n        if (client) {\n            return client;\n        }\n        if (type === 'S3') {\n            client = new SnowflakeS3Util(connectionConfig);\n        }\n        else if (type === 'AZURE') {\n            client = new SnowflakeAzureUtil(connectionConfig);\n        }\n        else if (type === 'GCS') {\n            client = new SnowflakeGCSUtil(connectionConfig);\n        }\n        return client;\n    };\n    /**\n     * Create the client based on the location type.\n     */\n    this.createClient = function (stageInfo, useAccelerateEndpoint = false) {\n        const utilClass = this.getForStorageType(stageInfo['locationType']);\n        return utilClass.createClient(stageInfo, useAccelerateEndpoint);\n    };\n    /**\n     * Encrypt then upload one file stream.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFileStream = async function (meta) {\n        let encryptionMetadata;\n        let dataFileStream = meta['fileStream'];\n        if (meta['encryptionMaterial']) {\n            const result = await SnowflakeEncryptionUtil.encryptFileStream(meta['encryptionMaterial'], meta['fileStream']);\n            encryptionMetadata = result.encryptionMetadata;\n            dataFileStream = result.dataStream;\n        }\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let maxConcurrency = meta['parallel'];\n        let lastErr;\n        const maxRetry = DEFAULT_MAX_RETRY;\n        for (let retry = 0; retry < maxRetry; retry++) {\n            if (!meta['overwrite']) {\n                const fileHeader = await utilClass.getFileHeader(meta, meta['dstFileName']);\n                if (fileHeader && meta['resultStatus'] === resultStatus.UPLOADED) {\n                    // File already exists\n                    meta['dstFileSize'] = 0;\n                    meta['resultStatus'] = resultStatus.SKIPPED;\n                    return;\n                }\n            }\n            if (meta['overwrite'] || meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n                await utilClass.uploadFileStream(dataFileStream, meta, encryptionMetadata, maxConcurrency);\n            }\n            if (meta['resultStatus'] === resultStatus.UPLOADED) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying with max concurrency\n                maxConcurrency = meta['parallel'] - parseInt((retry * meta['parallel']) / maxRetry);\n                maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n                meta['lastMaxConcurrency'] = maxConcurrency;\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n        }\n        if (lastErr) {\n            throw new Error(lastErr);\n        }\n        else {\n            const msg = 'Unknown Error in uploading a file: ' + meta['srcFileName'];\n            throw new Error(msg);\n        }\n    };\n    /**\n     * Encrypt then upload one file.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFile = async function (meta) {\n        let encryptionMetadata;\n        let dataFile;\n        if (meta['encryptionMaterial']) {\n            const result = await SnowflakeEncryptionUtil.encryptFile(meta['encryptionMaterial'], meta['realSrcFilePath'], meta['tmpDir']);\n            encryptionMetadata = result.encryptionMetadata;\n            dataFile = result.dataFile;\n        }\n        else {\n            dataFile = meta['realSrcFilePath'];\n        }\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let maxConcurrency = meta['parallel'];\n        let lastErr;\n        const maxRetry = DEFAULT_MAX_RETRY;\n        for (let retry = 0; retry < maxRetry; retry++) {\n            if (!meta['overwrite']) {\n                const fileHeader = await utilClass.getFileHeader(meta, meta['dstFileName']);\n                if (fileHeader && meta['resultStatus'] === resultStatus.UPLOADED) {\n                    // File already exists\n                    meta['dstFileSize'] = 0;\n                    meta['resultStatus'] = resultStatus.SKIPPED;\n                    return;\n                }\n            }\n            if (meta['overwrite'] || meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n                await utilClass.uploadFile(dataFile, meta, encryptionMetadata, maxConcurrency);\n            }\n            if (meta['resultStatus'] === resultStatus.UPLOADED) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n                lastErr = meta['lastError'];\n                // Failed to upload file, retrying with max concurrency\n                maxConcurrency = meta['parallel'] - parseInt((retry * meta['parallel']) / maxRetry);\n                maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n                meta['lastMaxConcurrency'] = maxConcurrency;\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n        }\n        if (lastErr) {\n            throw new Error(lastErr);\n        }\n        else {\n            const msg = 'Unknown Error in uploading a file: ' + dataFile;\n            throw new Error(msg);\n        }\n    };\n    /**\n     * Attempt upload of a file and retry if fails.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.uploadOneFileWithRetry = async function (meta) {\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let breakFlag = false;\n        for (let x = 0; x < 10; x++) {\n            await this.uploadOneFile(meta);\n            if (meta['resultStatus'] === resultStatus.UPLOADED) {\n                for (let y = 0; y < 10; y++) {\n                    await utilClass.getFileHeader(meta, meta['dstFileName']);\n                    if (meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n                        // Wait 1 second\n                        await new Promise((resolve) => setTimeout(resolve, 1000));\n                        continue;\n                    }\n                    break;\n                }\n            }\n            breakFlag = true;\n            break;\n        }\n        if (!breakFlag) {\n            // Could not upload a file even after retry\n            meta['resultStatus'] = resultStatus.ERROR;\n        }\n    };\n    /**\n     * Download a file.\n     *\n     * @param {Object} meta\n     *\n     * @returns {null}\n     */\n    this.downloadOneFile = async function (meta) {\n        // Downloads a file from S3\n        let fullDstPath = meta['localLocation'];\n        await new Promise((resolve, reject) => {\n            fs.realpath(fullDstPath, (err, basePath) => {\n                if (err) {\n                    reject(err);\n                }\n                fullDstPath = path.join(basePath, path.basename(meta['dstFileName']));\n                resolve();\n            });\n        });\n        // TODO: validate fullDstPath is under the writable directory\n        const baseDir = path.dirname(fullDstPath);\n        await new Promise((resolve) => {\n            fs.exists(baseDir, (exists) => {\n                if (!exists) {\n                    fs.mkdir(baseDir, () => {\n                        resolve();\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n        let fileHeader = await utilClass.getFileHeader(meta, meta['srcFileName']);\n        if (fileHeader) {\n            meta['srcFileSize'] = fileHeader.contentLength;\n        }\n        let maxConcurrency = meta['parallel'];\n        let lastErr;\n        const maxRetry = DEFAULT_MAX_RETRY;\n        Logger().debug(`Started downloading result. File: ${meta.dstFileName}, location: ${meta.stageInfo.location}`);\n        const timer = new ExecutionTimer().start();\n        for (let retry = 0; retry < maxRetry; retry++) {\n            // Download the file\n            await utilClass.nativeDownloadFile(meta, fullDstPath, maxConcurrency);\n            if (meta['resultStatus'] === resultStatus.DOWNLOADED) {\n                timer.stop();\n                Logger().debug(`Successfully downloaded result. File: ${meta.dstFileName}, download time: ${timer.getDuration()} ms, chunkSize: ${meta.srcFileSize} bytes.`);\n                if (meta['encryptionMaterial']) {\n                    /**\n                     * For storage utils that do not have the privilege of\n                     * getting the metadata early, both object and metadata\n                     * are downloaded at once.In which case, the file meta will\n                     * be updated with all the metadata that we need and\n                     * then we can call getFileHeader to get just that and also\n                     * preserve the idea of getting metadata in the first place.\n                     * One example of this is the utils that use presigned url\n                     * for upload / download and not the storage client library.\n                     **/\n                    if (meta['presignedUrl']) {\n                        fileHeader = await utilClass.getFileHeader(meta, meta['srcFilePath']);\n                    }\n                    Logger().debug(`Start decrypting the downloaded file for ${meta.dstFileName} at path: ${fullDstPath}.`);\n                    timer.start();\n                    const tmpDstName = await SnowflakeEncryptionUtil.decryptFile(fileHeader.encryptionMetadata, meta['encryptionMaterial'], fullDstPath, meta['tmpDir']);\n                    timer.stop();\n                    Logger().debug(`Successfully decrypted the downloaded file for ${meta.dstFileName} in ${timer.getDuration()} ms.`);\n                    // Copy decrypted tmp file to target destination path\n                    await new Promise((resolve, reject) => {\n                        fs.copyFile(tmpDstName, fullDstPath, async (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            resolve();\n                        });\n                    });\n                    // Delete tmp file\n                    await new Promise((resolve, reject) => {\n                        fs.unlink(tmpDstName, (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            resolve();\n                        });\n                    });\n                    // Delete tmp folder\n                    await new Promise((resolve, reject) => {\n                        fs.rmdir(meta['tmpDir'], (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            resolve();\n                        });\n                    });\n                }\n                await new Promise((resolve) => {\n                    fs.stat(fullDstPath, (err, stat) => {\n                        meta['dstFileSize'] = stat.size;\n                        Logger().debug(`File size verification: Downloaded file at \"${meta.fullDstPath}\" is ${stat.size} bytes.`);\n                        resolve();\n                    });\n                });\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n                Logger().debug(`Need to renew token for downloading file: ${meta.dstFileName}`);\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n                Logger().debug(`Need to renew presigned URL for downloading. file: ${meta.dstFileName}, presignedUrl: ${meta.presignedUrl}`);\n                return;\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n                Logger().debug(`Need to retry with lower concurrency for downloading file: ${meta.dstFileName}`);\n                lastErr = meta['lastError'];\n                // Failed to download file, retrying with max concurrency\n                maxConcurrency = meta['parallel'] - parseInt((retry * meta['parallel']) / maxRetry);\n                maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n                meta['lastMaxConcurrency'] = maxConcurrency;\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n            else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n                Logger().debug(`Need to retry for downloading file: ${meta.dstFileName}`);\n                lastErr = meta['lastError'];\n                // Failed to download file, retrying\n                if (!meta['noSleepingTime']) {\n                    const sleepingTime = Math.min(Math.pow(2, retry), 16);\n                    await new Promise((resolve) => setTimeout(resolve, sleepingTime));\n                }\n            }\n        }\n        if (lastErr) {\n            Logger().error(`Failed to downloading file: ${meta.dstFileName} with error: ${lastErr}`);\n            throw new Error(lastErr);\n        }\n        else {\n            const msg = 'Unknown Error in downloading a file: ' + meta['srcFileName'];\n            throw new Error(msg);\n        }\n    };\n}\nexports.RemoteStorageUtil = RemoteStorageUtil;\n//# sourceMappingURL=remote_storage_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L3JlbW90ZV9zdG9yYWdlX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isd0JBQXdCLDJIQUEyQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyxtR0FBYztBQUNqRCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBWTtBQUM3Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDMUQscUNBQXFDLDBJQUFxQztBQUMxRSxxQkFBcUIsa0hBQW9DO0FBQ3pELGVBQWUsMEdBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQixjQUFjLHdCQUF3QjtBQUNuSDtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCLG1CQUFtQixxQkFBcUIsaUJBQWlCLGtCQUFrQjtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGtCQUFrQixXQUFXLFlBQVk7QUFDeEg7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGtCQUFrQixLQUFLLHFCQUFxQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpQkFBaUIsT0FBTyxXQUFXO0FBQ3pIO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsaUJBQWlCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixpQkFBaUIsa0JBQWtCLGtCQUFrQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsaUJBQWlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0IsY0FBYyxRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvcmVtb3RlX3N0b3JhZ2VfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBTbm93Zmxha2VTM1V0aWwgPSByZXF1aXJlKCcuL3MzX3V0aWwnKS5TM1V0aWw7XG5jb25zdCBTbm93Zmxha2VBenVyZVV0aWwgPSByZXF1aXJlKCcuL2F6dXJlX3V0aWwnKTtcbmNvbnN0IFNub3dmbGFrZUdDU1V0aWwgPSByZXF1aXJlKCcuL2djc191dGlsJyk7XG5jb25zdCBFeGVjdXRpb25UaW1lciA9IHJlcXVpcmUoJy4uL2xvZ2dlci9leGVjdXRpb25fdGltZXInKTtcbmNvbnN0IFNub3dmbGFrZUVuY3J5cHRpb25VdGlsID0gbmV3IChyZXF1aXJlKCcuL2VuY3J5cHRfdXRpbCcpLkVuY3J5cHRVdGlsKSgpO1xuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJykuZGVmYXVsdDtcbmNvbnN0IERFRkFVTFRfQ09OQ1VSUkVOQ1kgPSAxO1xuY29uc3QgREVGQVVMVF9NQVhfUkVUUlkgPSA1O1xuLy8gRmlsZSBFbmNyeXB0aW9uIE1hdGVyaWFsXG5mdW5jdGlvbiBTbm93Zmxha2VGaWxlRW5jcnlwdGlvbk1hdGVyaWFsKGtleSwgcWlkLCBzbWtpZCkge1xuICAgIGNvbnN0IHNta2lkU3RyaW5nID0gJycgKyBzbWtpZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeVN0YWdlTWFzdGVyS2V5OiBrZXksIC8vIHF1ZXJ5IHN0YWdlIG1hc3RlciBrZXlcbiAgICAgICAgcXVlcnlJZDogcWlkLCAvLyBxdWVyeSBpZFxuICAgICAgICBzbWtJZDogc21raWRTdHJpbmcsIC8vIFNNSyBpZFxuICAgIH07XG59XG5leHBvcnRzLlNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWwgPSBTbm93Zmxha2VGaWxlRW5jcnlwdGlvbk1hdGVyaWFsO1xuLyoqXG4gKiBDcmVhdGVzIGEgcmVtb3RlIHN0b3JhZ2UgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZW1vdGVTdG9yYWdlVXRpbChjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgbGV0IGNsaWVudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogR2V0IHN0b3JhZ2UgdHlwZSBiYXNlZCBvbiBsb2NhdGlvbiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRGb3JTdG9yYWdlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdTMycpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyBTbm93Zmxha2VTM1V0aWwoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ0FaVVJFJykge1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IFNub3dmbGFrZUF6dXJlVXRpbChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnR0NTJykge1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IFNub3dmbGFrZUdDU1V0aWwoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgY2xpZW50IGJhc2VkIG9uIHRoZSBsb2NhdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKHN0YWdlSW5mbywgdXNlQWNjZWxlcmF0ZUVuZHBvaW50ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdXRpbENsYXNzID0gdGhpcy5nZXRGb3JTdG9yYWdlVHlwZShzdGFnZUluZm9bJ2xvY2F0aW9uVHlwZSddKTtcbiAgICAgICAgcmV0dXJuIHV0aWxDbGFzcy5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvLCB1c2VBY2NlbGVyYXRlRW5kcG9pbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5jcnlwdCB0aGVuIHVwbG9hZCBvbmUgZmlsZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy51cGxvYWRPbmVGaWxlU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgbGV0IGRhdGFGaWxlU3RyZWFtID0gbWV0YVsnZmlsZVN0cmVhbSddO1xuICAgICAgICBpZiAobWV0YVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFNub3dmbGFrZUVuY3J5cHRpb25VdGlsLmVuY3J5cHRGaWxlU3RyZWFtKG1ldGFbJ2VuY3J5cHRpb25NYXRlcmlhbCddLCBtZXRhWydmaWxlU3RyZWFtJ10pO1xuICAgICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhID0gcmVzdWx0LmVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICAgICAgICAgIGRhdGFGaWxlU3RyZWFtID0gcmVzdWx0LmRhdGFTdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXRpbENsYXNzID0gdGhpcy5nZXRGb3JTdG9yYWdlVHlwZShtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb25UeXBlJ10pO1xuICAgICAgICBsZXQgbWF4Q29uY3VycmVuY3kgPSBtZXRhWydwYXJhbGxlbCddO1xuICAgICAgICBsZXQgbGFzdEVycjtcbiAgICAgICAgY29uc3QgbWF4UmV0cnkgPSBERUZBVUxUX01BWF9SRVRSWTtcbiAgICAgICAgZm9yIChsZXQgcmV0cnkgPSAwOyByZXRyeSA8IG1heFJldHJ5OyByZXRyeSsrKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGFbJ292ZXJ3cml0ZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUhlYWRlciA9IGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlSGVhZGVyICYmIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuU0tJUFBFRDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhWydvdmVyd3JpdGUnXSB8fCBtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXRpbENsYXNzLnVwbG9hZEZpbGVTdHJlYW0oZGF0YUZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSwgbWF4Q29uY3VycmVuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byB1cGxvYWQgZmlsZSwgcmV0cnlpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGFbJ25vU2xlZXBpbmdUaW1lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xlZXBpbmdUaW1lID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnkpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHNsZWVwaW5nVGltZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byB1cGxvYWQgZmlsZSwgcmV0cnlpbmcgd2l0aCBtYXggY29uY3VycmVuY3lcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeSA9IG1ldGFbJ3BhcmFsbGVsJ10gLSBwYXJzZUludCgocmV0cnkgKiBtZXRhWydwYXJhbGxlbCddKSAvIG1heFJldHJ5KTtcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeSA9IE1hdGgubWF4KERFRkFVTFRfQ09OQ1VSUkVOQ1ksIG1heENvbmN1cnJlbmN5KTtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0TWF4Q29uY3VycmVuY3knXSA9IG1heENvbmN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobGFzdEVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5rbm93biBFcnJvciBpbiB1cGxvYWRpbmcgYSBmaWxlOiAnICsgbWV0YVsnc3JjRmlsZU5hbWUnXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmNyeXB0IHRoZW4gdXBsb2FkIG9uZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXBsb2FkT25lRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIGxldCBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgICAgIGxldCBkYXRhRmlsZTtcbiAgICAgICAgaWYgKG1ldGFbJ2VuY3J5cHRpb25NYXRlcmlhbCddKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTbm93Zmxha2VFbmNyeXB0aW9uVXRpbC5lbmNyeXB0RmlsZShtZXRhWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSwgbWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10sIG1ldGFbJ3RtcERpciddKTtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IHJlc3VsdC5lbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgICAgICAgICBkYXRhRmlsZSA9IHJlc3VsdC5kYXRhRmlsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFGaWxlID0gbWV0YVsncmVhbFNyY0ZpbGVQYXRoJ107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXRpbENsYXNzID0gdGhpcy5nZXRGb3JTdG9yYWdlVHlwZShtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb25UeXBlJ10pO1xuICAgICAgICBsZXQgbWF4Q29uY3VycmVuY3kgPSBtZXRhWydwYXJhbGxlbCddO1xuICAgICAgICBsZXQgbGFzdEVycjtcbiAgICAgICAgY29uc3QgbWF4UmV0cnkgPSBERUZBVUxUX01BWF9SRVRSWTtcbiAgICAgICAgZm9yIChsZXQgcmV0cnkgPSAwOyByZXRyeSA8IG1heFJldHJ5OyByZXRyeSsrKSB7XG4gICAgICAgICAgICBpZiAoIW1ldGFbJ292ZXJ3cml0ZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUhlYWRlciA9IGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlSGVhZGVyICYmIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuU0tJUFBFRDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhWydvdmVyd3JpdGUnXSB8fCBtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXRpbENsYXNzLnVwbG9hZEZpbGUoZGF0YUZpbGUsIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSwgbWF4Q29uY3VycmVuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byB1cGxvYWQgZmlsZSwgcmV0cnlpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGFbJ25vU2xlZXBpbmdUaW1lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xlZXBpbmdUaW1lID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnkpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHNsZWVwaW5nVGltZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byB1cGxvYWQgZmlsZSwgcmV0cnlpbmcgd2l0aCBtYXggY29uY3VycmVuY3lcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeSA9IG1ldGFbJ3BhcmFsbGVsJ10gLSBwYXJzZUludCgocmV0cnkgKiBtZXRhWydwYXJhbGxlbCddKSAvIG1heFJldHJ5KTtcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeSA9IE1hdGgubWF4KERFRkFVTFRfQ09OQ1VSUkVOQ1ksIG1heENvbmN1cnJlbmN5KTtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0TWF4Q29uY3VycmVuY3knXSA9IG1heENvbmN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobGFzdEVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5rbm93biBFcnJvciBpbiB1cGxvYWRpbmcgYSBmaWxlOiAnICsgZGF0YUZpbGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB1cGxvYWQgb2YgYSBmaWxlIGFuZCByZXRyeSBpZiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZE9uZUZpbGVXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiAobWV0YSkge1xuICAgICAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvblR5cGUnXSk7XG4gICAgICAgIGxldCBicmVha0ZsYWcgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZE9uZUZpbGUobWV0YSk7XG4gICAgICAgICAgICBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5VUExPQURFRCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgMTA7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB1dGlsQ2xhc3MuZ2V0RmlsZUhlYWRlcihtZXRhLCBtZXRhWydkc3RGaWxlTmFtZSddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrRmxhZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJyZWFrRmxhZykge1xuICAgICAgICAgICAgLy8gQ291bGQgbm90IHVwbG9hZCBhIGZpbGUgZXZlbiBhZnRlciByZXRyeVxuICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGEgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRvd25sb2FkT25lRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgIC8vIERvd25sb2FkcyBhIGZpbGUgZnJvbSBTM1xuICAgICAgICBsZXQgZnVsbERzdFBhdGggPSBtZXRhWydsb2NhbExvY2F0aW9uJ107XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZzLnJlYWxwYXRoKGZ1bGxEc3RQYXRoLCAoZXJyLCBiYXNlUGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bGxEc3RQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCBwYXRoLmJhc2VuYW1lKG1ldGFbJ2RzdEZpbGVOYW1lJ10pKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIGZ1bGxEc3RQYXRoIGlzIHVuZGVyIHRoZSB3cml0YWJsZSBkaXJlY3RvcnlcbiAgICAgICAgY29uc3QgYmFzZURpciA9IHBhdGguZGlybmFtZShmdWxsRHN0UGF0aCk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBmcy5leGlzdHMoYmFzZURpciwgKGV4aXN0cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLm1rZGlyKGJhc2VEaXIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvblR5cGUnXSk7XG4gICAgICAgIGxldCBmaWxlSGVhZGVyID0gYXdhaXQgdXRpbENsYXNzLmdldEZpbGVIZWFkZXIobWV0YSwgbWV0YVsnc3JjRmlsZU5hbWUnXSk7XG4gICAgICAgIGlmIChmaWxlSGVhZGVyKSB7XG4gICAgICAgICAgICBtZXRhWydzcmNGaWxlU2l6ZSddID0gZmlsZUhlYWRlci5jb250ZW50TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhDb25jdXJyZW5jeSA9IG1ldGFbJ3BhcmFsbGVsJ107XG4gICAgICAgIGxldCBsYXN0RXJyO1xuICAgICAgICBjb25zdCBtYXhSZXRyeSA9IERFRkFVTFRfTUFYX1JFVFJZO1xuICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgU3RhcnRlZCBkb3dubG9hZGluZyByZXN1bHQuIEZpbGU6ICR7bWV0YS5kc3RGaWxlTmFtZX0sIGxvY2F0aW9uOiAke21ldGEuc3RhZ2VJbmZvLmxvY2F0aW9ufWApO1xuICAgICAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpLnN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IHJldHJ5ID0gMDsgcmV0cnkgPCBtYXhSZXRyeTsgcmV0cnkrKykge1xuICAgICAgICAgICAgLy8gRG93bmxvYWQgdGhlIGZpbGVcbiAgICAgICAgICAgIGF3YWl0IHV0aWxDbGFzcy5uYXRpdmVEb3dubG9hZEZpbGUobWV0YSwgZnVsbERzdFBhdGgsIG1heENvbmN1cnJlbmN5KTtcbiAgICAgICAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFN1Y2Nlc3NmdWxseSBkb3dubG9hZGVkIHJlc3VsdC4gRmlsZTogJHttZXRhLmRzdEZpbGVOYW1lfSwgZG93bmxvYWQgdGltZTogJHt0aW1lci5nZXREdXJhdGlvbigpfSBtcywgY2h1bmtTaXplOiAke21ldGEuc3JjRmlsZVNpemV9IGJ5dGVzLmApO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRm9yIHN0b3JhZ2UgdXRpbHMgdGhhdCBkbyBub3QgaGF2ZSB0aGUgcHJpdmlsZWdlIG9mXG4gICAgICAgICAgICAgICAgICAgICAqIGdldHRpbmcgdGhlIG1ldGFkYXRhIGVhcmx5LCBib3RoIG9iamVjdCBhbmQgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogYXJlIGRvd25sb2FkZWQgYXQgb25jZS5JbiB3aGljaCBjYXNlLCB0aGUgZmlsZSBtZXRhIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICogYmUgdXBkYXRlZCB3aXRoIGFsbCB0aGUgbWV0YWRhdGEgdGhhdCB3ZSBuZWVkIGFuZFxuICAgICAgICAgICAgICAgICAgICAgKiB0aGVuIHdlIGNhbiBjYWxsIGdldEZpbGVIZWFkZXIgdG8gZ2V0IGp1c3QgdGhhdCBhbmQgYWxzb1xuICAgICAgICAgICAgICAgICAgICAgKiBwcmVzZXJ2ZSB0aGUgaWRlYSBvZiBnZXR0aW5nIG1ldGFkYXRhIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgICogT25lIGV4YW1wbGUgb2YgdGhpcyBpcyB0aGUgdXRpbHMgdGhhdCB1c2UgcHJlc2lnbmVkIHVybFxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdXBsb2FkIC8gZG93bmxvYWQgYW5kIG5vdCB0aGUgc3RvcmFnZSBjbGllbnQgbGlicmFyeS5cbiAgICAgICAgICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YVsncHJlc2lnbmVkVXJsJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVIZWFkZXIgPSBhd2FpdCB1dGlsQ2xhc3MuZ2V0RmlsZUhlYWRlcihtZXRhLCBtZXRhWydzcmNGaWxlUGF0aCddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgU3RhcnQgZGVjcnlwdGluZyB0aGUgZG93bmxvYWRlZCBmaWxlIGZvciAke21ldGEuZHN0RmlsZU5hbWV9IGF0IHBhdGg6ICR7ZnVsbERzdFBhdGh9LmApO1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBEc3ROYW1lID0gYXdhaXQgU25vd2ZsYWtlRW5jcnlwdGlvblV0aWwuZGVjcnlwdEZpbGUoZmlsZUhlYWRlci5lbmNyeXB0aW9uTWV0YWRhdGEsIG1ldGFbJ2VuY3J5cHRpb25NYXRlcmlhbCddLCBmdWxsRHN0UGF0aCwgbWV0YVsndG1wRGlyJ10pO1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBTdWNjZXNzZnVsbHkgZGVjcnlwdGVkIHRoZSBkb3dubG9hZGVkIGZpbGUgZm9yICR7bWV0YS5kc3RGaWxlTmFtZX0gaW4gJHt0aW1lci5nZXREdXJhdGlvbigpfSBtcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBkZWNyeXB0ZWQgdG1wIGZpbGUgdG8gdGFyZ2V0IGRlc3RpbmF0aW9uIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMuY29weUZpbGUodG1wRHN0TmFtZSwgZnVsbERzdFBhdGgsIGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0bXAgZmlsZVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmsodG1wRHN0TmFtZSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRtcCBmb2xkZXJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMucm1kaXIobWV0YVsndG1wRGlyJ10sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZzLnN0YXQoZnVsbERzdFBhdGgsIChlcnIsIHN0YXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSBzdGF0LnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIoKS5kZWJ1ZyhgRmlsZSBzaXplIHZlcmlmaWNhdGlvbjogRG93bmxvYWRlZCBmaWxlIGF0IFwiJHttZXRhLmZ1bGxEc3RQYXRofVwiIGlzICR7c3RhdC5zaXplfSBieXRlcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTikge1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBOZWVkIHRvIHJlbmV3IHRva2VuIGZvciBkb3dubG9hZGluZyBmaWxlOiAke21ldGEuZHN0RmlsZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYE5lZWQgdG8gcmVuZXcgcHJlc2lnbmVkIFVSTCBmb3IgZG93bmxvYWRpbmcuIGZpbGU6ICR7bWV0YS5kc3RGaWxlTmFtZX0sIHByZXNpZ25lZFVybDogJHttZXRhLnByZXNpZ25lZFVybH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUllfV0lUSF9MT1dFUl9DT05DVVJSRU5DWSkge1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBOZWVkIHRvIHJldHJ5IHdpdGggbG93ZXIgY29uY3VycmVuY3kgZm9yIGRvd25sb2FkaW5nIGZpbGU6ICR7bWV0YS5kc3RGaWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gbWV0YVsnbGFzdEVycm9yJ107XG4gICAgICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGRvd25sb2FkIGZpbGUsIHJldHJ5aW5nIHdpdGggbWF4IGNvbmN1cnJlbmN5XG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVuY3kgPSBtZXRhWydwYXJhbGxlbCddIC0gcGFyc2VJbnQoKHJldHJ5ICogbWV0YVsncGFyYWxsZWwnXSkgLyBtYXhSZXRyeSk7XG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVuY3kgPSBNYXRoLm1heChERUZBVUxUX0NPTkNVUlJFTkNZLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgICAgICAgICAgICAgbWV0YVsnbGFzdE1heENvbmN1cnJlbmN5J10gPSBtYXhDb25jdXJyZW5jeTtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGFbJ25vU2xlZXBpbmdUaW1lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xlZXBpbmdUaW1lID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnkpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHNsZWVwaW5nVGltZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWSkge1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBOZWVkIHRvIHJldHJ5IGZvciBkb3dubG9hZGluZyBmaWxlOiAke21ldGEuZHN0RmlsZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAgICAgICAgIC8vIEZhaWxlZCB0byBkb3dubG9hZCBmaWxlLCByZXRyeWluZ1xuICAgICAgICAgICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RXJyKSB7XG4gICAgICAgICAgICBMb2dnZXIoKS5lcnJvcihgRmFpbGVkIHRvIGRvd25sb2FkaW5nIGZpbGU6ICR7bWV0YS5kc3RGaWxlTmFtZX0gd2l0aCBlcnJvcjogJHtsYXN0RXJyfWApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGxhc3RFcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1Vua25vd24gRXJyb3IgaW4gZG93bmxvYWRpbmcgYSBmaWxlOiAnICsgbWV0YVsnc3JjRmlsZU5hbWUnXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuUmVtb3RlU3RvcmFnZVV0aWwgPSBSZW1vdGVTdG9yYWdlVXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW90ZV9zdG9yYWdlX3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/remote_storage_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { NodeHttpHandler } = __webpack_require__(/*! @smithy/node-http-handler */ \"(rsc)/./node_modules/@smithy/node-http-handler/dist-es/index.js\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").FileHeader);\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst getProxyAgent = (__webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\").getProxyAgent);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Logger = (__webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst AMZ_IV = 'x-amz-iv';\nconst AMZ_KEY = 'x-amz-key';\nconst AMZ_MATDESC = 'x-amz-matdesc';\nconst SFC_DIGEST = 'sfc-digest';\nconst EXPIRED_TOKEN = 'ExpiredToken';\nconst NO_SUCH_KEY = 'NoSuchKey';\nconst SNOWFLAKE_S3_DESTINATION = 's3.amazonaws.com';\nconst ERRORNO_WSAECONNABORTED = 10053; // network connection was aborted\nconst DATA_SIZE_THRESHOLD = 67108864; // magic number, given from  error message.\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\").resultStatus);\nconst HTTP_HEADER_VALUE_OCTET_STREAM = 'application/octet-stream';\n// S3 Location: S3 bucket name + path\nfunction S3Location(bucketName, s3path) {\n    return {\n        bucketName: bucketName, // S3 bucket name\n        s3path: s3path, // S3 path name\n    };\n}\n/**\n * Creates an S3 utility object.\n *\n * @param connectionConfig\n *\n * @param s3 - used for tests, mock can be supplied\n * @param filestream - used for tests, mock can be supplied\n * @returns {Object}\n * @constructor\n */\nfunction S3Util(connectionConfig, s3, filestream) {\n    const AWS = typeof s3 !== 'undefined' ? s3 : __webpack_require__(/*! @aws-sdk/client-s3 */ \"@aws-sdk/client-s3\");\n    const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n    /**\n     * Create an AWS S3 client using an AWS token.\n     */\n    this.createClient = function (stageInfo, useAccelerateEndpoint) {\n        const stageCredentials = stageInfo['creds'];\n        const securityToken = stageCredentials['AWS_TOKEN'];\n        const isRegionalUrlEnabled = stageInfo.useRegionalUrl || stageInfo.useS3RegionalUrl;\n        // if GS sends us an endpoint, it's likely for FIPS. Use it.\n        let endPoint = null;\n        if (stageInfo['endPoint']) {\n            endPoint = `https://${stageInfo['endPoint']}`;\n        }\n        else {\n            if (stageInfo.region && isRegionalUrlEnabled) {\n                const domainSuffixForRegionalUrl = stageInfo.region.toLowerCase().startsWith('cn-')\n                    ? 'amazonaws.com.cn'\n                    : 'amazonaws.com';\n                endPoint = `https://s3.${stageInfo.region}.${domainSuffixForRegionalUrl}`;\n            }\n        }\n        const config = {\n            apiVersion: '2006-03-01',\n            region: stageInfo['region'],\n            credentials: {\n                accessKeyId: stageCredentials['AWS_KEY_ID'],\n                secretAccessKey: stageCredentials['AWS_SECRET_KEY'],\n                sessionToken: securityToken,\n            },\n            endpoint: endPoint,\n            useAccelerateEndpoint: useAccelerateEndpoint,\n        };\n        const proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'S3 Util');\n        if (proxy) {\n            const proxyAgent = getProxyAgent({\n                proxyOptions: proxy,\n                connectionConfig,\n                parsedUrl: new URL(connectionConfig.accessUrl),\n                destination: endPoint || SNOWFLAKE_S3_DESTINATION,\n            });\n            config.requestHandler = new NodeHttpHandler({\n                httpAgent: proxyAgent,\n                httpsAgent: proxyAgent,\n            });\n        }\n        return new AWS.S3(config);\n    };\n    /**\n     * Get file header based on file being uploaded or not.\n     *\n     * @param {Object} meta\n     * @param {String} filename\n     *\n     * @returns {Object}\n     */\n    this.getFileHeader = async function (meta, filename) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const s3location = extractBucketNameAndPath(stageInfo['location']);\n        const params = {\n            Bucket: s3location.bucketName,\n            Key: s3location.s3path + filename,\n        };\n        let akey;\n        try {\n            await client.getObject(params).then(function (data) {\n                akey = data;\n            });\n        }\n        catch (err) {\n            if (err['Code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else if (err['Code'] === NO_SUCH_KEY) {\n                meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n                return FileHeader(null, null, null);\n            }\n            else if (err['Code'] === '400') {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n                return null;\n            }\n            else {\n                meta['resultStatus'] = resultStatus.ERROR;\n                return null;\n            }\n        }\n        meta['resultStatus'] = resultStatus.UPLOADED;\n        let encryptionMetadata;\n        if (akey && akey.Metadata[AMZ_KEY]) {\n            encryptionMetadata = EncryptionMetadata(akey.Metadata[AMZ_KEY], akey.Metadata[AMZ_IV], akey.Metadata[AMZ_MATDESC]);\n        }\n        return FileHeader(akey.Metadata[SFC_DIGEST], akey.ContentLength, encryptionMetadata);\n    };\n    /**\n     * Create the file metadata then upload the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     */\n    this.uploadFile = async function (dataFile, meta, encryptionMetadata) {\n        const fileStream = fs.readFileSync(dataFile);\n        await this.uploadFileStream(fileStream, meta, encryptionMetadata);\n    };\n    /**\n     * Create the file metadata then upload the file stream.\n     *\n     * @param {String} fileStream\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     */\n    this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n        const s3Metadata = {\n            HTTP_HEADER_CONTENT_TYPE: HTTP_HEADER_VALUE_OCTET_STREAM,\n            SFC_DIGEST: meta['SHA256_DIGEST'],\n        };\n        if (encryptionMetadata) {\n            s3Metadata[AMZ_IV] = encryptionMetadata.iv;\n            s3Metadata[AMZ_KEY] = encryptionMetadata.key;\n            s3Metadata[AMZ_MATDESC] = encryptionMetadata.matDesc;\n        }\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const s3location = extractBucketNameAndPath(meta['stageInfo']['location']);\n        const params = {\n            Bucket: s3location.bucketName,\n            Body: fileStream,\n            Key: s3location.s3path + meta['dstFileName'],\n            Metadata: s3Metadata,\n        };\n        // call S3 to upload file to specified bucket\n        try {\n            await client.putObject(params);\n        }\n        catch (err) {\n            if (err['Code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            else {\n                meta['lastError'] = err;\n                if (err['Code'] === ERRORNO_WSAECONNABORTED.toString()) {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n                }\n                else {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY;\n                }\n            }\n            return;\n        }\n        meta['dstFileSize'] = meta['uploadSize'];\n        meta['resultStatus'] = resultStatus.UPLOADED;\n    };\n    /**\n     * Download the file.\n     *\n     * @param {String} dataFile\n     * @param {Object} meta\n     * @param {Object} encryptionMetadata\n     */\n    this.nativeDownloadFile = async function (meta, fullDstPath) {\n        const stageInfo = meta['stageInfo'];\n        const client = this.createClient(stageInfo);\n        const s3location = extractBucketNameAndPath(meta['stageInfo']['location']);\n        const params = {\n            Bucket: s3location.bucketName,\n            Key: s3location.s3path + meta['dstFileName'],\n        };\n        // call S3 to download file to specified bucket\n        try {\n            Logger().debug(`Send Get Request to the Bucket: ${params.Bucket}, GET request: ${params.Key}`);\n            await client\n                .getObject(params)\n                .then((data) => {\n                Logger().debug(`Http Status for the GET request: ${params.Key} : ${data.$metadata.httpStatusCode}`);\n                return data.Body.transformToByteArray();\n            })\n                .then((data) => {\n                return new Promise((resolve, reject) => {\n                    fs.writeFile(fullDstPath, data, 'binary', (err) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        resolve();\n                    });\n                });\n            });\n        }\n        catch (err) {\n            if (err['Code'] === EXPIRED_TOKEN) {\n                meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n            }\n            else {\n                meta['lastError'] = err;\n                if (err['Code'] === ERRORNO_WSAECONNABORTED.toString()) {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n                }\n                else {\n                    meta['resultStatus'] = resultStatus.NEED_RETRY;\n                }\n            }\n            return;\n        }\n        meta['resultStatus'] = resultStatus.DOWNLOADED;\n    };\n}\n/**\n * Extract the bucket name and path from the metadata's stage location.\n *\n * @param {String} stageLocation\n *\n * @returns {Object}\n */\nfunction extractBucketNameAndPath(stageLocation) {\n    // expand '~' and '~user' expressions\n    if (process.platform !== 'win32') {\n        stageLocation = expandTilde(stageLocation);\n    }\n    let bucketName = stageLocation;\n    let s3path;\n    // split stage location as bucket name and path\n    if (stageLocation.includes('/')) {\n        bucketName = stageLocation.substring(0, stageLocation.indexOf('/'));\n        s3path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n        if (s3path && !s3path.endsWith('/')) {\n            s3path += '/';\n        }\n    }\n    return S3Location(bucketName, s3path);\n}\nmodule.exports = {\n    S3Util,\n    SNOWFLAKE_S3_DESTINATION,\n    DATA_SIZE_THRESHOLD,\n    extractBucketNameAndPath,\n};\n//# sourceMappingURL=s3_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L3MzX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsa0dBQTJCO0FBQy9ELDJCQUEyQixpSkFBNEM7QUFDdkUsbUJBQW1CLGdIQUFrQztBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxzQkFBc0IsbUhBQXFDO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFlO0FBQ3pDLGVBQWUsMEdBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHNDQUFzQztBQUN0QyxxQkFBcUIsa0hBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsbUJBQU8sQ0FBQyw4Q0FBb0I7QUFDN0UsZ0VBQWdFLG1CQUFPLENBQUMsY0FBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQixHQUFHLDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWMsaUJBQWlCLFdBQVc7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVksSUFBSSw4QkFBOEI7QUFDakg7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9zM191dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBOb2RlSHR0cEhhbmRsZXIgfSA9IHJlcXVpcmUoJ0BzbWl0aHkvbm9kZS1odHRwLWhhbmRsZXInKTtcbmNvbnN0IEVuY3J5cHRpb25NZXRhZGF0YSA9IHJlcXVpcmUoJy4vZW5jcnlwdF91dGlsJykuRW5jcnlwdGlvbk1ldGFkYXRhO1xuY29uc3QgRmlsZUhlYWRlciA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLkZpbGVIZWFkZXI7XG5jb25zdCBleHBhbmRUaWxkZSA9IHJlcXVpcmUoJ2V4cGFuZC10aWxkZScpO1xuY29uc3QgZ2V0UHJveHlBZ2VudCA9IHJlcXVpcmUoJy4uL2h0dHAvbm9kZScpLmdldFByb3h5QWdlbnQ7XG5jb25zdCBQcm94eVV0aWwgPSByZXF1aXJlKCcuLi9wcm94eV91dGlsJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKS5kZWZhdWx0O1xuY29uc3QgQU1aX0lWID0gJ3gtYW16LWl2JztcbmNvbnN0IEFNWl9LRVkgPSAneC1hbXota2V5JztcbmNvbnN0IEFNWl9NQVRERVNDID0gJ3gtYW16LW1hdGRlc2MnO1xuY29uc3QgU0ZDX0RJR0VTVCA9ICdzZmMtZGlnZXN0JztcbmNvbnN0IEVYUElSRURfVE9LRU4gPSAnRXhwaXJlZFRva2VuJztcbmNvbnN0IE5PX1NVQ0hfS0VZID0gJ05vU3VjaEtleSc7XG5jb25zdCBTTk9XRkxBS0VfUzNfREVTVElOQVRJT04gPSAnczMuYW1hem9uYXdzLmNvbSc7XG5jb25zdCBFUlJPUk5PX1dTQUVDT05OQUJPUlRFRCA9IDEwMDUzOyAvLyBuZXR3b3JrIGNvbm5lY3Rpb24gd2FzIGFib3J0ZWRcbmNvbnN0IERBVEFfU0laRV9USFJFU0hPTEQgPSA2NzEwODg2NDsgLy8gbWFnaWMgbnVtYmVyLCBnaXZlbiBmcm9tICBlcnJvciBtZXNzYWdlLlxuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuY29uc3QgSFRUUF9IRUFERVJfVkFMVUVfT0NURVRfU1RSRUFNID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4vLyBTMyBMb2NhdGlvbjogUzMgYnVja2V0IG5hbWUgKyBwYXRoXG5mdW5jdGlvbiBTM0xvY2F0aW9uKGJ1Y2tldE5hbWUsIHMzcGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ1Y2tldE5hbWU6IGJ1Y2tldE5hbWUsIC8vIFMzIGJ1Y2tldCBuYW1lXG4gICAgICAgIHMzcGF0aDogczNwYXRoLCAvLyBTMyBwYXRoIG5hbWVcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIFMzIHV0aWxpdHkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHBhcmFtIHMzIC0gdXNlZCBmb3IgdGVzdHMsIG1vY2sgY2FuIGJlIHN1cHBsaWVkXG4gKiBAcGFyYW0gZmlsZXN0cmVhbSAtIHVzZWQgZm9yIHRlc3RzLCBtb2NrIGNhbiBiZSBzdXBwbGllZFxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTM1V0aWwoY29ubmVjdGlvbkNvbmZpZywgczMsIGZpbGVzdHJlYW0pIHtcbiAgICBjb25zdCBBV1MgPSB0eXBlb2YgczMgIT09ICd1bmRlZmluZWQnID8gczMgOiByZXF1aXJlKCdAYXdzLXNkay9jbGllbnQtczMnKTtcbiAgICBjb25zdCBmcyA9IHR5cGVvZiBmaWxlc3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IGZpbGVzdHJlYW0gOiByZXF1aXJlKCdmcycpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBBV1MgUzMgY2xpZW50IHVzaW5nIGFuIEFXUyB0b2tlbi5cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIChzdGFnZUluZm8sIHVzZUFjY2VsZXJhdGVFbmRwb2ludCkge1xuICAgICAgICBjb25zdCBzdGFnZUNyZWRlbnRpYWxzID0gc3RhZ2VJbmZvWydjcmVkcyddO1xuICAgICAgICBjb25zdCBzZWN1cml0eVRva2VuID0gc3RhZ2VDcmVkZW50aWFsc1snQVdTX1RPS0VOJ107XG4gICAgICAgIGNvbnN0IGlzUmVnaW9uYWxVcmxFbmFibGVkID0gc3RhZ2VJbmZvLnVzZVJlZ2lvbmFsVXJsIHx8IHN0YWdlSW5mby51c2VTM1JlZ2lvbmFsVXJsO1xuICAgICAgICAvLyBpZiBHUyBzZW5kcyB1cyBhbiBlbmRwb2ludCwgaXQncyBsaWtlbHkgZm9yIEZJUFMuIFVzZSBpdC5cbiAgICAgICAgbGV0IGVuZFBvaW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHN0YWdlSW5mb1snZW5kUG9pbnQnXSkge1xuICAgICAgICAgICAgZW5kUG9pbnQgPSBgaHR0cHM6Ly8ke3N0YWdlSW5mb1snZW5kUG9pbnQnXX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YWdlSW5mby5yZWdpb24gJiYgaXNSZWdpb25hbFVybEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW5TdWZmaXhGb3JSZWdpb25hbFVybCA9IHN0YWdlSW5mby5yZWdpb24udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdjbi0nKVxuICAgICAgICAgICAgICAgICAgICA/ICdhbWF6b25hd3MuY29tLmNuJ1xuICAgICAgICAgICAgICAgICAgICA6ICdhbWF6b25hd3MuY29tJztcbiAgICAgICAgICAgICAgICBlbmRQb2ludCA9IGBodHRwczovL3MzLiR7c3RhZ2VJbmZvLnJlZ2lvbn0uJHtkb21haW5TdWZmaXhGb3JSZWdpb25hbFVybH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGFwaVZlcnNpb246ICcyMDA2LTAzLTAxJyxcbiAgICAgICAgICAgIHJlZ2lvbjogc3RhZ2VJbmZvWydyZWdpb24nXSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6IHN0YWdlQ3JlZGVudGlhbHNbJ0FXU19LRVlfSUQnXSxcbiAgICAgICAgICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6IHN0YWdlQ3JlZGVudGlhbHNbJ0FXU19TRUNSRVRfS0VZJ10sXG4gICAgICAgICAgICAgICAgc2Vzc2lvblRva2VuOiBzZWN1cml0eVRva2VuLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRQb2ludCxcbiAgICAgICAgICAgIHVzZUFjY2VsZXJhdGVFbmRwb2ludDogdXNlQWNjZWxlcmF0ZUVuZHBvaW50LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm94eSA9IFByb3h5VXRpbC5nZXRQcm94eShjb25uZWN0aW9uQ29uZmlnLmdldFByb3h5KCksICdTMyBVdGlsJyk7XG4gICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgY29uc3QgcHJveHlBZ2VudCA9IGdldFByb3h5QWdlbnQoe1xuICAgICAgICAgICAgICAgIHByb3h5T3B0aW9uczogcHJveHksXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZWRVcmw6IG5ldyBVUkwoY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwpLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBlbmRQb2ludCB8fCBTTk9XRkxBS0VfUzNfREVTVElOQVRJT04sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZy5yZXF1ZXN0SGFuZGxlciA9IG5ldyBOb2RlSHR0cEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIGh0dHBBZ2VudDogcHJveHlBZ2VudCxcbiAgICAgICAgICAgICAgICBodHRwc0FnZW50OiBwcm94eUFnZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBV1MuUzMoY29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIGhlYWRlciBiYXNlZCBvbiBmaWxlIGJlaW5nIHVwbG9hZGVkIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RmlsZUhlYWRlciA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhLCBmaWxlbmFtZSkge1xuICAgICAgICBjb25zdCBzdGFnZUluZm8gPSBtZXRhWydzdGFnZUluZm8nXTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvKTtcbiAgICAgICAgY29uc3QgczNsb2NhdGlvbiA9IGV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUluZm9bJ2xvY2F0aW9uJ10pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBCdWNrZXQ6IHMzbG9jYXRpb24uYnVja2V0TmFtZSxcbiAgICAgICAgICAgIEtleTogczNsb2NhdGlvbi5zM3BhdGggKyBmaWxlbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGFrZXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuZ2V0T2JqZWN0KHBhcmFtcykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGFrZXkgPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnQ29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJbJ0NvZGUnXSA9PT0gTk9fU1VDSF9LRVkpIHtcbiAgICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5OT1RfRk9VTkRfRklMRTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmlsZUhlYWRlcihudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVyclsnQ29kZSddID09PSAnNDAwJykge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgICAgIGxldCBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgICAgIGlmIChha2V5ICYmIGFrZXkuTWV0YWRhdGFbQU1aX0tFWV0pIHtcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IEVuY3J5cHRpb25NZXRhZGF0YShha2V5Lk1ldGFkYXRhW0FNWl9LRVldLCBha2V5Lk1ldGFkYXRhW0FNWl9JVl0sIGFrZXkuTWV0YWRhdGFbQU1aX01BVERFU0NdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRmlsZUhlYWRlcihha2V5Lk1ldGFkYXRhW1NGQ19ESUdFU1RdLCBha2V5LkNvbnRlbnRMZW5ndGgsIGVuY3J5cHRpb25NZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGZpbGUgbWV0YWRhdGEgdGhlbiB1cGxvYWQgdGhlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZEZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZGF0YUZpbGUsIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBmaWxlU3RyZWFtID0gZnMucmVhZEZpbGVTeW5jKGRhdGFGaWxlKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cGxvYWRGaWxlU3RyZWFtKGZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGZpbGUgbWV0YWRhdGEgdGhlbiB1cGxvYWQgdGhlIGZpbGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVTdHJlYW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZEZpbGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAoZmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHMzTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBIVFRQX0hFQURFUl9DT05URU5UX1RZUEU6IEhUVFBfSEVBREVSX1ZBTFVFX09DVEVUX1NUUkVBTSxcbiAgICAgICAgICAgIFNGQ19ESUdFU1Q6IG1ldGFbJ1NIQTI1Nl9ESUdFU1QnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgczNNZXRhZGF0YVtBTVpfSVZdID0gZW5jcnlwdGlvbk1ldGFkYXRhLml2O1xuICAgICAgICAgICAgczNNZXRhZGF0YVtBTVpfS0VZXSA9IGVuY3J5cHRpb25NZXRhZGF0YS5rZXk7XG4gICAgICAgICAgICBzM01ldGFkYXRhW0FNWl9NQVRERVNDXSA9IGVuY3J5cHRpb25NZXRhZGF0YS5tYXREZXNjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgICAgICBjb25zdCBzM2xvY2F0aW9uID0gZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgQnVja2V0OiBzM2xvY2F0aW9uLmJ1Y2tldE5hbWUsXG4gICAgICAgICAgICBCb2R5OiBmaWxlU3RyZWFtLFxuICAgICAgICAgICAgS2V5OiBzM2xvY2F0aW9uLnMzcGF0aCArIG1ldGFbJ2RzdEZpbGVOYW1lJ10sXG4gICAgICAgICAgICBNZXRhZGF0YTogczNNZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FsbCBTMyB0byB1cGxvYWQgZmlsZSB0byBzcGVjaWZpZWQgYnVja2V0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucHV0T2JqZWN0KHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyclsnQ29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyWydDb2RlJ10gPT09IEVSUk9STk9fV1NBRUNPTk5BQk9SVEVELnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IG1ldGFbJ3VwbG9hZFNpemUnXTtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICAqL1xuICAgIHRoaXMubmF0aXZlRG93bmxvYWRGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZ1bGxEc3RQYXRoKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgICAgICBjb25zdCBzM2xvY2F0aW9uID0gZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgQnVja2V0OiBzM2xvY2F0aW9uLmJ1Y2tldE5hbWUsXG4gICAgICAgICAgICBLZXk6IHMzbG9jYXRpb24uczNwYXRoICsgbWV0YVsnZHN0RmlsZU5hbWUnXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FsbCBTMyB0byBkb3dubG9hZCBmaWxlIHRvIHNwZWNpZmllZCBidWNrZXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBTZW5kIEdldCBSZXF1ZXN0IHRvIHRoZSBCdWNrZXQ6ICR7cGFyYW1zLkJ1Y2tldH0sIEdFVCByZXF1ZXN0OiAke3BhcmFtcy5LZXl9YCk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnRcbiAgICAgICAgICAgICAgICAuZ2V0T2JqZWN0KHBhcmFtcylcbiAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBIdHRwIFN0YXR1cyBmb3IgdGhlIEdFVCByZXF1ZXN0OiAke3BhcmFtcy5LZXl9IDogJHtkYXRhLiRtZXRhZGF0YS5odHRwU3RhdHVzQ29kZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5Cb2R5LnRyYW5zZm9ybVRvQnl0ZUFycmF5KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlKGZ1bGxEc3RQYXRoLCBkYXRhLCAnYmluYXJ5JywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnJbJ0NvZGUnXSA9PT0gRVhQSVJFRF9UT0tFTikge1xuICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKGVyclsnQ29kZSddID09PSBFUlJPUk5PX1dTQUVDT05OQUJPUlRFRC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUllfV0lUSF9MT1dFUl9DT05DVVJSRU5DWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUlk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdCB0aGUgYnVja2V0IG5hbWUgYW5kIHBhdGggZnJvbSB0aGUgbWV0YWRhdGEncyBzdGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhZ2VMb2NhdGlvblxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUxvY2F0aW9uKSB7XG4gICAgLy8gZXhwYW5kICd+JyBhbmQgJ351c2VyJyBleHByZXNzaW9uc1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICAgIHN0YWdlTG9jYXRpb24gPSBleHBhbmRUaWxkZShzdGFnZUxvY2F0aW9uKTtcbiAgICB9XG4gICAgbGV0IGJ1Y2tldE5hbWUgPSBzdGFnZUxvY2F0aW9uO1xuICAgIGxldCBzM3BhdGg7XG4gICAgLy8gc3BsaXQgc3RhZ2UgbG9jYXRpb24gYXMgYnVja2V0IG5hbWUgYW5kIHBhdGhcbiAgICBpZiAoc3RhZ2VMb2NhdGlvbi5pbmNsdWRlcygnLycpKSB7XG4gICAgICAgIGJ1Y2tldE5hbWUgPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZygwLCBzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSk7XG4gICAgICAgIHMzcGF0aCA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpICsgMSwgc3RhZ2VMb2NhdGlvbi5sZW5ndGgpO1xuICAgICAgICBpZiAoczNwYXRoICYmICFzM3BhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgczNwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUzNMb2NhdGlvbihidWNrZXROYW1lLCBzM3BhdGgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUzNVdGlsLFxuICAgIFNOT1dGTEFLRV9TM19ERVNUSU5BVElPTixcbiAgICBEQVRBX1NJWkVfVEhSRVNIT0xELFxuICAgIGV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zM191dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_transfer_agent/s3_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/file_util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst fsPromises = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/dist/commonjs/index.js\");\nconst { isWindows } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = (__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\")[\"default\"]);\nconst resultStatus = {\n    ERROR: 'ERROR',\n    UPLOADED: 'UPLOADED',\n    DOWNLOADED: 'DOWNLOADED',\n    COLLISION: 'COLLISION',\n    SKIPPED: 'SKIPPED',\n    RENEW_TOKEN: 'RENEW_TOKEN',\n    RENEW_PRESIGNED_URL: 'RENEW_PRESIGNED_URL',\n    NOT_FOUND_FILE: 'NOT_FOUND_FILE',\n    NEED_RETRY: 'NEED_RETRY',\n    NEED_RETRY_WITH_LOWER_CONCURRENCY: 'NEED_RETRY_WITH_LOWER_CONCURRENCY',\n};\nexports.resultStatus = resultStatus;\nconst ownerReadAndWriteFilePermission = 0o600;\nconst othersCanReadFilePermission = 0o044;\nconst othersCanWriteFilePermission = 0o022;\nconst executableFilePermission = 0o111;\nconst skipWarningForReadPermissionsEnv = 'SF_SKIP_WARNING_FOR_READ_PERMISSIONS_ON_CONFIG_FILE';\n// File Header\nfunction FileHeader(digest, contentLength, encryptionMetadata) {\n    return {\n        digest: digest,\n        contentLength: contentLength,\n        encryptionMetadata: encryptionMetadata,\n    };\n}\nexports.FileHeader = FileHeader;\n/**\n * Creates a file utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction FileUtil() {\n    /**\n     * Compress file with GZIP.\n     *\n     * @param {String} fileName\n     * @param {String} tmpDir\n     *\n     * @returns {Object}\n     */\n    this.compressFileWithGZIP = async function (fileName, tmpDir) {\n        // Set file name and path for compressed file\n        const baseName = path.basename(fileName);\n        const gzipFileName = path.join(tmpDir, baseName + '_c.gz');\n        await new Promise(function (resolve) {\n            // Create gzip object\n            const gzip = zlib.createGzip();\n            // Create stream object for reader and writer\n            const reader = fs.createReadStream(fileName);\n            const writer = fs.createWriteStream(gzipFileName);\n            // Write and compress file\n            const result = reader.pipe(gzip).pipe(writer);\n            result.on('finish', function () {\n                resolve();\n            });\n        });\n        await this.normalizeGzipHeader(gzipFileName);\n        const fileInfo = fs.statSync(gzipFileName);\n        return {\n            name: gzipFileName,\n            size: fileInfo.size,\n        };\n    };\n    /**\n     * Normalize the header by removing the timestamp.\n     * Note: GZIP in python includes the file name when compressing but\n     * nodejs does not so there is no need to remove it here.\n     *\n     * @param {String} gzipFileName\n     *\n     * @returns {null}\n     */\n    this.normalizeGzipHeader = async function (gzipFileName) {\n        const fd = fs.openSync(gzipFileName, 'rs+');\n        // Reset the timestamp in gzip header\n        // Write at position 4\n        const timestampBuffer = Buffer.alloc(4);\n        timestampBuffer.writeUInt32LE(0, 0);\n        fs.writeSync(fd, timestampBuffer, 0, 4, 4);\n        fs.closeSync(fd);\n    };\n    /**\n     * Get file digest and size.\n     *\n     * @param {String} fileName\n     *\n     * @returns {Object}\n     */\n    this.getDigestAndSizeForFile = async function (fileName) {\n        const chunkSize = 16 * 4 * 1024;\n        const fileInfo = fs.statSync(fileName);\n        const bufferSize = fileInfo.size;\n        let buffer = [];\n        await new Promise(function (resolve) {\n            // Create reader stream and set maximum chunk size\n            const infile = fs.createReadStream(fileName, { highWaterMark: chunkSize });\n            infile.on('data', function (chunk) {\n                buffer.push(chunk);\n            });\n            infile.on('close', function () {\n                buffer = Buffer.concat(buffer);\n                resolve();\n            });\n        });\n        const hash = crypto.createHash('sha256').update(buffer).digest('base64');\n        return {\n            digest: hash,\n            size: bufferSize,\n        };\n    };\n}\nexports.FileUtil = FileUtil;\nexports.getMatchingFilePaths = function (dir, fileName) {\n    const pathWithWildcard = path.join(dir, fileName);\n    const pathWithWildcardDependsOnPlatform = isWindows()\n        ? pathWithWildcard.replace(/\\\\/g, '/')\n        : pathWithWildcard;\n    return glob.sync(pathWithWildcardDependsOnPlatform);\n};\n/**\n * Checks if the provided file or directory is writable only by the user and os that file owner is the same as os user. FsPromises can be provided.\n * @param filePath\n * @param fsPromises\n * @param useSync\n * @returns {Promise<void>|void} Returns a Promise<void> or void on Windows (no validation needed), otherwise returns the result of the validation\n\n */\nexports.validateNoExtraPermissionsForOthers = function (filePath, fsPromises = null, useSync = false) {\n    const fsp = fsPromises ? fsPromises : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n    if (isWindows()) {\n        return;\n    }\n    const validatePermissions = (stats) => {\n        const permission = stats.mode & 0o777;\n        if (!shouldSkipWarningForReadPermissions() &&\n            (permission & othersCanReadFilePermission) !== 0) {\n            Logger()\n                .warn(`file ${filePath} is readable by someone other than the owner. Your Permission: ${permission.toString(8)}. If you want \"+\n\t\t\t\"to disable this warning, either remove read permissions from group and others or set the environment \"+\n\t\t\t\"variable ${skipWarningForReadPermissionsEnv} to true`);\n        }\n        if ((permission & executableFilePermission) !== 0) {\n            throw new Error(`file ${filePath} is executable — this poses a security risk because the file could be misused as a script or executed unintentionally. File Permission: ${permission.toString(8)}`);\n        }\n        if ((permission & othersCanWriteFilePermission) !== 0) {\n            throw new Error(`file ${filePath} is writable by group or others — this poses a security risk because it allows unauthorized users to modify sensitive settings. File Permission: ${permission.toString(8)}`);\n        }\n        //The owner should have read and write permission.\n        if ((permission & ownerReadAndWriteFilePermission) === ownerReadAndWriteFilePermission) {\n            Logger().debug(`Validated that the owner has read and write permission for file: ${filePath}, Permission: ${permission.toString(8)}`);\n        }\n        else {\n            throw new Error(`Invalid file permissions (${permission.toString(8)} for file ${filePath}). Make sure the owner has read and write permissions, and other users do not have access to it. Please fix the ownership and permissions of the file or remove the file and re-run the driver.`);\n        }\n        const userInfo = os.userInfo();\n        if (stats.uid === userInfo.uid) {\n            Logger().debug('Validated file owner');\n        }\n        else {\n            throw new Error(`Invalid file owner for file ${filePath}). Make sure the user running the software is the owner of the file, or remove the file and re-run the driver.`);\n        }\n    };\n    const handleError = (err) => {\n        // When file doesn't exist - return\n        if (err.code === 'ENOENT') {\n            return;\n        }\n        throw err;\n    };\n    if (useSync) {\n        try {\n            const stats = fs.statSync(filePath);\n            return validatePermissions(stats);\n        }\n        catch (err) {\n            handleError(err);\n        }\n    }\n    else {\n        return fsp.stat(filePath).then(validatePermissions).catch(handleError);\n    }\n};\nexports.validateNoExtraPermissionsForOthersSync = function (filePath) {\n    return exports.validateNoExtraPermissionsForOthers(filePath, fs, true);\n};\n/**\n * Checks if the provided file is writable only by the user and os that file owner is the same as os user. FsPromises can be provided.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<FileHandle>}\n */\nexports.getSecureHandle = async function (filePath, flags, fsPromises) {\n    const fsp = fsPromises ? fsPromises : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n    try {\n        const fileHandle = await fsp.open(filePath, flags, 0o600);\n        if (os.platform() === 'win32') {\n            return fileHandle;\n        }\n        const stats = await fileHandle.stat();\n        const mode = stats.mode;\n        const permission = mode & 0o777;\n        //This should be 600 permission, which means the file permission has not been changed by others.\n        if (permission === 0o600) {\n            Logger().debug(`Validated that the user has only read and write permission for file: ${filePath}, Permission: ${permission}`);\n        }\n        else {\n            throw new Error(`Invalid file permissions (${permission.toString(8)} for file ${filePath}). Make sure you have read and write permissions and other users do not have access to it. Please remove the file and re-run the driver.`);\n        }\n        const userInfo = os.userInfo();\n        if (stats.uid === userInfo.uid) {\n            Logger().debug('Validated file owner');\n        }\n        else {\n            throw new Error(`Invalid file owner for file ${filePath}). Make sure the system user is the owner of the file otherwise please remove the file and re-run the driver.`);\n        }\n        return fileHandle;\n    }\n    catch (err) {\n        //When file doesn't exist - return\n        if (err.code === 'ENOENT') {\n            return null;\n        }\n        else {\n            throw err;\n        }\n    }\n};\nexports.closeHandle = async function (fileHandle) {\n    if (fileHandle !== undefined && fileHandle !== null) {\n        await fileHandle.close();\n    }\n};\n/**\n * Checks if the provided file or directory permissions are correct.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileModeCorrect = async function (filePath, expectedMode, fsPromises) {\n    if (os.platform() === 'win32') {\n        return true;\n    }\n    return await fsPromises.stat(filePath).then((stats) => {\n        // we have to limit the number of LSB bits to 9 with the mask, as the stats.mode starts with the file type,\n        // e.g. the directory with permissions 755 will have stats.mask of 40755.\n        const mask = (1 << 9) - 1;\n        return (stats.mode & mask) === expectedMode;\n    });\n};\n/**\n * Checks if the provided file or directory is writable only by the user.\n * @param configFilePath\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileNotWritableByGroupOrOthers = async function (configFilePath, fsPromises) {\n    if (os.platform() === 'win32') {\n        return true;\n    }\n    const stats = await fsPromises.stat(configFilePath);\n    return (stats.mode & (1 << 4)) === 0 && (stats.mode & (1 << 1)) === 0;\n};\n/**\n * Generate checksum for given text. The algorithm and encoding can be provided.\n * @param text\n * @param algorithm\n * @param encoding\n * @returns {Promise<String>} resolves always to true for Windows\n */\nexports.generateChecksum = function (text, algorithm, encoding) {\n    return crypto\n        .createHash(algorithm || 'sha256')\n        .update(text, 'utf8')\n        .digest(encoding || 'hex')\n        .substring(0, 32);\n};\nexports.IsFileExisted = async function (filePath) {\n    try {\n        await fsPromises.access(filePath, fs.constants.F_OK);\n        return true;\n    }\n    catch (err) {\n        return false;\n    }\n};\nfunction shouldSkipWarningForReadPermissions() {\n    return process.env[skipWarningForReadPermissionsEnv] !== undefined;\n}\n//# sourceMappingURL=file_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsbUJBQW1CLG1CQUFPLENBQUMsMENBQWtCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLDhEQUFNO0FBQzNCLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsbUVBQVE7QUFDdEMsZUFBZSx5R0FBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMEJBQTBCO0FBQ3JGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9COztBQUVqQztBQUNBLDJDQUEyQztBQUMzQywwQ0FBMEMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsZ0VBQWdFLHVCQUF1QjtBQUMvSDtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSx5SUFBeUksdUJBQXVCO0FBQzlNO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxrSkFBa0osdUJBQXVCO0FBQ3ZOO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixTQUFTLGdCQUFnQix1QkFBdUI7QUFDL0k7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0IsV0FBVyxTQUFTO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCLDBDQUEwQyxtQkFBTyxDQUFDLGdDQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLFNBQVMsZ0JBQWdCLFdBQVc7QUFDdkk7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0IsV0FBVyxTQUFTO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9maWxlX3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IGZzUHJvbWlzZXMgPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGdsb2IgPSByZXF1aXJlKCdnbG9iJyk7XG5jb25zdCB7IGlzV2luZG93cyB9ID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpLmRlZmF1bHQ7XG5jb25zdCByZXN1bHRTdGF0dXMgPSB7XG4gICAgRVJST1I6ICdFUlJPUicsXG4gICAgVVBMT0FERUQ6ICdVUExPQURFRCcsXG4gICAgRE9XTkxPQURFRDogJ0RPV05MT0FERUQnLFxuICAgIENPTExJU0lPTjogJ0NPTExJU0lPTicsXG4gICAgU0tJUFBFRDogJ1NLSVBQRUQnLFxuICAgIFJFTkVXX1RPS0VOOiAnUkVORVdfVE9LRU4nLFxuICAgIFJFTkVXX1BSRVNJR05FRF9VUkw6ICdSRU5FV19QUkVTSUdORURfVVJMJyxcbiAgICBOT1RfRk9VTkRfRklMRTogJ05PVF9GT1VORF9GSUxFJyxcbiAgICBORUVEX1JFVFJZOiAnTkVFRF9SRVRSWScsXG4gICAgTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZOiAnTkVFRF9SRVRSWV9XSVRIX0xPV0VSX0NPTkNVUlJFTkNZJyxcbn07XG5leHBvcnRzLnJlc3VsdFN0YXR1cyA9IHJlc3VsdFN0YXR1cztcbmNvbnN0IG93bmVyUmVhZEFuZFdyaXRlRmlsZVBlcm1pc3Npb24gPSAwbzYwMDtcbmNvbnN0IG90aGVyc0NhblJlYWRGaWxlUGVybWlzc2lvbiA9IDBvMDQ0O1xuY29uc3Qgb3RoZXJzQ2FuV3JpdGVGaWxlUGVybWlzc2lvbiA9IDBvMDIyO1xuY29uc3QgZXhlY3V0YWJsZUZpbGVQZXJtaXNzaW9uID0gMG8xMTE7XG5jb25zdCBza2lwV2FybmluZ0ZvclJlYWRQZXJtaXNzaW9uc0VudiA9ICdTRl9TS0lQX1dBUk5JTkdfRk9SX1JFQURfUEVSTUlTU0lPTlNfT05fQ09ORklHX0ZJTEUnO1xuLy8gRmlsZSBIZWFkZXJcbmZ1bmN0aW9uIEZpbGVIZWFkZXIoZGlnZXN0LCBjb250ZW50TGVuZ3RoLCBlbmNyeXB0aW9uTWV0YWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaWdlc3Q6IGRpZ2VzdCxcbiAgICAgICAgY29udGVudExlbmd0aDogY29udGVudExlbmd0aCxcbiAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhOiBlbmNyeXB0aW9uTWV0YWRhdGEsXG4gICAgfTtcbn1cbmV4cG9ydHMuRmlsZUhlYWRlciA9IEZpbGVIZWFkZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBmaWxlIHV0aWxpdHkgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmlsZVV0aWwoKSB7XG4gICAgLyoqXG4gICAgICogQ29tcHJlc3MgZmlsZSB3aXRoIEdaSVAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZU5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG1wRGlyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuY29tcHJlc3NGaWxlV2l0aEdaSVAgPSBhc3luYyBmdW5jdGlvbiAoZmlsZU5hbWUsIHRtcERpcikge1xuICAgICAgICAvLyBTZXQgZmlsZSBuYW1lIGFuZCBwYXRoIGZvciBjb21wcmVzc2VkIGZpbGVcbiAgICAgICAgY29uc3QgYmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVOYW1lKTtcbiAgICAgICAgY29uc3QgZ3ppcEZpbGVOYW1lID0gcGF0aC5qb2luKHRtcERpciwgYmFzZU5hbWUgKyAnX2MuZ3onKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBnemlwIG9iamVjdFxuICAgICAgICAgICAgY29uc3QgZ3ppcCA9IHpsaWIuY3JlYXRlR3ppcCgpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSBvYmplY3QgZm9yIHJlYWRlciBhbmQgd3JpdGVyXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGd6aXBGaWxlTmFtZSk7XG4gICAgICAgICAgICAvLyBXcml0ZSBhbmQgY29tcHJlc3MgZmlsZVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLnBpcGUoZ3ppcCkucGlwZSh3cml0ZXIpO1xuICAgICAgICAgICAgcmVzdWx0Lm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm5vcm1hbGl6ZUd6aXBIZWFkZXIoZ3ppcEZpbGVOYW1lKTtcbiAgICAgICAgY29uc3QgZmlsZUluZm8gPSBmcy5zdGF0U3luYyhnemlwRmlsZU5hbWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogZ3ppcEZpbGVOYW1lLFxuICAgICAgICAgICAgc2l6ZTogZmlsZUluZm8uc2l6ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgaGVhZGVyIGJ5IHJlbW92aW5nIHRoZSB0aW1lc3RhbXAuXG4gICAgICogTm90ZTogR1pJUCBpbiBweXRob24gaW5jbHVkZXMgdGhlIGZpbGUgbmFtZSB3aGVuIGNvbXByZXNzaW5nIGJ1dFxuICAgICAqIG5vZGVqcyBkb2VzIG5vdCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHJlbW92ZSBpdCBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGd6aXBGaWxlTmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bGx9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxpemVHemlwSGVhZGVyID0gYXN5bmMgZnVuY3Rpb24gKGd6aXBGaWxlTmFtZSkge1xuICAgICAgICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKGd6aXBGaWxlTmFtZSwgJ3JzKycpO1xuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIGluIGd6aXAgaGVhZGVyXG4gICAgICAgIC8vIFdyaXRlIGF0IHBvc2l0aW9uIDRcbiAgICAgICAgY29uc3QgdGltZXN0YW1wQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICB0aW1lc3RhbXBCdWZmZXIud3JpdGVVSW50MzJMRSgwLCAwKTtcbiAgICAgICAgZnMud3JpdGVTeW5jKGZkLCB0aW1lc3RhbXBCdWZmZXIsIDAsIDQsIDQpO1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgZGlnZXN0IGFuZCBzaXplLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVOYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0RGlnZXN0QW5kU2l6ZUZvckZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gMTYgKiA0ICogMTAyNDtcbiAgICAgICAgY29uc3QgZmlsZUluZm8gPSBmcy5zdGF0U3luYyhmaWxlTmFtZSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBmaWxlSW5mby5zaXplO1xuICAgICAgICBsZXQgYnVmZmVyID0gW107XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgcmVhZGVyIHN0cmVhbSBhbmQgc2V0IG1heGltdW0gY2h1bmsgc2l6ZVxuICAgICAgICAgICAgY29uc3QgaW5maWxlID0gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlTmFtZSwgeyBoaWdoV2F0ZXJNYXJrOiBjaHVua1NpemUgfSk7XG4gICAgICAgICAgICBpbmZpbGUub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChjaHVuayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZmlsZS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChidWZmZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlnZXN0OiBoYXNoLFxuICAgICAgICAgICAgc2l6ZTogYnVmZmVyU2l6ZSxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5GaWxlVXRpbCA9IEZpbGVVdGlsO1xuZXhwb3J0cy5nZXRNYXRjaGluZ0ZpbGVQYXRocyA9IGZ1bmN0aW9uIChkaXIsIGZpbGVOYW1lKSB7XG4gICAgY29uc3QgcGF0aFdpdGhXaWxkY2FyZCA9IHBhdGguam9pbihkaXIsIGZpbGVOYW1lKTtcbiAgICBjb25zdCBwYXRoV2l0aFdpbGRjYXJkRGVwZW5kc09uUGxhdGZvcm0gPSBpc1dpbmRvd3MoKVxuICAgICAgICA/IHBhdGhXaXRoV2lsZGNhcmQucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAgIDogcGF0aFdpdGhXaWxkY2FyZDtcbiAgICByZXR1cm4gZ2xvYi5zeW5jKHBhdGhXaXRoV2lsZGNhcmREZXBlbmRzT25QbGF0Zm9ybSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgb3IgZGlyZWN0b3J5IGlzIHdyaXRhYmxlIG9ubHkgYnkgdGhlIHVzZXIgYW5kIG9zIHRoYXQgZmlsZSBvd25lciBpcyB0aGUgc2FtZSBhcyBvcyB1c2VyLiBGc1Byb21pc2VzIGNhbiBiZSBwcm92aWRlZC5cbiAqIEBwYXJhbSBmaWxlUGF0aFxuICogQHBhcmFtIGZzUHJvbWlzZXNcbiAqIEBwYXJhbSB1c2VTeW5jXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPnx2b2lkfSBSZXR1cm5zIGEgUHJvbWlzZTx2b2lkPiBvciB2b2lkIG9uIFdpbmRvd3MgKG5vIHZhbGlkYXRpb24gbmVlZGVkKSwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgdmFsaWRhdGlvblxuXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVOb0V4dHJhUGVybWlzc2lvbnNGb3JPdGhlcnMgPSBmdW5jdGlvbiAoZmlsZVBhdGgsIGZzUHJvbWlzZXMgPSBudWxsLCB1c2VTeW5jID0gZmFsc2UpIHtcbiAgICBjb25zdCBmc3AgPSBmc1Byb21pc2VzID8gZnNQcm9taXNlcyA6IHJlcXVpcmUoJ2ZzL3Byb21pc2VzJyk7XG4gICAgaWYgKGlzV2luZG93cygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVQZXJtaXNzaW9ucyA9IChzdGF0cykgPT4ge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gc3RhdHMubW9kZSAmIDBvNzc3O1xuICAgICAgICBpZiAoIXNob3VsZFNraXBXYXJuaW5nRm9yUmVhZFBlcm1pc3Npb25zKCkgJiZcbiAgICAgICAgICAgIChwZXJtaXNzaW9uICYgb3RoZXJzQ2FuUmVhZEZpbGVQZXJtaXNzaW9uKSAhPT0gMCkge1xuICAgICAgICAgICAgTG9nZ2VyKClcbiAgICAgICAgICAgICAgICAud2FybihgZmlsZSAke2ZpbGVQYXRofSBpcyByZWFkYWJsZSBieSBzb21lb25lIG90aGVyIHRoYW4gdGhlIG93bmVyLiBZb3VyIFBlcm1pc3Npb246ICR7cGVybWlzc2lvbi50b1N0cmluZyg4KX0uIElmIHlvdSB3YW50IFwiK1xuXHRcdFx0XCJ0byBkaXNhYmxlIHRoaXMgd2FybmluZywgZWl0aGVyIHJlbW92ZSByZWFkIHBlcm1pc3Npb25zIGZyb20gZ3JvdXAgYW5kIG90aGVycyBvciBzZXQgdGhlIGVudmlyb25tZW50IFwiK1xuXHRcdFx0XCJ2YXJpYWJsZSAke3NraXBXYXJuaW5nRm9yUmVhZFBlcm1pc3Npb25zRW52fSB0byB0cnVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwZXJtaXNzaW9uICYgZXhlY3V0YWJsZUZpbGVQZXJtaXNzaW9uKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWxlICR7ZmlsZVBhdGh9IGlzIGV4ZWN1dGFibGUg4oCUIHRoaXMgcG9zZXMgYSBzZWN1cml0eSByaXNrIGJlY2F1c2UgdGhlIGZpbGUgY291bGQgYmUgbWlzdXNlZCBhcyBhIHNjcmlwdCBvciBleGVjdXRlZCB1bmludGVudGlvbmFsbHkuIEZpbGUgUGVybWlzc2lvbjogJHtwZXJtaXNzaW9uLnRvU3RyaW5nKDgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocGVybWlzc2lvbiAmIG90aGVyc0NhbldyaXRlRmlsZVBlcm1pc3Npb24pICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGUgJHtmaWxlUGF0aH0gaXMgd3JpdGFibGUgYnkgZ3JvdXAgb3Igb3RoZXJzIOKAlCB0aGlzIHBvc2VzIGEgc2VjdXJpdHkgcmlzayBiZWNhdXNlIGl0IGFsbG93cyB1bmF1dGhvcml6ZWQgdXNlcnMgdG8gbW9kaWZ5IHNlbnNpdGl2ZSBzZXR0aW5ncy4gRmlsZSBQZXJtaXNzaW9uOiAke3Blcm1pc3Npb24udG9TdHJpbmcoOCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGUgb3duZXIgc2hvdWxkIGhhdmUgcmVhZCBhbmQgd3JpdGUgcGVybWlzc2lvbi5cbiAgICAgICAgaWYgKChwZXJtaXNzaW9uICYgb3duZXJSZWFkQW5kV3JpdGVGaWxlUGVybWlzc2lvbikgPT09IG93bmVyUmVhZEFuZFdyaXRlRmlsZVBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKGBWYWxpZGF0ZWQgdGhhdCB0aGUgb3duZXIgaGFzIHJlYWQgYW5kIHdyaXRlIHBlcm1pc3Npb24gZm9yIGZpbGU6ICR7ZmlsZVBhdGh9LCBQZXJtaXNzaW9uOiAke3Blcm1pc3Npb24udG9TdHJpbmcoOCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsZSBwZXJtaXNzaW9ucyAoJHtwZXJtaXNzaW9uLnRvU3RyaW5nKDgpfSBmb3IgZmlsZSAke2ZpbGVQYXRofSkuIE1ha2Ugc3VyZSB0aGUgb3duZXIgaGFzIHJlYWQgYW5kIHdyaXRlIHBlcm1pc3Npb25zLCBhbmQgb3RoZXIgdXNlcnMgZG8gbm90IGhhdmUgYWNjZXNzIHRvIGl0LiBQbGVhc2UgZml4IHRoZSBvd25lcnNoaXAgYW5kIHBlcm1pc3Npb25zIG9mIHRoZSBmaWxlIG9yIHJlbW92ZSB0aGUgZmlsZSBhbmQgcmUtcnVuIHRoZSBkcml2ZXIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlckluZm8gPSBvcy51c2VySW5mbygpO1xuICAgICAgICBpZiAoc3RhdHMudWlkID09PSB1c2VySW5mby51aWQpIHtcbiAgICAgICAgICAgIExvZ2dlcigpLmRlYnVnKCdWYWxpZGF0ZWQgZmlsZSBvd25lcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbGUgb3duZXIgZm9yIGZpbGUgJHtmaWxlUGF0aH0pLiBNYWtlIHN1cmUgdGhlIHVzZXIgcnVubmluZyB0aGUgc29mdHdhcmUgaXMgdGhlIG93bmVyIG9mIHRoZSBmaWxlLCBvciByZW1vdmUgdGhlIGZpbGUgYW5kIHJlLXJ1biB0aGUgZHJpdmVyLmApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgLy8gV2hlbiBmaWxlIGRvZXNuJ3QgZXhpc3QgLSByZXR1cm5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9O1xuICAgIGlmICh1c2VTeW5jKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVBlcm1pc3Npb25zKHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnNwLnN0YXQoZmlsZVBhdGgpLnRoZW4odmFsaWRhdGVQZXJtaXNzaW9ucykuY2F0Y2goaGFuZGxlRXJyb3IpO1xuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlTm9FeHRyYVBlcm1pc3Npb25zRm9yT3RoZXJzU3luYyA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgIHJldHVybiBleHBvcnRzLnZhbGlkYXRlTm9FeHRyYVBlcm1pc3Npb25zRm9yT3RoZXJzKGZpbGVQYXRoLCBmcywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgaXMgd3JpdGFibGUgb25seSBieSB0aGUgdXNlciBhbmQgb3MgdGhhdCBmaWxlIG93bmVyIGlzIHRoZSBzYW1lIGFzIG9zIHVzZXIuIEZzUHJvbWlzZXMgY2FuIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIGZpbGVQYXRoXG4gKiBAcGFyYW0gZXhwZWN0ZWRNb2RlXG4gKiBAcGFyYW0gZnNQcm9taXNlc1xuICogQHJldHVybnMge1Byb21pc2U8RmlsZUhhbmRsZT59XG4gKi9cbmV4cG9ydHMuZ2V0U2VjdXJlSGFuZGxlID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVQYXRoLCBmbGFncywgZnNQcm9taXNlcykge1xuICAgIGNvbnN0IGZzcCA9IGZzUHJvbWlzZXMgPyBmc1Byb21pc2VzIDogcmVxdWlyZSgnZnMvcHJvbWlzZXMnKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlSGFuZGxlID0gYXdhaXQgZnNwLm9wZW4oZmlsZVBhdGgsIGZsYWdzLCAwbzYwMCk7XG4gICAgICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZUhhbmRsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZpbGVIYW5kbGUuc3RhdCgpO1xuICAgICAgICBjb25zdCBtb2RlID0gc3RhdHMubW9kZTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IG1vZGUgJiAwbzc3NztcbiAgICAgICAgLy9UaGlzIHNob3VsZCBiZSA2MDAgcGVybWlzc2lvbiwgd2hpY2ggbWVhbnMgdGhlIGZpbGUgcGVybWlzc2lvbiBoYXMgbm90IGJlZW4gY2hhbmdlZCBieSBvdGhlcnMuXG4gICAgICAgIGlmIChwZXJtaXNzaW9uID09PSAwbzYwMCkge1xuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoYFZhbGlkYXRlZCB0aGF0IHRoZSB1c2VyIGhhcyBvbmx5IHJlYWQgYW5kIHdyaXRlIHBlcm1pc3Npb24gZm9yIGZpbGU6ICR7ZmlsZVBhdGh9LCBQZXJtaXNzaW9uOiAke3Blcm1pc3Npb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsZSBwZXJtaXNzaW9ucyAoJHtwZXJtaXNzaW9uLnRvU3RyaW5nKDgpfSBmb3IgZmlsZSAke2ZpbGVQYXRofSkuIE1ha2Ugc3VyZSB5b3UgaGF2ZSByZWFkIGFuZCB3cml0ZSBwZXJtaXNzaW9ucyBhbmQgb3RoZXIgdXNlcnMgZG8gbm90IGhhdmUgYWNjZXNzIHRvIGl0LiBQbGVhc2UgcmVtb3ZlIHRoZSBmaWxlIGFuZCByZS1ydW4gdGhlIGRyaXZlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySW5mbyA9IG9zLnVzZXJJbmZvKCk7XG4gICAgICAgIGlmIChzdGF0cy51aWQgPT09IHVzZXJJbmZvLnVpZCkge1xuICAgICAgICAgICAgTG9nZ2VyKCkuZGVidWcoJ1ZhbGlkYXRlZCBmaWxlIG93bmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsZSBvd25lciBmb3IgZmlsZSAke2ZpbGVQYXRofSkuIE1ha2Ugc3VyZSB0aGUgc3lzdGVtIHVzZXIgaXMgdGhlIG93bmVyIG9mIHRoZSBmaWxlIG90aGVyd2lzZSBwbGVhc2UgcmVtb3ZlIHRoZSBmaWxlIGFuZCByZS1ydW4gdGhlIGRyaXZlci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZUhhbmRsZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvL1doZW4gZmlsZSBkb2Vzbid0IGV4aXN0IC0gcmV0dXJuXG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMuY2xvc2VIYW5kbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZUhhbmRsZSkge1xuICAgIGlmIChmaWxlSGFuZGxlICE9PSB1bmRlZmluZWQgJiYgZmlsZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLmNsb3NlKCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBmaWxlIG9yIGRpcmVjdG9yeSBwZXJtaXNzaW9ucyBhcmUgY29ycmVjdC5cbiAqIEBwYXJhbSBmaWxlUGF0aFxuICogQHBhcmFtIGV4cGVjdGVkTW9kZVxuICogQHBhcmFtIGZzUHJvbWlzZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSByZXNvbHZlcyBhbHdheXMgdG8gdHJ1ZSBmb3IgV2luZG93c1xuICovXG5leHBvcnRzLmlzRmlsZU1vZGVDb3JyZWN0ID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVQYXRoLCBleHBlY3RlZE1vZGUsIGZzUHJvbWlzZXMpIHtcbiAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGZzUHJvbWlzZXMuc3RhdChmaWxlUGF0aCkudGhlbigoc3RhdHMpID0+IHtcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIExTQiBiaXRzIHRvIDkgd2l0aCB0aGUgbWFzaywgYXMgdGhlIHN0YXRzLm1vZGUgc3RhcnRzIHdpdGggdGhlIGZpbGUgdHlwZSxcbiAgICAgICAgLy8gZS5nLiB0aGUgZGlyZWN0b3J5IHdpdGggcGVybWlzc2lvbnMgNzU1IHdpbGwgaGF2ZSBzdGF0cy5tYXNrIG9mIDQwNzU1LlxuICAgICAgICBjb25zdCBtYXNrID0gKDEgPDwgOSkgLSAxO1xuICAgICAgICByZXR1cm4gKHN0YXRzLm1vZGUgJiBtYXNrKSA9PT0gZXhwZWN0ZWRNb2RlO1xuICAgIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBmaWxlIG9yIGRpcmVjdG9yeSBpcyB3cml0YWJsZSBvbmx5IGJ5IHRoZSB1c2VyLlxuICogQHBhcmFtIGNvbmZpZ0ZpbGVQYXRoXG4gKiBAcGFyYW0gZnNQcm9taXNlc1xuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHJlc29sdmVzIGFsd2F5cyB0byB0cnVlIGZvciBXaW5kb3dzXG4gKi9cbmV4cG9ydHMuaXNGaWxlTm90V3JpdGFibGVCeUdyb3VwT3JPdGhlcnMgPSBhc3luYyBmdW5jdGlvbiAoY29uZmlnRmlsZVBhdGgsIGZzUHJvbWlzZXMpIHtcbiAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmc1Byb21pc2VzLnN0YXQoY29uZmlnRmlsZVBhdGgpO1xuICAgIHJldHVybiAoc3RhdHMubW9kZSAmICgxIDw8IDQpKSA9PT0gMCAmJiAoc3RhdHMubW9kZSAmICgxIDw8IDEpKSA9PT0gMDtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGNoZWNrc3VtIGZvciBnaXZlbiB0ZXh0LiBUaGUgYWxnb3JpdGhtIGFuZCBlbmNvZGluZyBjYW4gYmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0gdGV4dFxuICogQHBhcmFtIGFsZ29yaXRobVxuICogQHBhcmFtIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTdHJpbmc+fSByZXNvbHZlcyBhbHdheXMgdG8gdHJ1ZSBmb3IgV2luZG93c1xuICovXG5leHBvcnRzLmdlbmVyYXRlQ2hlY2tzdW0gPSBmdW5jdGlvbiAodGV4dCwgYWxnb3JpdGhtLCBlbmNvZGluZykge1xuICAgIHJldHVybiBjcnlwdG9cbiAgICAgICAgLmNyZWF0ZUhhc2goYWxnb3JpdGhtIHx8ICdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKHRleHQsICd1dGY4JylcbiAgICAgICAgLmRpZ2VzdChlbmNvZGluZyB8fCAnaGV4JylcbiAgICAgICAgLnN1YnN0cmluZygwLCAzMik7XG59O1xuZXhwb3J0cy5Jc0ZpbGVFeGlzdGVkID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZnNQcm9taXNlcy5hY2Nlc3MoZmlsZVBhdGgsIGZzLmNvbnN0YW50cy5GX09LKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzaG91bGRTa2lwV2FybmluZ0ZvclJlYWRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbc2tpcFdhcm5pbmdGb3JSZWFkUGVybWlzc2lvbnNFbnZdICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlX3V0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js":
/*!**************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/global_config.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { XMLParser, XMLValidator } = __webpack_require__(/*! fast-xml-parser */ \"(rsc)/./node_modules/fast-xml-parser/src/fxp.js\");\nlet disableOCSPChecks = false;\n/**\n * Updates the value of the 'disableOCSPChecks' parameter.\n *\n * @param {boolean} value\n */\nexports.setDisableOCSPChecks = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isBoolean(value));\n    disableOCSPChecks = value;\n};\n/**\n * Returns the value of the 'disableOCSPChecks' parameter.\n *\n * @returns {boolean}\n */\nexports.isOCSPChecksDisabled = function () {\n    return disableOCSPChecks;\n};\nlet ocspFailOpen = true;\nexports.ocspFailOpen = ocspFailOpen;\n/**\n * Updates the value of the 'ocspFailOpen' parameter.\n *\n * @param {boolean} value\n */\nexports.setOcspFailOpen = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isBoolean(value));\n    ocspFailOpen = value;\n};\n/**\n * Returns the value of the 'ocspFailOpen' parameter.\n *\n * @param {boolean} value\n */\nexports.getOcspFailOpen = function () {\n    return ocspFailOpen;\n};\nconst ocspModes = {\n    FAIL_CLOSED: 'FAIL_CLOSED',\n    FAIL_OPEN: 'FAIL_OPEN',\n    INSECURE: 'INSECURE',\n};\nexports.ocspModes = ocspModes;\n/**\n * Returns the OCSP mode\n *\n * @returns {string}\n */\nexports.getOcspMode = function () {\n    if (disableOCSPChecks) {\n        return ocspModes.INSECURE;\n    }\n    else if (!ocspFailOpen) {\n        return ocspModes.FAIL_CLOSED;\n    }\n    return ocspModes.FAIL_OPEN;\n};\n/**\n * Returns the upper limit for number of entries we can have in the OCSP response cache.\n *\n * @returns {number}\n */\nexports.getOcspResponseCacheSizeLimit = function () {\n    return 1000;\n};\n/**\n * Returns the maximum time in seconds that entries can live in the OCSP\n * response cache.\n *\n * @returns {number}\n */\nexports.getOcspResponseCacheMaxAge = function () {\n    // 24 hours, in seconds\n    // It was in millionseconds before but the timestamp we save in\n    // cache file was in seconds. Compare that with max age in millionseconds\n    // would makes the cache never expire.\n    // change max age here because customer would have local cache file exist\n    // already and we need to keep that valid with new version of the driver.\n    // use small value for test only\n    let maxage = Number(process.env.SF_OCSP_TEST_CACHE_MAXAGE) || 86400;\n    if (maxage > 86400 || maxage <= 0) {\n        maxage = 86400;\n    }\n    return maxage;\n};\n/**\n * Creates a cache directory.\n *\n * @returns {string}\n */\nexports.mkdirCacheDir = function () {\n    let cacheRootDir = process.env.SF_OCSP_RESPONSE_CACHE_DIR;\n    if (!Util.exists(cacheRootDir)) {\n        cacheRootDir = os.homedir();\n    }\n    if (!Util.exists(cacheRootDir)) {\n        cacheRootDir = os.tmpdir(); // fallback to TMP if user home doesn't exist.\n    }\n    let cacheDir;\n    const platform = os.platform();\n    if (platform === 'darwin') {\n        cacheDir = path.join(cacheRootDir, 'Library', 'Caches', 'Snowflake');\n    }\n    else if (platform === 'win32') {\n        cacheDir = path.join(cacheRootDir, 'AppData', 'Local', 'Snowflake', 'Caches');\n    }\n    else {\n        // linux\n        cacheDir = path.join(cacheRootDir, '.cache', 'snowflake');\n    }\n    try {\n        fs.mkdirSync(cacheDir, { recursive: true });\n    }\n    catch (e) {\n        Logger.getInstance().debug('Failed to create a cache directory %s, err: %s', cacheDir, e);\n    }\n    return cacheDir;\n};\nconst rest = {\n    HTTPS_PORT: 443,\n    HTTPS_PROTOCOL: 'https',\n};\nexports.rest = rest;\n// The default JSON parser\nexports.jsonColumnVariantParser = (rawColumnValue) => new Function(`return (${rawColumnValue});`)();\n/**\n * Updates the value of the 'jsonColumnVariantParser' parameter.\n *\n * @param {function: (rawColumnValue: string) => any} value\n */\nexports.setJsonColumnVariantParser = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isFunction(value));\n    exports.jsonColumnVariantParser = value;\n};\n/**\n * As a default we set parameters values identical like in fast-xml-parser lib defaults\n * thus preserving backward compatibility if customer doesn't set custom configuration\n * and give possibility to set only part of parameters\n */\nconst defaultXmlParserConfiguration = {\n    ignoreAttributes: true,\n    alwaysCreateTextNode: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n};\n// The default XML parser\nexports.xmlColumnVariantParser = createXmlColumnVariantParser(defaultXmlParserConfiguration);\n/**\n * Updates the value of the 'xmlColumnVariantParser' parameter.\n * Return fucntion with custom XmlParser configuration or default if not set.\n *\n * @param {function: (rawColumnValue: string) => any} value\n */\nexports.setXmlColumnVariantParser = function (value) {\n    // validate input\n    Errors.assertInternal(Util.isFunction(value));\n    exports.xmlColumnVariantParser = value;\n};\n/**\n * Create and update the 'xmlColumnVariantParser' parameter using custom parser configuration.\n *\n * @param {function: (rawColumnValue: string) => any} params\n */\nexports.createXmlColumnVariantParserWithParameters = function (params) {\n    exports.xmlColumnVariantParser = createXmlColumnVariantParser(params);\n};\n/**\n * Create function to parse XML using XMlParser with custom configuration.\n * Parametrs that you can override:\n *  ignoreAttributes: true,\n *  attributeNamePrefix: '@_',\n *  attributesGroupName: false,\n *  alwaysCreateTextNode: false\n *\n * @param {object} config\n */\nfunction createXmlColumnVariantParser(config) {\n    let parserConfiguration;\n    if (!Util.isObject(config)) {\n        parserConfiguration = defaultXmlParserConfiguration;\n    }\n    else {\n        parserConfiguration = {\n            ignoreAttributes: Util.exists(config.ignoreAttributes)\n                ? config.ignoreAttributes\n                : defaultXmlParserConfiguration.ignoreAttributes,\n            attributeNamePrefix: Util.exists(config.attributeNamePrefix)\n                ? config.attributeNamePrefix\n                : defaultXmlParserConfiguration.attributeNamePrefix,\n            //For attributesGroupName null value is acceptable and mean no grouping\n            attributesGroupName: config.attributesGroupName !== undefined\n                ? config.attributesGroupName\n                : defaultXmlParserConfiguration.attributesGroupName,\n            alwaysCreateTextNode: Util.exists(config.alwaysCreateTextNode)\n                ? config.alwaysCreateTextNode\n                : defaultXmlParserConfiguration.alwaysCreateTextNode,\n        };\n    }\n    return (rawColumnValue) => {\n        // check if raw string is in XML format\n        // ensure each tag is enclosed and all attributes and elements are valid\n        // XMLValidator.validate returns true if valid, returns an error if invalid\n        const validateResult = XMLValidator.validate(rawColumnValue);\n        if (validateResult === true) {\n            // use XML parser\n            return new XMLParser(parserConfiguration).parse(rawColumnValue);\n        }\n        else {\n            throw new Error(validateResult.err.msg);\n        }\n    };\n}\nlet keepAlive = true;\n/**\n * Updates the value of the 'keepAlive' parameter.\n *\n * @param {boolean} value\n */\nexports.setKeepAlive = function (value) {\n    Errors.assertInternal(Util.isBoolean(value));\n    keepAlive = value;\n};\n/**\n * Returns the overriden value of 'keepAlive' or default if not set. Default value is true\n *\n * @param {boolean} value\n */\nexports.getKeepAlive = function () {\n    return keepAlive;\n};\nlet credentialManager = null;\nexports.setCustomCredentialManager = function (customCredentialManager) {\n    Errors.checkArgumentValid(Util.checkValidCustomCredentialManager(customCredentialManager), ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER);\n    credentialManager = customCredentialManager;\n    Logger.getInstance().info('Custom credential manager is set by a user.');\n};\nexports.getCredentialManager = function () {\n    return credentialManager;\n};\nlet envProxy = true;\nexports.setEnvProxy = function (value) {\n    Errors.assertInternal(Util.isBoolean(value));\n    envProxy = value;\n};\nexports.isEnvProxyActive = function () {\n    return envProxy;\n};\nlet customRedirectingClient;\nexports.setCustomRedirectingClient = function (value) {\n    customRedirectingClient = value;\n};\nexports.getCustomRedirectingClient = function () {\n    return customRedirectingClient;\n};\n//# sourceMappingURL=global_config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9nbG9iYWxfY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxtRUFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsdUVBQVU7QUFDakMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsK0JBQStCLCtDQUErQyxlQUFlLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLElBQUksOEJBQThCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQsSUFBSSw4QkFBOEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZ2xvYmFsX2NvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jb25zdCB7IFhNTFBhcnNlciwgWE1MVmFsaWRhdG9yIH0gPSByZXF1aXJlKCdmYXN0LXhtbC1wYXJzZXInKTtcbmxldCBkaXNhYmxlT0NTUENoZWNrcyA9IGZhbHNlO1xuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ2Rpc2FibGVPQ1NQQ2hlY2tzJyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICovXG5leHBvcnRzLnNldERpc2FibGVPQ1NQQ2hlY2tzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Jvb2xlYW4odmFsdWUpKTtcbiAgICBkaXNhYmxlT0NTUENoZWNrcyA9IHZhbHVlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlICdkaXNhYmxlT0NTUENoZWNrcycgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzT0NTUENoZWNrc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNhYmxlT0NTUENoZWNrcztcbn07XG5sZXQgb2NzcEZhaWxPcGVuID0gdHJ1ZTtcbmV4cG9ydHMub2NzcEZhaWxPcGVuID0gb2NzcEZhaWxPcGVuO1xuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ29jc3BGYWlsT3BlbicgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqL1xuZXhwb3J0cy5zZXRPY3NwRmFpbE9wZW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpO1xuICAgIG9jc3BGYWlsT3BlbiA9IHZhbHVlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlICdvY3NwRmFpbE9wZW4nIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKi9cbmV4cG9ydHMuZ2V0T2NzcEZhaWxPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvY3NwRmFpbE9wZW47XG59O1xuY29uc3Qgb2NzcE1vZGVzID0ge1xuICAgIEZBSUxfQ0xPU0VEOiAnRkFJTF9DTE9TRUQnLFxuICAgIEZBSUxfT1BFTjogJ0ZBSUxfT1BFTicsXG4gICAgSU5TRUNVUkU6ICdJTlNFQ1VSRScsXG59O1xuZXhwb3J0cy5vY3NwTW9kZXMgPSBvY3NwTW9kZXM7XG4vKipcbiAqIFJldHVybnMgdGhlIE9DU1AgbW9kZVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZ2V0T2NzcE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRpc2FibGVPQ1NQQ2hlY2tzKSB7XG4gICAgICAgIHJldHVybiBvY3NwTW9kZXMuSU5TRUNVUkU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvY3NwRmFpbE9wZW4pIHtcbiAgICAgICAgcmV0dXJuIG9jc3BNb2Rlcy5GQUlMX0NMT1NFRDtcbiAgICB9XG4gICAgcmV0dXJuIG9jc3BNb2Rlcy5GQUlMX09QRU47XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB1cHBlciBsaW1pdCBmb3IgbnVtYmVyIG9mIGVudHJpZXMgd2UgY2FuIGhhdmUgaW4gdGhlIE9DU1AgcmVzcG9uc2UgY2FjaGUuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRPY3NwUmVzcG9uc2VDYWNoZVNpemVMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMTAwMDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gdGltZSBpbiBzZWNvbmRzIHRoYXQgZW50cmllcyBjYW4gbGl2ZSBpbiB0aGUgT0NTUFxuICogcmVzcG9uc2UgY2FjaGUuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRPY3NwUmVzcG9uc2VDYWNoZU1heEFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAyNCBob3VycywgaW4gc2Vjb25kc1xuICAgIC8vIEl0IHdhcyBpbiBtaWxsaW9uc2Vjb25kcyBiZWZvcmUgYnV0IHRoZSB0aW1lc3RhbXAgd2Ugc2F2ZSBpblxuICAgIC8vIGNhY2hlIGZpbGUgd2FzIGluIHNlY29uZHMuIENvbXBhcmUgdGhhdCB3aXRoIG1heCBhZ2UgaW4gbWlsbGlvbnNlY29uZHNcbiAgICAvLyB3b3VsZCBtYWtlcyB0aGUgY2FjaGUgbmV2ZXIgZXhwaXJlLlxuICAgIC8vIGNoYW5nZSBtYXggYWdlIGhlcmUgYmVjYXVzZSBjdXN0b21lciB3b3VsZCBoYXZlIGxvY2FsIGNhY2hlIGZpbGUgZXhpc3RcbiAgICAvLyBhbHJlYWR5IGFuZCB3ZSBuZWVkIHRvIGtlZXAgdGhhdCB2YWxpZCB3aXRoIG5ldyB2ZXJzaW9uIG9mIHRoZSBkcml2ZXIuXG4gICAgLy8gdXNlIHNtYWxsIHZhbHVlIGZvciB0ZXN0IG9ubHlcbiAgICBsZXQgbWF4YWdlID0gTnVtYmVyKHByb2Nlc3MuZW52LlNGX09DU1BfVEVTVF9DQUNIRV9NQVhBR0UpIHx8IDg2NDAwO1xuICAgIGlmIChtYXhhZ2UgPiA4NjQwMCB8fCBtYXhhZ2UgPD0gMCkge1xuICAgICAgICBtYXhhZ2UgPSA4NjQwMDtcbiAgICB9XG4gICAgcmV0dXJuIG1heGFnZTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBkaXJlY3RvcnkuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5ta2RpckNhY2hlRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBjYWNoZVJvb3REaXIgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX0RJUjtcbiAgICBpZiAoIVV0aWwuZXhpc3RzKGNhY2hlUm9vdERpcikpIHtcbiAgICAgICAgY2FjaGVSb290RGlyID0gb3MuaG9tZWRpcigpO1xuICAgIH1cbiAgICBpZiAoIVV0aWwuZXhpc3RzKGNhY2hlUm9vdERpcikpIHtcbiAgICAgICAgY2FjaGVSb290RGlyID0gb3MudG1wZGlyKCk7IC8vIGZhbGxiYWNrIHRvIFRNUCBpZiB1c2VyIGhvbWUgZG9lc24ndCBleGlzdC5cbiAgICB9XG4gICAgbGV0IGNhY2hlRGlyO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gb3MucGxhdGZvcm0oKTtcbiAgICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIGNhY2hlRGlyID0gcGF0aC5qb2luKGNhY2hlUm9vdERpciwgJ0xpYnJhcnknLCAnQ2FjaGVzJywgJ1Nub3dmbGFrZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICBjYWNoZURpciA9IHBhdGguam9pbihjYWNoZVJvb3REaXIsICdBcHBEYXRhJywgJ0xvY2FsJywgJ1Nub3dmbGFrZScsICdDYWNoZXMnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGxpbnV4XG4gICAgICAgIGNhY2hlRGlyID0gcGF0aC5qb2luKGNhY2hlUm9vdERpciwgJy5jYWNoZScsICdzbm93Zmxha2UnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgZnMubWtkaXJTeW5jKGNhY2hlRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBjcmVhdGUgYSBjYWNoZSBkaXJlY3RvcnkgJXMsIGVycjogJXMnLCBjYWNoZURpciwgZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZURpcjtcbn07XG5jb25zdCByZXN0ID0ge1xuICAgIEhUVFBTX1BPUlQ6IDQ0MyxcbiAgICBIVFRQU19QUk9UT0NPTDogJ2h0dHBzJyxcbn07XG5leHBvcnRzLnJlc3QgPSByZXN0O1xuLy8gVGhlIGRlZmF1bHQgSlNPTiBwYXJzZXJcbmV4cG9ydHMuanNvbkNvbHVtblZhcmlhbnRQYXJzZXIgPSAocmF3Q29sdW1uVmFsdWUpID0+IG5ldyBGdW5jdGlvbihgcmV0dXJuICgke3Jhd0NvbHVtblZhbHVlfSk7YCkoKTtcbi8qKlxuICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlICdqc29uQ29sdW1uVmFyaWFudFBhcnNlcicgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb246IChyYXdDb2x1bW5WYWx1ZTogc3RyaW5nKSA9PiBhbnl9IHZhbHVlXG4gKi9cbmV4cG9ydHMuc2V0SnNvbkNvbHVtblZhcmlhbnRQYXJzZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzRnVuY3Rpb24odmFsdWUpKTtcbiAgICBleHBvcnRzLmpzb25Db2x1bW5WYXJpYW50UGFyc2VyID0gdmFsdWU7XG59O1xuLyoqXG4gKiBBcyBhIGRlZmF1bHQgd2Ugc2V0IHBhcmFtZXRlcnMgdmFsdWVzIGlkZW50aWNhbCBsaWtlIGluIGZhc3QteG1sLXBhcnNlciBsaWIgZGVmYXVsdHNcbiAqIHRodXMgcHJlc2VydmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGlmIGN1c3RvbWVyIGRvZXNuJ3Qgc2V0IGN1c3RvbSBjb25maWd1cmF0aW9uXG4gKiBhbmQgZ2l2ZSBwb3NzaWJpbGl0eSB0byBzZXQgb25seSBwYXJ0IG9mIHBhcmFtZXRlcnNcbiAqL1xuY29uc3QgZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgICBhbHdheXNDcmVhdGVUZXh0Tm9kZTogZmFsc2UsXG4gICAgYXR0cmlidXRlTmFtZVByZWZpeDogJ0BfJyxcbiAgICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBmYWxzZSxcbn07XG4vLyBUaGUgZGVmYXVsdCBYTUwgcGFyc2VyXG5leHBvcnRzLnhtbENvbHVtblZhcmlhbnRQYXJzZXIgPSBjcmVhdGVYbWxDb2x1bW5WYXJpYW50UGFyc2VyKGRlZmF1bHRYbWxQYXJzZXJDb25maWd1cmF0aW9uKTtcbi8qKlxuICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlICd4bWxDb2x1bW5WYXJpYW50UGFyc2VyJyBwYXJhbWV0ZXIuXG4gKiBSZXR1cm4gZnVjbnRpb24gd2l0aCBjdXN0b20gWG1sUGFyc2VyIGNvbmZpZ3VyYXRpb24gb3IgZGVmYXVsdCBpZiBub3Qgc2V0LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb246IChyYXdDb2x1bW5WYWx1ZTogc3RyaW5nKSA9PiBhbnl9IHZhbHVlXG4gKi9cbmV4cG9ydHMuc2V0WG1sQ29sdW1uVmFyaWFudFBhcnNlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNGdW5jdGlvbih2YWx1ZSkpO1xuICAgIGV4cG9ydHMueG1sQ29sdW1uVmFyaWFudFBhcnNlciA9IHZhbHVlO1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCB1cGRhdGUgdGhlICd4bWxDb2x1bW5WYXJpYW50UGFyc2VyJyBwYXJhbWV0ZXIgdXNpbmcgY3VzdG9tIHBhcnNlciBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb246IChyYXdDb2x1bW5WYWx1ZTogc3RyaW5nKSA9PiBhbnl9IHBhcmFtc1xuICovXG5leHBvcnRzLmNyZWF0ZVhtbENvbHVtblZhcmlhbnRQYXJzZXJXaXRoUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBleHBvcnRzLnhtbENvbHVtblZhcmlhbnRQYXJzZXIgPSBjcmVhdGVYbWxDb2x1bW5WYXJpYW50UGFyc2VyKHBhcmFtcyk7XG59O1xuLyoqXG4gKiBDcmVhdGUgZnVuY3Rpb24gdG8gcGFyc2UgWE1MIHVzaW5nIFhNbFBhcnNlciB3aXRoIGN1c3RvbSBjb25maWd1cmF0aW9uLlxuICogUGFyYW1ldHJzIHRoYXQgeW91IGNhbiBvdmVycmlkZTpcbiAqICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICogIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXG4gKiAgYXR0cmlidXRlc0dyb3VwTmFtZTogZmFsc2UsXG4gKiAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IGZhbHNlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVYbWxDb2x1bW5WYXJpYW50UGFyc2VyKGNvbmZpZykge1xuICAgIGxldCBwYXJzZXJDb25maWd1cmF0aW9uO1xuICAgIGlmICghVXRpbC5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgIHBhcnNlckNvbmZpZ3VyYXRpb24gPSBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcnNlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICBpZ25vcmVBdHRyaWJ1dGVzOiBVdGlsLmV4aXN0cyhjb25maWcuaWdub3JlQXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5pZ25vcmVBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbi5pZ25vcmVBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXR0cmlidXRlTmFtZVByZWZpeDogVXRpbC5leGlzdHMoY29uZmlnLmF0dHJpYnV0ZU5hbWVQcmVmaXgpXG4gICAgICAgICAgICAgICAgPyBjb25maWcuYXR0cmlidXRlTmFtZVByZWZpeFxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24uYXR0cmlidXRlTmFtZVByZWZpeCxcbiAgICAgICAgICAgIC8vRm9yIGF0dHJpYnV0ZXNHcm91cE5hbWUgbnVsbCB2YWx1ZSBpcyBhY2NlcHRhYmxlIGFuZCBtZWFuIG5vIGdyb3VwaW5nXG4gICAgICAgICAgICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBjb25maWcuYXR0cmlidXRlc0dyb3VwTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjb25maWcuYXR0cmlidXRlc0dyb3VwTmFtZVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24uYXR0cmlidXRlc0dyb3VwTmFtZSxcbiAgICAgICAgICAgIGFsd2F5c0NyZWF0ZVRleHROb2RlOiBVdGlsLmV4aXN0cyhjb25maWcuYWx3YXlzQ3JlYXRlVGV4dE5vZGUpXG4gICAgICAgICAgICAgICAgPyBjb25maWcuYWx3YXlzQ3JlYXRlVGV4dE5vZGVcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRYbWxQYXJzZXJDb25maWd1cmF0aW9uLmFsd2F5c0NyZWF0ZVRleHROb2RlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gKHJhd0NvbHVtblZhbHVlKSA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHJhdyBzdHJpbmcgaXMgaW4gWE1MIGZvcm1hdFxuICAgICAgICAvLyBlbnN1cmUgZWFjaCB0YWcgaXMgZW5jbG9zZWQgYW5kIGFsbCBhdHRyaWJ1dGVzIGFuZCBlbGVtZW50cyBhcmUgdmFsaWRcbiAgICAgICAgLy8gWE1MVmFsaWRhdG9yLnZhbGlkYXRlIHJldHVybnMgdHJ1ZSBpZiB2YWxpZCwgcmV0dXJucyBhbiBlcnJvciBpZiBpbnZhbGlkXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlUmVzdWx0ID0gWE1MVmFsaWRhdG9yLnZhbGlkYXRlKHJhd0NvbHVtblZhbHVlKTtcbiAgICAgICAgaWYgKHZhbGlkYXRlUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyB1c2UgWE1MIHBhcnNlclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxQYXJzZXIocGFyc2VyQ29uZmlndXJhdGlvbikucGFyc2UocmF3Q29sdW1uVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRlUmVzdWx0LmVyci5tc2cpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBrZWVwQWxpdmUgPSB0cnVlO1xuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ2tlZXBBbGl2ZScgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqL1xuZXhwb3J0cy5zZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Jvb2xlYW4odmFsdWUpKTtcbiAgICBrZWVwQWxpdmUgPSB2YWx1ZTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG92ZXJyaWRlbiB2YWx1ZSBvZiAna2VlcEFsaXZlJyBvciBkZWZhdWx0IGlmIG5vdCBzZXQuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqL1xuZXhwb3J0cy5nZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGtlZXBBbGl2ZTtcbn07XG5sZXQgY3JlZGVudGlhbE1hbmFnZXIgPSBudWxsO1xuZXhwb3J0cy5zZXRDdXN0b21DcmVkZW50aWFsTWFuYWdlciA9IGZ1bmN0aW9uIChjdXN0b21DcmVkZW50aWFsTWFuYWdlcikge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5jaGVja1ZhbGlkQ3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpLCBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfQ1VTVE9NX0NSRURFTlRJQUxfTUFOQUdFUik7XG4gICAgY3JlZGVudGlhbE1hbmFnZXIgPSBjdXN0b21DcmVkZW50aWFsTWFuYWdlcjtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDdXN0b20gY3JlZGVudGlhbCBtYW5hZ2VyIGlzIHNldCBieSBhIHVzZXIuJyk7XG59O1xuZXhwb3J0cy5nZXRDcmVkZW50aWFsTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlZGVudGlhbE1hbmFnZXI7XG59O1xubGV0IGVudlByb3h5ID0gdHJ1ZTtcbmV4cG9ydHMuc2V0RW52UHJveHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Jvb2xlYW4odmFsdWUpKTtcbiAgICBlbnZQcm94eSA9IHZhbHVlO1xufTtcbmV4cG9ydHMuaXNFbnZQcm94eUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZW52UHJveHk7XG59O1xubGV0IGN1c3RvbVJlZGlyZWN0aW5nQ2xpZW50O1xuZXhwb3J0cy5zZXRDdXN0b21SZWRpcmVjdGluZ0NsaWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGN1c3RvbVJlZGlyZWN0aW5nQ2xpZW50ID0gdmFsdWU7XG59O1xuZXhwb3J0cy5nZXRDdXN0b21SZWRpcmVjdGluZ0NsaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3VzdG9tUmVkaXJlY3RpbmdDbGllbnQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFsX2NvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/global_config_typed.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.globalConfigCustomValues = exports.GLOBAL_CONFIG_DEFAULTS = void 0;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst disk_cache_1 = __webpack_require__(/*! ./disk_cache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/disk_cache.js\");\nexports.GLOBAL_CONFIG_DEFAULTS = {\n    crlDownloadTimeout: 10000,\n    crlCacheValidityTime: 86400000,\n    get crlCacheDir() {\n        return process.env.SNOWFLAKE_CRL_ON_DISK_CACHE_DIR || path_1.default.join((0, disk_cache_1.getDefaultCacheDir)(), 'crls');\n    },\n};\nexports.globalConfigCustomValues = {};\nexports[\"default\"] = {\n    setValues: (options) => {\n        const filteredOptions = Object.fromEntries(Object.entries(options).filter(([key, value]) => key in exports.GLOBAL_CONFIG_DEFAULTS && value !== undefined));\n        (0, logger_1.default)().debug('Setting global config typed values: %j', filteredOptions);\n        Object.assign(exports.globalConfigCustomValues, filteredOptions);\n    },\n    getValue: (key) => {\n        return exports.globalConfigCustomValues[key] ?? exports.GLOBAL_CONFIG_DEFAULTS[key];\n    },\n};\n//# sourceMappingURL=global_config_typed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9nbG9iYWxfY29uZmlnX3R5cGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsOEJBQThCO0FBQ2pFLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDLGlDQUFpQyxtQkFBTyxDQUFDLHVFQUFVO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLCtFQUFjO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQyxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvZ2xvYmFsX2NvbmZpZ190eXBlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2xvYmFsQ29uZmlnQ3VzdG9tVmFsdWVzID0gZXhwb3J0cy5HTE9CQUxfQ09ORklHX0RFRkFVTFRTID0gdm9pZCAwO1xuY29uc3QgcGF0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTtcbmNvbnN0IGxvZ2dlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xvZ2dlclwiKSk7XG5jb25zdCBkaXNrX2NhY2hlXzEgPSByZXF1aXJlKFwiLi9kaXNrX2NhY2hlXCIpO1xuZXhwb3J0cy5HTE9CQUxfQ09ORklHX0RFRkFVTFRTID0ge1xuICAgIGNybERvd25sb2FkVGltZW91dDogMTAwMDAsXG4gICAgY3JsQ2FjaGVWYWxpZGl0eVRpbWU6IDg2NDAwMDAwLFxuICAgIGdldCBjcmxDYWNoZURpcigpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LlNOT1dGTEFLRV9DUkxfT05fRElTS19DQUNIRV9ESVIgfHwgcGF0aF8xLmRlZmF1bHQuam9pbigoMCwgZGlza19jYWNoZV8xLmdldERlZmF1bHRDYWNoZURpcikoKSwgJ2NybHMnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZ2xvYmFsQ29uZmlnQ3VzdG9tVmFsdWVzID0ge307XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgc2V0VmFsdWVzOiAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE9wdGlvbnMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IGtleSBpbiBleHBvcnRzLkdMT0JBTF9DT05GSUdfREVGQVVMVFMgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICAoMCwgbG9nZ2VyXzEuZGVmYXVsdCkoKS5kZWJ1ZygnU2V0dGluZyBnbG9iYWwgY29uZmlnIHR5cGVkIHZhbHVlczogJWonLCBmaWx0ZXJlZE9wdGlvbnMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZ2xvYmFsQ29uZmlnQ3VzdG9tVmFsdWVzLCBmaWx0ZXJlZE9wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2V0VmFsdWU6IChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2xvYmFsQ29uZmlnQ3VzdG9tVmFsdWVzW2tleV0gPz8gZXhwb3J0cy5HTE9CQUxfQ09ORklHX0RFRkFVTFRTW2tleV07XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxfY29uZmlnX3R5cGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config_typed.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/base.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\");\nconst axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nconst URL = (__webpack_require__(/*! node:url */ \"node:url\").URL);\nconst requestUtil = __webpack_require__(/*! ./request_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js\");\nconst DEFAULT_REQUEST_TIMEOUT = 360000;\n/**\n * Creates a new HTTP client.\n *\n * @param connectionConfig\n * @constructor\n */\nfunction HttpClient(connectionConfig) {\n    // save the connection config\n    Logger.getInstance().trace('Initializing base HttpClient with Connection Config[%s]', connectionConfig.describeIdentityAttributes());\n    this._connectionConfig = connectionConfig;\n}\n/**\n * Issues an HTTP request.\n *\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.request = function (options) {\n    Logger.getInstance().trace('Request%s - preparing for sending.', requestUtil.describeRequestFromOptions(options));\n    const requestObject = {};\n    const requestAbortController = new AbortController();\n    const requestHandlers = { signal: requestAbortController.signal };\n    const requestOptions = prepareRequestOptions.call(this, options, requestHandlers);\n    let sendRequest = async function sendRequest() {\n        Logger.getInstance().trace('Request%s - sending.', requestUtil.describeRequestFromOptions(requestOptions));\n        const timer = new ExecutionTimer().start();\n        requestObject.requestPromise = axios\n            .request(requestOptions)\n            .then((response) => {\n            const httpResponseTime = timer.getDuration();\n            Logger.getInstance().debug('Request%s - response received after %s milliseconds with status %s.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime, response.status);\n            parseResponseData(response);\n            sanitizeAxiosResponse(response);\n            if (Util.isFunction(options.callback)) {\n                Logger.getInstance().trace('Request%s - calling callback function.', requestUtil.describeRequestFromOptions(requestOptions));\n                return options.callback(null, normalizeResponse(response), response.data);\n            }\n            else {\n                Logger.getInstance().trace('Request%s - callback function was not provided.', requestUtil.describeRequestFromOptions(requestOptions));\n                return null;\n            }\n        })\n            .catch((err) => {\n            const httpResponseTime = timer.getDuration();\n            Logger.getInstance().debug('Request%s - failed after %s milliseconds.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime);\n            sanitizeAxiosError(err);\n            if (Util.isFunction(options.callback)) {\n                if (err.response) {\n                    // axios returns error for not 2xx responses - let's unwrap it\n                    Logger.getInstance().trace('Request%s - calling callback function for error from response. Received code: ', requestUtil.describeRequestFromOptions(requestOptions), err.response.status);\n                    options.callback(null, normalizeResponse(err.response), err.response.data);\n                }\n                else {\n                    Logger.getInstance().trace('Request%s - calling callback function for error without response.', requestUtil.describeRequestFromOptions(requestOptions));\n                    options.callback(err, normalizeResponse(null), null);\n                }\n                return null;\n            }\n            else {\n                Logger.getInstance().warn('Request%s - callback function was not provided. Error will be re-raised.', requestUtil.describeRequestFromOptions(requestOptions));\n                throw err;\n            }\n        });\n    };\n    sendRequest = sendRequest.bind(this);\n    Logger.getInstance().trace('Request%s - issued for the next tick.', requestUtil.describeRequestFromOptions(requestOptions));\n    process.nextTick(sendRequest);\n    // return an externalized request object that only contains\n    // methods we're comfortable exposing to the outside world\n    requestObject.abort = function () {\n        if (requestAbortController) {\n            Logger.getInstance().trace('Request%s - aborting.', requestUtil.describeRequestFromOptions(requestOptions));\n            requestAbortController.abort();\n            Logger.getInstance().debug('Request%s - aborted.', requestUtil.describeRequestFromOptions(requestOptions));\n        }\n    };\n    return requestObject;\n};\n/**\n * Issues an HTTP request.\n *\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.requestAsync = async function (options) {\n    Logger.getInstance().trace('Request%s - preparing for async sending.', requestUtil.describeRequestFromOptions(options));\n    const timer = new ExecutionTimer();\n    try {\n        const requestOptions = prepareRequestOptions.call(this, options);\n        timer.start();\n        const response = await axios.request(requestOptions);\n        const httpResponseTime = timer.getDuration();\n        Logger.getInstance().debug('Request%s - response received after %s milliseconds with status %s.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime, response.status);\n        parseResponseData(response);\n        sanitizeAxiosResponse(response);\n        return normalizeResponse(response);\n    }\n    catch (err) {\n        const httpResponseTime = timer.getDuration();\n        Logger.getInstance().debug('Request%s - failed after %s milliseconds. Error will be re-raised.', requestUtil.describeRequestFromOptions(options), httpResponseTime);\n        sanitizeAxiosError(err);\n        throw err;\n    }\n};\nfunction parseResponseData(response) {\n    Logger.getInstance().trace('Request%s - parsing response data.', requestUtil.describeRequestFromResponse(response));\n    parseIfJSONData(response);\n}\nfunction parseIfJSONData(response) {\n    if (Util.isString(response['data']) &&\n        response['headers']['content-type'] === 'application/json') {\n        response['json'] = response['data'];\n        response['data'] = JSON.parse(response['data']);\n    }\n}\n/**\n * Issues an HTTP POST request.\n *\n * @param {String} url\n * @param {String} body\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.post = async function (url, body, options) {\n    return this.requestAsync({\n        url: url,\n        method: 'POST',\n        data: body,\n        ...options,\n    });\n};\n/**\n * Issues an HTTP GET request.\n *\n * @param {String} url\n * @param {Object} params\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.get = async function (url, params) {\n    return this.requestAsync({\n        url: url,\n        method: 'GET',\n        ...params,\n    });\n};\n/**\n * Issues an HTTP HEAD request.\n *\n * @param {String} url\n * @param {Object} config\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.head = async function (url, config) {\n    return this.requestAsync({\n        url: url,\n        method: 'HEAD',\n        ...config,\n    });\n};\n/**\n * Issues an HTTP PUT request.\n *\n * @param {String} url\n * @param {Object} data\n * @param {Object} config\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.put = async function (url, data, config) {\n    return this.requestAsync({\n        url: url,\n        method: 'PUT',\n        data: data,\n        ...config,\n    });\n};\n/**\n * @abstract\n * Returns the module to use when making HTTP requests. Subclasses must override\n * and provide their own implementations.\n *\n * @returns {*}\n */\nHttpClient.prototype.getRequestModule = function () {\n    return null;\n};\n/**\n * Returns the agent and proxy options.\n *\n * @returns {*}\n */\nHttpClient.prototype.getAgent = function () {\n    return null;\n};\nmodule.exports = HttpClient;\nfunction sanitizeAxiosResponse(response) {\n    Logger.getInstance().trace('Request%s - sanitizing response data.', requestUtil.describeRequestFromResponse(response));\n    response.request = undefined;\n    if (response.config) {\n        response.config.data = undefined;\n        response.config.headers = undefined;\n    }\n}\nfunction sanitizeAxiosError(error) {\n    error.request = undefined;\n    error.config = undefined;\n    if (error.response) {\n        Logger.getInstance().trace('Request%s - sanitizing response error data.', requestUtil.describeRequestFromResponse(error.response));\n        sanitizeAxiosResponse(error.response);\n    }\n}\nfunction prepareRequestOptions(options, requestHandlers = {}) {\n    Logger.getInstance().trace('Request%s - constructing options.', requestUtil.describeRequestFromOptions(options));\n    const headers = normalizeHeaders(options.headers) || {};\n    const timeout = options.timeout || this._connectionConfig.getTimeout() || DEFAULT_REQUEST_TIMEOUT;\n    let data = options.data || options.json || options.body;\n    if (data) {\n        const bufferUncompressed = Buffer.from(JSON.stringify(data), 'utf8');\n        zlib.gzip(bufferUncompressed, null, function (err, bufferCompressed) {\n            // if the compression was successful\n            if (!err) {\n                data = bufferCompressed;\n                headers['Content-Encoding'] = 'gzip';\n                Logger.getInstance().debug('Request%s - original buffer length: %d bytes. Compressed buffer length: %d bytes.', requestUtil.describeRequestFromOptions(options), bufferUncompressed.buffer.byteLength, bufferCompressed.buffer.byteLength);\n            }\n            else {\n                // Logging 'err' variable value should not be done, since it may contain compressed customer's data.\n                // It can be added only for debugging purposes.\n                Logger.getInstance().warn('Request%s - could not compress request data.', requestUtil.describeRequestFromOptions(options));\n            }\n        });\n    }\n    const params = options.params;\n    let mock;\n    if (this._connectionConfig.agentClass) {\n        mock = {\n            agentClass: this._connectionConfig.agentClass,\n        };\n    }\n    const backoffStrategy = this.constructExponentialBackoffStrategy();\n    const requestOptions = {\n        method: options.method,\n        url: options.url,\n        headers: headers,\n        data: data,\n        params: params,\n        timeout: timeout,\n        requestOCSP: true,\n        retryDelay: backoffStrategy,\n        rejectUnauthorized: true,\n        // we manually parse jsons or other structures from the server so they need to be text\n        responseType: options.responseType || 'text',\n        proxy: false,\n        ...requestHandlers,\n    };\n    const url = new URL(options.url);\n    const isHttps = url.protocol === 'https:';\n    const agent = this.getAgent(url, this._connectionConfig.getProxy(), mock);\n    if (isHttps) {\n        requestOptions.httpsAgent = agent;\n    }\n    else {\n        requestOptions.httpAgent = agent;\n    }\n    Logger.getInstance().debug('Request%s - options - timeout: %s, retryDelay: %s, responseType: %s', requestUtil.describeRequestFromOptions(options), requestOptions.timeout, requestOptions.retryDelay, requestOptions.responseType);\n    return requestOptions;\n}\n/**\n * Normalizes a request headers object so that we get the same behavior\n * regardless of whether we're using request.js or browser-request.js.\n *\n * @param {Object} headers\n *\n * @returns {Object}\n */\nfunction normalizeHeaders(headers) {\n    Logger.getInstance().trace('Normalizing headers');\n    if (Util.isObject(headers)) {\n        const normalizedHeaders = {\n            'user-agent': Util.userAgent,\n        };\n        // shallow copy the headers object and convert some headers like 'Accept'\n        // and 'Content-Type' to lower case while copying; this is necessary\n        // because the browser-request module, which we use to make http requests in\n        // the browser, does not do case-insensitive checks when deciding whether to\n        // insert default values for the 'accept' and 'content-type' headers; in\n        // otherwise, if someone specifies an 'Accept': 'application/json' header,\n        // browser-request will inject its own 'accept': 'application/json' header\n        // and the browser XMLHttpRequest object will concatenate the two values and\n        // send 'Accept': 'application/json, application/json' with the request\n        let headerNameLowerCase;\n        for (const headerName in headers) {\n            if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n                headerNameLowerCase = headerName.toLowerCase();\n                if (headerNameLowerCase === 'accept' || headerNameLowerCase === 'content-type') {\n                    normalizedHeaders[headerNameLowerCase] = headers[headerName];\n                }\n                else {\n                    normalizedHeaders[headerName] = headers[headerName];\n                }\n            }\n        }\n        Logger.getInstance().trace('Headers were normalized');\n        return normalizedHeaders;\n    }\n    else {\n        Logger.getInstance().trace('Headers were not an object. Original value will be returned.');\n        return headers;\n    }\n}\n/**\n * Normalizes the response object so that we can extract response headers from\n * it in a uniform way regardless of whether we're using request.js or\n * browser-request.js.\n *\n * @param {Object} response\n *\n * @return {Object}\n */\nfunction normalizeResponse(response) {\n    // if the response doesn't already have a getResponseHeader() method, add one\n    if (response && !response.getResponseHeader) {\n        Logger.getInstance().trace('Request%s - normalizing.', requestUtil.describeRequestFromResponse(response));\n        response.getResponseHeader = function (header) {\n            return (response.headers && response.headers[Util.isString(header) ? header.toLowerCase() : header]);\n        };\n    }\n    if (response) {\n        response.body = response.data; // converting axios response body to old expected body attribute\n        response.statusCode = response.status; // converting axios status to old expected statusCode\n    }\n    return response;\n}\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL2Jhc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBMkI7QUFDMUQsY0FBYyxtQkFBTyxDQUFDLDZEQUFPO0FBQzdCLFlBQVkscURBQXVCO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHdGQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL2Jhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgRXhlY3V0aW9uVGltZXIgPSByZXF1aXJlKCcuLi9sb2dnZXIvZXhlY3V0aW9uX3RpbWVyJyk7XG5jb25zdCBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG5jb25zdCBVUkwgPSByZXF1aXJlKCdub2RlOnVybCcpLlVSTDtcbmNvbnN0IHJlcXVlc3RVdGlsID0gcmVxdWlyZSgnLi9yZXF1ZXN0X3V0aWwnKTtcbmNvbnN0IERFRkFVTFRfUkVRVUVTVF9USU1FT1VUID0gMzYwMDAwO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEhUVFAgY2xpZW50LlxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHR0cENsaWVudChjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgLy8gc2F2ZSB0aGUgY29ubmVjdGlvbiBjb25maWdcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnSW5pdGlhbGl6aW5nIGJhc2UgSHR0cENsaWVudCB3aXRoIENvbm5lY3Rpb24gQ29uZmlnWyVzXScsIGNvbm5lY3Rpb25Db25maWcuZGVzY3JpYmVJZGVudGl0eUF0dHJpYnV0ZXMoKSk7XG4gICAgdGhpcy5fY29ubmVjdGlvbkNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWc7XG59XG4vKipcbiAqIElzc3VlcyBhbiBIVFRQIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIHByZXBhcmluZyBmb3Igc2VuZGluZy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgY29uc3QgcmVxdWVzdE9iamVjdCA9IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXJzID0geyBzaWduYWw6IHJlcXVlc3RBYm9ydENvbnRyb2xsZXIuc2lnbmFsIH07XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBwcmVwYXJlUmVxdWVzdE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCByZXF1ZXN0SGFuZGxlcnMpO1xuICAgIGxldCBzZW5kUmVxdWVzdCA9IGFzeW5jIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gc2VuZGluZy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpLnN0YXJ0KCk7XG4gICAgICAgIHJlcXVlc3RPYmplY3QucmVxdWVzdFByb21pc2UgPSBheGlvc1xuICAgICAgICAgICAgLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZVRpbWUgPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIHJlc3BvbnNlIHJlY2VpdmVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcyB3aXRoIHN0YXR1cyAlcy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyksIGh0dHBSZXNwb25zZVRpbWUsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICBwYXJzZVJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG4gICAgICAgICAgICBzYW5pdGl6ZUF4aW9zUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihvcHRpb25zLmNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9uLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwgbm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UpLCByZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjYWxsYmFjayBmdW5jdGlvbiB3YXMgbm90IHByb3ZpZGVkLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHR0cFJlc3BvbnNlVGltZSA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyksIGh0dHBSZXNwb25zZVRpbWUpO1xuICAgICAgICAgICAgc2FuaXRpemVBeGlvc0Vycm9yKGVycik7XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBheGlvcyByZXR1cm5zIGVycm9yIGZvciBub3QgMnh4IHJlc3BvbnNlcyAtIGxldCdzIHVud3JhcCBpdFxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gY2FsbGluZyBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXJyb3IgZnJvbSByZXNwb25zZS4gUmVjZWl2ZWQgY29kZTogJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpLCBlcnIucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCBub3JtYWxpemVSZXNwb25zZShlcnIucmVzcG9uc2UpLCBlcnIucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gY2FsbGluZyBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXJyb3Igd2l0aG91dCByZXNwb25zZS4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVyciwgbm9ybWFsaXplUmVzcG9uc2UobnVsbCksIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ1JlcXVlc3QlcyAtIGNhbGxiYWNrIGZ1bmN0aW9uIHdhcyBub3QgcHJvdmlkZWQuIEVycm9yIHdpbGwgYmUgcmUtcmFpc2VkLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHNlbmRSZXF1ZXN0ID0gc2VuZFJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gaXNzdWVkIGZvciB0aGUgbmV4dCB0aWNrLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhzZW5kUmVxdWVzdCk7XG4gICAgLy8gcmV0dXJuIGFuIGV4dGVybmFsaXplZCByZXF1ZXN0IG9iamVjdCB0aGF0IG9ubHkgY29udGFpbnNcbiAgICAvLyBtZXRob2RzIHdlJ3JlIGNvbWZvcnRhYmxlIGV4cG9zaW5nIHRvIHRoZSBvdXRzaWRlIHdvcmxkXG4gICAgcmVxdWVzdE9iamVjdC5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlcXVlc3RBYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBhYm9ydGluZy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICAgICAgcmVxdWVzdEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIGFib3J0ZWQuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcXVlc3RPYmplY3Q7XG59O1xuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge09iamVjdH0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVxdWVzdCB0aGF0IHdhcyBpc3N1ZWQuXG4gKi9cbkh0dHBDbGllbnQucHJvdG90eXBlLnJlcXVlc3RBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIHByZXBhcmluZyBmb3IgYXN5bmMgc2VuZGluZy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHByZXBhcmVSZXF1ZXN0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aW1lci5zdGFydCgpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBodHRwUmVzcG9uc2VUaW1lID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIHJlc3BvbnNlIHJlY2VpdmVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcyB3aXRoIHN0YXR1cyAlcy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyksIGh0dHBSZXNwb25zZVRpbWUsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIHBhcnNlUmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICAgICAgc2FuaXRpemVBeGlvc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBodHRwUmVzcG9uc2VUaW1lID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMuIEVycm9yIHdpbGwgYmUgcmUtcmFpc2VkLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpLCBodHRwUmVzcG9uc2VUaW1lKTtcbiAgICAgICAgc2FuaXRpemVBeGlvc0Vycm9yKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuZnVuY3Rpb24gcGFyc2VSZXNwb25zZURhdGEocmVzcG9uc2UpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gcGFyc2luZyByZXNwb25zZSBkYXRhLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShyZXNwb25zZSkpO1xuICAgIHBhcnNlSWZKU09ORGF0YShyZXNwb25zZSk7XG59XG5mdW5jdGlvbiBwYXJzZUlmSlNPTkRhdGEocmVzcG9uc2UpIHtcbiAgICBpZiAoVXRpbC5pc1N0cmluZyhyZXNwb25zZVsnZGF0YSddKSAmJlxuICAgICAgICByZXNwb25zZVsnaGVhZGVycyddWydjb250ZW50LXR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgIHJlc3BvbnNlWydqc29uJ10gPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICByZXNwb25zZVsnZGF0YSddID0gSlNPTi5wYXJzZShyZXNwb25zZVsnZGF0YSddKTtcbiAgICB9XG59XG4vKipcbiAqIElzc3VlcyBhbiBIVFRQIFBPU1QgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUucG9zdCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCBHRVQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKlxuICogQHJldHVybnMge09iamVjdH0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVxdWVzdCB0aGF0IHdhcyBpc3N1ZWQuXG4gKi9cbkh0dHBDbGllbnQucHJvdG90eXBlLmdldCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyh7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAuLi5wYXJhbXMsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCBIRUFEIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5oZWFkID0gYXN5bmMgZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG1ldGhvZDogJ0hFQUQnLFxuICAgICAgICAuLi5jb25maWcsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCBQVVQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5wdXQgPSBhc3luYyBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgLi4uY29uZmlnLFxuICAgIH0pO1xufTtcbi8qKlxuICogQGFic3RyYWN0XG4gKiBSZXR1cm5zIHRoZSBtb2R1bGUgdG8gdXNlIHdoZW4gbWFraW5nIEhUVFAgcmVxdWVzdHMuIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZVxuICogYW5kIHByb3ZpZGUgdGhlaXIgb3duIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0UmVxdWVzdE1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGFnZW50IGFuZCBwcm94eSBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5nZXRBZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBDbGllbnQ7XG5mdW5jdGlvbiBzYW5pdGl6ZUF4aW9zUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gc2FuaXRpemluZyByZXNwb25zZSBkYXRhLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShyZXNwb25zZSkpO1xuICAgIHJlc3BvbnNlLnJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHJlc3BvbnNlLmNvbmZpZykge1xuICAgICAgICByZXNwb25zZS5jb25maWcuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVzcG9uc2UuY29uZmlnLmhlYWRlcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVBeGlvc0Vycm9yKGVycm9yKSB7XG4gICAgZXJyb3IucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICBlcnJvci5jb25maWcgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBzYW5pdGl6aW5nIHJlc3BvbnNlIGVycm9yIGRhdGEuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlKGVycm9yLnJlc3BvbnNlKSk7XG4gICAgICAgIHNhbml0aXplQXhpb3NSZXNwb25zZShlcnJvci5yZXNwb25zZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMsIHJlcXVlc3RIYW5kbGVycyA9IHt9KSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIGNvbnN0cnVjdGluZyBvcHRpb25zLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5nZXRUaW1lb3V0KCkgfHwgREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQ7XG4gICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9ucy5qc29uIHx8IG9wdGlvbnMuYm9keTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBjb25zdCBidWZmZXJVbmNvbXByZXNzZWQgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShkYXRhKSwgJ3V0ZjgnKTtcbiAgICAgICAgemxpYi5nemlwKGJ1ZmZlclVuY29tcHJlc3NlZCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYnVmZmVyQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXByZXNzaW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBidWZmZXJDb21wcmVzc2VkO1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtRW5jb2RpbmcnXSA9ICdnemlwJztcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gb3JpZ2luYWwgYnVmZmVyIGxlbmd0aDogJWQgYnl0ZXMuIENvbXByZXNzZWQgYnVmZmVyIGxlbmd0aDogJWQgYnl0ZXMuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMob3B0aW9ucyksIGJ1ZmZlclVuY29tcHJlc3NlZC5idWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyQ29tcHJlc3NlZC5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb2dnaW5nICdlcnInIHZhcmlhYmxlIHZhbHVlIHNob3VsZCBub3QgYmUgZG9uZSwgc2luY2UgaXQgbWF5IGNvbnRhaW4gY29tcHJlc3NlZCBjdXN0b21lcidzIGRhdGEuXG4gICAgICAgICAgICAgICAgLy8gSXQgY2FuIGJlIGFkZGVkIG9ubHkgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdSZXF1ZXN0JXMgLSBjb3VsZCBub3QgY29tcHJlc3MgcmVxdWVzdCBkYXRhLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgIGxldCBtb2NrO1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uQ29uZmlnLmFnZW50Q2xhc3MpIHtcbiAgICAgICAgbW9jayA9IHtcbiAgICAgICAgICAgIGFnZW50Q2xhc3M6IHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuYWdlbnRDbGFzcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYmFja29mZlN0cmF0ZWd5ID0gdGhpcy5jb25zdHJ1Y3RFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneSgpO1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgcmVxdWVzdE9DU1A6IHRydWUsXG4gICAgICAgIHJldHJ5RGVsYXk6IGJhY2tvZmZTdHJhdGVneSxcbiAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiB0cnVlLFxuICAgICAgICAvLyB3ZSBtYW51YWxseSBwYXJzZSBqc29ucyBvciBvdGhlciBzdHJ1Y3R1cmVzIGZyb20gdGhlIHNlcnZlciBzbyB0aGV5IG5lZWQgdG8gYmUgdGV4dFxuICAgICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlIHx8ICd0ZXh0JyxcbiAgICAgICAgcHJveHk6IGZhbHNlLFxuICAgICAgICAuLi5yZXF1ZXN0SGFuZGxlcnMsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9wdGlvbnMudXJsKTtcbiAgICBjb25zdCBpc0h0dHBzID0gdXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICBjb25zdCBhZ2VudCA9IHRoaXMuZ2V0QWdlbnQodXJsLCB0aGlzLl9jb25uZWN0aW9uQ29uZmlnLmdldFByb3h5KCksIG1vY2spO1xuICAgIGlmIChpc0h0dHBzKSB7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmh0dHBzQWdlbnQgPSBhZ2VudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmh0dHBBZ2VudCA9IGFnZW50O1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gb3B0aW9ucyAtIHRpbWVvdXQ6ICVzLCByZXRyeURlbGF5OiAlcywgcmVzcG9uc2VUeXBlOiAlcycsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpLCByZXF1ZXN0T3B0aW9ucy50aW1lb3V0LCByZXF1ZXN0T3B0aW9ucy5yZXRyeURlbGF5LCByZXF1ZXN0T3B0aW9ucy5yZXNwb25zZVR5cGUpO1xuICAgIHJldHVybiByZXF1ZXN0T3B0aW9ucztcbn1cbi8qKlxuICogTm9ybWFsaXplcyBhIHJlcXVlc3QgaGVhZGVycyBvYmplY3Qgc28gdGhhdCB3ZSBnZXQgdGhlIHNhbWUgYmVoYXZpb3JcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB3ZSdyZSB1c2luZyByZXF1ZXN0LmpzIG9yIGJyb3dzZXItcmVxdWVzdC5qcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcnMoaGVhZGVycykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdOb3JtYWxpemluZyBoZWFkZXJzJyk7XG4gICAgaWYgKFV0aWwuaXNPYmplY3QoaGVhZGVycykpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSB7XG4gICAgICAgICAgICAndXNlci1hZ2VudCc6IFV0aWwudXNlckFnZW50LFxuICAgICAgICB9O1xuICAgICAgICAvLyBzaGFsbG93IGNvcHkgdGhlIGhlYWRlcnMgb2JqZWN0IGFuZCBjb252ZXJ0IHNvbWUgaGVhZGVycyBsaWtlICdBY2NlcHQnXG4gICAgICAgIC8vIGFuZCAnQ29udGVudC1UeXBlJyB0byBsb3dlciBjYXNlIHdoaWxlIGNvcHlpbmc7IHRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXItcmVxdWVzdCBtb2R1bGUsIHdoaWNoIHdlIHVzZSB0byBtYWtlIGh0dHAgcmVxdWVzdHMgaW5cbiAgICAgICAgLy8gdGhlIGJyb3dzZXIsIGRvZXMgbm90IGRvIGNhc2UtaW5zZW5zaXRpdmUgY2hlY2tzIHdoZW4gZGVjaWRpbmcgd2hldGhlciB0b1xuICAgICAgICAvLyBpbnNlcnQgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSAnYWNjZXB0JyBhbmQgJ2NvbnRlbnQtdHlwZScgaGVhZGVyczsgaW5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBpZiBzb21lb25lIHNwZWNpZmllcyBhbiAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nIGhlYWRlcixcbiAgICAgICAgLy8gYnJvd3Nlci1yZXF1ZXN0IHdpbGwgaW5qZWN0IGl0cyBvd24gJ2FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyBoZWFkZXJcbiAgICAgICAgLy8gYW5kIHRoZSBicm93c2VyIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCB3aWxsIGNvbmNhdGVuYXRlIHRoZSB0d28gdmFsdWVzIGFuZFxuICAgICAgICAvLyBzZW5kICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgYXBwbGljYXRpb24vanNvbicgd2l0aCB0aGUgcmVxdWVzdFxuICAgICAgICBsZXQgaGVhZGVyTmFtZUxvd2VyQ2FzZTtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgaGVhZGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJOYW1lTG93ZXJDYXNlID0gaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJOYW1lTG93ZXJDYXNlID09PSAnYWNjZXB0JyB8fCBoZWFkZXJOYW1lTG93ZXJDYXNlID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSGVhZGVyc1toZWFkZXJOYW1lTG93ZXJDYXNlXSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSGVhZGVyc1toZWFkZXJOYW1lXSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdIZWFkZXJzIHdlcmUgbm9ybWFsaXplZCcpO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnSGVhZGVycyB3ZXJlIG5vdCBhbiBvYmplY3QuIE9yaWdpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuJyk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbn1cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgcmVzcG9uc2Ugb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGV4dHJhY3QgcmVzcG9uc2UgaGVhZGVycyBmcm9tXG4gKiBpdCBpbiBhIHVuaWZvcm0gd2F5IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB3ZSdyZSB1c2luZyByZXF1ZXN0LmpzIG9yXG4gKiBicm93c2VyLXJlcXVlc3QuanMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIC8vIGlmIHRoZSByZXNwb25zZSBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhIGdldFJlc3BvbnNlSGVhZGVyKCkgbWV0aG9kLCBhZGQgb25lXG4gICAgaWYgKHJlc3BvbnNlICYmICFyZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcikge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gbm9ybWFsaXppbmcuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgICAgIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIChyZXNwb25zZS5oZWFkZXJzICYmIHJlc3BvbnNlLmhlYWRlcnNbVXRpbC5pc1N0cmluZyhoZWFkZXIpID8gaGVhZGVyLnRvTG93ZXJDYXNlKCkgOiBoZWFkZXJdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSByZXNwb25zZS5kYXRhOyAvLyBjb252ZXJ0aW5nIGF4aW9zIHJlc3BvbnNlIGJvZHkgdG8gb2xkIGV4cGVjdGVkIGJvZHkgYXR0cmlidXRlXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7IC8vIGNvbnZlcnRpbmcgYXhpb3Mgc3RhdHVzIHRvIG9sZCBleHBlY3RlZCBzdGF0dXNDb2RlXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/node.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBypassProxy = exports.httpsAgentCache = exports.NodeHttpClient = void 0;\nexports.getProxyAgent = getProxyAgent;\nconst node_untyped_1 = __webpack_require__(/*! ./node_untyped */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js\");\nvar node_untyped_2 = __webpack_require__(/*! ./node_untyped */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js\");\nObject.defineProperty(exports, \"NodeHttpClient\", ({ enumerable: true, get: function () { return node_untyped_2.NodeHttpClient; } }));\nObject.defineProperty(exports, \"httpsAgentCache\", ({ enumerable: true, get: function () { return node_untyped_2.httpsAgentCache; } }));\nObject.defineProperty(exports, \"isBypassProxy\", ({ enumerable: true, get: function () { return node_untyped_2.isBypassProxy; } }));\n/**\n * Work In Progress TypeScript migration for http/node_untyped.js\n */\nfunction getProxyAgent(config) {\n    const { proxyOptions, connectionConfig, parsedUrl, destination, mockAgent } = config;\n    return (0, node_untyped_1.getProxyAgent)(proxyOptions, parsedUrl, destination, mockAgent, connectionConfig);\n}\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCO0FBQ3hFLHFCQUFxQjtBQUNyQix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQzdDLGtEQUFpRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNsSSxtREFBa0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDcEksaURBQWdELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRUFBb0U7QUFDaEY7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL25vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQnlwYXNzUHJveHkgPSBleHBvcnRzLmh0dHBzQWdlbnRDYWNoZSA9IGV4cG9ydHMuTm9kZUh0dHBDbGllbnQgPSB2b2lkIDA7XG5leHBvcnRzLmdldFByb3h5QWdlbnQgPSBnZXRQcm94eUFnZW50O1xuY29uc3Qgbm9kZV91bnR5cGVkXzEgPSByZXF1aXJlKFwiLi9ub2RlX3VudHlwZWRcIik7XG52YXIgbm9kZV91bnR5cGVkXzIgPSByZXF1aXJlKFwiLi9ub2RlX3VudHlwZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb2RlSHR0cENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZV91bnR5cGVkXzIuTm9kZUh0dHBDbGllbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJodHRwc0FnZW50Q2FjaGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vZGVfdW50eXBlZF8yLmh0dHBzQWdlbnRDYWNoZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnlwYXNzUHJveHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vZGVfdW50eXBlZF8yLmlzQnlwYXNzUHJveHk7IH0gfSk7XG4vKipcbiAqIFdvcmsgSW4gUHJvZ3Jlc3MgVHlwZVNjcmlwdCBtaWdyYXRpb24gZm9yIGh0dHAvbm9kZV91bnR5cGVkLmpzXG4gKi9cbmZ1bmN0aW9uIGdldFByb3h5QWdlbnQoY29uZmlnKSB7XG4gICAgY29uc3QgeyBwcm94eU9wdGlvbnMsIGNvbm5lY3Rpb25Db25maWcsIHBhcnNlZFVybCwgZGVzdGluYXRpb24sIG1vY2tBZ2VudCB9ID0gY29uZmlnO1xuICAgIHJldHVybiAoMCwgbm9kZV91bnR5cGVkXzEuZ2V0UHJveHlBZ2VudCkocHJveHlPcHRpb25zLCBwYXJzZWRVcmwsIGRlc3RpbmF0aW9uLCBtb2NrQWdlbnQsIGNvbm5lY3Rpb25Db25maWcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\");\nconst Base = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/base.js\");\nconst HttpsOcspAgent = __webpack_require__(/*! ../agent/https_ocsp_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_ocsp_agent.js\");\nconst HttpsCrlAgent = (__webpack_require__(/*! ../agent/https_crl_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_crl_agent.js\")[\"default\"]);\nconst HttpsProxyAgent = __webpack_require__(/*! ../agent/https_proxy_agent */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/https_proxy_agent.js\");\nconst HttpAgent = (__webpack_require__(/*! http */ \"http\").Agent);\nconst GlobalConfig = __webpack_require__(/*! ../../lib/global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst RequestUtil = __webpack_require__(/*! ../http/request_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js\");\nconst { isCrlValidationEnabled } = __webpack_require__(/*! ../agent/crl_validator */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/agent/crl_validator.js\");\n/**\n * Returns the delay time calculated by exponential backoff with\n * decorrelated jitter. For more details, check out:\n * http://www.awsarchitectureblog.com/2015/03/backoff.html\n * @return  {Number} number of milliseconds to wait before retrying again the request.\n */\nNodeHttpClient.prototype.constructExponentialBackoffStrategy = function () {\n    Logger.getInstance().trace('Calculating exponential backoff strategy');\n    const previousSleepTime = this._connectionConfig.getRetrySfStartingSleepTime();\n    // maximum seconds\n    const cap = this._connectionConfig.getRetrySfMaxSleepTime();\n    // minimum seconds\n    const base = 1;\n    const nextSleepTime = Util.nextSleepTime(base, cap, previousSleepTime);\n    const nextSleepTimeInMilliseconds = nextSleepTime * 1000;\n    Logger.getInstance().trace('Calculated exponential backoff strategy sleep time: %d', nextSleepTimeInMilliseconds);\n    return nextSleepTimeInMilliseconds;\n};\n/**\n * Creates a client that can be used to make requests in Node.js.\n *\n * @param {ConnectionConfig} connectionConfig\n * @constructor\n */\nfunction NodeHttpClient(connectionConfig) {\n    Logger.getInstance().trace('Initializing NodeHttpClient with Connection Config[%s]', connectionConfig.describeIdentityAttributes());\n    Base.apply(this, [connectionConfig]);\n}\nUtil.inherits(NodeHttpClient, Base);\nconst httpsAgentCache = new Map();\nfunction getFromCacheOrCreate(AgentClass, options, agentId) {\n    Logger.getInstance().trace('Agent[id: %s] - trying to retrieve from cache or create.', agentId);\n    let agent = {};\n    function createAgent(AgentClass, agentOptions, agentId) {\n        Logger.getInstance().trace('Agent[id: %s] - creating a new agent instance.', agentId);\n        const agent = new AgentClass(agentOptions);\n        httpsAgentCache.set(agentId, agent);\n        Logger.getInstance().trace('Agent[id: %s] - new instance stored in cache.', agentId);\n        // detect and log PROXY envvar + agent proxy settings\n        const compareAndLogEnvAndAgentProxies = ProxyUtil.getCompareAndLogEnvAndAgentProxies(agentOptions);\n        Logger.getInstance().debug('Agent[id: %s] - proxy settings used in requests: %s', agentId, compareAndLogEnvAndAgentProxies.messages);\n        // if there's anything to warn on (e.g. both envvar + agent proxy used, and they are different)\n        // log warnings on them\n        if (compareAndLogEnvAndAgentProxies.warnings) {\n            Logger.getInstance().warn('Agent[id: %s] - %s', agentId, compareAndLogEnvAndAgentProxies.warnings);\n        }\n        return agent;\n    }\n    if (httpsAgentCache.has(agentId)) {\n        Logger.getInstance().trace('Agent[id: %s] - retrieving an agent instance from cache.', agentId);\n        agent = httpsAgentCache.get(agentId);\n    }\n    else {\n        agent = createAgent(AgentClass, options, agentId);\n    }\n    return agent;\n}\nfunction enrichAgentOptionsWithProxyConfig(agentOptions, proxy) {\n    agentOptions.host = proxy.host;\n    agentOptions.port = proxy.port;\n    agentOptions.protocol = proxy.protocol;\n    agentOptions.useForOCSP = proxy.useForOCSP;\n    agentOptions.noProxy = proxy.noProxy;\n    if (proxy.user && proxy.password) {\n        agentOptions.user = proxy.user;\n        agentOptions.password = proxy.password;\n    }\n}\nfunction isBypassProxy(proxy, destination, agentId) {\n    const matches = ProxyUtil.isByPassProxy(proxy, destination);\n    if (matches) {\n        Logger.getInstance().debug('Agent[id: %s] - bypassing proxy allowed for destination: %s', agentId, destination);\n        return true;\n    }\n    return false;\n}\n/**\n * @inheritDoc\n */\nNodeHttpClient.prototype.getAgent = function (parsedUrl, proxy, mock) {\n    Logger.getInstance().trace('Agent[url: %s] - getting an agent instance.', RequestUtil.describeURL(parsedUrl.href));\n    if (!proxy && GlobalConfig.isEnvProxyActive()) {\n        const isHttps = parsedUrl.protocol === 'https:';\n        proxy = ProxyUtil.getProxyFromEnv(isHttps);\n        if (proxy) {\n            Logger.getInstance().debug('Agent[url: %s] - proxy info loaded from the environment variable. Proxy host: %s', RequestUtil.describeURL(parsedUrl.href), proxy.host);\n        }\n    }\n    return getProxyAgent(proxy, parsedUrl, parsedUrl.href, mock, this._connectionConfig);\n};\nfunction getProxyAgent(proxyOptions, parsedUrl, destination, mock, connectionConfig) {\n    Logger.getInstance().trace('Agent[url: %s] - getting a proxy agent instance.', RequestUtil.describeURL(parsedUrl.href));\n    const agentOptions = {\n        protocol: parsedUrl.protocol,\n        hostname: parsedUrl.hostname,\n        keepAlive: GlobalConfig.getKeepAlive(),\n    };\n    if (mock) {\n        const mockAgent = mock.agentClass(agentOptions);\n        if (mockAgent.protocol === parsedUrl.protocol) {\n            Logger.getInstance().debug('Agent[url: %s] - the mock agent will be used.', RequestUtil.describeURL(parsedUrl.href));\n            return mockAgent;\n        }\n    }\n    const destHost = ProxyUtil.getHostFromURL(destination);\n    const agentId = createAgentId({\n        protocol: agentOptions.protocol,\n        hostname: agentOptions.hostname,\n        destination: destHost,\n        keepAlive: agentOptions.keepAlive,\n        connectionConfig,\n    });\n    Logger.getInstance().debug('Agent[id: %s] - the destination host is: %s.', agentId, destHost);\n    const bypassProxy = isBypassProxy(proxyOptions, destination, agentId);\n    let agent;\n    const isHttps = agentOptions.protocol === 'https:';\n    if (isHttps) {\n        agentOptions.crlValidatorConfig = connectionConfig.crlValidatorConfig;\n        if (proxyOptions && !bypassProxy) {\n            Logger.getInstance().trace('Agent[id: %s] - using HTTPS agent enriched with proxy options.', agentId);\n            enrichAgentOptionsWithProxyConfig(agentOptions, proxyOptions);\n            agent = getFromCacheOrCreate(HttpsProxyAgent, agentOptions, agentId);\n        }\n        else {\n            const AgentClass = isCrlValidationEnabled(connectionConfig.crlValidatorConfig)\n                ? HttpsCrlAgent\n                : HttpsOcspAgent;\n            Logger.getInstance().trace(`Agent[id: %s] - using ${AgentClass.name} agent without proxy.`, agentId);\n            agent = getFromCacheOrCreate(AgentClass, agentOptions, agentId);\n        }\n    }\n    else if (proxyOptions && !bypassProxy) {\n        Logger.getInstance().trace('Agent[id: %s] - using HTTP agent enriched with proxy options.', agentId);\n        enrichAgentOptionsWithProxyConfig(agentOptions, proxyOptions);\n        agent = getFromCacheOrCreate(HttpAgent, agentOptions, agentId);\n    }\n    else {\n        Logger.getInstance().trace('Agent[id: %s] - using HTTP agent without proxy.', agentId);\n        agent = getFromCacheOrCreate(HttpAgent, agentOptions, agentId);\n    }\n    return agent;\n}\nfunction createAgentId({ protocol, hostname, destination, keepAlive, connectionConfig }) {\n    return [\n        protocol,\n        hostname,\n        destination,\n        keepAlive ? 'keepAlive' : 'noKeepAlive',\n        `crl:${connectionConfig.crlValidatorConfig.checkMode}`,\n    ].join('-');\n}\nmodule.exports = { NodeHttpClient, getProxyAgent, isBypassProxy, httpsAgentCache };\n//# sourceMappingURL=node_untyped.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL25vZGVfdW50eXBlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUN6QyxhQUFhLG1CQUFPLENBQUMsd0VBQVE7QUFDN0IsdUJBQXVCLG1CQUFPLENBQUMsd0dBQTJCO0FBQzFELHNCQUFzQix3SUFBMkM7QUFDakUsd0JBQXdCLG1CQUFPLENBQUMsMEdBQTRCO0FBQzVELGtCQUFrQiwrQ0FBcUI7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDbEQsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLGtHQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUE4RDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvaHR0cC9ub2RlX3VudHlwZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgUHJveHlVdGlsID0gcmVxdWlyZSgnLi4vcHJveHlfdXRpbCcpO1xuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY29uc3QgSHR0cHNPY3NwQWdlbnQgPSByZXF1aXJlKCcuLi9hZ2VudC9odHRwc19vY3NwX2FnZW50Jyk7XG5jb25zdCBIdHRwc0NybEFnZW50ID0gcmVxdWlyZSgnLi4vYWdlbnQvaHR0cHNfY3JsX2FnZW50JykuZGVmYXVsdDtcbmNvbnN0IEh0dHBzUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4uL2FnZW50L2h0dHBzX3Byb3h5X2FnZW50Jyk7XG5jb25zdCBIdHRwQWdlbnQgPSByZXF1aXJlKCdodHRwJykuQWdlbnQ7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi8uLi9saWIvZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBSZXF1ZXN0VXRpbCA9IHJlcXVpcmUoJy4uL2h0dHAvcmVxdWVzdF91dGlsJyk7XG5jb25zdCB7IGlzQ3JsVmFsaWRhdGlvbkVuYWJsZWQgfSA9IHJlcXVpcmUoJy4uL2FnZW50L2NybF92YWxpZGF0b3InKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVsYXkgdGltZSBjYWxjdWxhdGVkIGJ5IGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aFxuICogZGVjb3JyZWxhdGVkIGppdHRlci4gRm9yIG1vcmUgZGV0YWlscywgY2hlY2sgb3V0OlxuICogaHR0cDovL3d3dy5hd3NhcmNoaXRlY3R1cmVibG9nLmNvbS8yMDE1LzAzL2JhY2tvZmYuaHRtbFxuICogQHJldHVybiAge051bWJlcn0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXRyeWluZyBhZ2FpbiB0aGUgcmVxdWVzdC5cbiAqL1xuTm9kZUh0dHBDbGllbnQucHJvdG90eXBlLmNvbnN0cnVjdEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDYWxjdWxhdGluZyBleHBvbmVudGlhbCBiYWNrb2ZmIHN0cmF0ZWd5Jyk7XG4gICAgY29uc3QgcHJldmlvdXNTbGVlcFRpbWUgPSB0aGlzLl9jb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZTdGFydGluZ1NsZWVwVGltZSgpO1xuICAgIC8vIG1heGltdW0gc2Vjb25kc1xuICAgIGNvbnN0IGNhcCA9IHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heFNsZWVwVGltZSgpO1xuICAgIC8vIG1pbmltdW0gc2Vjb25kc1xuICAgIGNvbnN0IGJhc2UgPSAxO1xuICAgIGNvbnN0IG5leHRTbGVlcFRpbWUgPSBVdGlsLm5leHRTbGVlcFRpbWUoYmFzZSwgY2FwLCBwcmV2aW91c1NsZWVwVGltZSk7XG4gICAgY29uc3QgbmV4dFNsZWVwVGltZUluTWlsbGlzZWNvbmRzID0gbmV4dFNsZWVwVGltZSAqIDEwMDA7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0NhbGN1bGF0ZWQgZXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneSBzbGVlcCB0aW1lOiAlZCcsIG5leHRTbGVlcFRpbWVJbk1pbGxpc2Vjb25kcyk7XG4gICAgcmV0dXJuIG5leHRTbGVlcFRpbWVJbk1pbGxpc2Vjb25kcztcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBjbGllbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIHJlcXVlc3RzIGluIE5vZGUuanMuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9uQ29uZmlnfSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTm9kZUh0dHBDbGllbnQoY29ubmVjdGlvbkNvbmZpZykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdJbml0aWFsaXppbmcgTm9kZUh0dHBDbGllbnQgd2l0aCBDb25uZWN0aW9uIENvbmZpZ1slc10nLCBjb25uZWN0aW9uQ29uZmlnLmRlc2NyaWJlSWRlbnRpdHlBdHRyaWJ1dGVzKCkpO1xuICAgIEJhc2UuYXBwbHkodGhpcywgW2Nvbm5lY3Rpb25Db25maWddKTtcbn1cblV0aWwuaW5oZXJpdHMoTm9kZUh0dHBDbGllbnQsIEJhc2UpO1xuY29uc3QgaHR0cHNBZ2VudENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0RnJvbUNhY2hlT3JDcmVhdGUoQWdlbnRDbGFzcywgb3B0aW9ucywgYWdlbnRJZCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gdHJ5aW5nIHRvIHJldHJpZXZlIGZyb20gY2FjaGUgb3IgY3JlYXRlLicsIGFnZW50SWQpO1xuICAgIGxldCBhZ2VudCA9IHt9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZW50KEFnZW50Q2xhc3MsIGFnZW50T3B0aW9ucywgYWdlbnRJZCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbaWQ6ICVzXSAtIGNyZWF0aW5nIGEgbmV3IGFnZW50IGluc3RhbmNlLicsIGFnZW50SWQpO1xuICAgICAgICBjb25zdCBhZ2VudCA9IG5ldyBBZ2VudENsYXNzKGFnZW50T3B0aW9ucyk7XG4gICAgICAgIGh0dHBzQWdlbnRDYWNoZS5zZXQoYWdlbnRJZCwgYWdlbnQpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbaWQ6ICVzXSAtIG5ldyBpbnN0YW5jZSBzdG9yZWQgaW4gY2FjaGUuJywgYWdlbnRJZCk7XG4gICAgICAgIC8vIGRldGVjdCBhbmQgbG9nIFBST1hZIGVudnZhciArIGFnZW50IHByb3h5IHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGNvbXBhcmVBbmRMb2dFbnZBbmRBZ2VudFByb3hpZXMgPSBQcm94eVV0aWwuZ2V0Q29tcGFyZUFuZExvZ0VudkFuZEFnZW50UHJveGllcyhhZ2VudE9wdGlvbnMpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQWdlbnRbaWQ6ICVzXSAtIHByb3h5IHNldHRpbmdzIHVzZWQgaW4gcmVxdWVzdHM6ICVzJywgYWdlbnRJZCwgY29tcGFyZUFuZExvZ0VudkFuZEFnZW50UHJveGllcy5tZXNzYWdlcyk7XG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55dGhpbmcgdG8gd2FybiBvbiAoZS5nLiBib3RoIGVudnZhciArIGFnZW50IHByb3h5IHVzZWQsIGFuZCB0aGV5IGFyZSBkaWZmZXJlbnQpXG4gICAgICAgIC8vIGxvZyB3YXJuaW5ncyBvbiB0aGVtXG4gICAgICAgIGlmIChjb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzLndhcm5pbmdzKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdBZ2VudFtpZDogJXNdIC0gJXMnLCBhZ2VudElkLCBjb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzLndhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgfVxuICAgIGlmIChodHRwc0FnZW50Q2FjaGUuaGFzKGFnZW50SWQpKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gcmV0cmlldmluZyBhbiBhZ2VudCBpbnN0YW5jZSBmcm9tIGNhY2hlLicsIGFnZW50SWQpO1xuICAgICAgICBhZ2VudCA9IGh0dHBzQWdlbnRDYWNoZS5nZXQoYWdlbnRJZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhZ2VudCA9IGNyZWF0ZUFnZW50KEFnZW50Q2xhc3MsIG9wdGlvbnMsIGFnZW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gYWdlbnQ7XG59XG5mdW5jdGlvbiBlbnJpY2hBZ2VudE9wdGlvbnNXaXRoUHJveHlDb25maWcoYWdlbnRPcHRpb25zLCBwcm94eSkge1xuICAgIGFnZW50T3B0aW9ucy5ob3N0ID0gcHJveHkuaG9zdDtcbiAgICBhZ2VudE9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnQ7XG4gICAgYWdlbnRPcHRpb25zLnByb3RvY29sID0gcHJveHkucHJvdG9jb2w7XG4gICAgYWdlbnRPcHRpb25zLnVzZUZvck9DU1AgPSBwcm94eS51c2VGb3JPQ1NQO1xuICAgIGFnZW50T3B0aW9ucy5ub1Byb3h5ID0gcHJveHkubm9Qcm94eTtcbiAgICBpZiAocHJveHkudXNlciAmJiBwcm94eS5wYXNzd29yZCkge1xuICAgICAgICBhZ2VudE9wdGlvbnMudXNlciA9IHByb3h5LnVzZXI7XG4gICAgICAgIGFnZW50T3B0aW9ucy5wYXNzd29yZCA9IHByb3h5LnBhc3N3b3JkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQnlwYXNzUHJveHkocHJveHksIGRlc3RpbmF0aW9uLCBhZ2VudElkKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFByb3h5VXRpbC5pc0J5UGFzc1Byb3h5KHByb3h5LCBkZXN0aW5hdGlvbik7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0FnZW50W2lkOiAlc10gLSBieXBhc3NpbmcgcHJveHkgYWxsb3dlZCBmb3IgZGVzdGluYXRpb246ICVzJywgYWdlbnRJZCwgZGVzdGluYXRpb24pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5Ob2RlSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0QWdlbnQgPSBmdW5jdGlvbiAocGFyc2VkVXJsLCBwcm94eSwgbW9jaykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFt1cmw6ICVzXSAtIGdldHRpbmcgYW4gYWdlbnQgaW5zdGFuY2UuJywgUmVxdWVzdFV0aWwuZGVzY3JpYmVVUkwocGFyc2VkVXJsLmhyZWYpKTtcbiAgICBpZiAoIXByb3h5ICYmIEdsb2JhbENvbmZpZy5pc0VudlByb3h5QWN0aXZlKCkpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgIHByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5RnJvbUVudihpc0h0dHBzKTtcbiAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQWdlbnRbdXJsOiAlc10gLSBwcm94eSBpbmZvIGxvYWRlZCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS4gUHJveHkgaG9zdDogJXMnLCBSZXF1ZXN0VXRpbC5kZXNjcmliZVVSTChwYXJzZWRVcmwuaHJlZiksIHByb3h5Lmhvc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZXRQcm94eUFnZW50KHByb3h5LCBwYXJzZWRVcmwsIHBhcnNlZFVybC5ocmVmLCBtb2NrLCB0aGlzLl9jb25uZWN0aW9uQ29uZmlnKTtcbn07XG5mdW5jdGlvbiBnZXRQcm94eUFnZW50KHByb3h5T3B0aW9ucywgcGFyc2VkVXJsLCBkZXN0aW5hdGlvbiwgbW9jaywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFt1cmw6ICVzXSAtIGdldHRpbmcgYSBwcm94eSBhZ2VudCBpbnN0YW5jZS4nLCBSZXF1ZXN0VXRpbC5kZXNjcmliZVVSTChwYXJzZWRVcmwuaHJlZikpO1xuICAgIGNvbnN0IGFnZW50T3B0aW9ucyA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHBhcnNlZFVybC5wcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IHBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICAgICAga2VlcEFsaXZlOiBHbG9iYWxDb25maWcuZ2V0S2VlcEFsaXZlKCksXG4gICAgfTtcbiAgICBpZiAobW9jaykge1xuICAgICAgICBjb25zdCBtb2NrQWdlbnQgPSBtb2NrLmFnZW50Q2xhc3MoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgaWYgKG1vY2tBZ2VudC5wcm90b2NvbCA9PT0gcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQWdlbnRbdXJsOiAlc10gLSB0aGUgbW9jayBhZ2VudCB3aWxsIGJlIHVzZWQuJywgUmVxdWVzdFV0aWwuZGVzY3JpYmVVUkwocGFyc2VkVXJsLmhyZWYpKTtcbiAgICAgICAgICAgIHJldHVybiBtb2NrQWdlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVzdEhvc3QgPSBQcm94eVV0aWwuZ2V0SG9zdEZyb21VUkwoZGVzdGluYXRpb24pO1xuICAgIGNvbnN0IGFnZW50SWQgPSBjcmVhdGVBZ2VudElkKHtcbiAgICAgICAgcHJvdG9jb2w6IGFnZW50T3B0aW9ucy5wcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IGFnZW50T3B0aW9ucy5ob3N0bmFtZSxcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3RIb3N0LFxuICAgICAgICBrZWVwQWxpdmU6IGFnZW50T3B0aW9ucy5rZWVwQWxpdmUsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcsXG4gICAgfSk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0FnZW50W2lkOiAlc10gLSB0aGUgZGVzdGluYXRpb24gaG9zdCBpczogJXMuJywgYWdlbnRJZCwgZGVzdEhvc3QpO1xuICAgIGNvbnN0IGJ5cGFzc1Byb3h5ID0gaXNCeXBhc3NQcm94eShwcm94eU9wdGlvbnMsIGRlc3RpbmF0aW9uLCBhZ2VudElkKTtcbiAgICBsZXQgYWdlbnQ7XG4gICAgY29uc3QgaXNIdHRwcyA9IGFnZW50T3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgaWYgKGlzSHR0cHMpIHtcbiAgICAgICAgYWdlbnRPcHRpb25zLmNybFZhbGlkYXRvckNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWcuY3JsVmFsaWRhdG9yQ29uZmlnO1xuICAgICAgICBpZiAocHJveHlPcHRpb25zICYmICFieXBhc3NQcm94eSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSB1c2luZyBIVFRQUyBhZ2VudCBlbnJpY2hlZCB3aXRoIHByb3h5IG9wdGlvbnMuJywgYWdlbnRJZCk7XG4gICAgICAgICAgICBlbnJpY2hBZ2VudE9wdGlvbnNXaXRoUHJveHlDb25maWcoYWdlbnRPcHRpb25zLCBwcm94eU9wdGlvbnMpO1xuICAgICAgICAgICAgYWdlbnQgPSBnZXRGcm9tQ2FjaGVPckNyZWF0ZShIdHRwc1Byb3h5QWdlbnQsIGFnZW50T3B0aW9ucywgYWdlbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBBZ2VudENsYXNzID0gaXNDcmxWYWxpZGF0aW9uRW5hYmxlZChjb25uZWN0aW9uQ29uZmlnLmNybFZhbGlkYXRvckNvbmZpZylcbiAgICAgICAgICAgICAgICA/IEh0dHBzQ3JsQWdlbnRcbiAgICAgICAgICAgICAgICA6IEh0dHBzT2NzcEFnZW50O1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYEFnZW50W2lkOiAlc10gLSB1c2luZyAke0FnZW50Q2xhc3MubmFtZX0gYWdlbnQgd2l0aG91dCBwcm94eS5gLCBhZ2VudElkKTtcbiAgICAgICAgICAgIGFnZW50ID0gZ2V0RnJvbUNhY2hlT3JDcmVhdGUoQWdlbnRDbGFzcywgYWdlbnRPcHRpb25zLCBhZ2VudElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwcm94eU9wdGlvbnMgJiYgIWJ5cGFzc1Byb3h5KSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gdXNpbmcgSFRUUCBhZ2VudCBlbnJpY2hlZCB3aXRoIHByb3h5IG9wdGlvbnMuJywgYWdlbnRJZCk7XG4gICAgICAgIGVucmljaEFnZW50T3B0aW9uc1dpdGhQcm94eUNvbmZpZyhhZ2VudE9wdGlvbnMsIHByb3h5T3B0aW9ucyk7XG4gICAgICAgIGFnZW50ID0gZ2V0RnJvbUNhY2hlT3JDcmVhdGUoSHR0cEFnZW50LCBhZ2VudE9wdGlvbnMsIGFnZW50SWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSB1c2luZyBIVFRQIGFnZW50IHdpdGhvdXQgcHJveHkuJywgYWdlbnRJZCk7XG4gICAgICAgIGFnZW50ID0gZ2V0RnJvbUNhY2hlT3JDcmVhdGUoSHR0cEFnZW50LCBhZ2VudE9wdGlvbnMsIGFnZW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gYWdlbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVBZ2VudElkKHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBkZXN0aW5hdGlvbiwga2VlcEFsaXZlLCBjb25uZWN0aW9uQ29uZmlnIH0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBrZWVwQWxpdmUgPyAna2VlcEFsaXZlJyA6ICdub0tlZXBBbGl2ZScsXG4gICAgICAgIGBjcmw6JHtjb25uZWN0aW9uQ29uZmlnLmNybFZhbGlkYXRvckNvbmZpZy5jaGVja01vZGV9YCxcbiAgICBdLmpvaW4oJy0nKTtcbn1cbm1vZHVsZS5leHBvcnRzID0geyBOb2RlSHR0cENsaWVudCwgZ2V0UHJveHlBZ2VudCwgaXNCeXBhc3NQcm94eSwgaHR0cHNBZ2VudENhY2hlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlX3VudHlwZWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node_untyped.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/http/request_util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst LoggingUtil = __webpack_require__(/*! ../logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\");\nconst sfParams = __webpack_require__(/*! ../constants/sf_params */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js\");\n// Initial whitelist for attributes - they will be described with values\nconst DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES = [\n    'baseUrl',\n    'path',\n    'method',\n    sfParams.paramsNames.SF_REQUEST_ID,\n    sfParams.paramsNames.SF_REQUEST_GUID,\n    sfParams.paramsNames.SF_WAREHOUSE_NAME,\n    sfParams.paramsNames.SF_DB_NAME,\n    sfParams.paramsNames.SF_SCHEMA_NAME,\n];\n// Initial blacklist for attributes - described as present/not present only\nconst DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES = [sfParams.paramsNames.SF_TOKEN];\n// Helper function to resolve attributes arrays given defaults and overrides.\nfunction resolveAttributeList(defaultAttrs, overrideAttrs) {\n    return overrideAttrs || defaultAttrs;\n}\n/**\n * Describes a request based on its options.\n * Should work with not-yet-parsed options as well (before calling prepareRequestOptions method).\n *\n * @param {Object} requestOptions - Object representing the request data with top-level keys.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string representation of the request data.\n */\nfunction describeRequestFromOptions(requestOptions, { overrideAttributesDescribedWithValues, overrideAttributesDescribedWithoutValues } = {}) {\n    const describingAttributesWithValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES, overrideAttributesDescribedWithValues);\n    const describingAttributesWithoutValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES, overrideAttributesDescribedWithoutValues);\n    const { method, url, params } = requestOptions || {};\n    return describeRequestData({ method, url, params }, describingAttributesWithValues, describingAttributesWithoutValues);\n}\n/**\n * Creates a string that represents request data from a response.\n * Helps to identify the request that was the source of the response.\n *\n * @param {Object} response - Axios response object.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string representation of the request data.\n */\nfunction describeRequestFromResponse(response, { overrideAttributesDescribedWithValues, overrideAttributesDescribedWithoutValues } = {}) {\n    let method;\n    let url;\n    let params;\n    const responseConfig = response?.config;\n    const describingAttributesWithValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES, overrideAttributesDescribedWithValues);\n    const describingAttributesWithoutValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES, overrideAttributesDescribedWithoutValues);\n    if (responseConfig) {\n        method = responseConfig.method;\n        url = responseConfig.url;\n        params = responseConfig.params;\n    }\n    return describeRequestData({ method, url, params }, describingAttributesWithValues, describingAttributesWithoutValues);\n}\n/**\n * Constructs a string representation of request data.\n *\n * @param {Object} requestData - Object containing the method, url, and parameters.\n * @param {string} requestData.method - HTTP method.\n * @param {string} requestData.url - Request URL.\n * @param {Object} [requestData.params] - Additional query parameters.\n * @param {Array<string>} attributesWithValues - Attributes to describe with values.\n * @param {Array<string>} attributesWithoutValues - Attributes to describe without values.\n * @returns {string} A string describing the request data.\n */\nfunction describeRequestData({ method, url, params } = {}, attributesWithValues, attributesWithoutValues) {\n    const requestObject = {\n        // Ensure consistent casing for methods to match request-response pairs in logs.\n        method: method?.toUpperCase(),\n        ...constructURLData(url, params),\n    };\n    return LoggingUtil.describeAttributes(requestObject, attributesWithValues, attributesWithoutValues);\n}\n/**\n * Constructs an object representing URL data including the base URL, path, and query parameters.\n *\n * @param {string} url - The full URL.\n * @param {Object} [params] - Additional query parameters.\n * @returns {Object} Contains baseUrl, path, and merged query parameters.\n */\nfunction constructURLData(url, params = {}) {\n    if (!url) {\n        return { baseUrl: undefined, path: undefined, queryParams: {} };\n    }\n    const urlObj = new URL(url);\n    const queryParams = { ...params };\n    urlObj.searchParams.forEach((value, key) => {\n        queryParams[key] = value;\n    });\n    const baseUrl = `${urlObj.protocol}//${urlObj.hostname}${urlObj.port ? `:${urlObj.port}` : ''}`;\n    return {\n        baseUrl: baseUrl,\n        path: urlObj.pathname,\n        ...queryParams,\n    };\n}\n/**\n * @param {string} url - The URL to describe.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string describing the URL.\n */\nfunction describeURL(url, { overrideAttributesDescribedWithValues, overrideAttributesDescribedWithoutValues } = {}) {\n    const describingAttributesWithValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES, overrideAttributesDescribedWithValues);\n    const describingAttributesWithoutValues = resolveAttributeList(DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES, overrideAttributesDescribedWithoutValues);\n    const urlData = constructURLData(url);\n    return LoggingUtil.describeAttributes(urlData, describingAttributesWithValues, describingAttributesWithoutValues);\n}\nexports.DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES =\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES;\nexports.DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES =\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES;\nexports.describeRequestFromOptions = describeRequestFromOptions;\nexports.describeRequestFromResponse = describeRequestFromResponse;\nexports.describeURL = describeURL;\n//# sourceMappingURL=request_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL3JlcXVlc3RfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLGtHQUF3QjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxrR0FBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHNEQUFzRCxrRkFBa0YsSUFBSTtBQUM1STtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEMsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGlEQUFpRCxrRkFBa0YsSUFBSTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLCtCQUErQixzQkFBc0IsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsZ0JBQWdCLElBQUksZ0JBQWdCLEVBQUUsa0JBQWtCLFlBQVksT0FBTztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQSw0QkFBNEIsa0ZBQWtGLElBQUk7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9odHRwL3JlcXVlc3RfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IExvZ2dpbmdVdGlsID0gcmVxdWlyZSgnLi4vbG9nZ2VyL2xvZ2dpbmdfdXRpbCcpO1xuY29uc3Qgc2ZQYXJhbXMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvc2ZfcGFyYW1zJyk7XG4vLyBJbml0aWFsIHdoaXRlbGlzdCBmb3IgYXR0cmlidXRlcyAtIHRoZXkgd2lsbCBiZSBkZXNjcmliZWQgd2l0aCB2YWx1ZXNcbmNvbnN0IERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMgPSBbXG4gICAgJ2Jhc2VVcmwnLFxuICAgICdwYXRoJyxcbiAgICAnbWV0aG9kJyxcbiAgICBzZlBhcmFtcy5wYXJhbXNOYW1lcy5TRl9SRVFVRVNUX0lELFxuICAgIHNmUGFyYW1zLnBhcmFtc05hbWVzLlNGX1JFUVVFU1RfR1VJRCxcbiAgICBzZlBhcmFtcy5wYXJhbXNOYW1lcy5TRl9XQVJFSE9VU0VfTkFNRSxcbiAgICBzZlBhcmFtcy5wYXJhbXNOYW1lcy5TRl9EQl9OQU1FLFxuICAgIHNmUGFyYW1zLnBhcmFtc05hbWVzLlNGX1NDSEVNQV9OQU1FLFxuXTtcbi8vIEluaXRpYWwgYmxhY2tsaXN0IGZvciBhdHRyaWJ1dGVzIC0gZGVzY3JpYmVkIGFzIHByZXNlbnQvbm90IHByZXNlbnQgb25seVxuY29uc3QgREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUyA9IFtzZlBhcmFtcy5wYXJhbXNOYW1lcy5TRl9UT0tFTl07XG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcmVzb2x2ZSBhdHRyaWJ1dGVzIGFycmF5cyBnaXZlbiBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzLlxuZnVuY3Rpb24gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoZGVmYXVsdEF0dHJzLCBvdmVycmlkZUF0dHJzKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlQXR0cnMgfHwgZGVmYXVsdEF0dHJzO1xufVxuLyoqXG4gKiBEZXNjcmliZXMgYSByZXF1ZXN0IGJhc2VkIG9uIGl0cyBvcHRpb25zLlxuICogU2hvdWxkIHdvcmsgd2l0aCBub3QteWV0LXBhcnNlZCBvcHRpb25zIGFzIHdlbGwgKGJlZm9yZSBjYWxsaW5nIHByZXBhcmVSZXF1ZXN0T3B0aW9ucyBtZXRob2QpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9ucyAtIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgZGF0YSB3aXRoIHRvcC1sZXZlbCBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGRlc2NyaWJpbmcgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlc11cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXF1ZXN0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zLCB7IG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXMgfSA9IHt9KSB7XG4gICAgY29uc3QgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzID0gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIX1ZBTFVFUywgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlcyk7XG4gICAgY29uc3QgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRob3V0VmFsdWVzID0gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUywgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlcyk7XG4gICAgY29uc3QgeyBtZXRob2QsIHVybCwgcGFyYW1zIH0gPSByZXF1ZXN0T3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gZGVzY3JpYmVSZXF1ZXN0RGF0YSh7IG1ldGhvZCwgdXJsLCBwYXJhbXMgfSwgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzLCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyByZXF1ZXN0IGRhdGEgZnJvbSBhIHJlc3BvbnNlLlxuICogSGVscHMgdG8gaWRlbnRpZnkgdGhlIHJlcXVlc3QgdGhhdCB3YXMgdGhlIHNvdXJjZSBvZiB0aGUgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gQXhpb3MgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGRlc2NyaWJpbmcgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlc11cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXF1ZXN0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShyZXNwb25zZSwgeyBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzLCBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzIH0gPSB7fSkge1xuICAgIGxldCBtZXRob2Q7XG4gICAgbGV0IHVybDtcbiAgICBsZXQgcGFyYW1zO1xuICAgIGNvbnN0IHJlc3BvbnNlQ29uZmlnID0gcmVzcG9uc2U/LmNvbmZpZztcbiAgICBjb25zdCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhWYWx1ZXMgPSByZXNvbHZlQXR0cmlidXRlTGlzdChERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhfVkFMVUVTLCBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzKTtcbiAgICBjb25zdCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgPSByZXNvbHZlQXR0cmlidXRlTGlzdChERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhPVVRfVkFMVUVTLCBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzKTtcbiAgICBpZiAocmVzcG9uc2VDb25maWcpIHtcbiAgICAgICAgbWV0aG9kID0gcmVzcG9uc2VDb25maWcubWV0aG9kO1xuICAgICAgICB1cmwgPSByZXNwb25zZUNvbmZpZy51cmw7XG4gICAgICAgIHBhcmFtcyA9IHJlc3BvbnNlQ29uZmlnLnBhcmFtcztcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaWJlUmVxdWVzdERhdGEoeyBtZXRob2QsIHVybCwgcGFyYW1zIH0sIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aFZhbHVlcywgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRob3V0VmFsdWVzKTtcbn1cbi8qKlxuICogQ29uc3RydWN0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiByZXF1ZXN0IGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3REYXRhIC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1ldGhvZCwgdXJsLCBhbmQgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0RGF0YS5tZXRob2QgLSBIVFRQIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0RGF0YS51cmwgLSBSZXF1ZXN0IFVSTC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdERhdGEucGFyYW1zXSAtIEFkZGl0aW9uYWwgcXVlcnkgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc1dpdGhWYWx1ZXMgLSBBdHRyaWJ1dGVzIHRvIGRlc2NyaWJlIHdpdGggdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyAtIEF0dHJpYnV0ZXMgdG8gZGVzY3JpYmUgd2l0aG91dCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBkZXNjcmliaW5nIHRoZSByZXF1ZXN0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUmVxdWVzdERhdGEoeyBtZXRob2QsIHVybCwgcGFyYW1zIH0gPSB7fSwgYXR0cmlidXRlc1dpdGhWYWx1ZXMsIGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzKSB7XG4gICAgY29uc3QgcmVxdWVzdE9iamVjdCA9IHtcbiAgICAgICAgLy8gRW5zdXJlIGNvbnNpc3RlbnQgY2FzaW5nIGZvciBtZXRob2RzIHRvIG1hdGNoIHJlcXVlc3QtcmVzcG9uc2UgcGFpcnMgaW4gbG9ncy5cbiAgICAgICAgbWV0aG9kOiBtZXRob2Q/LnRvVXBwZXJDYXNlKCksXG4gICAgICAgIC4uLmNvbnN0cnVjdFVSTERhdGEodXJsLCBwYXJhbXMpLFxuICAgIH07XG4gICAgcmV0dXJuIExvZ2dpbmdVdGlsLmRlc2NyaWJlQXR0cmlidXRlcyhyZXF1ZXN0T2JqZWN0LCBhdHRyaWJ1dGVzV2l0aFZhbHVlcywgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMpO1xufVxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgVVJMIGRhdGEgaW5jbHVkaW5nIHRoZSBiYXNlIFVSTCwgcGF0aCwgYW5kIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBmdWxsIFVSTC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIEFkZGl0aW9uYWwgcXVlcnkgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IENvbnRhaW5zIGJhc2VVcmwsIHBhdGgsIGFuZCBtZXJnZWQgcXVlcnkgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0VVJMRGF0YSh1cmwsIHBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuIHsgYmFzZVVybDogdW5kZWZpbmVkLCBwYXRoOiB1bmRlZmluZWQsIHF1ZXJ5UGFyYW1zOiB7fSB9O1xuICAgIH1cbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7IC4uLnBhcmFtcyB9O1xuICAgIHVybE9iai5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBxdWVyeVBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3QgYmFzZVVybCA9IGAke3VybE9iai5wcm90b2NvbH0vLyR7dXJsT2JqLmhvc3RuYW1lfSR7dXJsT2JqLnBvcnQgPyBgOiR7dXJsT2JqLnBvcnR9YCA6ICcnfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZVVybDogYmFzZVVybCxcbiAgICAgICAgcGF0aDogdXJsT2JqLnBhdGhuYW1lLFxuICAgICAgICAuLi5xdWVyeVBhcmFtcyxcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byBkZXNjcmliZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBkZXNjcmliaW5nIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtvcHRpb25zLm92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXNdXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtvcHRpb25zLm92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBkZXNjcmliaW5nIHRoZSBVUkwuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlVVJMKHVybCwgeyBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzLCBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzIH0gPSB7fSkge1xuICAgIGNvbnN0IGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aFZhbHVlcyA9IHJlc29sdmVBdHRyaWJ1dGVMaXN0KERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXMpO1xuICAgIGNvbnN0IGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyA9IHJlc29sdmVBdHRyaWJ1dGVMaXN0KERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSE9VVF9WQUxVRVMsIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXMpO1xuICAgIGNvbnN0IHVybERhdGEgPSBjb25zdHJ1Y3RVUkxEYXRhKHVybCk7XG4gICAgcmV0dXJuIExvZ2dpbmdVdGlsLmRlc2NyaWJlQXR0cmlidXRlcyh1cmxEYXRhLCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhWYWx1ZXMsIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyk7XG59XG5leHBvcnRzLkRFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMgPVxuICAgIERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVM7XG5leHBvcnRzLkRFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSE9VVF9WQUxVRVMgPVxuICAgIERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSE9VVF9WQUxVRVM7XG5leHBvcnRzLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zID0gZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnM7XG5leHBvcnRzLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZSA9IGRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZTtcbmV4cG9ydHMuZGVzY3JpYmVVUkwgPSBkZXNjcmliZVVSTDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/http/request_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setInstance = setInstance;\nexports.getInstance = getInstance;\nconst browser_1 = __importDefault(__webpack_require__(/*! ./logger/browser */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/browser.js\"));\nlet instance;\n/**\n * Sets the logger instance. For internal use only.\n */\nfunction setInstance(newInstance) {\n    instance = newInstance;\n}\n/**\n * Returns the current logger instance.\n * @deprecated\n *\n * In TypeScript, use default import:\n * ```\n *  import Logger from './Logger';\n *  Logger().info(...)\n * ```\n *\n * In JavaScript, use:\n * ```\n *  const Logger = require('./Logger').default;\n *  Logger().info(...)\n * ```\n */\nfunction getInstance() {\n    // use the browser implementation of logger as the default implementation;\n    // we do this so that unit tests don't fail when the modules they're testing\n    // log messages\n    if (!instance) {\n        instance = new browser_1.default();\n    }\n    return instance;\n}\nexports[\"default\"] = () => getInstance();\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGtDQUFrQyxtQkFBTyxDQUFDLHVGQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvbG9nZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRJbnN0YW5jZSA9IHNldEluc3RhbmNlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuY29uc3QgYnJvd3Nlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xvZ2dlci9icm93c2VyXCIpKTtcbmxldCBpbnN0YW5jZTtcbi8qKlxuICogU2V0cyB0aGUgbG9nZ2VyIGluc3RhbmNlLiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKi9cbmZ1bmN0aW9uIHNldEluc3RhbmNlKG5ld0luc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UgPSBuZXdJbnN0YW5jZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2dnZXIgaW5zdGFuY2UuXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIEluIFR5cGVTY3JpcHQsIHVzZSBkZWZhdWx0IGltcG9ydDpcbiAqIGBgYFxuICogIGltcG9ydCBMb2dnZXIgZnJvbSAnLi9Mb2dnZXInO1xuICogIExvZ2dlcigpLmluZm8oLi4uKVxuICogYGBgXG4gKlxuICogSW4gSmF2YVNjcmlwdCwgdXNlOlxuICogYGBgXG4gKiAgY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKS5kZWZhdWx0O1xuICogIExvZ2dlcigpLmluZm8oLi4uKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICAgIC8vIHVzZSB0aGUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBsb2dnZXIgYXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb247XG4gICAgLy8gd2UgZG8gdGhpcyBzbyB0aGF0IHVuaXQgdGVzdHMgZG9uJ3QgZmFpbCB3aGVuIHRoZSBtb2R1bGVzIHRoZXkncmUgdGVzdGluZ1xuICAgIC8vIGxvZyBtZXNzYWdlc1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgYnJvd3Nlcl8xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gKCkgPT4gZ2V0SW5zdGFuY2UoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/browser.js":
/*!***************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/browser.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\n/**\n * Creates a new Logger instance for when we're running in the browser.\n *\n * @param {Object} [options]\n *\n * @constructor\n */\nfunction Logger(options) {\n    /**\n     * The array to which all log messages will be added.\n     *\n     * @type {String[]}\n     */\n    const buffer = [];\n    /**\n     * Logs a message at a given level.\n     *\n     * @param {String} levelTag the tag associated with the level at which to log\n     *   the message.\n     * @param {String} message the message to log.\n     * @param {Number} bufferMaxLength the maximum size to which the message\n     *   buffer can grow.\n     */\n    const logMessage = function (levelTag, message, bufferMaxLength) {\n        // add the log level tag (e.g. info, warn, etc.) to the front of the message\n        message = Util.format('%s: %s', levelTag, message);\n        // if the buffer is full, evict old messages\n        while (buffer.length >= bufferMaxLength) {\n            buffer.shift();\n        }\n        // add the new message to the buffer\n        buffer.push(message);\n    };\n    // create an inner implementation to which all our methods will be forwarded\n    const common = Core.createLogger(options, logMessage);\n    /**\n     * Configures this logger.\n     *\n     * @param {Object} options\n     */\n    this.configure = function (options) {\n        common.configure(options);\n    };\n    /**\n     * Returns the current log level.\n     *\n     * @returns {Number}\n     */\n    this.getLevel = function () {\n        return common.getLevelNumber();\n    };\n    /**\n     * Logs a given message at the error level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.error = function (message, ...params) {\n        common.error.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the warning level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.warn = function (message, ...params) {\n        common.warn.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the info level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.info = function (message, ...params) {\n        common.info.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the debug level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.debug = function (message, ...params) {\n        common.debug.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the trace level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.trace = function (message, ...params) {\n        common.trace.apply(common, [message, ...params]);\n    };\n    /**\n     * Returns the log buffer.\n     *\n     * @returns {String[]}\n     */\n    this.getLogBuffer = function () {\n        // return a copy of the buffer array; calling slice() shallow-copies the\n        // original array, but that's sufficient in this case because the array\n        // contains strings\n        return buffer.slice();\n    };\n}\nmodule.exports = Logger;\n//# sourceMappingURL=browser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsMEVBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL2xvZ2dlci9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMb2dnZXIgaW5zdGFuY2UgZm9yIHdoZW4gd2UncmUgcnVubmluZyBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvZ2dlcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IHRvIHdoaWNoIGFsbCBsb2cgbWVzc2FnZXMgd2lsbCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxldmVsVGFnIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBsZXZlbCBhdCB3aGljaCB0byBsb2dcbiAgICAgKiAgIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGxvZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYnVmZmVyTWF4TGVuZ3RoIHRoZSBtYXhpbXVtIHNpemUgdG8gd2hpY2ggdGhlIG1lc3NhZ2VcbiAgICAgKiAgIGJ1ZmZlciBjYW4gZ3Jvdy5cbiAgICAgKi9cbiAgICBjb25zdCBsb2dNZXNzYWdlID0gZnVuY3Rpb24gKGxldmVsVGFnLCBtZXNzYWdlLCBidWZmZXJNYXhMZW5ndGgpIHtcbiAgICAgICAgLy8gYWRkIHRoZSBsb2cgbGV2ZWwgdGFnIChlLmcuIGluZm8sIHdhcm4sIGV0Yy4pIHRvIHRoZSBmcm9udCBvZiB0aGUgbWVzc2FnZVxuICAgICAgICBtZXNzYWdlID0gVXRpbC5mb3JtYXQoJyVzOiAlcycsIGxldmVsVGFnLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gaWYgdGhlIGJ1ZmZlciBpcyBmdWxsLCBldmljdCBvbGQgbWVzc2FnZXNcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPj0gYnVmZmVyTWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBidWZmZXJcbiAgICAgICAgYnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gICAgfTtcbiAgICAvLyBjcmVhdGUgYW4gaW5uZXIgaW1wbGVtZW50YXRpb24gdG8gd2hpY2ggYWxsIG91ciBtZXRob2RzIHdpbGwgYmUgZm9yd2FyZGVkXG4gICAgY29uc3QgY29tbW9uID0gQ29yZS5jcmVhdGVMb2dnZXIob3B0aW9ucywgbG9nTWVzc2FnZSk7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGlzIGxvZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBjb21tb24uY29uZmlndXJlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb24uZ2V0TGV2ZWxOdW1iZXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBlcnJvciBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi5lcnJvci5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB3YXJuaW5nIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24ud2Fybi5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBpbmZvIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24uaW5mby5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSBkZWJ1ZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMuZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi5kZWJ1Zy5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB0cmFjZSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMudHJhY2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbW1vbi50cmFjZS5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvZyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5nZXRMb2dCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGJ1ZmZlciBhcnJheTsgY2FsbGluZyBzbGljZSgpIHNoYWxsb3ctY29waWVzIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCBhcnJheSwgYnV0IHRoYXQncyBzdWZmaWNpZW50IGluIHRoaXMgY2FzZSBiZWNhdXNlIHRoZSBhcnJheVxuICAgICAgICAvLyBjb250YWlucyBzdHJpbmdzXG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/core.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst SecretDetector = new (__webpack_require__(/*! ../secret_detector.js */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/secret_detector.js\"))();\nconst LOG_LEVEL_OFF = {\n    tag: 'OFF',\n    level: -1,\n};\nconst LOG_LEVEL_ERROR = {\n    tag: 'ERROR',\n    level: 0,\n};\nconst LOG_LEVEL_WARN = {\n    tag: 'WARN',\n    level: 1,\n};\nconst LOG_LEVEL_INFO = {\n    tag: 'INFO',\n    level: 2,\n};\nconst LOG_LEVEL_DEBUG = {\n    tag: 'DEBUG',\n    level: 3,\n};\nconst LOG_LEVEL_TRACE = {\n    tag: 'TRACE',\n    level: 4,\n};\nconst LOG_LEVELS = [\n    LOG_LEVEL_OFF,\n    LOG_LEVEL_ERROR,\n    LOG_LEVEL_WARN,\n    LOG_LEVEL_INFO,\n    LOG_LEVEL_DEBUG,\n    LOG_LEVEL_TRACE,\n];\nconst LOG_LEVEL_TAGS = {\n    OFF: LOG_LEVEL_OFF.tag,\n    ERROR: LOG_LEVEL_ERROR.tag,\n    WARN: LOG_LEVEL_WARN.tag,\n    INFO: LOG_LEVEL_INFO.tag,\n    DEBUG: LOG_LEVEL_DEBUG.tag,\n    TRACE: LOG_LEVEL_TRACE.tag,\n};\nexports.LOG_LEVEL_TAGS = LOG_LEVEL_TAGS;\n// create two maps, one in which the key is the log level and the value is the\n// corresponding log level object, and another in which the key is the log tag\n// and the value is the corresponding log level\nconst MAP_LOG_LEVEL_TO_OBJECT = {};\nconst MAP_LOG_TAG_TO_LEVEL = {};\nfor (let index = 0, length = LOG_LEVELS.length; index < length; index++) {\n    const logLevelObject = LOG_LEVELS[index];\n    MAP_LOG_LEVEL_TO_OBJECT[logLevelObject.level] = logLevelObject;\n    MAP_LOG_TAG_TO_LEVEL[logLevelObject.tag] = logLevelObject.level;\n}\nconst DEFAULT_BUFFER_MAX_LENGTH = 500;\nconst DEFAULT_MESSAGE_MAX_LENGTH = 500;\nconst DEFAULT_LEVEL = LOG_LEVEL_INFO;\n/**\n * Creates a new Logger instance.\n *\n * @param options {Object}\n * @param logMessage {Function}\n * @param reconfigureOperation {Function} Action to perform to change log destination file\n *\n * @returns {Object}\n */\nexports.createLogger = function (options, logMessage, reconfigureOperation) {\n    // a log function must be specified\n    Errors.assertInternal(Util.isFunction(logMessage));\n    /**\n     * Whether to include the current timestamp in the log message.\n     */\n    let includeTimestamp;\n    /**\n     * The maximum size (in terms of number of messages) to which the log buffer\n     * can grow.\n     *\n     * @type {Number}\n     */\n    let bufferMaxLength;\n    /**\n     * The maximum message length. Longer messages will be truncated.\n     *\n     * @type {Number}\n     */\n    let messageMaxLength;\n    /**\n     * The current log level. Any message logged at a lower level won't be added\n     * to the log buffer.\n     *\n     * @type {Object}\n     */\n    let currlevelObject;\n    // create a new logger instance\n    const logger = {\n        /**\n         * Configures this logger.\n         *\n         * @param {Object} options\n         */\n        configure: function (options) {\n            let localIncludeTimestamp;\n            let localBufferMaxLength;\n            let localMessageMaxLength;\n            let localLevel;\n            let localFilePath;\n            let localAdditionalLogToConsole;\n            // if an options argument is specified\n            if (Util.exists(options)) {\n                // make sure it's an object\n                Errors.assertInternal(Util.isObject(options));\n                localIncludeTimestamp = options.includeTimestamp;\n                localBufferMaxLength = options.bufferMaxLength;\n                localMessageMaxLength = options.messageMaxLength;\n                localLevel = options.level;\n                localFilePath = options.filePath;\n                localAdditionalLogToConsole = options.additionalLogToConsole;\n            }\n            // if an includeTimestamp options is specified, convert it to a boolean\n            if (Util.exists(localIncludeTimestamp)) {\n                includeTimestamp = !!localIncludeTimestamp;\n            }\n            else if (!Util.exists(includeTimestamp)) {\n                // default to true\n                includeTimestamp = true;\n            }\n            // if a bufferMaxLength option is specified, make sure\n            // it's a positive integer before updating the logger option\n            if (Util.exists(localBufferMaxLength)) {\n                Errors.assertInternal(Util.number.isPositiveInteger(localBufferMaxLength));\n                bufferMaxLength = localBufferMaxLength;\n            }\n            else if (!Util.exists(bufferMaxLength)) {\n                // initialize logger option if configure() hasn't been called before\n                bufferMaxLength = DEFAULT_BUFFER_MAX_LENGTH;\n            }\n            // if a messageMaxLength option is specified, make sure\n            // it's a positive integer before updating the logger option\n            if (Util.exists(localMessageMaxLength)) {\n                Errors.assertInternal(Util.number.isPositiveInteger(localMessageMaxLength));\n                messageMaxLength = localMessageMaxLength;\n            }\n            else if (!Util.exists(messageMaxLength)) {\n                // initialize logger option if configure() hasn't been called before\n                messageMaxLength = DEFAULT_MESSAGE_MAX_LENGTH;\n            }\n            // if a level option is specified, make sure\n            // it's valid before updating the logger option\n            if (Util.exists(localLevel)) {\n                Errors.assertInternal(Object.prototype.hasOwnProperty.call(MAP_LOG_LEVEL_TO_OBJECT, localLevel));\n                currlevelObject = MAP_LOG_LEVEL_TO_OBJECT[localLevel];\n            }\n            else if (!Util.exists(currlevelObject)) {\n                // initialize logger option if configure() hasn't been called before\n                currlevelObject = DEFAULT_LEVEL;\n            }\n            if (Util.isFunction(reconfigureOperation)) {\n                reconfigureOperation(localFilePath, localAdditionalLogToConsole);\n            }\n        },\n        /**\n         * Logs a given message at the error level.\n         *\n         * @param {String} message\n         */\n        error: function (message) {\n            log(LOG_LEVEL_ERROR, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the warn level.\n         *\n         * @param {String} message\n         */\n        warn: function (message) {\n            log(LOG_LEVEL_WARN, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the info level.\n         *\n         * @param {String} message\n         */\n        info: function (message) {\n            log(LOG_LEVEL_INFO, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the debug level.\n         *\n         * @param {String} message\n         */\n        debug: function (message) {\n            log(LOG_LEVEL_DEBUG, message, getMessageArgs(arguments));\n        },\n        /**\n         * Logs a given message at the trace level.\n         *\n         * @param {String} message\n         */\n        trace: function (message) {\n            log(LOG_LEVEL_TRACE, message, getMessageArgs(arguments));\n        },\n        /**\n         * Returns the log buffer.\n         *\n         * @returns {String[]}\n         */\n        getLogBuffer: function () {\n            return [];\n        },\n        /**\n         * Returns the level number associated with the current log level.\n         *\n         * @returns {Number}\n         */\n        getLevelNumber: function () {\n            return currlevelObject.level;\n        },\n        /**\n         * Returns the tag associated with the current log level.\n         *\n         * @returns {String}\n         */\n        getLevelTag: function () {\n            return currlevelObject.tag;\n        },\n        /**\n         * Returns a map in which the keys are the level tags and the values are the\n         * corresponding log levels.\n         *\n         * @returns {Object}\n         */\n        getLevelTagsMap: function () {\n            return MAP_LOG_TAG_TO_LEVEL;\n        },\n    };\n    // configure the logger\n    logger.configure(options);\n    /**\n     * Logs a message at a given level.\n     *\n     * @param {Object} targetLevelObject the level at which to log the message.\n     * @param {String} message the message template.\n     * @param {String[]} messageArgs any arguments to substitute into the message.\n     */\n    const log = function (targetLevelObject, message, messageArgs) {\n        // the message should not be logged if the target\n        // level is more verbose than the current level\n        if (targetLevelObject.level <= currlevelObject.level) {\n            // substitute the messageArgs into the message template\n            messageArgs.unshift(message);\n            message = Util.format.apply(Util, messageArgs);\n            // truncate the message if it's too long\n            if (message.length > messageMaxLength) {\n                message = message.slice(0, messageMaxLength);\n            }\n            // if needed, add the current time to the front of the message\n            if (includeTimestamp) {\n                message = Util.format('[%s]: %s', moment().format('h:mm:ss.SSS A'), message);\n            }\n            // mask secrets\n            message = SecretDetector.maskSecrets(message).maskedtxt;\n            // log the message\n            logMessage(targetLevelObject.tag, message, bufferMaxLength);\n        }\n    };\n    return logger;\n};\nexports.isValidLogTag = function (logTag) {\n    if (!Util.isString(logTag)) {\n        return false;\n    }\n    return Object.prototype.hasOwnProperty.call(MAP_LOG_TAG_TO_LEVEL, logTag.toUpperCase());\n};\nexports.logTagToLevel = function (logTag) {\n    Errors.assertInternal(Util.isString(logTag));\n    return MAP_LOG_TAG_TO_LEVEL[logTag.toUpperCase()];\n};\n/**\n * Helper method to extract the messageArgs from the arguments passed to\n * trace(), debug(), info(), warn() and error().\n *\n * @param {Object} args\n *\n * @returns {*}\n */\nfunction getMessageArgs(args) {\n    return Array.prototype.slice.call(args, 1);\n}\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvY29yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLDZGQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvbG9nZ2VyL2NvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFNlY3JldERldGVjdG9yID0gbmV3IChyZXF1aXJlKCcuLi9zZWNyZXRfZGV0ZWN0b3IuanMnKSkoKTtcbmNvbnN0IExPR19MRVZFTF9PRkYgPSB7XG4gICAgdGFnOiAnT0ZGJyxcbiAgICBsZXZlbDogLTEsXG59O1xuY29uc3QgTE9HX0xFVkVMX0VSUk9SID0ge1xuICAgIHRhZzogJ0VSUk9SJyxcbiAgICBsZXZlbDogMCxcbn07XG5jb25zdCBMT0dfTEVWRUxfV0FSTiA9IHtcbiAgICB0YWc6ICdXQVJOJyxcbiAgICBsZXZlbDogMSxcbn07XG5jb25zdCBMT0dfTEVWRUxfSU5GTyA9IHtcbiAgICB0YWc6ICdJTkZPJyxcbiAgICBsZXZlbDogMixcbn07XG5jb25zdCBMT0dfTEVWRUxfREVCVUcgPSB7XG4gICAgdGFnOiAnREVCVUcnLFxuICAgIGxldmVsOiAzLFxufTtcbmNvbnN0IExPR19MRVZFTF9UUkFDRSA9IHtcbiAgICB0YWc6ICdUUkFDRScsXG4gICAgbGV2ZWw6IDQsXG59O1xuY29uc3QgTE9HX0xFVkVMUyA9IFtcbiAgICBMT0dfTEVWRUxfT0ZGLFxuICAgIExPR19MRVZFTF9FUlJPUixcbiAgICBMT0dfTEVWRUxfV0FSTixcbiAgICBMT0dfTEVWRUxfSU5GTyxcbiAgICBMT0dfTEVWRUxfREVCVUcsXG4gICAgTE9HX0xFVkVMX1RSQUNFLFxuXTtcbmNvbnN0IExPR19MRVZFTF9UQUdTID0ge1xuICAgIE9GRjogTE9HX0xFVkVMX09GRi50YWcsXG4gICAgRVJST1I6IExPR19MRVZFTF9FUlJPUi50YWcsXG4gICAgV0FSTjogTE9HX0xFVkVMX1dBUk4udGFnLFxuICAgIElORk86IExPR19MRVZFTF9JTkZPLnRhZyxcbiAgICBERUJVRzogTE9HX0xFVkVMX0RFQlVHLnRhZyxcbiAgICBUUkFDRTogTE9HX0xFVkVMX1RSQUNFLnRhZyxcbn07XG5leHBvcnRzLkxPR19MRVZFTF9UQUdTID0gTE9HX0xFVkVMX1RBR1M7XG4vLyBjcmVhdGUgdHdvIG1hcHMsIG9uZSBpbiB3aGljaCB0aGUga2V5IGlzIHRoZSBsb2cgbGV2ZWwgYW5kIHRoZSB2YWx1ZSBpcyB0aGVcbi8vIGNvcnJlc3BvbmRpbmcgbG9nIGxldmVsIG9iamVjdCwgYW5kIGFub3RoZXIgaW4gd2hpY2ggdGhlIGtleSBpcyB0aGUgbG9nIHRhZ1xuLy8gYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29ycmVzcG9uZGluZyBsb2cgbGV2ZWxcbmNvbnN0IE1BUF9MT0dfTEVWRUxfVE9fT0JKRUNUID0ge307XG5jb25zdCBNQVBfTE9HX1RBR19UT19MRVZFTCA9IHt9O1xuZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBMT0dfTEVWRUxTLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBsb2dMZXZlbE9iamVjdCA9IExPR19MRVZFTFNbaW5kZXhdO1xuICAgIE1BUF9MT0dfTEVWRUxfVE9fT0JKRUNUW2xvZ0xldmVsT2JqZWN0LmxldmVsXSA9IGxvZ0xldmVsT2JqZWN0O1xuICAgIE1BUF9MT0dfVEFHX1RPX0xFVkVMW2xvZ0xldmVsT2JqZWN0LnRhZ10gPSBsb2dMZXZlbE9iamVjdC5sZXZlbDtcbn1cbmNvbnN0IERFRkFVTFRfQlVGRkVSX01BWF9MRU5HVEggPSA1MDA7XG5jb25zdCBERUZBVUxUX01FU1NBR0VfTUFYX0xFTkdUSCA9IDUwMDtcbmNvbnN0IERFRkFVTFRfTEVWRUwgPSBMT0dfTEVWRUxfSU5GTztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMb2dnZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBsb2dNZXNzYWdlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSByZWNvbmZpZ3VyZU9wZXJhdGlvbiB7RnVuY3Rpb259IEFjdGlvbiB0byBwZXJmb3JtIHRvIGNoYW5nZSBsb2cgZGVzdGluYXRpb24gZmlsZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gKG9wdGlvbnMsIGxvZ01lc3NhZ2UsIHJlY29uZmlndXJlT3BlcmF0aW9uKSB7XG4gICAgLy8gYSBsb2cgZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Z1bmN0aW9uKGxvZ01lc3NhZ2UpKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIHRoZSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBsZXQgaW5jbHVkZVRpbWVzdGFtcDtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBzaXplIChpbiB0ZXJtcyBvZiBudW1iZXIgb2YgbWVzc2FnZXMpIHRvIHdoaWNoIHRoZSBsb2cgYnVmZmVyXG4gICAgICogY2FuIGdyb3cuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxldCBidWZmZXJNYXhMZW5ndGg7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbWVzc2FnZSBsZW5ndGguIExvbmdlciBtZXNzYWdlcyB3aWxsIGJlIHRydW5jYXRlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbGV0IG1lc3NhZ2VNYXhMZW5ndGg7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbG9nIGxldmVsLiBBbnkgbWVzc2FnZSBsb2dnZWQgYXQgYSBsb3dlciBsZXZlbCB3b24ndCBiZSBhZGRlZFxuICAgICAqIHRvIHRoZSBsb2cgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsZXQgY3VycmxldmVsT2JqZWN0O1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBsb2dnZXIgaW5zdGFuY2VcbiAgICBjb25zdCBsb2dnZXIgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoaXMgbG9nZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlndXJlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5jbHVkZVRpbWVzdGFtcDtcbiAgICAgICAgICAgIGxldCBsb2NhbEJ1ZmZlck1heExlbmd0aDtcbiAgICAgICAgICAgIGxldCBsb2NhbE1lc3NhZ2VNYXhMZW5ndGg7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbDtcbiAgICAgICAgICAgIGxldCBsb2NhbEZpbGVQYXRoO1xuICAgICAgICAgICAgbGV0IGxvY2FsQWRkaXRpb25hbExvZ1RvQ29uc29sZTtcbiAgICAgICAgICAgIC8vIGlmIGFuIG9wdGlvbnMgYXJndW1lbnQgaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgaXQncyBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgbG9jYWxJbmNsdWRlVGltZXN0YW1wID0gb3B0aW9ucy5pbmNsdWRlVGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGxvY2FsQnVmZmVyTWF4TGVuZ3RoID0gb3B0aW9ucy5idWZmZXJNYXhMZW5ndGg7XG4gICAgICAgICAgICAgICAgbG9jYWxNZXNzYWdlTWF4TGVuZ3RoID0gb3B0aW9ucy5tZXNzYWdlTWF4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxvY2FsTGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICAgICAgICAgICAgICAgIGxvY2FsRmlsZVBhdGggPSBvcHRpb25zLmZpbGVQYXRoO1xuICAgICAgICAgICAgICAgIGxvY2FsQWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IG9wdGlvbnMuYWRkaXRpb25hbExvZ1RvQ29uc29sZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGFuIGluY2x1ZGVUaW1lc3RhbXAgb3B0aW9ucyBpcyBzcGVjaWZpZWQsIGNvbnZlcnQgaXQgdG8gYSBib29sZWFuXG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMobG9jYWxJbmNsdWRlVGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVUaW1lc3RhbXAgPSAhIWxvY2FsSW5jbHVkZVRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFVdGlsLmV4aXN0cyhpbmNsdWRlVGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIGluY2x1ZGVUaW1lc3RhbXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSBidWZmZXJNYXhMZW5ndGggb3B0aW9uIGlzIHNwZWNpZmllZCwgbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyBpdCdzIGEgcG9zaXRpdmUgaW50ZWdlciBiZWZvcmUgdXBkYXRpbmcgdGhlIGxvZ2dlciBvcHRpb25cbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhsb2NhbEJ1ZmZlck1heExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIobG9jYWxCdWZmZXJNYXhMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBidWZmZXJNYXhMZW5ndGggPSBsb2NhbEJ1ZmZlck1heExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFVdGlsLmV4aXN0cyhidWZmZXJNYXhMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBsb2dnZXIgb3B0aW9uIGlmIGNvbmZpZ3VyZSgpIGhhc24ndCBiZWVuIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICBidWZmZXJNYXhMZW5ndGggPSBERUZBVUxUX0JVRkZFUl9NQVhfTEVOR1RIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSBtZXNzYWdlTWF4TGVuZ3RoIG9wdGlvbiBpcyBzcGVjaWZpZWQsIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQncyBhIHBvc2l0aXZlIGludGVnZXIgYmVmb3JlIHVwZGF0aW5nIHRoZSBsb2dnZXIgb3B0aW9uXG4gICAgICAgICAgICBpZiAoVXRpbC5leGlzdHMobG9jYWxNZXNzYWdlTWF4TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLm51bWJlci5pc1Bvc2l0aXZlSW50ZWdlcihsb2NhbE1lc3NhZ2VNYXhMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlTWF4TGVuZ3RoID0gbG9jYWxNZXNzYWdlTWF4TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVV0aWwuZXhpc3RzKG1lc3NhZ2VNYXhMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBsb2dnZXIgb3B0aW9uIGlmIGNvbmZpZ3VyZSgpIGhhc24ndCBiZWVuIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICBtZXNzYWdlTWF4TGVuZ3RoID0gREVGQVVMVF9NRVNTQUdFX01BWF9MRU5HVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBhIGxldmVsIG9wdGlvbiBpcyBzcGVjaWZpZWQsIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQncyB2YWxpZCBiZWZvcmUgdXBkYXRpbmcgdGhlIGxvZ2dlciBvcHRpb25cbiAgICAgICAgICAgIGlmIChVdGlsLmV4aXN0cyhsb2NhbExldmVsKSkge1xuICAgICAgICAgICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTUFQX0xPR19MRVZFTF9UT19PQkpFQ1QsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICBjdXJybGV2ZWxPYmplY3QgPSBNQVBfTE9HX0xFVkVMX1RPX09CSkVDVFtsb2NhbExldmVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFVdGlsLmV4aXN0cyhjdXJybGV2ZWxPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBsb2dnZXIgb3B0aW9uIGlmIGNvbmZpZ3VyZSgpIGhhc24ndCBiZWVuIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICBjdXJybGV2ZWxPYmplY3QgPSBERUZBVUxUX0xFVkVMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihyZWNvbmZpZ3VyZU9wZXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZWNvbmZpZ3VyZU9wZXJhdGlvbihsb2NhbEZpbGVQYXRoLCBsb2NhbEFkZGl0aW9uYWxMb2dUb0NvbnNvbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGVycm9yIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2coTE9HX0xFVkVMX0VSUk9SLCBtZXNzYWdlLCBnZXRNZXNzYWdlQXJncyhhcmd1bWVudHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB3YXJuIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgd2FybjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZyhMT0dfTEVWRUxfV0FSTiwgbWVzc2FnZSwgZ2V0TWVzc2FnZUFyZ3MoYXJndW1lbnRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgaW5mbyBsZXZlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGluZm86IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2coTE9HX0xFVkVMX0lORk8sIG1lc3NhZ2UsIGdldE1lc3NhZ2VBcmdzKGFyZ3VtZW50cykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGRlYnVnIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVidWc6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2coTE9HX0xFVkVMX0RFQlVHLCBtZXNzYWdlLCBnZXRNZXNzYWdlQXJncyhhcmd1bWVudHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB0cmFjZSBsZXZlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIHRyYWNlOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nKExPR19MRVZFTF9UUkFDRSwgbWVzc2FnZSwgZ2V0TWVzc2FnZUFyZ3MoYXJndW1lbnRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsb2cgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMb2dCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxldmVsIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbG9nIGxldmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGV2ZWxOdW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJybGV2ZWxPYmplY3QubGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldExldmVsVGFnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmxldmVsT2JqZWN0LnRhZztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBtYXAgaW4gd2hpY2ggdGhlIGtleXMgYXJlIHRoZSBsZXZlbCB0YWdzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyBsb2cgbGV2ZWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGV2ZWxUYWdzTWFwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTUFQX0xPR19UQUdfVE9fTEVWRUw7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvLyBjb25maWd1cmUgdGhlIGxvZ2dlclxuICAgIGxvZ2dlci5jb25maWd1cmUob3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRMZXZlbE9iamVjdCB0aGUgbGV2ZWwgYXQgd2hpY2ggdG8gbG9nIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG1lc3NhZ2VBcmdzIGFueSBhcmd1bWVudHMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0IGxvZyA9IGZ1bmN0aW9uICh0YXJnZXRMZXZlbE9iamVjdCwgbWVzc2FnZSwgbWVzc2FnZUFyZ3MpIHtcbiAgICAgICAgLy8gdGhlIG1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBsb2dnZWQgaWYgdGhlIHRhcmdldFxuICAgICAgICAvLyBsZXZlbCBpcyBtb3JlIHZlcmJvc2UgdGhhbiB0aGUgY3VycmVudCBsZXZlbFxuICAgICAgICBpZiAodGFyZ2V0TGV2ZWxPYmplY3QubGV2ZWwgPD0gY3VycmxldmVsT2JqZWN0LmxldmVsKSB7XG4gICAgICAgICAgICAvLyBzdWJzdGl0dXRlIHRoZSBtZXNzYWdlQXJncyBpbnRvIHRoZSBtZXNzYWdlIHRlbXBsYXRlXG4gICAgICAgICAgICBtZXNzYWdlQXJncy51bnNoaWZ0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgbWVzc2FnZSA9IFV0aWwuZm9ybWF0LmFwcGx5KFV0aWwsIG1lc3NhZ2VBcmdzKTtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRoZSBtZXNzYWdlIGlmIGl0J3MgdG9vIGxvbmdcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCA+IG1lc3NhZ2VNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5zbGljZSgwLCBtZXNzYWdlTWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5lZWRlZCwgYWRkIHRoZSBjdXJyZW50IHRpbWUgdG8gdGhlIGZyb250IG9mIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICBpZiAoaW5jbHVkZVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBVdGlsLmZvcm1hdCgnWyVzXTogJXMnLCBtb21lbnQoKS5mb3JtYXQoJ2g6bW06c3MuU1NTIEEnKSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXNrIHNlY3JldHNcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBTZWNyZXREZXRlY3Rvci5tYXNrU2VjcmV0cyhtZXNzYWdlKS5tYXNrZWR0eHQ7XG4gICAgICAgICAgICAvLyBsb2cgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGxvZ01lc3NhZ2UodGFyZ2V0TGV2ZWxPYmplY3QudGFnLCBtZXNzYWdlLCBidWZmZXJNYXhMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbG9nZ2VyO1xufTtcbmV4cG9ydHMuaXNWYWxpZExvZ1RhZyA9IGZ1bmN0aW9uIChsb2dUYWcpIHtcbiAgICBpZiAoIVV0aWwuaXNTdHJpbmcobG9nVGFnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTUFQX0xPR19UQUdfVE9fTEVWRUwsIGxvZ1RhZy50b1VwcGVyQ2FzZSgpKTtcbn07XG5leHBvcnRzLmxvZ1RhZ1RvTGV2ZWwgPSBmdW5jdGlvbiAobG9nVGFnKSB7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNTdHJpbmcobG9nVGFnKSk7XG4gICAgcmV0dXJuIE1BUF9MT0dfVEFHX1RPX0xFVkVMW2xvZ1RhZy50b1VwcGVyQ2FzZSgpXTtcbn07XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gZXh0cmFjdCB0aGUgbWVzc2FnZUFyZ3MgZnJvbSB0aGUgYXJndW1lbnRzIHBhc3NlZCB0b1xuICogdHJhY2UoKSwgZGVidWcoKSwgaW5mbygpLCB3YXJuKCkgYW5kIGVycm9yKCkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWVzc2FnZUFyZ3MoYXJncykge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fsPromises = __webpack_require__(/*! fs/promises */ \"fs/promises\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { logTagToLevel } = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\nconst { ConfigurationUtil, Levels } = __webpack_require__(/*! ../configuration/client_configuration */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/configuration/client_configuration.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst { isFileModeCorrect } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/file_util.js\");\nconst { exists } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst clientConfiguration = new ConfigurationUtil();\nconst getClientConfig = clientConfiguration.getClientConfig;\nlet initTrialParameters;\n/**\n * @param {string} configFilePathFromConnectionString\n * @returns {Promise<void>}\n */\nexports.init = async function (configFilePathFromConnectionString) {\n    try {\n        if (!allowedToInitialize(configFilePathFromConnectionString)) {\n            return;\n        }\n        Logger.getInstance().info('Trying to initialize Easy Logging');\n        const config = await getClientConfig(configFilePathFromConnectionString);\n        if (!config) {\n            Logger.getInstance().info('Easy Logging is disabled as no config has been found');\n            initTrialParameters = {\n                configFilePathFromConnectionString: configFilePathFromConnectionString,\n            };\n            return;\n        }\n        const logLevel = mapLogLevel(config);\n        const logPath = await getLogPath(config);\n        const logger = Logger.getInstance();\n        logger.info('Initializing Easy Logging with logPath=%s and logLevel=%s from file: %s', logPath, config.loggingConfig.logLevel, config.configPath);\n        logger.configure({\n            level: logLevel,\n            filePath: path.join(logPath, 'snowflake.log'),\n            additionalLogToConsole: false,\n        });\n        logger.easyLoggingConfigureCounter = (logger.easyLoggingConfigureCounter ?? 0) + 1;\n        initTrialParameters = {\n            configFilePathFromConnectionString: configFilePathFromConnectionString,\n        };\n    }\n    catch (err) {\n        const error = new EasyLoggingError('Failed to initialize easy logging', err);\n        Logger.getInstance().error(error);\n        throw error;\n    }\n};\nexports.reset = function () {\n    initTrialParameters = undefined;\n    Logger.getInstance().easyLoggingConfigureCounter = undefined;\n};\nfunction allowedToInitialize(configFilePathFromConnectionString) {\n    const everTriedToInitialize = !!initTrialParameters;\n    const triedToInitializeWithoutConfigFile = everTriedToInitialize && initTrialParameters.configFilePathFromConnectionString == null;\n    const isGivenConfigFilePath = !!configFilePathFromConnectionString;\n    const isAllowedToInitialize = !everTriedToInitialize || (triedToInitializeWithoutConfigFile && isGivenConfigFilePath);\n    if (!isAllowedToInitialize &&\n        initTrialParameters.configFilePathFromConnectionString !== configFilePathFromConnectionString) {\n        Logger.getInstance().warn(`Easy logging will not be configured for CLIENT_CONFIG_FILE=${configFilePathFromConnectionString} because it was previously configured for a different client config`);\n    }\n    return isAllowedToInitialize;\n}\nfunction mapLogLevel(config) {\n    const configLogLevel = getLogLevel(config);\n    const logLevelNumber = logTagToLevel(configLogLevel);\n    if (logLevelNumber === null || logLevelNumber === undefined) {\n        throw new Error('Failed to convert configuration log level into internal one');\n    }\n    return logLevelNumber;\n}\nfunction getLogLevel(config) {\n    const logLevel = config.loggingConfig.logLevel;\n    if (!logLevel) {\n        Logger.getInstance().warn('LogLevel in client config not found. Using default value: OFF');\n        return Levels.Off;\n    }\n    return logLevel;\n}\nasync function getLogPath(config) {\n    let logPath = config.loggingConfig.logPath;\n    if (!logPath) {\n        Logger.getInstance().warn('LogPath in client config not found. Using home directory as a default value');\n        logPath = os.homedir();\n        if (!exists(logPath)) {\n            throw new EasyLoggingError('Home directory does not exist');\n        }\n    }\n    const pathWithNodeJsSubdirectory = path.join(logPath, 'nodejs');\n    await fsPromises\n        .access(pathWithNodeJsSubdirectory, fs.constants.F_OK)\n        .then(async () => {\n        if (!(await isFileModeCorrect(pathWithNodeJsSubdirectory, 0o700, fsPromises))) {\n            Logger.getInstance().warn('Log directory: %s could potentially be accessed by others', pathWithNodeJsSubdirectory);\n        }\n    })\n        .catch(async () => {\n        try {\n            await fsPromises.mkdir(pathWithNodeJsSubdirectory, { recursive: true, mode: 0o700 });\n        }\n        catch (err) {\n            throw new EasyLoggingError(`Failed to create the directory for logs: ${pathWithNodeJsSubdirectory}`);\n        }\n    });\n    return pathWithNodeJsSubdirectory;\n}\nclass EasyLoggingError extends Error {\n    name = 'EasyLoggingError';\n    constructor(message, cause) {\n        super(message);\n        this.cause = cause;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    toString() {\n        return this.message + ': ' + this.cause.toString();\n    }\n}\n//# sourceMappingURL=easy_logging_starter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvZWFzeV9sb2dnaW5nX3N0YXJ0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFRO0FBQzFDLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyxnSUFBdUM7QUFDckYsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyw4RUFBYztBQUNwRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLG9FQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxvQ0FBb0M7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUVBQWlFLDhCQUE4QjtBQUMvRjtBQUNBO0FBQ0EsbUZBQW1GLDJCQUEyQjtBQUM5RztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvZWFzeV9sb2dnaW5nX3N0YXJ0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZnNQcm9taXNlcyA9IHJlcXVpcmUoJ2ZzL3Byb21pc2VzJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IGxvZ1RhZ1RvTGV2ZWwgfSA9IHJlcXVpcmUoJy4vY29yZScpO1xuY29uc3QgeyBDb25maWd1cmF0aW9uVXRpbCwgTGV2ZWxzIH0gPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2NsaWVudF9jb25maWd1cmF0aW9uJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IHsgaXNGaWxlTW9kZUNvcnJlY3QgfSA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpO1xuY29uc3QgeyBleGlzdHMgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IGNsaWVudENvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvblV0aWwoKTtcbmNvbnN0IGdldENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZ3VyYXRpb24uZ2V0Q2xpZW50Q29uZmlnO1xubGV0IGluaXRUcmlhbFBhcmFtZXRlcnM7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0cy5pbml0ID0gYXN5bmMgZnVuY3Rpb24gKGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWFsbG93ZWRUb0luaXRpYWxpemUoY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdUcnlpbmcgdG8gaW5pdGlhbGl6ZSBFYXN5IExvZ2dpbmcnKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgZ2V0Q2xpZW50Q29uZmlnKGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpO1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnRWFzeSBMb2dnaW5nIGlzIGRpc2FibGVkIGFzIG5vIGNvbmZpZyBoYXMgYmVlbiBmb3VuZCcpO1xuICAgICAgICAgICAgaW5pdFRyaWFsUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nOiBjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2dMZXZlbCA9IG1hcExvZ0xldmVsKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGxvZ1BhdGggPSBhd2FpdCBnZXRMb2dQYXRoKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBsb2dnZXIuaW5mbygnSW5pdGlhbGl6aW5nIEVhc3kgTG9nZ2luZyB3aXRoIGxvZ1BhdGg9JXMgYW5kIGxvZ0xldmVsPSVzIGZyb20gZmlsZTogJXMnLCBsb2dQYXRoLCBjb25maWcubG9nZ2luZ0NvbmZpZy5sb2dMZXZlbCwgY29uZmlnLmNvbmZpZ1BhdGgpO1xuICAgICAgICBsb2dnZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGxldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBwYXRoLmpvaW4obG9nUGF0aCwgJ3Nub3dmbGFrZS5sb2cnKSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLmVhc3lMb2dnaW5nQ29uZmlndXJlQ291bnRlciA9IChsb2dnZXIuZWFzeUxvZ2dpbmdDb25maWd1cmVDb3VudGVyID8/IDApICsgMTtcbiAgICAgICAgaW5pdFRyaWFsUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmc6IGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRWFzeUxvZ2dpbmdFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgZWFzeSBsb2dnaW5nJywgZXJyKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuZXhwb3J0cy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpbml0VHJpYWxQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVhc3lMb2dnaW5nQ29uZmlndXJlQ291bnRlciA9IHVuZGVmaW5lZDtcbn07XG5mdW5jdGlvbiBhbGxvd2VkVG9Jbml0aWFsaXplKGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgICBjb25zdCBldmVyVHJpZWRUb0luaXRpYWxpemUgPSAhIWluaXRUcmlhbFBhcmFtZXRlcnM7XG4gICAgY29uc3QgdHJpZWRUb0luaXRpYWxpemVXaXRob3V0Q29uZmlnRmlsZSA9IGV2ZXJUcmllZFRvSW5pdGlhbGl6ZSAmJiBpbml0VHJpYWxQYXJhbWV0ZXJzLmNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcgPT0gbnVsbDtcbiAgICBjb25zdCBpc0dpdmVuQ29uZmlnRmlsZVBhdGggPSAhIWNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmc7XG4gICAgY29uc3QgaXNBbGxvd2VkVG9Jbml0aWFsaXplID0gIWV2ZXJUcmllZFRvSW5pdGlhbGl6ZSB8fCAodHJpZWRUb0luaXRpYWxpemVXaXRob3V0Q29uZmlnRmlsZSAmJiBpc0dpdmVuQ29uZmlnRmlsZVBhdGgpO1xuICAgIGlmICghaXNBbGxvd2VkVG9Jbml0aWFsaXplICYmXG4gICAgICAgIGluaXRUcmlhbFBhcmFtZXRlcnMuY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZyAhPT0gY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBFYXN5IGxvZ2dpbmcgd2lsbCBub3QgYmUgY29uZmlndXJlZCBmb3IgQ0xJRU5UX0NPTkZJR19GSUxFPSR7Y29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZ30gYmVjYXVzZSBpdCB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkIGZvciBhIGRpZmZlcmVudCBjbGllbnQgY29uZmlnYCk7XG4gICAgfVxuICAgIHJldHVybiBpc0FsbG93ZWRUb0luaXRpYWxpemU7XG59XG5mdW5jdGlvbiBtYXBMb2dMZXZlbChjb25maWcpIHtcbiAgICBjb25zdCBjb25maWdMb2dMZXZlbCA9IGdldExvZ0xldmVsKGNvbmZpZyk7XG4gICAgY29uc3QgbG9nTGV2ZWxOdW1iZXIgPSBsb2dUYWdUb0xldmVsKGNvbmZpZ0xvZ0xldmVsKTtcbiAgICBpZiAobG9nTGV2ZWxOdW1iZXIgPT09IG51bGwgfHwgbG9nTGV2ZWxOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb252ZXJ0IGNvbmZpZ3VyYXRpb24gbG9nIGxldmVsIGludG8gaW50ZXJuYWwgb25lJyk7XG4gICAgfVxuICAgIHJldHVybiBsb2dMZXZlbE51bWJlcjtcbn1cbmZ1bmN0aW9uIGdldExvZ0xldmVsKGNvbmZpZykge1xuICAgIGNvbnN0IGxvZ0xldmVsID0gY29uZmlnLmxvZ2dpbmdDb25maWcubG9nTGV2ZWw7XG4gICAgaWYgKCFsb2dMZXZlbCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdMb2dMZXZlbCBpbiBjbGllbnQgY29uZmlnIG5vdCBmb3VuZC4gVXNpbmcgZGVmYXVsdCB2YWx1ZTogT0ZGJyk7XG4gICAgICAgIHJldHVybiBMZXZlbHMuT2ZmO1xuICAgIH1cbiAgICByZXR1cm4gbG9nTGV2ZWw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRMb2dQYXRoKGNvbmZpZykge1xuICAgIGxldCBsb2dQYXRoID0gY29uZmlnLmxvZ2dpbmdDb25maWcubG9nUGF0aDtcbiAgICBpZiAoIWxvZ1BhdGgpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignTG9nUGF0aCBpbiBjbGllbnQgY29uZmlnIG5vdCBmb3VuZC4gVXNpbmcgaG9tZSBkaXJlY3RvcnkgYXMgYSBkZWZhdWx0IHZhbHVlJyk7XG4gICAgICAgIGxvZ1BhdGggPSBvcy5ob21lZGlyKCk7XG4gICAgICAgIGlmICghZXhpc3RzKGxvZ1BhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRWFzeUxvZ2dpbmdFcnJvcignSG9tZSBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSA9IHBhdGguam9pbihsb2dQYXRoLCAnbm9kZWpzJyk7XG4gICAgYXdhaXQgZnNQcm9taXNlc1xuICAgICAgICAuYWNjZXNzKHBhdGhXaXRoTm9kZUpzU3ViZGlyZWN0b3J5LCBmcy5jb25zdGFudHMuRl9PSylcbiAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIShhd2FpdCBpc0ZpbGVNb2RlQ29ycmVjdChwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSwgMG83MDAsIGZzUHJvbWlzZXMpKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignTG9nIGRpcmVjdG9yeTogJXMgY291bGQgcG90ZW50aWFsbHkgYmUgYWNjZXNzZWQgYnkgb3RoZXJzJywgcGF0aFdpdGhOb2RlSnNTdWJkaXJlY3RvcnkpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzUHJvbWlzZXMubWtkaXIocGF0aFdpdGhOb2RlSnNTdWJkaXJlY3RvcnksIHsgcmVjdXJzaXZlOiB0cnVlLCBtb2RlOiAwbzcwMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRWFzeUxvZ2dpbmdFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB0aGUgZGlyZWN0b3J5IGZvciBsb2dzOiAke3BhdGhXaXRoTm9kZUpzU3ViZGlyZWN0b3J5fWApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGhXaXRoTm9kZUpzU3ViZGlyZWN0b3J5O1xufVxuY2xhc3MgRWFzeUxvZ2dpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBuYW1lID0gJ0Vhc3lMb2dnaW5nRXJyb3InO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZSArICc6ICcgKyB0aGlzLmNhdXNlLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFzeV9sb2dnaW5nX3N0YXJ0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/easy_logging_starter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nfunction ExecutionTimer() {\n    let startTime = null;\n    let endTime = null;\n    // Private function to log and check if the timer was started\n    function wasStarted() {\n        return Util.exists(startTime);\n    }\n    this.start = function () {\n        startTime = performance.now();\n        endTime = null; // Reset endTime if the timer is reused\n        return this;\n    };\n    this.stop = function () {\n        if (!wasStarted()) {\n            // Returning this to allow chaining even after invalid call.\n            // startTime can be used to check, if any start point was ever recorded.\n            Logger.getInstance().debug('Tried to stop timer, that was not started');\n            return this;\n        }\n        endTime = performance.now();\n        return this;\n    };\n    // Get the duration in milliseconds\n    this.getDuration = function () {\n        if (!wasStarted()) {\n            return;\n        }\n        if (endTime === null) {\n            endTime = performance.now();\n        }\n        return Math.round((endTime - startTime) * 100) / 100;\n    };\n}\nmodule.exports = ExecutionTimer;\n//# sourceMappingURL=execution_timer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvZXhlY3V0aW9uX3RpbWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw4QkFBWTtBQUM1QyxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvbG9nZ2VyL2V4ZWN1dGlvbl90aW1lci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHJlcXVpcmUoJ3BlcmZfaG9va3MnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmZ1bmN0aW9uIEV4ZWN1dGlvblRpbWVyKCkge1xuICAgIGxldCBzdGFydFRpbWUgPSBudWxsO1xuICAgIGxldCBlbmRUaW1lID0gbnVsbDtcbiAgICAvLyBQcml2YXRlIGZ1bmN0aW9uIHRvIGxvZyBhbmQgY2hlY2sgaWYgdGhlIHRpbWVyIHdhcyBzdGFydGVkXG4gICAgZnVuY3Rpb24gd2FzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIFV0aWwuZXhpc3RzKHN0YXJ0VGltZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBlbmRUaW1lID0gbnVsbDsgLy8gUmVzZXQgZW5kVGltZSBpZiB0aGUgdGltZXIgaXMgcmV1c2VkXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgLy8gUmV0dXJuaW5nIHRoaXMgdG8gYWxsb3cgY2hhaW5pbmcgZXZlbiBhZnRlciBpbnZhbGlkIGNhbGwuXG4gICAgICAgICAgICAvLyBzdGFydFRpbWUgY2FuIGJlIHVzZWQgdG8gY2hlY2ssIGlmIGFueSBzdGFydCBwb2ludCB3YXMgZXZlciByZWNvcmRlZC5cbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdUcmllZCB0byBzdG9wIHRpbWVyLCB0aGF0IHdhcyBub3Qgc3RhcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIEdldCB0aGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgdGhpcy5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF3YXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kVGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChlbmRUaW1lIC0gc3RhcnRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uVGltZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRpb25fdGltZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/execution_timer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst PROVIDED_TEXT = 'provided';\nconst NOT_PROVIDED_TEXT = 'not provided';\n/**\n * Describes the presence of a given value. If the value is not empty (as a string),\n * returns the corresponding text (by default: 'provided' or 'not provided').\n *\n * @param {*} valueToDescribe - The value to check for presence.\n * @param {Object} [options] - Optional overrides for the \"provided\" and \"not provided\" text.\n * @param {string} [options.overrideProvidedText]\n * @param {string} [options.overrideNotProvidedText]\n * @returns {string} A string indicating the presence of `valueToDescribe`.\n */\nexports.describePresence = function (valueToDescribe, { overrideProvidedText, overrideNotProvidedText } = {}) {\n    const providedText = overrideProvidedText || PROVIDED_TEXT;\n    const notProvidedText = overrideNotProvidedText || NOT_PROVIDED_TEXT;\n    return Util.isNotEmptyAsString(valueToDescribe) ? providedText : notProvidedText;\n};\n/**\n * @param {Object} sourceObject - The object holding attribute values.\n * @param {Array<string>} attributesWithValues - Attributes to show with their values.\n * @param {Array<string>} attributesWithoutValues - Attributes to show as present/not present.\n * @returns {string} Comma-separated string describing the attributes.\n */\nexports.attributesToString = function (sourceObject = {}, attributesWithValues = [], attributesWithoutValues = []) {\n    const withValues = attributesWithValues\n        .filter((attr) => sourceObject[attr] !== undefined)\n        .map((attr) => `${attr}=${String(sourceObject[attr])}`);\n    const withoutValues = attributesWithoutValues\n        .filter((attr) => sourceObject[attr] !== undefined)\n        .map((attr) => `${attr} is ${exports.describePresence(sourceObject[attr])}`);\n    return [...withValues, ...withoutValues].join(', ');\n};\n/**\n * @param {Object} sourceObject - The object holding attribute values.\n * @param {Array<string>} attributesWithValues - Attributes to show with their values.\n * @param {Array<string>} attributesWithoutValues - Attributes to show as present/not present.\n * @returns {string} A bracketed string of described attributes.\n */\nexports.describeAttributes = function (sourceObject, attributesWithValues, attributesWithoutValues) {\n    const attributesDescription = exports.attributesToString(sourceObject, attributesWithValues, attributesWithoutValues);\n    return `[${attributesDescription}]`;\n};\n//# sourceMappingURL=logging_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbG9nZ2luZ191dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG9FQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHdCQUF3QixnQ0FBZ0MsZ0RBQWdELElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQixLQUFLLEdBQUcsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxLQUFLLDZDQUE2QztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbG9nZ2luZ191dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IFBST1ZJREVEX1RFWFQgPSAncHJvdmlkZWQnO1xuY29uc3QgTk9UX1BST1ZJREVEX1RFWFQgPSAnbm90IHByb3ZpZGVkJztcbi8qKlxuICogRGVzY3JpYmVzIHRoZSBwcmVzZW5jZSBvZiBhIGdpdmVuIHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgbm90IGVtcHR5IChhcyBhIHN0cmluZyksXG4gKiByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgKGJ5IGRlZmF1bHQ6ICdwcm92aWRlZCcgb3IgJ25vdCBwcm92aWRlZCcpLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVUb0Rlc2NyaWJlIC0gVGhlIHZhbHVlIHRvIGNoZWNrIGZvciBwcmVzZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBvdmVycmlkZXMgZm9yIHRoZSBcInByb3ZpZGVkXCIgYW5kIFwibm90IHByb3ZpZGVkXCIgdGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdmVycmlkZVByb3ZpZGVkVGV4dF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdmVycmlkZU5vdFByb3ZpZGVkVGV4dF1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHByZXNlbmNlIG9mIGB2YWx1ZVRvRGVzY3JpYmVgLlxuICovXG5leHBvcnRzLmRlc2NyaWJlUHJlc2VuY2UgPSBmdW5jdGlvbiAodmFsdWVUb0Rlc2NyaWJlLCB7IG92ZXJyaWRlUHJvdmlkZWRUZXh0LCBvdmVycmlkZU5vdFByb3ZpZGVkVGV4dCB9ID0ge30pIHtcbiAgICBjb25zdCBwcm92aWRlZFRleHQgPSBvdmVycmlkZVByb3ZpZGVkVGV4dCB8fCBQUk9WSURFRF9URVhUO1xuICAgIGNvbnN0IG5vdFByb3ZpZGVkVGV4dCA9IG92ZXJyaWRlTm90UHJvdmlkZWRUZXh0IHx8IE5PVF9QUk9WSURFRF9URVhUO1xuICAgIHJldHVybiBVdGlsLmlzTm90RW1wdHlBc1N0cmluZyh2YWx1ZVRvRGVzY3JpYmUpID8gcHJvdmlkZWRUZXh0IDogbm90UHJvdmlkZWRUZXh0O1xufTtcbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iamVjdCAtIFRoZSBvYmplY3QgaG9sZGluZyBhdHRyaWJ1dGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdHRyaWJ1dGVzV2l0aFZhbHVlcyAtIEF0dHJpYnV0ZXMgdG8gc2hvdyB3aXRoIHRoZWlyIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgLSBBdHRyaWJ1dGVzIHRvIHNob3cgYXMgcHJlc2VudC9ub3QgcHJlc2VudC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbW1hLXNlcGFyYXRlZCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgYXR0cmlidXRlcy5cbiAqL1xuZXhwb3J0cy5hdHRyaWJ1dGVzVG9TdHJpbmcgPSBmdW5jdGlvbiAoc291cmNlT2JqZWN0ID0ge30sIGF0dHJpYnV0ZXNXaXRoVmFsdWVzID0gW10sIGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzID0gW10pIHtcbiAgICBjb25zdCB3aXRoVmFsdWVzID0gYXR0cmlidXRlc1dpdGhWYWx1ZXNcbiAgICAgICAgLmZpbHRlcigoYXR0cikgPT4gc291cmNlT2JqZWN0W2F0dHJdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIC5tYXAoKGF0dHIpID0+IGAke2F0dHJ9PSR7U3RyaW5nKHNvdXJjZU9iamVjdFthdHRyXSl9YCk7XG4gICAgY29uc3Qgd2l0aG91dFZhbHVlcyA9IGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzXG4gICAgICAgIC5maWx0ZXIoKGF0dHIpID0+IHNvdXJjZU9iamVjdFthdHRyXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAubWFwKChhdHRyKSA9PiBgJHthdHRyfSBpcyAke2V4cG9ydHMuZGVzY3JpYmVQcmVzZW5jZShzb3VyY2VPYmplY3RbYXR0cl0pfWApO1xuICAgIHJldHVybiBbLi4ud2l0aFZhbHVlcywgLi4ud2l0aG91dFZhbHVlc10uam9pbignLCAnKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmplY3QgLSBUaGUgb2JqZWN0IGhvbGRpbmcgYXR0cmlidXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc1dpdGhWYWx1ZXMgLSBBdHRyaWJ1dGVzIHRvIHNob3cgd2l0aCB0aGVpciB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzIC0gQXR0cmlidXRlcyB0byBzaG93IGFzIHByZXNlbnQvbm90IHByZXNlbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGJyYWNrZXRlZCBzdHJpbmcgb2YgZGVzY3JpYmVkIGF0dHJpYnV0ZXMuXG4gKi9cbmV4cG9ydHMuZGVzY3JpYmVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHNvdXJjZU9iamVjdCwgYXR0cmlidXRlc1dpdGhWYWx1ZXMsIGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlc0Rlc2NyaXB0aW9uID0gZXhwb3J0cy5hdHRyaWJ1dGVzVG9TdHJpbmcoc291cmNlT2JqZWN0LCBhdHRyaWJ1dGVzV2l0aFZhbHVlcywgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMpO1xuICAgIHJldHVybiBgWyR7YXR0cmlidXRlc0Rlc2NyaXB0aW9ufV1gO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmdfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/node.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/logger/node.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst winston = __webpack_require__(/*! winston */ \"(rsc)/./node_modules/winston/lib/winston.js\");\nconst Core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/core.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst DEFAULT_ADDITIONAL_LOG_TO_CONSOLE = true;\n/**\n * Creates a new Logger instance for when we're running in node.\n *\n * @param {Object} [options]\n *\n * @constructor\n */\nfunction Logger(options) {\n    let winstonLogger;\n    const defaultFilePath = 'snowflake.log';\n    let filePath = getFilePath(options);\n    let additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n    let transportLabels = [];\n    this.setLogger = function (logger) {\n        winstonLogger = logger;\n    };\n    /**\n     * This operation is for purpose of tests only. The idea is to force flushing logs to files.\n     * Winston logger emits 'finish' event before flushes all the transports so waiting for this event on logger is not good enough.\n     * For simplicity, we just close each transport without waiting here.\n     */\n    this.closeTransports = function () {\n        if (transportsCreated()) {\n            for (const transport of winstonLogger.transports) {\n                closeTransport(transport);\n            }\n        }\n    };\n    function transportsCreated() {\n        try {\n            winstonLogger.transports;\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    function closeTransport(transport) {\n        if (!transport.close) {\n            return;\n        }\n        transport.close();\n    }\n    function reconfigureWinstonLogger(filePathInput, additionalLogToConsoleInput) {\n        const currentWinstonLogger = winstonLogger;\n        filePath = filePathInput ?? filePath;\n        if (Util.isBoolean(additionalLogToConsoleInput)) {\n            additionalLogToConsole = additionalLogToConsoleInput;\n        }\n        else {\n            additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n        }\n        winstonLogger = null; // it will be created for the first log operation\n        if (currentWinstonLogger) {\n            currentWinstonLogger.close();\n        }\n    }\n    function setTransportLabels(transportLabelsInput) {\n        transportLabels = transportLabelsInput;\n    }\n    this.getTransportLabels = function () {\n        return transportLabels;\n    };\n    /**\n     * Logs a message at a given level.\n     *\n     * @param {String} levelTag the tag associated with the level at which to log\n     *   the message.\n     * @param {String} message the message to log.\n     */\n    const logMessage = function (levelTag, message) {\n        // initialize the winston logger if needed\n        if (!winstonLogger) {\n            let transports;\n            let transportLabels;\n            if ('STDOUT' === filePath.toUpperCase()) {\n                transports = [new winston.transports.Console()];\n                transportLabels = ['Console'];\n            }\n            else if (additionalLogToConsole === true) {\n                transports = [\n                    new winston.transports.Console(),\n                    new winston.transports.File({ filename: filePath }),\n                ];\n                transportLabels = ['Console', 'File'];\n            }\n            else {\n                transports = [new winston.transports.File({ filename: filePath })];\n                transportLabels = ['File'];\n            }\n            winstonLogger = new winston.createLogger({\n                transports: transports,\n                level: common.getLevelTag(),\n                levels: common.getLevelTagsMap(),\n            });\n            setTransportLabels(transportLabels);\n        }\n        // get the appropriate logging method using the level tag and use this\n        // method to log the message\n        winstonLogger[levelTag](message);\n    };\n    // create an inner implementation to which all our methods will be forwarded\n    const common = Core.createLogger(options, logMessage, reconfigureWinstonLogger);\n    function getFilePath(options) {\n        if (Util.exists(options)) {\n            Errors.assertInternal(Util.isObject(options));\n            return options.filePath ?? defaultFilePath;\n        }\n        return defaultFilePath;\n    }\n    this.getLevelTag = function () {\n        return common.getLevelTag();\n    };\n    this.getLevelTagsMap = function () {\n        return common.getLevelTagsMap();\n    };\n    /**\n     * Configures this logger.\n     *\n     * @param {Object} options\n     */\n    this.configure = function (options) {\n        if (Util.isBoolean(options.additionalLogToConsole)) {\n            additionalLogToConsole = options.additionalLogToConsole;\n        }\n        else {\n            additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n        }\n        common.configure(options);\n    };\n    /**\n     * Returns the current log level.\n     *\n     * @returns {Number}\n     */\n    this.getLevel = function () {\n        return common.getLevelNumber();\n    };\n    /**\n     * Logs a given message at the error level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.error = function (message, ...params) {\n        common.error.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the warning level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.warn = function (message, ...params) {\n        common.warn.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the info level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.info = function (message, ...params) {\n        common.info.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the debug level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.debug = function (message, ...params) {\n        common.debug.apply(common, [message, ...params]);\n    };\n    /**\n     * Logs a given message at the trace level.\n     *\n     * @param {String} message\n     * @param params\n     */\n    this.trace = function (message, ...params) {\n        common.trace.apply(common, [message, ...params]);\n    };\n    /**\n     * Returns the log buffer.\n     *\n     * @returns {String[]}\n     */\n    this.getLogBuffer = function () {\n        return common.getLogBuffer();\n    };\n}\nmodule.exports = Logger;\n//# sourceMappingURL=node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywwRUFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9sb2dnZXIvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XG5jb25zdCBDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBERUZBVUxUX0FERElUSU9OQUxfTE9HX1RPX0NPTlNPTEUgPSB0cnVlO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExvZ2dlciBpbnN0YW5jZSBmb3Igd2hlbiB3ZSdyZSBydW5uaW5nIGluIG5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2dnZXIob3B0aW9ucykge1xuICAgIGxldCB3aW5zdG9uTG9nZ2VyO1xuICAgIGNvbnN0IGRlZmF1bHRGaWxlUGF0aCA9ICdzbm93Zmxha2UubG9nJztcbiAgICBsZXQgZmlsZVBhdGggPSBnZXRGaWxlUGF0aChvcHRpb25zKTtcbiAgICBsZXQgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IERFRkFVTFRfQURESVRJT05BTF9MT0dfVE9fQ09OU09MRTtcbiAgICBsZXQgdHJhbnNwb3J0TGFiZWxzID0gW107XG4gICAgdGhpcy5zZXRMb2dnZXIgPSBmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgIHdpbnN0b25Mb2dnZXIgPSBsb2dnZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBmb3IgcHVycG9zZSBvZiB0ZXN0cyBvbmx5LiBUaGUgaWRlYSBpcyB0byBmb3JjZSBmbHVzaGluZyBsb2dzIHRvIGZpbGVzLlxuICAgICAqIFdpbnN0b24gbG9nZ2VyIGVtaXRzICdmaW5pc2gnIGV2ZW50IGJlZm9yZSBmbHVzaGVzIGFsbCB0aGUgdHJhbnNwb3J0cyBzbyB3YWl0aW5nIGZvciB0aGlzIGV2ZW50IG9uIGxvZ2dlciBpcyBub3QgZ29vZCBlbm91Z2guXG4gICAgICogRm9yIHNpbXBsaWNpdHksIHdlIGp1c3QgY2xvc2UgZWFjaCB0cmFuc3BvcnQgd2l0aG91dCB3YWl0aW5nIGhlcmUuXG4gICAgICovXG4gICAgdGhpcy5jbG9zZVRyYW5zcG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0cmFuc3BvcnRzQ3JlYXRlZCgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zcG9ydCBvZiB3aW5zdG9uTG9nZ2VyLnRyYW5zcG9ydHMpIHtcbiAgICAgICAgICAgICAgICBjbG9zZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0cmFuc3BvcnRzQ3JlYXRlZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbnN0b25Mb2dnZXIudHJhbnNwb3J0cztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZVRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQuY2xvc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25maWd1cmVXaW5zdG9uTG9nZ2VyKGZpbGVQYXRoSW5wdXQsIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGVJbnB1dCkge1xuICAgICAgICBjb25zdCBjdXJyZW50V2luc3RvbkxvZ2dlciA9IHdpbnN0b25Mb2dnZXI7XG4gICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGhJbnB1dCA/PyBmaWxlUGF0aDtcbiAgICAgICAgaWYgKFV0aWwuaXNCb29sZWFuKGFkZGl0aW9uYWxMb2dUb0NvbnNvbGVJbnB1dCkpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGUgPSBhZGRpdGlvbmFsTG9nVG9Db25zb2xlSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsTG9nVG9Db25zb2xlID0gREVGQVVMVF9BRERJVElPTkFMX0xPR19UT19DT05TT0xFO1xuICAgICAgICB9XG4gICAgICAgIHdpbnN0b25Mb2dnZXIgPSBudWxsOyAvLyBpdCB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZSBmaXJzdCBsb2cgb3BlcmF0aW9uXG4gICAgICAgIGlmIChjdXJyZW50V2luc3RvbkxvZ2dlcikge1xuICAgICAgICAgICAgY3VycmVudFdpbnN0b25Mb2dnZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUcmFuc3BvcnRMYWJlbHModHJhbnNwb3J0TGFiZWxzSW5wdXQpIHtcbiAgICAgICAgdHJhbnNwb3J0TGFiZWxzID0gdHJhbnNwb3J0TGFiZWxzSW5wdXQ7XG4gICAgfVxuICAgIHRoaXMuZ2V0VHJhbnNwb3J0TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0TGFiZWxzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFRhZyB0aGUgdGFnIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGV2ZWwgYXQgd2hpY2ggdG8gbG9nXG4gICAgICogICB0aGUgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICovXG4gICAgY29uc3QgbG9nTWVzc2FnZSA9IGZ1bmN0aW9uIChsZXZlbFRhZywgbWVzc2FnZSkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB3aW5zdG9uIGxvZ2dlciBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCF3aW5zdG9uTG9nZ2VyKSB7XG4gICAgICAgICAgICBsZXQgdHJhbnNwb3J0cztcbiAgICAgICAgICAgIGxldCB0cmFuc3BvcnRMYWJlbHM7XG4gICAgICAgICAgICBpZiAoJ1NURE9VVCcgPT09IGZpbGVQYXRoLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzID0gW25ldyB3aW5zdG9uLnRyYW5zcG9ydHMuQ29uc29sZSgpXTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRMYWJlbHMgPSBbJ0NvbnNvbGUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFkZGl0aW9uYWxMb2dUb0NvbnNvbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgd2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IHdpbnN0b24udHJhbnNwb3J0cy5GaWxlKHsgZmlsZW5hbWU6IGZpbGVQYXRoIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0TGFiZWxzID0gWydDb25zb2xlJywgJ0ZpbGUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHMgPSBbbmV3IHdpbnN0b24udHJhbnNwb3J0cy5GaWxlKHsgZmlsZW5hbWU6IGZpbGVQYXRoIH0pXTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRMYWJlbHMgPSBbJ0ZpbGUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbnN0b25Mb2dnZXIgPSBuZXcgd2luc3Rvbi5jcmVhdGVMb2dnZXIoe1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IHRyYW5zcG9ydHMsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGNvbW1vbi5nZXRMZXZlbFRhZygpLFxuICAgICAgICAgICAgICAgIGxldmVsczogY29tbW9uLmdldExldmVsVGFnc01hcCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRUcmFuc3BvcnRMYWJlbHModHJhbnNwb3J0TGFiZWxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgdGhlIGFwcHJvcHJpYXRlIGxvZ2dpbmcgbWV0aG9kIHVzaW5nIHRoZSBsZXZlbCB0YWcgYW5kIHVzZSB0aGlzXG4gICAgICAgIC8vIG1ldGhvZCB0byBsb2cgdGhlIG1lc3NhZ2VcbiAgICAgICAgd2luc3RvbkxvZ2dlcltsZXZlbFRhZ10obWVzc2FnZSk7XG4gICAgfTtcbiAgICAvLyBjcmVhdGUgYW4gaW5uZXIgaW1wbGVtZW50YXRpb24gdG8gd2hpY2ggYWxsIG91ciBtZXRob2RzIHdpbGwgYmUgZm9yd2FyZGVkXG4gICAgY29uc3QgY29tbW9uID0gQ29yZS5jcmVhdGVMb2dnZXIob3B0aW9ucywgbG9nTWVzc2FnZSwgcmVjb25maWd1cmVXaW5zdG9uTG9nZ2VyKTtcbiAgICBmdW5jdGlvbiBnZXRGaWxlUGF0aChvcHRpb25zKSB7XG4gICAgICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmlsZVBhdGggPz8gZGVmYXVsdEZpbGVQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0RmlsZVBhdGg7XG4gICAgfVxuICAgIHRoaXMuZ2V0TGV2ZWxUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb24uZ2V0TGV2ZWxUYWcoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TGV2ZWxUYWdzTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uLmdldExldmVsVGFnc01hcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGlzIGxvZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5hZGRpdGlvbmFsTG9nVG9Db25zb2xlKSkge1xuICAgICAgICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IG9wdGlvbnMuYWRkaXRpb25hbExvZ1RvQ29uc29sZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGUgPSBERUZBVUxUX0FERElUSU9OQUxfTE9HX1RPX0NPTlNPTEU7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9nIGxldmVsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uLmdldExldmVsTnVtYmVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgZXJyb3IgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICB0aGlzLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24uZXJyb3IuYXBwbHkoY29tbW9uLCBbbWVzc2FnZSwgLi4ucGFyYW1zXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgd2FybmluZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29tbW9uLndhcm4uYXBwbHkoY29tbW9uLCBbbWVzc2FnZSwgLi4ucGFyYW1zXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgaW5mbyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29tbW9uLmluZm8uYXBwbHkoY29tbW9uLCBbbWVzc2FnZSwgLi4ucGFyYW1zXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgZGVidWcgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICB0aGlzLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24uZGVidWcuYXBwbHkoY29tbW9uLCBbbWVzc2FnZSwgLi4ucGFyYW1zXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgdHJhY2UgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgICAgICBjb21tb24udHJhY2UuYXBwbHkoY29tbW9uLCBbbWVzc2FnZSwgLi4ucGFyYW1zXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2cgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TG9nQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uLmdldExvZ0J1ZmZlcigpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IExvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/parameters.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\n/**\n * Creates a new Parameter.\n *\n * @param {Object} options\n * @constructor\n */\nfunction Parameter(options) {\n    // validate input\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isString(options.name));\n    Errors.assertInternal(Util.exists(options.value));\n    const name = options.name;\n    let value = options.value;\n    /**\n     * Returns the name of the parameter.\n     *\n     * @returns {String}\n     */\n    this.getName = function () {\n        return name;\n    };\n    /**\n     * Returns the value of the parameter.\n     *\n     * @returns {*}\n     */\n    this.getValue = function () {\n        return value;\n    };\n    /**\n     * Updates the value of the parameter.\n     *\n     * @param {*} targetValue\n     */\n    this.setValue = function (targetValue) {\n        value = targetValue;\n    };\n}\nconst names = (exports.names = {});\nnames.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS = 'JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS';\nnames.SERVICE_NAME = 'SERVICE_NAME';\nnames.CLIENT_SESSION_KEEP_ALIVE = 'CLIENT_SESSION_KEEP_ALIVE';\nnames.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY =\n    'CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY';\nnames.JS_TREAT_INTEGER_AS_BIGINT = 'JS_TREAT_INTEGER_AS_BIGINT';\nnames.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD = 'CLIENT_STAGE_ARRAY_BINDING_THRESHOLD';\nnames.MULTI_STATEMENT_COUNT = 'MULTI_STATEMENT_COUNT';\nnames.QUERY_CONTEXT_CACHE_SIZE = 'QUERY_CONTEXT_CACHE_SIZE';\nconst parameters = [\n    new Parameter({\n        name: names.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS,\n        value: false,\n        desc: 'Whether to disable OCSP validation in the JavaScript driver ' +\n            'when communicating with non-Snowflake endpoints (e.g. S3/Blob).',\n    }),\n    new Parameter({\n        name: names.SERVICE_NAME,\n        value: '',\n        desc: 'Hint for load balancer.',\n    }),\n    new Parameter({\n        name: names.CLIENT_SESSION_KEEP_ALIVE,\n        value: false,\n        desc: 'When true, enables the driver to keep the session alive indefinitely',\n    }),\n    new Parameter({\n        name: names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY,\n        value: 3600,\n        desc: 'The amount of time (in seconds) between subsequent heartbeat requests to the server.',\n    }),\n    new Parameter({\n        name: names.JS_TREAT_INTEGER_AS_BIGINT,\n        value: false,\n        desc: 'When true, enables the driver converts integer columns into BigInt',\n    }),\n    new Parameter({\n        name: names.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD,\n        value: 100000,\n        desc: 'The client stage array binding threshold',\n    }),\n    new Parameter({\n        name: names.MULTI_STATEMENT_COUNT,\n        value: 1,\n        desc: 'When 1, multi statement is disable, when 0, multi statement is unlimited',\n    }),\n    new Parameter({\n        name: names.QUERY_CONTEXT_CACHE_SIZE,\n        value: 5,\n        desc: 'Query Context Cache Size',\n    }),\n];\n// put all the parameters in a map so they're easy to retrieve and update\nconst mapParamNameToParam = {};\nfor (let index = 0, length = parameters.length; index < length; index++) {\n    const parameter = parameters[index];\n    mapParamNameToParam[parameter.getName()] = parameter;\n}\n/**\n * Returns the value of a given parameter.\n *\n * @param {String} parameterName\n *\n * @returns {*}\n */\nexports.getValue = function (parameterName) {\n    // resolve the parameter name\n    const parameter = mapParamNameToParam[parameterName];\n    // verify that a valid parameter name was specified\n    Errors.assertInternal(Util.exists(parameter), 'invalid parameter name: ' + parameterName);\n    return parameter.getValue();\n};\n/**\n * Updates the parameter values.\n *\n * @param {Object[]} parametersConfig\n */\nexports.update = function (parametersConfig) {\n    // if an input is specified\n    if (Util.exists(parametersConfig)) {\n        Errors.assertInternal(Util.isArray(parametersConfig));\n        // if any of the items in the configs array matches a known\n        // parameter, update the corresponding parameter's value\n        for (let index = 0, length = parametersConfig.length; index < length; index++) {\n            const parameterConfig = parametersConfig[index];\n            if (Object.prototype.hasOwnProperty.call(mapParamNameToParam, parameterConfig.name)) {\n                const parameter = mapParamNameToParam[parameterConfig.name];\n                parameter.setValue(parameterConfig.value);\n            }\n        }\n    }\n};\n//# sourceMappingURL=parameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9wYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWEsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvcGFyYW1ldGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFyYW1ldGVyKG9wdGlvbnMpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc1N0cmluZyhvcHRpb25zLm5hbWUpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMob3B0aW9ucy52YWx1ZSkpO1xuICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgbGV0IHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0VmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gKHRhcmdldFZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgfTtcbn1cbmNvbnN0IG5hbWVzID0gKGV4cG9ydHMubmFtZXMgPSB7fSk7XG5uYW1lcy5KU19EUklWRVJfRElTQUJMRV9PQ1NQX0ZPUl9OT05fU0ZfRU5EUE9JTlRTID0gJ0pTX0RSSVZFUl9ESVNBQkxFX09DU1BfRk9SX05PTl9TRl9FTkRQT0lOVFMnO1xubmFtZXMuU0VSVklDRV9OQU1FID0gJ1NFUlZJQ0VfTkFNRSc7XG5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFID0gJ0NMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkUnO1xubmFtZXMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZID1cbiAgICAnQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZJztcbm5hbWVzLkpTX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UID0gJ0pTX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UJztcbm5hbWVzLkNMSUVOVF9TVEFHRV9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCA9ICdDTElFTlRfU1RBR0VfQVJSQVlfQklORElOR19USFJFU0hPTEQnO1xubmFtZXMuTVVMVElfU1RBVEVNRU5UX0NPVU5UID0gJ01VTFRJX1NUQVRFTUVOVF9DT1VOVCc7XG5uYW1lcy5RVUVSWV9DT05URVhUX0NBQ0hFX1NJWkUgPSAnUVVFUllfQ09OVEVYVF9DQUNIRV9TSVpFJztcbmNvbnN0IHBhcmFtZXRlcnMgPSBbXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLkpTX0RSSVZFUl9ESVNBQkxFX09DU1BfRk9SX05PTl9TRl9FTkRQT0lOVFMsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgZGVzYzogJ1doZXRoZXIgdG8gZGlzYWJsZSBPQ1NQIHZhbGlkYXRpb24gaW4gdGhlIEphdmFTY3JpcHQgZHJpdmVyICcgK1xuICAgICAgICAgICAgJ3doZW4gY29tbXVuaWNhdGluZyB3aXRoIG5vbi1Tbm93Zmxha2UgZW5kcG9pbnRzIChlLmcuIFMzL0Jsb2IpLicsXG4gICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLlNFUlZJQ0VfTkFNRSxcbiAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICBkZXNjOiAnSGludCBmb3IgbG9hZCBiYWxhbmNlci4nLFxuICAgIH0pLFxuICAgIG5ldyBQYXJhbWV0ZXIoe1xuICAgICAgICBuYW1lOiBuYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIGRlc2M6ICdXaGVuIHRydWUsIGVuYWJsZXMgdGhlIGRyaXZlciB0byBrZWVwIHRoZSBzZXNzaW9uIGFsaXZlIGluZGVmaW5pdGVseScsXG4gICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkVfSEVBUlRCRUFUX0ZSRVFVRU5DWSxcbiAgICAgICAgdmFsdWU6IDM2MDAsXG4gICAgICAgIGRlc2M6ICdUaGUgYW1vdW50IG9mIHRpbWUgKGluIHNlY29uZHMpIGJldHdlZW4gc3Vic2VxdWVudCBoZWFydGJlYXQgcmVxdWVzdHMgdG8gdGhlIHNlcnZlci4nLFxuICAgIH0pLFxuICAgIG5ldyBQYXJhbWV0ZXIoe1xuICAgICAgICBuYW1lOiBuYW1lcy5KU19UUkVBVF9JTlRFR0VSX0FTX0JJR0lOVCxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBkZXNjOiAnV2hlbiB0cnVlLCBlbmFibGVzIHRoZSBkcml2ZXIgY29udmVydHMgaW50ZWdlciBjb2x1bW5zIGludG8gQmlnSW50JyxcbiAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKHtcbiAgICAgICAgbmFtZTogbmFtZXMuQ0xJRU5UX1NUQUdFX0FSUkFZX0JJTkRJTkdfVEhSRVNIT0xELFxuICAgICAgICB2YWx1ZTogMTAwMDAwLFxuICAgICAgICBkZXNjOiAnVGhlIGNsaWVudCBzdGFnZSBhcnJheSBiaW5kaW5nIHRocmVzaG9sZCcsXG4gICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcih7XG4gICAgICAgIG5hbWU6IG5hbWVzLk1VTFRJX1NUQVRFTUVOVF9DT1VOVCxcbiAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgIGRlc2M6ICdXaGVuIDEsIG11bHRpIHN0YXRlbWVudCBpcyBkaXNhYmxlLCB3aGVuIDAsIG11bHRpIHN0YXRlbWVudCBpcyB1bmxpbWl0ZWQnLFxuICAgIH0pLFxuICAgIG5ldyBQYXJhbWV0ZXIoe1xuICAgICAgICBuYW1lOiBuYW1lcy5RVUVSWV9DT05URVhUX0NBQ0hFX1NJWkUsXG4gICAgICAgIHZhbHVlOiA1LFxuICAgICAgICBkZXNjOiAnUXVlcnkgQ29udGV4dCBDYWNoZSBTaXplJyxcbiAgICB9KSxcbl07XG4vLyBwdXQgYWxsIHRoZSBwYXJhbWV0ZXJzIGluIGEgbWFwIHNvIHRoZXkncmUgZWFzeSB0byByZXRyaWV2ZSBhbmQgdXBkYXRlXG5jb25zdCBtYXBQYXJhbU5hbWVUb1BhcmFtID0ge307XG5mb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbaW5kZXhdO1xuICAgIG1hcFBhcmFtTmFtZVRvUGFyYW1bcGFyYW1ldGVyLmdldE5hbWUoKV0gPSBwYXJhbWV0ZXI7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbWV0ZXJOYW1lXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAocGFyYW1ldGVyTmFtZSkge1xuICAgIC8vIHJlc29sdmUgdGhlIHBhcmFtZXRlciBuYW1lXG4gICAgY29uc3QgcGFyYW1ldGVyID0gbWFwUGFyYW1OYW1lVG9QYXJhbVtwYXJhbWV0ZXJOYW1lXTtcbiAgICAvLyB2ZXJpZnkgdGhhdCBhIHZhbGlkIHBhcmFtZXRlciBuYW1lIHdhcyBzcGVjaWZpZWRcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMocGFyYW1ldGVyKSwgJ2ludmFsaWQgcGFyYW1ldGVyIG5hbWU6ICcgKyBwYXJhbWV0ZXJOYW1lKTtcbiAgICByZXR1cm4gcGFyYW1ldGVyLmdldFZhbHVlKCk7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IHBhcmFtZXRlcnNDb25maWdcbiAqL1xuZXhwb3J0cy51cGRhdGUgPSBmdW5jdGlvbiAocGFyYW1ldGVyc0NvbmZpZykge1xuICAgIC8vIGlmIGFuIGlucHV0IGlzIHNwZWNpZmllZFxuICAgIGlmIChVdGlsLmV4aXN0cyhwYXJhbWV0ZXJzQ29uZmlnKSkge1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KHBhcmFtZXRlcnNDb25maWcpKTtcbiAgICAgICAgLy8gaWYgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgY29uZmlncyBhcnJheSBtYXRjaGVzIGEga25vd25cbiAgICAgICAgLy8gcGFyYW1ldGVyLCB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyJ3MgdmFsdWVcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBwYXJhbWV0ZXJzQ29uZmlnLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlckNvbmZpZyA9IHBhcmFtZXRlcnNDb25maWdbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXBQYXJhbU5hbWVUb1BhcmFtLCBwYXJhbWV0ZXJDb25maWcubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXIgPSBtYXBQYXJhbU5hbWVUb1BhcmFtW3BhcmFtZXRlckNvbmZpZy5uYW1lXTtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXIuc2V0VmFsdWUocGFyYW1ldGVyQ29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/proxy_util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst GlobalConfig = __webpack_require__(/*! ./global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst LoggingUtil = __webpack_require__(/*! ./logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/logging_util.js\");\nconst ErrorCodes = Errors.codes;\n/**\n * @typedef {object} Proxy\n * @property {string} host - The host address of the proxy.\n * @property {string} protocol - The protocol used by the proxy (e.g., \"http\" or \"https\")\n * @property {string} user - The username for the proxy\n * @property {number} port - The port number.\n * @property {string} password - The password for the proxy\n * @property {string} noProxy -  Optional list of domains that should bypass the prox\n */\n/**\n * remove http:// or https:// from the input, e.g. used with proxy URL\n * @param input\n * @returns {string}\n */\nexports.removeScheme = function (input) {\n    return input.toString().replace(/(^\\w+:|^)\\/\\//, '');\n};\n/**\n * Try to get the PROXY environmental variables\n * On Windows, envvar name is case-insensitive, but on *nix, it's case-sensitive\n *\n * Compare them with the proxy specified on the Connection, if any\n * Return with the log constructed from the components detection and comparison\n * If there's something to warn the user about, return that too\n *\n * @param {Proxy} agentOptions from agent creation\n * @returns {{messages: string, warnings: string}} log messages\n */\nexports.getCompareAndLogEnvAndAgentProxies = function (agentOptions) {\n    const envProxy = {};\n    const logMessages = { messages: '', warnings: '' };\n    envProxy.httpProxy = process.env.http_proxy || process.env.HTTP_PROXY;\n    envProxy.httpsProxy = process.env.https_proxy || process.env.HTTPS_PROXY;\n    envProxy.noProxy = process.env.no_proxy || process.env.NO_PROXY;\n    envProxy.logHttpProxy = envProxy.httpProxy\n        ? 'HTTP_PROXY: ' + envProxy.httpProxy\n        : 'HTTP_PROXY: <unset>';\n    envProxy.logHttpsProxy = envProxy.httpsProxy\n        ? 'HTTPS_PROXY: ' + envProxy.httpsProxy\n        : 'HTTPS_PROXY: <unset>';\n    envProxy.logNoProxy = envProxy.noProxy ? 'NO_PROXY: ' + envProxy.noProxy : 'NO_PROXY: <unset>';\n    // log PROXY envvars\n    if (envProxy.httpProxy || envProxy.httpsProxy) {\n        logMessages.messages =\n            logMessages.messages +\n                ' // PROXY environment variables: ' +\n                `${envProxy.logHttpProxy} ${envProxy.logHttpsProxy} ${envProxy.logNoProxy}.`;\n    }\n    // log proxy config on Connection, if any set\n    if (agentOptions.host) {\n        const proxyHostAndPort = agentOptions.host + ':' + agentOptions.port;\n        const proxyProtocolHostAndPort = agentOptions.protocol\n            ? ' protocol=' + agentOptions.protocol + ' proxy=' + proxyHostAndPort\n            : ' proxy=' + proxyHostAndPort;\n        const proxyUsername = agentOptions.user ? ' user=' + agentOptions.user : '';\n        const proxyString = `${Util.exists(agentOptions.user) ? `${agentOptions.user}:${agentOptions.password}@` : ''}${proxyHostAndPort}`.toLowerCase();\n        logMessages.messages =\n            logMessages.messages +\n                ` // Proxy configured in Agent:${proxyProtocolHostAndPort}${proxyUsername}`;\n        // check if both the PROXY envvars and Connection proxy config is set\n        // generate warnings if they are, and are also different\n        if (envProxy.httpProxy &&\n            this.removeScheme(envProxy.httpProxy).toLowerCase() !== proxyString.toLowerCase()) {\n            logMessages.warnings =\n                logMessages.warnings +\n                    ` Using both the HTTP_PROXY (${this.describeProxy(this.getProxyFromEnv(false))})` +\n                    ` and the Connection proxy (${this.describeProxy(agentOptions)}), but with different values.` +\n                    ' If you experience connectivity issues, try unsetting one of them.';\n        }\n        if (envProxy.httpsProxy &&\n            this.removeScheme(envProxy.httpsProxy).toLowerCase() !== proxyString.toLowerCase()) {\n            logMessages.warnings =\n                logMessages.warnings +\n                    ` Using both the HTTPS_PROXY (${this.describeProxy(this.getProxyFromEnv(true))})` +\n                    ` and the Connection proxy (${this.describeProxy(agentOptions)}) settings to connect, but with different values.` +\n                    ' If you experience connectivity issues, try unsetting one of them.';\n        }\n    }\n    logMessages.messages = logMessages.messages ? logMessages.messages : ' none.';\n    return logMessages;\n};\n/**\n * Validate whether the proxy object has the appropriate information\n *\n * @param {Proxy} proxy\n * @returns {Proxy}\n */\nexports.validateProxy = function (proxy) {\n    const { host, port, noProxy, user, password } = proxy;\n    // check for missing proxyHost\n    Errors.checkArgumentExists(Util.exists(host), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_HOST);\n    // check for invalid proxyHost\n    Errors.checkArgumentValid(Util.isString(host), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_HOST);\n    // check for missing proxyPort\n    Errors.checkArgumentExists(Util.exists(port), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_PORT);\n    // check for invalid proxyPort\n    Errors.checkArgumentValid(Util.isNumber(port), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_PORT);\n    if (Util.exists(noProxy)) {\n        // check for invalid noProxy\n        Errors.checkArgumentValid(Util.isString(noProxy), ErrorCodes.ERR_CONN_CREATE_INVALID_NO_PROXY);\n    }\n    if (Util.exists(user) || Util.exists(password)) {\n        // check for missing proxyUser\n        Errors.checkArgumentExists(Util.exists(user), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_USER);\n        // check for invalid proxyUser\n        Errors.checkArgumentValid(Util.isString(user), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_USER);\n        // check for missing proxyPassword\n        Errors.checkArgumentExists(Util.exists(password), ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_PASS);\n        // check for invalid proxyPassword\n        Errors.checkArgumentValid(Util.isString(password), ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_PASS);\n    }\n    else {\n        delete proxy.user;\n        delete proxy.password;\n    }\n};\n/**\n * Obtain the proxy information from the environment variable.\n *\n * @param {boolean} isHttps\n * @returns {Proxy}\n */\nexports.getProxyFromEnv = function (isHttps = true) {\n    const getDefaultPortIfNotSet = (proxyFromEnv) => {\n        const isProxyProtocolHttps = proxyFromEnv.protocol === 'https:';\n        if (!proxyFromEnv.port) {\n            return isProxyProtocolHttps ? 443 : 80;\n        }\n        else {\n            return proxyFromEnv.port;\n        }\n    };\n    const protocol = isHttps ? 'https' : 'http';\n    let proxyFromEnv = Util.getEnvVar(`${protocol}_proxy`);\n    if (!proxyFromEnv) {\n        return null;\n    }\n    Logger.getInstance().debug(`Util.getProxyEnv: Using ${protocol.toUpperCase()}_PROXY from the environment variable`);\n    if (proxyFromEnv.indexOf('://') === -1) {\n        Logger.getInstance().info('Util.getProxyEnv: the protocol was missing from the environment proxy. Use the HTTP protocol.');\n        proxyFromEnv = 'http' + '://' + proxyFromEnv;\n    }\n    proxyFromEnv = new URL(proxyFromEnv);\n    const port = getDefaultPortIfNotSet(proxyFromEnv);\n    const proxy = {\n        host: Util.validateEmptyString(proxyFromEnv.hostname),\n        port: Number(port),\n        user: Util.validateEmptyString(proxyFromEnv.username),\n        password: Util.validateEmptyString(proxyFromEnv.password),\n        protocol: Util.validateEmptyString(proxyFromEnv.protocol),\n        noProxy: this.getNoProxyEnv(),\n        useForOCSP: !isHttps,\n    };\n    this.validateProxy(proxy);\n    return proxy;\n};\n/**\n * Obtain the no proxy information from the environment variable.\n *\n * @returns {string | undefined}\n */\nexports.getNoProxyEnv = function () {\n    const noProxy = Util.getEnvVar('no_proxy');\n    if (noProxy) {\n        return noProxy.split(',').join('|');\n    }\n    return undefined;\n};\n/**\n * Extract the host from the destination URL to check whether the same agent already exists or not.\n *\n * @param {string} destination\n * @returns {string}\n */\nexports.getHostFromURL = function (destination) {\n    if (destination.indexOf('://') === -1) {\n        destination = 'https' + '://' + destination;\n    }\n    try {\n        return new URL(destination).hostname;\n    }\n    catch (err) {\n        Logger.getInstance().error(`Failed to parse the destination to URL with the error: ${err}. Return destination as the host: ${destination}`);\n        return destination;\n    }\n};\n/**\n * if proxy exists, return the proxy. If not and the useEnvProxy is true, return the proxy from the environment variable.\n * @param {Proxy} proxy\n * @param {string} moduleName\n * @param {string} isHttp\n *\n * @returns {Proxy}\n */\nexports.getProxy = function (proxy, moduleName, isHttps) {\n    if (!proxy && GlobalConfig.isEnvProxyActive()) {\n        proxy = this.getProxyFromEnv(isHttps);\n        if (proxy) {\n            Logger.getInstance().debug(`${moduleName} loads the proxy info from the environment variable host: ${proxy.host}`);\n        }\n    }\n    return proxy;\n};\n/**\n * The proxy configuration fields in Azure are different from the proxy fields in the snowflake node.js driver.\n * Because of that, this function converts the snowflake proxy info to the Azure proxy info.\n * @param {Proxy} proxy\n * @returns {{host:string, port:number, user?:string, password?:string}}}\n */\nexports.getAzureProxy = function (proxy) {\n    const AzureProxy = {\n        ...proxy,\n        host: `${proxy.protocol}${proxy.protocol.endsWith(':') ? '' : ':'}//${proxy.host}`,\n    };\n    delete AzureProxy.noProxy;\n    delete AzureProxy.protocol;\n    if (!Util.exists(AzureProxy.user) || !Util.exists(AzureProxy.password)) {\n        delete AzureProxy.user;\n        delete AzureProxy.password;\n    }\n    return AzureProxy;\n};\n/**\n * Currently, there is no way to disable loading the proxy information from the environment path in Azure/blob.\n * To control this proxy option on the driver side, A temporary workaround is hide(remove) the environment proxy from the process\n * when the client is created (At this time, the client loads the proxy from the environment variables internally).\n * After the client is created, restore them with the 'restoreEnvironmentProxy' function.\n */\nlet envProxyList;\nconst proxyEnvList = ['http_proxy', 'https_proxy', 'no_proxy'];\nexports.hideEnvironmentProxy = function () {\n    if (GlobalConfig.isEnvProxyActive()) {\n        return;\n    }\n    Logger.getInstance().debug('As the useEnvProxy option is disabled, the proxy environment variables are temporarily hidden during the creation of an Azure client');\n    envProxyList = [];\n    for (const envVar of proxyEnvList) {\n        saveProxyInfoInList(envVar);\n        if (!Util.isWindows()) {\n            saveProxyInfoInList(envVar.toUpperCase());\n        }\n    }\n};\nfunction saveProxyInfoInList(envVar) {\n    const proxyEnv = process.env[envVar];\n    envProxyList.push(process.env[envVar]);\n    delete process.env[envVar];\n    if (Util.exists(proxyEnv)) {\n        Logger.getInstance().debug(`Temporarily exclude ${envVar} from the environment variable value: ${proxyEnv}`);\n    }\n    else {\n        Logger.getInstance().debug(`${envVar} was not defined, nothing to do`);\n    }\n}\nexports.restoreEnvironmentProxy = function () {\n    if (GlobalConfig.isEnvProxyActive()) {\n        return;\n    }\n    const iterator = envProxyList[Symbol.iterator]();\n    let nextValue = iterator.next().value;\n    for (const envVar of proxyEnvList) {\n        if (Util.exists(nextValue)) {\n            Logger.getInstance().debug(`The ${envVar} value exists with the value: ${nextValue} Restore back the proxy environment variable values`);\n            process.env[envVar] = nextValue;\n        }\n        nextValue = iterator.next().value;\n        if (!Util.isWindows()) {\n            if (Util.exists(nextValue)) {\n                Logger.getInstance().debug(`The ${envVar.toUpperCase()} value exists with the value: ${nextValue} Restore back the proxy environment variable values (for Non-Windows machine)`);\n                process.env[envVar.toUpperCase()] = nextValue;\n            }\n            nextValue = iterator.next().value;\n        }\n    }\n    Logger.getInstance().debug('An Azure client has been created. Restore back the proxy environment variable values');\n};\n/**\n * Provide the details of the proxy info.\n * @param proxy\n * @param destination {string | Regex }\n */\nexports.isByPassProxy = function (proxy, destination) {\n    if (proxy && proxy.noProxy) {\n        const bypassList = proxy.noProxy.split('|');\n        return bypassList.find((noProxy) => {\n            let host = noProxy.trim();\n            host = host.replace('*', '.*?');\n            if (destination instanceof RegExp) {\n                return destination.test(host);\n            }\n            const noProxyRegex = new RegExp(`^${host}`);\n            return noProxyRegex.test(destination);\n        });\n    }\n};\n/**\n * Provide the details of the proxy info.\n * @param proxy\n * @returns {string}\n */\nexports.describeProxy = function (proxy) {\n    if (Util.exists(proxy)) {\n        return (`proxyHost: ${proxy.host}, proxyPort: ${proxy.port}, ` +\n            `${Util.exists(proxy.user) ? `proxyUser: ${proxy.user}, proxyPassword is ${LoggingUtil.describePresence(proxy.password)}, ` : ''}` +\n            `proxyProtocol: ${proxy.protocol}, noProxy: ${proxy.noProxy}`);\n    }\n    else {\n        return 'proxy was not configured';\n    }\n};\n/**\n * Make the proxy string with the proxy info (json format)\n * @param proxy\n * @returns {string}\n */\nexports.stringifyProxy = function (proxy) {\n    if (Util.isEmptyObject(proxy)) {\n        return null;\n    }\n    return (`${proxy.protocol.startsWith('https') ? 'https' : 'http'}://` +\n        `${Util.exists(proxy.user) ? `${proxy.user}:${proxy.password}@` : ''}` +\n        `${proxy.host}:${proxy.port}`);\n};\n//# sourceMappingURL=proxy_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9wcm94eV91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLHVFQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0IscUJBQXFCLG1CQUFPLENBQUMscUZBQWlCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGlHQUF1QjtBQUNuRDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUIsRUFBRSx3QkFBd0IsRUFBRSxvQkFBb0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0Msa0JBQWtCLEdBQUcsc0JBQXNCLFFBQVEsRUFBRSxpQkFBaUI7QUFDekk7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUIsRUFBRSxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBZ0Q7QUFDbkcsa0RBQWtELGlDQUFpQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0NBQStDO0FBQ25HLGtEQUFrRCxpQ0FBaUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQixZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHVCQUF1QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixJQUFJLG9DQUFvQyxZQUFZO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSwyREFBMkQsV0FBVztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixjQUFjO0FBQ2Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQixlQUFlLEVBQUUsd0NBQXdDLElBQUksV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUSx1Q0FBdUMsU0FBUztBQUNsSDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRLCtCQUErQixXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsc0JBQXNCLCtCQUErQixXQUFXO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsOEJBQThCLFdBQVcsZUFBZSxXQUFXO0FBQ25FLGVBQWUsd0NBQXdDLFdBQVcscUJBQXFCLDZDQUE2QyxTQUFTO0FBQzdJLDhCQUE4QixlQUFlLGFBQWEsY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFLFdBQVcsNkJBQTZCLFdBQVcsR0FBRyxlQUFlLFFBQVE7QUFDN0UsV0FBVyxXQUFXLEdBQUcsV0FBVztBQUNwQztBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9wcm94eV91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IExvZ2dpbmdVdGlsID0gcmVxdWlyZSgnLi9sb2dnZXIvbG9nZ2luZ191dGlsJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcm94eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3QgLSBUaGUgaG9zdCBhZGRyZXNzIG9mIHRoZSBwcm94eS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm90b2NvbCAtIFRoZSBwcm90b2NvbCB1c2VkIGJ5IHRoZSBwcm94eSAoZS5nLiwgXCJodHRwXCIgb3IgXCJodHRwc1wiKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVzZXIgLSBUaGUgdXNlcm5hbWUgZm9yIHRoZSBwcm94eVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvcnQgLSBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgZm9yIHRoZSBwcm94eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5vUHJveHkgLSAgT3B0aW9uYWwgbGlzdCBvZiBkb21haW5zIHRoYXQgc2hvdWxkIGJ5cGFzcyB0aGUgcHJveFxuICovXG4vKipcbiAqIHJlbW92ZSBodHRwOi8vIG9yIGh0dHBzOi8vIGZyb20gdGhlIGlucHV0LCBlLmcuIHVzZWQgd2l0aCBwcm94eSBVUkxcbiAqIEBwYXJhbSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5yZW1vdmVTY2hlbWUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKS5yZXBsYWNlKC8oXlxcdys6fF4pXFwvXFwvLywgJycpO1xufTtcbi8qKlxuICogVHJ5IHRvIGdldCB0aGUgUFJPWFkgZW52aXJvbm1lbnRhbCB2YXJpYWJsZXNcbiAqIE9uIFdpbmRvd3MsIGVudnZhciBuYW1lIGlzIGNhc2UtaW5zZW5zaXRpdmUsIGJ1dCBvbiAqbml4LCBpdCdzIGNhc2Utc2Vuc2l0aXZlXG4gKlxuICogQ29tcGFyZSB0aGVtIHdpdGggdGhlIHByb3h5IHNwZWNpZmllZCBvbiB0aGUgQ29ubmVjdGlvbiwgaWYgYW55XG4gKiBSZXR1cm4gd2l0aCB0aGUgbG9nIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvbXBvbmVudHMgZGV0ZWN0aW9uIGFuZCBjb21wYXJpc29uXG4gKiBJZiB0aGVyZSdzIHNvbWV0aGluZyB0byB3YXJuIHRoZSB1c2VyIGFib3V0LCByZXR1cm4gdGhhdCB0b29cbiAqXG4gKiBAcGFyYW0ge1Byb3h5fSBhZ2VudE9wdGlvbnMgZnJvbSBhZ2VudCBjcmVhdGlvblxuICogQHJldHVybnMge3ttZXNzYWdlczogc3RyaW5nLCB3YXJuaW5nczogc3RyaW5nfX0gbG9nIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydHMuZ2V0Q29tcGFyZUFuZExvZ0VudkFuZEFnZW50UHJveGllcyA9IGZ1bmN0aW9uIChhZ2VudE9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnZQcm94eSA9IHt9O1xuICAgIGNvbnN0IGxvZ01lc3NhZ2VzID0geyBtZXNzYWdlczogJycsIHdhcm5pbmdzOiAnJyB9O1xuICAgIGVudlByb3h5Lmh0dHBQcm94eSA9IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWTtcbiAgICBlbnZQcm94eS5odHRwc1Byb3h5ID0gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFk7XG4gICAgZW52UHJveHkubm9Qcm94eSA9IHByb2Nlc3MuZW52Lm5vX3Byb3h5IHx8IHByb2Nlc3MuZW52Lk5PX1BST1hZO1xuICAgIGVudlByb3h5LmxvZ0h0dHBQcm94eSA9IGVudlByb3h5Lmh0dHBQcm94eVxuICAgICAgICA/ICdIVFRQX1BST1hZOiAnICsgZW52UHJveHkuaHR0cFByb3h5XG4gICAgICAgIDogJ0hUVFBfUFJPWFk6IDx1bnNldD4nO1xuICAgIGVudlByb3h5LmxvZ0h0dHBzUHJveHkgPSBlbnZQcm94eS5odHRwc1Byb3h5XG4gICAgICAgID8gJ0hUVFBTX1BST1hZOiAnICsgZW52UHJveHkuaHR0cHNQcm94eVxuICAgICAgICA6ICdIVFRQU19QUk9YWTogPHVuc2V0Pic7XG4gICAgZW52UHJveHkubG9nTm9Qcm94eSA9IGVudlByb3h5Lm5vUHJveHkgPyAnTk9fUFJPWFk6ICcgKyBlbnZQcm94eS5ub1Byb3h5IDogJ05PX1BST1hZOiA8dW5zZXQ+JztcbiAgICAvLyBsb2cgUFJPWFkgZW52dmFyc1xuICAgIGlmIChlbnZQcm94eS5odHRwUHJveHkgfHwgZW52UHJveHkuaHR0cHNQcm94eSkge1xuICAgICAgICBsb2dNZXNzYWdlcy5tZXNzYWdlcyA9XG4gICAgICAgICAgICBsb2dNZXNzYWdlcy5tZXNzYWdlcyArXG4gICAgICAgICAgICAgICAgJyAvLyBQUk9YWSBlbnZpcm9ubWVudCB2YXJpYWJsZXM6ICcgK1xuICAgICAgICAgICAgICAgIGAke2VudlByb3h5LmxvZ0h0dHBQcm94eX0gJHtlbnZQcm94eS5sb2dIdHRwc1Byb3h5fSAke2VudlByb3h5LmxvZ05vUHJveHl9LmA7XG4gICAgfVxuICAgIC8vIGxvZyBwcm94eSBjb25maWcgb24gQ29ubmVjdGlvbiwgaWYgYW55IHNldFxuICAgIGlmIChhZ2VudE9wdGlvbnMuaG9zdCkge1xuICAgICAgICBjb25zdCBwcm94eUhvc3RBbmRQb3J0ID0gYWdlbnRPcHRpb25zLmhvc3QgKyAnOicgKyBhZ2VudE9wdGlvbnMucG9ydDtcbiAgICAgICAgY29uc3QgcHJveHlQcm90b2NvbEhvc3RBbmRQb3J0ID0gYWdlbnRPcHRpb25zLnByb3RvY29sXG4gICAgICAgICAgICA/ICcgcHJvdG9jb2w9JyArIGFnZW50T3B0aW9ucy5wcm90b2NvbCArICcgcHJveHk9JyArIHByb3h5SG9zdEFuZFBvcnRcbiAgICAgICAgICAgIDogJyBwcm94eT0nICsgcHJveHlIb3N0QW5kUG9ydDtcbiAgICAgICAgY29uc3QgcHJveHlVc2VybmFtZSA9IGFnZW50T3B0aW9ucy51c2VyID8gJyB1c2VyPScgKyBhZ2VudE9wdGlvbnMudXNlciA6ICcnO1xuICAgICAgICBjb25zdCBwcm94eVN0cmluZyA9IGAke1V0aWwuZXhpc3RzKGFnZW50T3B0aW9ucy51c2VyKSA/IGAke2FnZW50T3B0aW9ucy51c2VyfToke2FnZW50T3B0aW9ucy5wYXNzd29yZH1AYCA6ICcnfSR7cHJveHlIb3N0QW5kUG9ydH1gLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvZ01lc3NhZ2VzLm1lc3NhZ2VzID1cbiAgICAgICAgICAgIGxvZ01lc3NhZ2VzLm1lc3NhZ2VzICtcbiAgICAgICAgICAgICAgICBgIC8vIFByb3h5IGNvbmZpZ3VyZWQgaW4gQWdlbnQ6JHtwcm94eVByb3RvY29sSG9zdEFuZFBvcnR9JHtwcm94eVVzZXJuYW1lfWA7XG4gICAgICAgIC8vIGNoZWNrIGlmIGJvdGggdGhlIFBST1hZIGVudnZhcnMgYW5kIENvbm5lY3Rpb24gcHJveHkgY29uZmlnIGlzIHNldFxuICAgICAgICAvLyBnZW5lcmF0ZSB3YXJuaW5ncyBpZiB0aGV5IGFyZSwgYW5kIGFyZSBhbHNvIGRpZmZlcmVudFxuICAgICAgICBpZiAoZW52UHJveHkuaHR0cFByb3h5ICYmXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNjaGVtZShlbnZQcm94eS5odHRwUHJveHkpLnRvTG93ZXJDYXNlKCkgIT09IHByb3h5U3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGxvZ01lc3NhZ2VzLndhcm5pbmdzID1cbiAgICAgICAgICAgICAgICBsb2dNZXNzYWdlcy53YXJuaW5ncyArXG4gICAgICAgICAgICAgICAgICAgIGAgVXNpbmcgYm90aCB0aGUgSFRUUF9QUk9YWSAoJHt0aGlzLmRlc2NyaWJlUHJveHkodGhpcy5nZXRQcm94eUZyb21FbnYoZmFsc2UpKX0pYCArXG4gICAgICAgICAgICAgICAgICAgIGAgYW5kIHRoZSBDb25uZWN0aW9uIHByb3h5ICgke3RoaXMuZGVzY3JpYmVQcm94eShhZ2VudE9wdGlvbnMpfSksIGJ1dCB3aXRoIGRpZmZlcmVudCB2YWx1ZXMuYCArXG4gICAgICAgICAgICAgICAgICAgICcgSWYgeW91IGV4cGVyaWVuY2UgY29ubmVjdGl2aXR5IGlzc3VlcywgdHJ5IHVuc2V0dGluZyBvbmUgb2YgdGhlbS4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZQcm94eS5odHRwc1Byb3h5ICYmXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNjaGVtZShlbnZQcm94eS5odHRwc1Byb3h5KS50b0xvd2VyQ2FzZSgpICE9PSBwcm94eVN0cmluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBsb2dNZXNzYWdlcy53YXJuaW5ncyA9XG4gICAgICAgICAgICAgICAgbG9nTWVzc2FnZXMud2FybmluZ3MgK1xuICAgICAgICAgICAgICAgICAgICBgIFVzaW5nIGJvdGggdGhlIEhUVFBTX1BST1hZICgke3RoaXMuZGVzY3JpYmVQcm94eSh0aGlzLmdldFByb3h5RnJvbUVudih0cnVlKSl9KWAgK1xuICAgICAgICAgICAgICAgICAgICBgIGFuZCB0aGUgQ29ubmVjdGlvbiBwcm94eSAoJHt0aGlzLmRlc2NyaWJlUHJveHkoYWdlbnRPcHRpb25zKX0pIHNldHRpbmdzIHRvIGNvbm5lY3QsIGJ1dCB3aXRoIGRpZmZlcmVudCB2YWx1ZXMuYCArXG4gICAgICAgICAgICAgICAgICAgICcgSWYgeW91IGV4cGVyaWVuY2UgY29ubmVjdGl2aXR5IGlzc3VlcywgdHJ5IHVuc2V0dGluZyBvbmUgb2YgdGhlbS4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ01lc3NhZ2VzLm1lc3NhZ2VzID0gbG9nTWVzc2FnZXMubWVzc2FnZXMgPyBsb2dNZXNzYWdlcy5tZXNzYWdlcyA6ICcgbm9uZS4nO1xuICAgIHJldHVybiBsb2dNZXNzYWdlcztcbn07XG4vKipcbiAqIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHByb3h5IG9iamVjdCBoYXMgdGhlIGFwcHJvcHJpYXRlIGluZm9ybWF0aW9uXG4gKlxuICogQHBhcmFtIHtQcm94eX0gcHJveHlcbiAqIEByZXR1cm5zIHtQcm94eX1cbiAqL1xuZXhwb3J0cy52YWxpZGF0ZVByb3h5ID0gZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgY29uc3QgeyBob3N0LCBwb3J0LCBub1Byb3h5LCB1c2VyLCBwYXNzd29yZCB9ID0gcHJveHk7XG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcHJveHlIb3N0XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMoaG9zdCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfSE9TVCk7XG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcHJveHlIb3N0XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGhvc3QpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX0hPU1QpO1xuICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIHByb3h5UG9ydFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHBvcnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1BPUlQpO1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHByb3h5UG9ydFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihwb3J0KSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QT1JUKTtcbiAgICBpZiAoVXRpbC5leGlzdHMobm9Qcm94eSkpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgbm9Qcm94eVxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcobm9Qcm94eSksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfTk9fUFJPWFkpO1xuICAgIH1cbiAgICBpZiAoVXRpbC5leGlzdHModXNlcikgfHwgVXRpbC5leGlzdHMocGFzc3dvcmQpKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIHByb3h5VXNlclxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyh1c2VyKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9VU0VSKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcHJveHlVc2VyXG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyh1c2VyKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9VU0VSKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcHJveHlQYXNzd29yZFxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhwYXNzd29yZCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfUEFTUyk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHByb3h5UGFzc3dvcmRcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHBhc3N3b3JkKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QQVNTKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwcm94eS51c2VyO1xuICAgICAgICBkZWxldGUgcHJveHkucGFzc3dvcmQ7XG4gICAgfVxufTtcbi8qKlxuICogT2J0YWluIHRoZSBwcm94eSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHR0cHNcbiAqIEByZXR1cm5zIHtQcm94eX1cbiAqL1xuZXhwb3J0cy5nZXRQcm94eUZyb21FbnYgPSBmdW5jdGlvbiAoaXNIdHRwcyA9IHRydWUpIHtcbiAgICBjb25zdCBnZXREZWZhdWx0UG9ydElmTm90U2V0ID0gKHByb3h5RnJvbUVudikgPT4ge1xuICAgICAgICBjb25zdCBpc1Byb3h5UHJvdG9jb2xIdHRwcyA9IHByb3h5RnJvbUVudi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgIGlmICghcHJveHlGcm9tRW52LnBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1Byb3h5UHJvdG9jb2xIdHRwcyA/IDQ0MyA6IDgwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb3h5RnJvbUVudi5wb3J0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm90b2NvbCA9IGlzSHR0cHMgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICAgIGxldCBwcm94eUZyb21FbnYgPSBVdGlsLmdldEVudlZhcihgJHtwcm90b2NvbH1fcHJveHlgKTtcbiAgICBpZiAoIXByb3h5RnJvbUVudikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFV0aWwuZ2V0UHJveHlFbnY6IFVzaW5nICR7cHJvdG9jb2wudG9VcHBlckNhc2UoKX1fUFJPWFkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVgKTtcbiAgICBpZiAocHJveHlGcm9tRW52LmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdVdGlsLmdldFByb3h5RW52OiB0aGUgcHJvdG9jb2wgd2FzIG1pc3NpbmcgZnJvbSB0aGUgZW52aXJvbm1lbnQgcHJveHkuIFVzZSB0aGUgSFRUUCBwcm90b2NvbC4nKTtcbiAgICAgICAgcHJveHlGcm9tRW52ID0gJ2h0dHAnICsgJzovLycgKyBwcm94eUZyb21FbnY7XG4gICAgfVxuICAgIHByb3h5RnJvbUVudiA9IG5ldyBVUkwocHJveHlGcm9tRW52KTtcbiAgICBjb25zdCBwb3J0ID0gZ2V0RGVmYXVsdFBvcnRJZk5vdFNldChwcm94eUZyb21FbnYpO1xuICAgIGNvbnN0IHByb3h5ID0ge1xuICAgICAgICBob3N0OiBVdGlsLnZhbGlkYXRlRW1wdHlTdHJpbmcocHJveHlGcm9tRW52Lmhvc3RuYW1lKSxcbiAgICAgICAgcG9ydDogTnVtYmVyKHBvcnQpLFxuICAgICAgICB1c2VyOiBVdGlsLnZhbGlkYXRlRW1wdHlTdHJpbmcocHJveHlGcm9tRW52LnVzZXJuYW1lKSxcbiAgICAgICAgcGFzc3dvcmQ6IFV0aWwudmFsaWRhdGVFbXB0eVN0cmluZyhwcm94eUZyb21FbnYucGFzc3dvcmQpLFxuICAgICAgICBwcm90b2NvbDogVXRpbC52YWxpZGF0ZUVtcHR5U3RyaW5nKHByb3h5RnJvbUVudi5wcm90b2NvbCksXG4gICAgICAgIG5vUHJveHk6IHRoaXMuZ2V0Tm9Qcm94eUVudigpLFxuICAgICAgICB1c2VGb3JPQ1NQOiAhaXNIdHRwcyxcbiAgICB9O1xuICAgIHRoaXMudmFsaWRhdGVQcm94eShwcm94eSk7XG4gICAgcmV0dXJuIHByb3h5O1xufTtcbi8qKlxuICogT2J0YWluIHRoZSBubyBwcm94eSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnRzLmdldE5vUHJveHlFbnYgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgbm9Qcm94eSA9IFV0aWwuZ2V0RW52VmFyKCdub19wcm94eScpO1xuICAgIGlmIChub1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5LnNwbGl0KCcsJykuam9pbignfCcpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogRXh0cmFjdCB0aGUgaG9zdCBmcm9tIHRoZSBkZXN0aW5hdGlvbiBVUkwgdG8gY2hlY2sgd2hldGhlciB0aGUgc2FtZSBhZ2VudCBhbHJlYWR5IGV4aXN0cyBvciBub3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmdldEhvc3RGcm9tVVJMID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKGRlc3RpbmF0aW9uLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9ICdodHRwcycgKyAnOi8vJyArIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTChkZXN0aW5hdGlvbikuaG9zdG5hbWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSB0aGUgZGVzdGluYXRpb24gdG8gVVJMIHdpdGggdGhlIGVycm9yOiAke2Vycn0uIFJldHVybiBkZXN0aW5hdGlvbiBhcyB0aGUgaG9zdDogJHtkZXN0aW5hdGlvbn1gKTtcbiAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbn07XG4vKipcbiAqIGlmIHByb3h5IGV4aXN0cywgcmV0dXJuIHRoZSBwcm94eS4gSWYgbm90IGFuZCB0aGUgdXNlRW52UHJveHkgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBwcm94eSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqIEBwYXJhbSB7UHJveHl9IHByb3h5XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGlzSHR0cFxuICpcbiAqIEByZXR1cm5zIHtQcm94eX1cbiAqL1xuZXhwb3J0cy5nZXRQcm94eSA9IGZ1bmN0aW9uIChwcm94eSwgbW9kdWxlTmFtZSwgaXNIdHRwcykge1xuICAgIGlmICghcHJveHkgJiYgR2xvYmFsQ29uZmlnLmlzRW52UHJveHlBY3RpdmUoKSkge1xuICAgICAgICBwcm94eSA9IHRoaXMuZ2V0UHJveHlGcm9tRW52KGlzSHR0cHMpO1xuICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGAke21vZHVsZU5hbWV9IGxvYWRzIHRoZSBwcm94eSBpbmZvIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGhvc3Q6ICR7cHJveHkuaG9zdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG59O1xuLyoqXG4gKiBUaGUgcHJveHkgY29uZmlndXJhdGlvbiBmaWVsZHMgaW4gQXp1cmUgYXJlIGRpZmZlcmVudCBmcm9tIHRoZSBwcm94eSBmaWVsZHMgaW4gdGhlIHNub3dmbGFrZSBub2RlLmpzIGRyaXZlci5cbiAqIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgc25vd2ZsYWtlIHByb3h5IGluZm8gdG8gdGhlIEF6dXJlIHByb3h5IGluZm8uXG4gKiBAcGFyYW0ge1Byb3h5fSBwcm94eVxuICogQHJldHVybnMge3tob3N0OnN0cmluZywgcG9ydDpudW1iZXIsIHVzZXI/OnN0cmluZywgcGFzc3dvcmQ/OnN0cmluZ319fVxuICovXG5leHBvcnRzLmdldEF6dXJlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICBjb25zdCBBenVyZVByb3h5ID0ge1xuICAgICAgICAuLi5wcm94eSxcbiAgICAgICAgaG9zdDogYCR7cHJveHkucHJvdG9jb2x9JHtwcm94eS5wcm90b2NvbC5lbmRzV2l0aCgnOicpID8gJycgOiAnOid9Ly8ke3Byb3h5Lmhvc3R9YCxcbiAgICB9O1xuICAgIGRlbGV0ZSBBenVyZVByb3h5Lm5vUHJveHk7XG4gICAgZGVsZXRlIEF6dXJlUHJveHkucHJvdG9jb2w7XG4gICAgaWYgKCFVdGlsLmV4aXN0cyhBenVyZVByb3h5LnVzZXIpIHx8ICFVdGlsLmV4aXN0cyhBenVyZVByb3h5LnBhc3N3b3JkKSkge1xuICAgICAgICBkZWxldGUgQXp1cmVQcm94eS51c2VyO1xuICAgICAgICBkZWxldGUgQXp1cmVQcm94eS5wYXNzd29yZDtcbiAgICB9XG4gICAgcmV0dXJuIEF6dXJlUHJveHk7XG59O1xuLyoqXG4gKiBDdXJyZW50bHksIHRoZXJlIGlzIG5vIHdheSB0byBkaXNhYmxlIGxvYWRpbmcgdGhlIHByb3h5IGluZm9ybWF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHBhdGggaW4gQXp1cmUvYmxvYi5cbiAqIFRvIGNvbnRyb2wgdGhpcyBwcm94eSBvcHRpb24gb24gdGhlIGRyaXZlciBzaWRlLCBBIHRlbXBvcmFyeSB3b3JrYXJvdW5kIGlzIGhpZGUocmVtb3ZlKSB0aGUgZW52aXJvbm1lbnQgcHJveHkgZnJvbSB0aGUgcHJvY2Vzc1xuICogd2hlbiB0aGUgY2xpZW50IGlzIGNyZWF0ZWQgKEF0IHRoaXMgdGltZSwgdGhlIGNsaWVudCBsb2FkcyB0aGUgcHJveHkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGludGVybmFsbHkpLlxuICogQWZ0ZXIgdGhlIGNsaWVudCBpcyBjcmVhdGVkLCByZXN0b3JlIHRoZW0gd2l0aCB0aGUgJ3Jlc3RvcmVFbnZpcm9ubWVudFByb3h5JyBmdW5jdGlvbi5cbiAqL1xubGV0IGVudlByb3h5TGlzdDtcbmNvbnN0IHByb3h5RW52TGlzdCA9IFsnaHR0cF9wcm94eScsICdodHRwc19wcm94eScsICdub19wcm94eSddO1xuZXhwb3J0cy5oaWRlRW52aXJvbm1lbnRQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoR2xvYmFsQ29uZmlnLmlzRW52UHJveHlBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBcyB0aGUgdXNlRW52UHJveHkgb3B0aW9uIGlzIGRpc2FibGVkLCB0aGUgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSB0ZW1wb3JhcmlseSBoaWRkZW4gZHVyaW5nIHRoZSBjcmVhdGlvbiBvZiBhbiBBenVyZSBjbGllbnQnKTtcbiAgICBlbnZQcm94eUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVudlZhciBvZiBwcm94eUVudkxpc3QpIHtcbiAgICAgICAgc2F2ZVByb3h5SW5mb0luTGlzdChlbnZWYXIpO1xuICAgICAgICBpZiAoIVV0aWwuaXNXaW5kb3dzKCkpIHtcbiAgICAgICAgICAgIHNhdmVQcm94eUluZm9Jbkxpc3QoZW52VmFyLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNhdmVQcm94eUluZm9Jbkxpc3QoZW52VmFyKSB7XG4gICAgY29uc3QgcHJveHlFbnYgPSBwcm9jZXNzLmVudltlbnZWYXJdO1xuICAgIGVudlByb3h5TGlzdC5wdXNoKHByb2Nlc3MuZW52W2VudlZhcl0pO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudltlbnZWYXJdO1xuICAgIGlmIChVdGlsLmV4aXN0cyhwcm94eUVudikpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFRlbXBvcmFyaWx5IGV4Y2x1ZGUgJHtlbnZWYXJ9IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlOiAke3Byb3h5RW52fWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYCR7ZW52VmFyfSB3YXMgbm90IGRlZmluZWQsIG5vdGhpbmcgdG8gZG9gKTtcbiAgICB9XG59XG5leHBvcnRzLnJlc3RvcmVFbnZpcm9ubWVudFByb3h5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChHbG9iYWxDb25maWcuaXNFbnZQcm94eUFjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBlbnZQcm94eUxpc3RbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGxldCBuZXh0VmFsdWUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgZm9yIChjb25zdCBlbnZWYXIgb2YgcHJveHlFbnZMaXN0KSB7XG4gICAgICAgIGlmIChVdGlsLmV4aXN0cyhuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVGhlICR7ZW52VmFyfSB2YWx1ZSBleGlzdHMgd2l0aCB0aGUgdmFsdWU6ICR7bmV4dFZhbHVlfSBSZXN0b3JlIGJhY2sgdGhlIHByb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlc2ApO1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbZW52VmFyXSA9IG5leHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VmFsdWUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIGlmICghVXRpbC5pc1dpbmRvd3MoKSkge1xuICAgICAgICAgICAgaWYgKFV0aWwuZXhpc3RzKG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVGhlICR7ZW52VmFyLnRvVXBwZXJDYXNlKCl9IHZhbHVlIGV4aXN0cyB3aXRoIHRoZSB2YWx1ZTogJHtuZXh0VmFsdWV9IFJlc3RvcmUgYmFjayB0aGUgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWVzIChmb3IgTm9uLVdpbmRvd3MgbWFjaGluZSlgKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudltlbnZWYXIudG9VcHBlckNhc2UoKV0gPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VmFsdWUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0FuIEF6dXJlIGNsaWVudCBoYXMgYmVlbiBjcmVhdGVkLiBSZXN0b3JlIGJhY2sgdGhlIHByb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlcycpO1xufTtcbi8qKlxuICogUHJvdmlkZSB0aGUgZGV0YWlscyBvZiB0aGUgcHJveHkgaW5mby5cbiAqIEBwYXJhbSBwcm94eVxuICogQHBhcmFtIGRlc3RpbmF0aW9uIHtzdHJpbmcgfCBSZWdleCB9XG4gKi9cbmV4cG9ydHMuaXNCeVBhc3NQcm94eSA9IGZ1bmN0aW9uIChwcm94eSwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAocHJveHkgJiYgcHJveHkubm9Qcm94eSkge1xuICAgICAgICBjb25zdCBieXBhc3NMaXN0ID0gcHJveHkubm9Qcm94eS5zcGxpdCgnfCcpO1xuICAgICAgICByZXR1cm4gYnlwYXNzTGlzdC5maW5kKChub1Byb3h5KSA9PiB7XG4gICAgICAgICAgICBsZXQgaG9zdCA9IG5vUHJveHkudHJpbSgpO1xuICAgICAgICAgICAgaG9zdCA9IGhvc3QucmVwbGFjZSgnKicsICcuKj8nKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbi50ZXN0KGhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9Qcm94eVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7aG9zdH1gKTtcbiAgICAgICAgICAgIHJldHVybiBub1Byb3h5UmVnZXgudGVzdChkZXN0aW5hdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIFByb3ZpZGUgdGhlIGRldGFpbHMgb2YgdGhlIHByb3h5IGluZm8uXG4gKiBAcGFyYW0gcHJveHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZGVzY3JpYmVQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xuICAgIGlmIChVdGlsLmV4aXN0cyhwcm94eSkpIHtcbiAgICAgICAgcmV0dXJuIChgcHJveHlIb3N0OiAke3Byb3h5Lmhvc3R9LCBwcm94eVBvcnQ6ICR7cHJveHkucG9ydH0sIGAgK1xuICAgICAgICAgICAgYCR7VXRpbC5leGlzdHMocHJveHkudXNlcikgPyBgcHJveHlVc2VyOiAke3Byb3h5LnVzZXJ9LCBwcm94eVBhc3N3b3JkIGlzICR7TG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShwcm94eS5wYXNzd29yZCl9LCBgIDogJyd9YCArXG4gICAgICAgICAgICBgcHJveHlQcm90b2NvbDogJHtwcm94eS5wcm90b2NvbH0sIG5vUHJveHk6ICR7cHJveHkubm9Qcm94eX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAncHJveHkgd2FzIG5vdCBjb25maWd1cmVkJztcbiAgICB9XG59O1xuLyoqXG4gKiBNYWtlIHRoZSBwcm94eSBzdHJpbmcgd2l0aCB0aGUgcHJveHkgaW5mbyAoanNvbiBmb3JtYXQpXG4gKiBAcGFyYW0gcHJveHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuc3RyaW5naWZ5UHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgICBpZiAoVXRpbC5pc0VtcHR5T2JqZWN0KHByb3h5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChgJHtwcm94eS5wcm90b2NvbC5zdGFydHNXaXRoKCdodHRwcycpID8gJ2h0dHBzJyA6ICdodHRwJ306Ly9gICtcbiAgICAgICAgYCR7VXRpbC5leGlzdHMocHJveHkudXNlcikgPyBgJHtwcm94eS51c2VyfToke3Byb3h5LnBhc3N3b3JkfUBgIDogJyd9YCArXG4gICAgICAgIGAke3Byb3h5Lmhvc3R9OiR7cHJveHkucG9ydH1gKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm94eV91dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/proxy_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/queryContextCache.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/queryContextCache.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n *\n * @param {String} id\n * @param {Number} timestamp\n * @param {Number} priority\n * @param {String} context\n */\nfunction QueryContextElement(id, timestamp, priority, context) {\n    this.id = id;\n    this.timestamp = timestamp;\n    this.priority = priority;\n    this.context = context;\n}\n/**\n * Most Recently Used and Priority based cache. A separate cache for each connection in the driver.\n */\n/**\n * @param {Number} capacity Maximum capacity of the cache.\n * @param {Number} sessionId Session for which the cache is created.\n */\nfunction QueryContextCache(capacity, sessionId) {\n    Logger.getInstance().debug(`Creating new QueryContextCache with capacity ${capacity} for session ${sessionId}`);\n    this.sessionId = sessionId;\n    this.capacity = capacity;\n    this.idMap = new Map(); // Map for id and QCC\n    this.treeSet = new Set(); // Order data as per priority\n    this.priorityMap = new Map(); // Map for priority and QCC\n}\nQueryContextCache.prototype.sortTreeSet = function () {\n    this.treeSet = new Set(Array.from(this.treeSet).sort((a, b) => a.priority - b.priority));\n};\nQueryContextCache.prototype.addQCE = function (qce) {\n    this.idMap.set(qce.id, qce);\n    this.priorityMap.set(qce.priority, qce);\n    this.treeSet.add(qce);\n    this.sortTreeSet();\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - Added QCE: ${JSON.stringify(qce)}`);\n};\n/**\n * Remove an element from the cache.\n *\n * @param {Object} qce element to remove.\n */\nQueryContextCache.prototype.removeQCE = function (qce) {\n    this.idMap.delete(qce.id);\n    this.priorityMap.delete(qce.priority);\n    this.treeSet.delete(qce);\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - Removed QCE: ${JSON.stringify(qce)}`);\n};\n/**\n * Replace the cache element with a new response element. Remove old element exist in the cache\n * and add a new element received.\n *\n * @param {Object} oldQCE an element exist in the cache\n * @param {Object} newQCE a new element just received.\n */\nQueryContextCache.prototype.replaceQCE = function (oldQCE, newQCE) {\n    // Remove old element from the cache\n    this.removeQCE(oldQCE);\n    // Add new element in the cache\n    this.addQCE(newQCE);\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - Replaced QCE: ${JSON.stringify(oldQCE)} with ${JSON.stringify(newQCE)}`);\n};\n/**\n * Merge a new element comes from the server with the existing cache. Merge is based on read time\n * stamp for the same id and based on priority for two different ids.\n *\n * @param {Number} id\n * @param {Number} timestamp\n * @param {Number} priority\n * @param {String} context\n *\n */\nQueryContextCache.prototype.merge = function (newQCE) {\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - Merging QCE: ${JSON.stringify(newQCE)}`);\n    if (this.idMap.has(newQCE.id)) {\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - Element id ${newQCE.id} found in cache`);\n        // ID found in the cache\n        const qce = this.idMap.get(newQCE.id);\n        if (newQCE.timestamp > qce.timestamp) {\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - New element is more recent. Current timestamp: ${qce.timestamp}, new timestamp: ${newQCE.timestamp}`);\n            if (qce.priority === newQCE.priority) {\n                Logger.getInstance().trace(`QCC session ${this.sessionId} - Element priority (${qce.priority}) is the same`);\n                // Same priority, overwrite new data at same place\n                qce.timestamp = newQCE.timestamp;\n                qce.context = newQCE.context;\n            }\n            else {\n                Logger.getInstance().trace(`QCC session ${this.sessionId} - Element priority changed. Current priority: ${qce.priority}, new priority: ${newQCE.priority}`);\n                // Change in priority\n                this.replaceQCE(qce, newQCE);\n            }\n        }\n        else if (newQCE.timestamp === qce.timestamp && qce.priority !== newQCE.priority) {\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - Element timestamp is the same, but priority changes. Current priority: ${qce.priority}, new priority: ${newQCE.priority}`);\n            // Same read timestamp but change in priority\n            this.replaceQCE(qce, newQCE);\n        }\n        else {\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - Element is the same. Doing nothing.`);\n        }\n    }\n    else {\n        Logger.getInstance().trace(`QCC session ${this.sessionId} - New element`);\n        // new id\n        if (this.priorityMap.has(newQCE.priority)) {\n            // Same priority with different id\n            const qce = this.priorityMap.get(newQCE.priority);\n            Logger.getInstance().trace(`QCC session ${this.sessionId} - Element with the same priority found: ${JSON.stringify(qce)}. Replacing with new element: ${JSON.stringify(newQCE)}`);\n            // Replace with new data\n            this.replaceQCE(qce, newQCE);\n        }\n        else {\n            Logger.getInstance().debug(`QCC session ${this.sessionId} - Adding new element to the cache: ${JSON.stringify(newQCE)}`);\n            // new priority\n            // Add new element in the cache\n            this.addQCE(newQCE, newQCE);\n        }\n    }\n};\n/**\n * After the merge, loop through priority list and make sure cache is at most capacity. Remove all\n * other elements from the list based on priority.\n */\nQueryContextCache.prototype.checkCacheCapacity = function () {\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - checkCacheCapacity() called. treeSet size ${this.treeSet.size}, cache capacity ${this.capacity}`);\n    // remove elements based on priority\n    while (this.treeSet.size > this.capacity) {\n        const qce = Array.from(this.treeSet).pop();\n        this.removeQCE(qce);\n    }\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - checkCacheCapacity() returns. treeSet size ${this.treeSet.size}, cache capacity ${this.capacity}`);\n};\n/** Clear the cache. */\nQueryContextCache.prototype.clearCache = function () {\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - clearCache() called`);\n    this.idMap.clear();\n    this.priorityMap.clear();\n    this.treeSet.clear();\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - clearCache() returns. Number of entries in cache now ${this.treeSet.size}`);\n};\nQueryContextCache.prototype.getElements = function () {\n    return this.treeSet;\n};\n/**\n * @param data: the QueryContext Object serialized as a JSON format string\n */\nQueryContextCache.prototype.deserializeQueryContext = function (data) {\n    const stringifyData = JSON.stringify(data);\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContext() called: data from server: ${stringifyData}`);\n    if (!data || stringifyData === '{}' || data.entries === null) {\n        this.clearCache();\n        Logger.getInstance().trace(`QCC session ${this.sessionId} - deserializeQueryContext() returns`);\n        this.logCacheEntries();\n        return;\n    }\n    try {\n        // Deserialize the entries. The first entry with priority is the main entry. An example JSON is:\n        // {\n        //   \"entries\": [\n        //    {\n        //     \"id\": 0,\n        //     \"readtimestamp\": 123456789,\n        //     \"priority\": 0,\n        //     \"context\": \"base64 encoded context\"\n        //    },\n        //     {\n        //       \"id\": 1,\n        //       \"readtimestamp\": 123456789,\n        //       \"priority\": 1,\n        //       \"context\": \"base64 encoded context\"\n        //     },\n        //     {\n        //       \"id\": 2,\n        //       \"readtimestamp\": 123456789,\n        //       \"priority\": 2,\n        //       \"context\": \"base64 encoded context\"\n        //     }\n        //   ]\n        const entries = data.entries;\n        if (entries !== null && Array.isArray(entries)) {\n            for (const entryNode of entries) {\n                const entry = this.deserializeQueryContextElement(entryNode);\n                if (entry != null) {\n                    this.merge(entry);\n                }\n                else {\n                    Logger.getInstance().warn(`QCC session ${this.sessionId} - deserializeQueryContextJson: deserializeQueryContextElement meets mismatch field type. Clear the QueryContextCache.`);\n                    this.clearCache();\n                    return;\n                }\n            }\n        }\n    }\n    catch (e) {\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContextJson: Exception = ${e.getMessage}`);\n        // Not rethrowing. clear the cache as incomplete merge can lead to unexpected behavior.\n        this.clearCache();\n    }\n    this.checkCacheCapacity();\n    this.logCacheEntries();\n};\nQueryContextCache.prototype.deserializeQueryContextElement = function (node) {\n    const { id, timestamp, priority, context } = node;\n    const entry = new QueryContextElement(id, timestamp, priority, null);\n    if (typeof context === 'string') {\n        entry.context = context;\n    }\n    else if (context === null || context === undefined) {\n        entry.context = null;\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContextElement \\`context\\` field is empty`);\n    }\n    else {\n        Logger.getInstance().warn(`QCC session ${this.sessionId} - deserializeQueryContextElement: \\`context\\` field is not String type`);\n        return null;\n    }\n    return entry;\n};\nQueryContextCache.prototype.logCacheEntries = function () {\n    this.treeSet.forEach(function (elem) {\n        Logger.getInstance().debug(`QCC session ${this.sessionId} - Cache Entry: id: ${elem.id} timestamp: ${elem.timestamp} priority: ${elem.priority}`);\n    }, this);\n};\nQueryContextCache.prototype.getSize = function () {\n    return this.treeSet.size;\n};\nQueryContextCache.prototype.getQueryContextDTO = function () {\n    const arr = [];\n    const querycontexts = Array.from(this.getElements());\n    for (let i = 0; i < this.treeSet.size; i++) {\n        arr.push({\n            id: querycontexts[i].id,\n            timestamp: querycontexts[i].timestamp,\n            priority: querycontexts[i].priority,\n            context: { base64Data: querycontexts[i].context } || null,\n        });\n    }\n    return {\n        entries: arr,\n    };\n};\nQueryContextCache.prototype.getSerializeQueryContext = function () {\n    const arr = [];\n    const querycontexts = Array.from(this.getElements());\n    for (let i = 0; i < this.treeSet.size; i++) {\n        arr.push({\n            id: querycontexts[i].id,\n            timestamp: querycontexts[i].timestamp,\n            priority: querycontexts[i].priority,\n            context: querycontexts[i].context || null,\n        });\n    }\n    return {\n        entries: arr,\n    };\n};\nmodule.exports = QueryContextCache;\n//# sourceMappingURL=queryContextCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9xdWVyeUNvbnRleHRDYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSwrRUFBK0UsVUFBVSxjQUFjLFVBQVU7QUFDakg7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IsZUFBZSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IsaUJBQWlCLG9CQUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLGtCQUFrQix3QkFBd0IsT0FBTyx1QkFBdUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDdEc7QUFDQSxrREFBa0QsZ0JBQWdCLGVBQWUsV0FBVztBQUM1RjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCLG1EQUFtRCxjQUFjLG1CQUFtQixpQkFBaUI7QUFDM0s7QUFDQSwwREFBMEQsZ0JBQWdCLHNCQUFzQixhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCLGdEQUFnRCxhQUFhLGtCQUFrQixnQkFBZ0I7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0IsMkVBQTJFLGFBQWEsa0JBQWtCLGdCQUFnQjtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0IsMENBQTBDLG9CQUFvQixnQ0FBZ0MsdUJBQXVCO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQixxQ0FBcUMsdUJBQXVCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLDhDQUE4QyxrQkFBa0IsbUJBQW1CLGNBQWM7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IsK0NBQStDLGtCQUFrQixtQkFBbUIsY0FBYztBQUNoSztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0IseURBQXlELGtCQUFrQjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLHdEQUF3RCxjQUFjO0FBQ3BJLHNDQUFzQztBQUN0QztBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0IsNkNBQTZDLGFBQWE7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0IscUJBQXFCLFNBQVMsYUFBYSxnQkFBZ0IsWUFBWSxjQUFjO0FBQ3ZKLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9xdWVyeUNvbnRleHRDYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG4vKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eVxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gUXVlcnlDb250ZXh0RWxlbWVudChpZCwgdGltZXN0YW1wLCBwcmlvcml0eSwgY29udGV4dCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cbi8qKlxuICogTW9zdCBSZWNlbnRseSBVc2VkIGFuZCBQcmlvcml0eSBiYXNlZCBjYWNoZS4gQSBzZXBhcmF0ZSBjYWNoZSBmb3IgZWFjaCBjb25uZWN0aW9uIGluIHRoZSBkcml2ZXIuXG4gKi9cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNhcGFjaXR5IE1heGltdW0gY2FwYWNpdHkgb2YgdGhlIGNhY2hlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNlc3Npb25JZCBTZXNzaW9uIGZvciB3aGljaCB0aGUgY2FjaGUgaXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gUXVlcnlDb250ZXh0Q2FjaGUoY2FwYWNpdHksIHNlc3Npb25JZCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBDcmVhdGluZyBuZXcgUXVlcnlDb250ZXh0Q2FjaGUgd2l0aCBjYXBhY2l0eSAke2NhcGFjaXR5fSBmb3Igc2Vzc2lvbiAke3Nlc3Npb25JZH1gKTtcbiAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5pZE1hcCA9IG5ldyBNYXAoKTsgLy8gTWFwIGZvciBpZCBhbmQgUUNDXG4gICAgdGhpcy50cmVlU2V0ID0gbmV3IFNldCgpOyAvLyBPcmRlciBkYXRhIGFzIHBlciBwcmlvcml0eVxuICAgIHRoaXMucHJpb3JpdHlNYXAgPSBuZXcgTWFwKCk7IC8vIE1hcCBmb3IgcHJpb3JpdHkgYW5kIFFDQ1xufVxuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLnNvcnRUcmVlU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJlZVNldCA9IG5ldyBTZXQoQXJyYXkuZnJvbSh0aGlzLnRyZWVTZXQpLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KSk7XG59O1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmFkZFFDRSA9IGZ1bmN0aW9uIChxY2UpIHtcbiAgICB0aGlzLmlkTWFwLnNldChxY2UuaWQsIHFjZSk7XG4gICAgdGhpcy5wcmlvcml0eU1hcC5zZXQocWNlLnByaW9yaXR5LCBxY2UpO1xuICAgIHRoaXMudHJlZVNldC5hZGQocWNlKTtcbiAgICB0aGlzLnNvcnRUcmVlU2V0KCk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gQWRkZWQgUUNFOiAke0pTT04uc3RyaW5naWZ5KHFjZSl9YCk7XG59O1xuLyoqXG4gKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcWNlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICovXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUucmVtb3ZlUUNFID0gZnVuY3Rpb24gKHFjZSkge1xuICAgIHRoaXMuaWRNYXAuZGVsZXRlKHFjZS5pZCk7XG4gICAgdGhpcy5wcmlvcml0eU1hcC5kZWxldGUocWNlLnByaW9yaXR5KTtcbiAgICB0aGlzLnRyZWVTZXQuZGVsZXRlKHFjZSk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gUmVtb3ZlZCBRQ0U6ICR7SlNPTi5zdHJpbmdpZnkocWNlKX1gKTtcbn07XG4vKipcbiAqIFJlcGxhY2UgdGhlIGNhY2hlIGVsZW1lbnQgd2l0aCBhIG5ldyByZXNwb25zZSBlbGVtZW50LiBSZW1vdmUgb2xkIGVsZW1lbnQgZXhpc3QgaW4gdGhlIGNhY2hlXG4gKiBhbmQgYWRkIGEgbmV3IGVsZW1lbnQgcmVjZWl2ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9sZFFDRSBhbiBlbGVtZW50IGV4aXN0IGluIHRoZSBjYWNoZVxuICogQHBhcmFtIHtPYmplY3R9IG5ld1FDRSBhIG5ldyBlbGVtZW50IGp1c3QgcmVjZWl2ZWQuXG4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5yZXBsYWNlUUNFID0gZnVuY3Rpb24gKG9sZFFDRSwgbmV3UUNFKSB7XG4gICAgLy8gUmVtb3ZlIG9sZCBlbGVtZW50IGZyb20gdGhlIGNhY2hlXG4gICAgdGhpcy5yZW1vdmVRQ0Uob2xkUUNFKTtcbiAgICAvLyBBZGQgbmV3IGVsZW1lbnQgaW4gdGhlIGNhY2hlXG4gICAgdGhpcy5hZGRRQ0UobmV3UUNFKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBSZXBsYWNlZCBRQ0U6ICR7SlNPTi5zdHJpbmdpZnkob2xkUUNFKX0gd2l0aCAke0pTT04uc3RyaW5naWZ5KG5ld1FDRSl9YCk7XG59O1xuLyoqXG4gKiBNZXJnZSBhIG5ldyBlbGVtZW50IGNvbWVzIGZyb20gdGhlIHNlcnZlciB3aXRoIHRoZSBleGlzdGluZyBjYWNoZS4gTWVyZ2UgaXMgYmFzZWQgb24gcmVhZCB0aW1lXG4gKiBzdGFtcCBmb3IgdGhlIHNhbWUgaWQgYW5kIGJhc2VkIG9uIHByaW9yaXR5IGZvciB0d28gZGlmZmVyZW50IGlkcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eVxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRleHRcbiAqXG4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChuZXdRQ0UpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBNZXJnaW5nIFFDRTogJHtKU09OLnN0cmluZ2lmeShuZXdRQ0UpfWApO1xuICAgIGlmICh0aGlzLmlkTWFwLmhhcyhuZXdRQ0UuaWQpKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEVsZW1lbnQgaWQgJHtuZXdRQ0UuaWR9IGZvdW5kIGluIGNhY2hlYCk7XG4gICAgICAgIC8vIElEIGZvdW5kIGluIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCBxY2UgPSB0aGlzLmlkTWFwLmdldChuZXdRQ0UuaWQpO1xuICAgICAgICBpZiAobmV3UUNFLnRpbWVzdGFtcCA+IHFjZS50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIE5ldyBlbGVtZW50IGlzIG1vcmUgcmVjZW50LiBDdXJyZW50IHRpbWVzdGFtcDogJHtxY2UudGltZXN0YW1wfSwgbmV3IHRpbWVzdGFtcDogJHtuZXdRQ0UudGltZXN0YW1wfWApO1xuICAgICAgICAgICAgaWYgKHFjZS5wcmlvcml0eSA9PT0gbmV3UUNFLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gRWxlbWVudCBwcmlvcml0eSAoJHtxY2UucHJpb3JpdHl9KSBpcyB0aGUgc2FtZWApO1xuICAgICAgICAgICAgICAgIC8vIFNhbWUgcHJpb3JpdHksIG92ZXJ3cml0ZSBuZXcgZGF0YSBhdCBzYW1lIHBsYWNlXG4gICAgICAgICAgICAgICAgcWNlLnRpbWVzdGFtcCA9IG5ld1FDRS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgcWNlLmNvbnRleHQgPSBuZXdRQ0UuY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEVsZW1lbnQgcHJpb3JpdHkgY2hhbmdlZC4gQ3VycmVudCBwcmlvcml0eTogJHtxY2UucHJpb3JpdHl9LCBuZXcgcHJpb3JpdHk6ICR7bmV3UUNFLnByaW9yaXR5fWApO1xuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBpbiBwcmlvcml0eVxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVFDRShxY2UsIG5ld1FDRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3UUNFLnRpbWVzdGFtcCA9PT0gcWNlLnRpbWVzdGFtcCAmJiBxY2UucHJpb3JpdHkgIT09IG5ld1FDRS5wcmlvcml0eSkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gRWxlbWVudCB0aW1lc3RhbXAgaXMgdGhlIHNhbWUsIGJ1dCBwcmlvcml0eSBjaGFuZ2VzLiBDdXJyZW50IHByaW9yaXR5OiAke3FjZS5wcmlvcml0eX0sIG5ldyBwcmlvcml0eTogJHtuZXdRQ0UucHJpb3JpdHl9YCk7XG4gICAgICAgICAgICAvLyBTYW1lIHJlYWQgdGltZXN0YW1wIGJ1dCBjaGFuZ2UgaW4gcHJpb3JpdHlcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVFDRShxY2UsIG5ld1FDRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBFbGVtZW50IGlzIHRoZSBzYW1lLiBEb2luZyBub3RoaW5nLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBOZXcgZWxlbWVudGApO1xuICAgICAgICAvLyBuZXcgaWRcbiAgICAgICAgaWYgKHRoaXMucHJpb3JpdHlNYXAuaGFzKG5ld1FDRS5wcmlvcml0eSkpIHtcbiAgICAgICAgICAgIC8vIFNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgaWRcbiAgICAgICAgICAgIGNvbnN0IHFjZSA9IHRoaXMucHJpb3JpdHlNYXAuZ2V0KG5ld1FDRS5wcmlvcml0eSk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBFbGVtZW50IHdpdGggdGhlIHNhbWUgcHJpb3JpdHkgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkocWNlKX0uIFJlcGxhY2luZyB3aXRoIG5ldyBlbGVtZW50OiAke0pTT04uc3RyaW5naWZ5KG5ld1FDRSl9YCk7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHdpdGggbmV3IGRhdGFcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVFDRShxY2UsIG5ld1FDRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBBZGRpbmcgbmV3IGVsZW1lbnQgdG8gdGhlIGNhY2hlOiAke0pTT04uc3RyaW5naWZ5KG5ld1FDRSl9YCk7XG4gICAgICAgICAgICAvLyBuZXcgcHJpb3JpdHlcbiAgICAgICAgICAgIC8vIEFkZCBuZXcgZWxlbWVudCBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgIHRoaXMuYWRkUUNFKG5ld1FDRSwgbmV3UUNFKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEFmdGVyIHRoZSBtZXJnZSwgbG9vcCB0aHJvdWdoIHByaW9yaXR5IGxpc3QgYW5kIG1ha2Ugc3VyZSBjYWNoZSBpcyBhdCBtb3N0IGNhcGFjaXR5LiBSZW1vdmUgYWxsXG4gKiBvdGhlciBlbGVtZW50cyBmcm9tIHRoZSBsaXN0IGJhc2VkIG9uIHByaW9yaXR5LlxuICovXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuY2hlY2tDYWNoZUNhcGFjaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGNoZWNrQ2FjaGVDYXBhY2l0eSgpIGNhbGxlZC4gdHJlZVNldCBzaXplICR7dGhpcy50cmVlU2V0LnNpemV9LCBjYWNoZSBjYXBhY2l0eSAke3RoaXMuY2FwYWNpdHl9YCk7XG4gICAgLy8gcmVtb3ZlIGVsZW1lbnRzIGJhc2VkIG9uIHByaW9yaXR5XG4gICAgd2hpbGUgKHRoaXMudHJlZVNldC5zaXplID4gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICBjb25zdCBxY2UgPSBBcnJheS5mcm9tKHRoaXMudHJlZVNldCkucG9wKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUUNFKHFjZSk7XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGNoZWNrQ2FjaGVDYXBhY2l0eSgpIHJldHVybnMuIHRyZWVTZXQgc2l6ZSAke3RoaXMudHJlZVNldC5zaXplfSwgY2FjaGUgY2FwYWNpdHkgJHt0aGlzLmNhcGFjaXR5fWApO1xufTtcbi8qKiBDbGVhciB0aGUgY2FjaGUuICovXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBjbGVhckNhY2hlKCkgY2FsbGVkYCk7XG4gICAgdGhpcy5pZE1hcC5jbGVhcigpO1xuICAgIHRoaXMucHJpb3JpdHlNYXAuY2xlYXIoKTtcbiAgICB0aGlzLnRyZWVTZXQuY2xlYXIoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBjbGVhckNhY2hlKCkgcmV0dXJucy4gTnVtYmVyIG9mIGVudHJpZXMgaW4gY2FjaGUgbm93ICR7dGhpcy50cmVlU2V0LnNpemV9YCk7XG59O1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRyZWVTZXQ7XG59O1xuLyoqXG4gKiBAcGFyYW0gZGF0YTogdGhlIFF1ZXJ5Q29udGV4dCBPYmplY3Qgc2VyaWFsaXplZCBhcyBhIEpTT04gZm9ybWF0IHN0cmluZ1xuICovXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZGVzZXJpYWxpemVRdWVyeUNvbnRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGNvbnN0IHN0cmluZ2lmeURhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dCgpIGNhbGxlZDogZGF0YSBmcm9tIHNlcnZlcjogJHtzdHJpbmdpZnlEYXRhfWApO1xuICAgIGlmICghZGF0YSB8fCBzdHJpbmdpZnlEYXRhID09PSAne30nIHx8IGRhdGEuZW50cmllcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHQoKSByZXR1cm5zYCk7XG4gICAgICAgIHRoaXMubG9nQ2FjaGVFbnRyaWVzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRGVzZXJpYWxpemUgdGhlIGVudHJpZXMuIFRoZSBmaXJzdCBlbnRyeSB3aXRoIHByaW9yaXR5IGlzIHRoZSBtYWluIGVudHJ5LiBBbiBleGFtcGxlIEpTT04gaXM6XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBcImVudHJpZXNcIjogW1xuICAgICAgICAvLyAgICB7XG4gICAgICAgIC8vICAgICBcImlkXCI6IDAsXG4gICAgICAgIC8vICAgICBcInJlYWR0aW1lc3RhbXBcIjogMTIzNDU2Nzg5LFxuICAgICAgICAvLyAgICAgXCJwcmlvcml0eVwiOiAwLFxuICAgICAgICAvLyAgICAgXCJjb250ZXh0XCI6IFwiYmFzZTY0IGVuY29kZWQgY29udGV4dFwiXG4gICAgICAgIC8vICAgIH0sXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgLy8gICAgICAgXCJyZWFkdGltZXN0YW1wXCI6IDEyMzQ1Njc4OSxcbiAgICAgICAgLy8gICAgICAgXCJwcmlvcml0eVwiOiAxLFxuICAgICAgICAvLyAgICAgICBcImNvbnRleHRcIjogXCJiYXNlNjQgZW5jb2RlZCBjb250ZXh0XCJcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgIFwiaWRcIjogMixcbiAgICAgICAgLy8gICAgICAgXCJyZWFkdGltZXN0YW1wXCI6IDEyMzQ1Njc4OSxcbiAgICAgICAgLy8gICAgICAgXCJwcmlvcml0eVwiOiAyLFxuICAgICAgICAvLyAgICAgICBcImNvbnRleHRcIjogXCJiYXNlNjQgZW5jb2RlZCBjb250ZXh0XCJcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICBdXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBkYXRhLmVudHJpZXM7XG4gICAgICAgIGlmIChlbnRyaWVzICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnlOb2RlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50KGVudHJ5Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGRlc2VyaWFsaXplUXVlcnlDb250ZXh0SnNvbjogZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50IG1lZXRzIG1pc21hdGNoIGZpZWxkIHR5cGUuIENsZWFyIHRoZSBRdWVyeUNvbnRleHRDYWNoZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHRKc29uOiBFeGNlcHRpb24gPSAke2UuZ2V0TWVzc2FnZX1gKTtcbiAgICAgICAgLy8gTm90IHJldGhyb3dpbmcuIGNsZWFyIHRoZSBjYWNoZSBhcyBpbmNvbXBsZXRlIG1lcmdlIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrQ2FjaGVDYXBhY2l0eSgpO1xuICAgIHRoaXMubG9nQ2FjaGVFbnRyaWVzKCk7XG59O1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmRlc2VyaWFsaXplUXVlcnlDb250ZXh0RWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgY29uc3QgeyBpZCwgdGltZXN0YW1wLCBwcmlvcml0eSwgY29udGV4dCB9ID0gbm9kZTtcbiAgICBjb25zdCBlbnRyeSA9IG5ldyBRdWVyeUNvbnRleHRFbGVtZW50KGlkLCB0aW1lc3RhbXAsIHByaW9yaXR5LCBudWxsKTtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVudHJ5LmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbnRyeS5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50IFxcYGNvbnRleHRcXGAgZmllbGQgaXMgZW1wdHlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50OiBcXGBjb250ZXh0XFxgIGZpZWxkIGlzIG5vdCBTdHJpbmcgdHlwZWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xufTtcblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5sb2dDYWNoZUVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmVlU2V0LmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gQ2FjaGUgRW50cnk6IGlkOiAke2VsZW0uaWR9IHRpbWVzdGFtcDogJHtlbGVtLnRpbWVzdGFtcH0gcHJpb3JpdHk6ICR7ZWxlbS5wcmlvcml0eX1gKTtcbiAgICB9LCB0aGlzKTtcbn07XG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmVlU2V0LnNpemU7XG59O1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmdldFF1ZXJ5Q29udGV4dERUTyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBjb25zdCBxdWVyeWNvbnRleHRzID0gQXJyYXkuZnJvbSh0aGlzLmdldEVsZW1lbnRzKCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmVlU2V0LnNpemU7IGkrKykge1xuICAgICAgICBhcnIucHVzaCh7XG4gICAgICAgICAgICBpZDogcXVlcnljb250ZXh0c1tpXS5pZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcXVlcnljb250ZXh0c1tpXS50aW1lc3RhbXAsXG4gICAgICAgICAgICBwcmlvcml0eTogcXVlcnljb250ZXh0c1tpXS5wcmlvcml0eSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHsgYmFzZTY0RGF0YTogcXVlcnljb250ZXh0c1tpXS5jb250ZXh0IH0gfHwgbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVudHJpZXM6IGFycixcbiAgICB9O1xufTtcblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5nZXRTZXJpYWxpemVRdWVyeUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgY29uc3QgcXVlcnljb250ZXh0cyA9IEFycmF5LmZyb20odGhpcy5nZXRFbGVtZW50cygpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJlZVNldC5zaXplOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHF1ZXJ5Y29udGV4dHNbaV0uaWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHF1ZXJ5Y29udGV4dHNbaV0udGltZXN0YW1wLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHF1ZXJ5Y29udGV4dHNbaV0ucHJpb3JpdHksXG4gICAgICAgICAgICBjb250ZXh0OiBxdWVyeWNvbnRleHRzW2ldLmNvbnRleHQgfHwgbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVudHJpZXM6IGFycixcbiAgICB9O1xufTtcbm1vZHVsZS5leHBvcnRzID0gUXVlcnlDb250ZXh0Q2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeUNvbnRleHRDYWNoZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/queryContextCache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/secret_detector.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/secret_detector.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * The secret detector detects sensitive information.\n * It masks secrets that might be leaked from two potential avenues\n *  1. Out of Band Telemetry\n *  2. Logging\n *\n * @param {Object} customPatterns contains 'regex' and 'mask' for customized masking\n * @param {Object} mock\n *\n * @returns {Object}\n * @constructor\n */\nfunction SecretDetector(customPatterns, mock) {\n    const CUSTOM_PATTERNS_REGEX = [];\n    const CUSTOM_PATTERNS_MASK = [];\n    let CUSTOM_PATTERNS_LENGTH;\n    if (customPatterns) {\n        // Check that the customPatterns object contains the keys 'regex' and 'mask\n        if (!customPatterns.regex) {\n            throw new Error(\"The customPatterns object must contain the 'regex' key\");\n        }\n        if (!customPatterns.mask) {\n            throw new Error(\"The customPatterns object must contain the 'mask' key\");\n        }\n        // Also check that their lengths are equal\n        if (customPatterns.regex.length !== customPatterns.mask.length) {\n            throw new Error(\"The customPatterns object must have equal length for both 'regex' and 'mask'\");\n        }\n        CUSTOM_PATTERNS_LENGTH = customPatterns.regex.length;\n        // Push the regex and mask elements onto their respective arrays\n        for (let index = 0; index < CUSTOM_PATTERNS_LENGTH; index++) {\n            CUSTOM_PATTERNS_REGEX.push(new RegExp(`${customPatterns.regex[index]}`, 'gi'));\n            CUSTOM_PATTERNS_MASK.push(String.raw `${customPatterns.mask[index]}`);\n        }\n    }\n    function maskCustomPattern(text) {\n        let result;\n        for (let index = 0; index < CUSTOM_PATTERNS_LENGTH; index++) {\n            result = text.replace(CUSTOM_PATTERNS_REGEX[index], CUSTOM_PATTERNS_MASK[index]);\n            // If the text is replaced, return the result\n            if (text !== result) {\n                return result;\n            }\n        }\n        // If text is unchanged, return the original\n        return text;\n    }\n    const AWS_KEY_PATTERN = new RegExp(String.raw `(aws_key_id|aws_secret_key|access_key_id|secret_access_key)\\s*=\\s*'([^']+)'`, 'gi');\n    const AWS_TOKEN_PATTERN = new RegExp(String.raw `(accessToken|tempToken|keySecret)\\s*:\\s*\"([a-z0-9/+]{32,}={0,2})\"`, 'gi');\n    const SAS_TOKEN_PATTERN = new RegExp(String.raw `(sig|signature|AWSAccessKeyId|password|passcode)=(\\?P<secret>[a-z0-9%/+]{16,})`, 'gi');\n    const PRIVATE_KEY_PATTERN = new RegExp(String.raw `-----BEGIN PRIVATE KEY-----\\\\n([a-z0-9/+=\\\\n]{32,})\\\\n-----END PRIVATE KEY-----`, // pragma: allowlist secret\n    'gim');\n    const PRIVATE_KEY_DATA_PATTERN = new RegExp(String.raw `\"privateKeyData\": \"([a-z0-9/+=\\\\n]{10,})\"`, 'gim');\n    // Colon in the group ([a-z0-9=/:_%-+]{8,}) was added to detect tokens that contain additional details before the actual token.\n    // Such as version or hint (token=ver:1-hint:1233-realToken...).\n    const CONNECTION_TOKEN_PATTERN = new RegExp(String.raw `(token|assertion content)([\\'\\\"\\s:=]+)([a-z0-9=/:_\\%\\-\\+]{8,})`, 'gi');\n    const PASSWORD_PATTERN = new RegExp(String.raw `(password|pwd)([\\'\\\"\\s:=]+)([a-z0-9!\\\"#\\$%&\\\\\\'\\(\\)\\*\\+\\,-\\./:;<=>\\?\\@\\[\\]\\^_` +\n        '`' +\n        String.raw `\\{\\|\\}~]{8,})`, 'gi');\n    const PASSCODE_PATTERN = new RegExp(String.raw `(passcode|otp|pin|otac)\\s*([:=])\\s*([0-9]{4,6})`, 'gi');\n    const OAUTH_CLIENT_SECRET_PATTERN = new RegExp(String.raw `(oauthClientId|oauthClientSecret|clientSecret)([\\'\\\"\\s:=]+)([a-z0-9!\\\"#\\$%&\\\\\\'\\(\\)\\*\\+\\,-\\./:;<=>\\?\\@\\[\\]\\^_` +\n        '`' +\n        String.raw `\\{\\|\\}~]{8,})`, 'gi');\n    function maskAwsKeys(text) {\n        return text.replace(AWS_KEY_PATTERN, String.raw `$1$2****`);\n    }\n    function maskAwsToken(text) {\n        return text.replace(AWS_TOKEN_PATTERN, String.raw `$1\":\"XXXX\"`);\n    }\n    function maskSasToken(text) {\n        return text.replace(SAS_TOKEN_PATTERN, String.raw `$1=****`);\n    }\n    function maskPrivateKey(text) {\n        return text.replace(PRIVATE_KEY_PATTERN, String.raw `-----BEGIN PRIVATE KEY-----\\\\\\\\nXXXX\\\\\\\\n-----END PRIVATE KEY-----`); // pragma: allowlist secret\n    }\n    function maskPrivateKeyData(text) {\n        return text.replace(PRIVATE_KEY_DATA_PATTERN, String.raw `\"privateKeyData\": \"XXXX\"`);\n    }\n    function maskConnectionToken(text) {\n        return text.replace(CONNECTION_TOKEN_PATTERN, String.raw `$1$2****`);\n    }\n    function maskPassword(text) {\n        return text.replace(PASSWORD_PATTERN, String.raw `$1$2****`);\n    }\n    function maskPasscode(text) {\n        return text.replace(PASSCODE_PATTERN, String.raw `$1$2****`);\n    }\n    function maskClientSecret(text) {\n        return text.replace(OAUTH_CLIENT_SECRET_PATTERN, String.raw `$1$2****`);\n    }\n    /**\n     * Masks any secrets.\n     *\n     * @param {String} text may contain a secret.\n     *\n     * @returns {Object} the masked string.\n     */\n    this.maskSecrets = function (text) {\n        let result;\n        if (!text) {\n            result = {\n                masked: false,\n                maskedtxt: text,\n                errstr: null,\n            };\n            return result;\n        }\n        let masked = false;\n        let maskedtxt = '';\n        let errstr = null;\n        try {\n            if (mock) {\n                mock.execute();\n            }\n            maskedtxt = maskClientSecret(maskPasscode(maskConnectionToken(maskPassword(maskPrivateKeyData(maskPrivateKey(maskAwsToken(maskSasToken(maskAwsKeys(text)))))))));\n            if (CUSTOM_PATTERNS_LENGTH > 0) {\n                maskedtxt = maskCustomPattern(maskedtxt);\n            }\n            if (maskedtxt !== text) {\n                masked = true;\n            }\n        }\n        catch (err) {\n            masked = true;\n            maskedtxt = err.toString();\n            errstr = err.toString();\n        }\n        result = {\n            masked: masked,\n            maskedtxt: maskedtxt,\n            errstr: errstr,\n        };\n        return result;\n    };\n}\nmodule.exports = SecretDetector;\n//# sourceMappingURL=secret_detector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZWNyZXRfZGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELHFEQUFxRCw0QkFBNEI7QUFDakYsb0RBQW9ELDJCQUEyQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsSUFBSSxFQUFFLElBQUk7QUFDcEgsOEhBQThILElBQUk7QUFDbEkscUdBQXFHLElBQUk7QUFDekc7QUFDQSwrRkFBK0YsSUFBSTtBQUNuRywyQ0FBMkMsR0FBRztBQUM5QztBQUNBLHNIQUFzSCxHQUFHO0FBQ3pILG1IQUFtSDtBQUNuSDtBQUNBLHNCQUFzQixJQUFJLEdBQUcsR0FBRztBQUNoQyw4RkFBOEYsSUFBSTtBQUNsRyw4SkFBOEo7QUFDOUo7QUFDQSxzQkFBc0IsSUFBSSxHQUFHLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZWNyZXRfZGV0ZWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBzZWNyZXQgZGV0ZWN0b3IgZGV0ZWN0cyBzZW5zaXRpdmUgaW5mb3JtYXRpb24uXG4gKiBJdCBtYXNrcyBzZWNyZXRzIHRoYXQgbWlnaHQgYmUgbGVha2VkIGZyb20gdHdvIHBvdGVudGlhbCBhdmVudWVzXG4gKiAgMS4gT3V0IG9mIEJhbmQgVGVsZW1ldHJ5XG4gKiAgMi4gTG9nZ2luZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXR0ZXJucyBjb250YWlucyAncmVnZXgnIGFuZCAnbWFzaycgZm9yIGN1c3RvbWl6ZWQgbWFza2luZ1xuICogQHBhcmFtIHtPYmplY3R9IG1vY2tcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFNlY3JldERldGVjdG9yKGN1c3RvbVBhdHRlcm5zLCBtb2NrKSB7XG4gICAgY29uc3QgQ1VTVE9NX1BBVFRFUk5TX1JFR0VYID0gW107XG4gICAgY29uc3QgQ1VTVE9NX1BBVFRFUk5TX01BU0sgPSBbXTtcbiAgICBsZXQgQ1VTVE9NX1BBVFRFUk5TX0xFTkdUSDtcbiAgICBpZiAoY3VzdG9tUGF0dGVybnMpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgY3VzdG9tUGF0dGVybnMgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzICdyZWdleCcgYW5kICdtYXNrXG4gICAgICAgIGlmICghY3VzdG9tUGF0dGVybnMucmVnZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXN0b21QYXR0ZXJucyBvYmplY3QgbXVzdCBjb250YWluIHRoZSAncmVnZXgnIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1c3RvbVBhdHRlcm5zLm1hc2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXN0b21QYXR0ZXJucyBvYmplY3QgbXVzdCBjb250YWluIHRoZSAnbWFzaycga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsc28gY2hlY2sgdGhhdCB0aGVpciBsZW5ndGhzIGFyZSBlcXVhbFxuICAgICAgICBpZiAoY3VzdG9tUGF0dGVybnMucmVnZXgubGVuZ3RoICE9PSBjdXN0b21QYXR0ZXJucy5tYXNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1c3RvbVBhdHRlcm5zIG9iamVjdCBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoIGZvciBib3RoICdyZWdleCcgYW5kICdtYXNrJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBDVVNUT01fUEFUVEVSTlNfTEVOR1RIID0gY3VzdG9tUGF0dGVybnMucmVnZXgubGVuZ3RoO1xuICAgICAgICAvLyBQdXNoIHRoZSByZWdleCBhbmQgbWFzayBlbGVtZW50cyBvbnRvIHRoZWlyIHJlc3BlY3RpdmUgYXJyYXlzXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBDVVNUT01fUEFUVEVSTlNfTEVOR1RIOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBDVVNUT01fUEFUVEVSTlNfUkVHRVgucHVzaChuZXcgUmVnRXhwKGAke2N1c3RvbVBhdHRlcm5zLnJlZ2V4W2luZGV4XX1gLCAnZ2knKSk7XG4gICAgICAgICAgICBDVVNUT01fUEFUVEVSTlNfTUFTSy5wdXNoKFN0cmluZy5yYXcgYCR7Y3VzdG9tUGF0dGVybnMubWFza1tpbmRleF19YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza0N1c3RvbVBhdHRlcm4odGV4dCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgQ1VTVE9NX1BBVFRFUk5TX0xFTkdUSDsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGV4dC5yZXBsYWNlKENVU1RPTV9QQVRURVJOU19SRUdFWFtpbmRleF0sIENVU1RPTV9QQVRURVJOU19NQVNLW2luZGV4XSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBpcyByZXBsYWNlZCwgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICh0ZXh0ICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRleHQgaXMgdW5jaGFuZ2VkLCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBBV1NfS0VZX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYChhd3Nfa2V5X2lkfGF3c19zZWNyZXRfa2V5fGFjY2Vzc19rZXlfaWR8c2VjcmV0X2FjY2Vzc19rZXkpXFxzKj1cXHMqJyhbXiddKyknYCwgJ2dpJyk7XG4gICAgY29uc3QgQVdTX1RPS0VOX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYChhY2Nlc3NUb2tlbnx0ZW1wVG9rZW58a2V5U2VjcmV0KVxccyo6XFxzKlwiKFthLXowLTkvK117MzIsfT17MCwyfSlcImAsICdnaScpO1xuICAgIGNvbnN0IFNBU19UT0tFTl9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3IGAoc2lnfHNpZ25hdHVyZXxBV1NBY2Nlc3NLZXlJZHxwYXNzd29yZHxwYXNzY29kZSk9KFxcP1A8c2VjcmV0PlthLXowLTklLytdezE2LH0pYCwgJ2dpJyk7XG4gICAgY29uc3QgUFJJVkFURV9LRVlfUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhdyBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxcXG4oW2EtejAtOS8rPVxcXFxuXXszMix9KVxcXFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWAsIC8vIHByYWdtYTogYWxsb3dsaXN0IHNlY3JldFxuICAgICdnaW0nKTtcbiAgICBjb25zdCBQUklWQVRFX0tFWV9EQVRBX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXcgYFwicHJpdmF0ZUtleURhdGFcIjogXCIoW2EtejAtOS8rPVxcXFxuXXsxMCx9KVwiYCwgJ2dpbScpO1xuICAgIC8vIENvbG9uIGluIHRoZSBncm91cCAoW2EtejAtOT0vOl8lLStdezgsfSkgd2FzIGFkZGVkIHRvIGRldGVjdCB0b2tlbnMgdGhhdCBjb250YWluIGFkZGl0aW9uYWwgZGV0YWlscyBiZWZvcmUgdGhlIGFjdHVhbCB0b2tlbi5cbiAgICAvLyBTdWNoIGFzIHZlcnNpb24gb3IgaGludCAodG9rZW49dmVyOjEtaGludDoxMjMzLXJlYWxUb2tlbi4uLikuXG4gICAgY29uc3QgQ09OTkVDVElPTl9UT0tFTl9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3IGAodG9rZW58YXNzZXJ0aW9uIGNvbnRlbnQpKFtcXCdcXFwiXFxzOj1dKykoW2EtejAtOT0vOl9cXCVcXC1cXCtdezgsfSlgLCAnZ2knKTtcbiAgICBjb25zdCBQQVNTV09SRF9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3IGAocGFzc3dvcmR8cHdkKShbXFwnXFxcIlxcczo9XSspKFthLXowLTkhXFxcIiNcXCQlJlxcXFxcXCdcXChcXClcXCpcXCtcXCwtXFwuLzo7PD0+XFw/XFxAXFxbXFxdXFxeX2AgK1xuICAgICAgICAnYCcgK1xuICAgICAgICBTdHJpbmcucmF3IGBcXHtcXHxcXH1+XXs4LH0pYCwgJ2dpJyk7XG4gICAgY29uc3QgUEFTU0NPREVfUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhdyBgKHBhc3Njb2RlfG90cHxwaW58b3RhYylcXHMqKFs6PV0pXFxzKihbMC05XXs0LDZ9KWAsICdnaScpO1xuICAgIGNvbnN0IE9BVVRIX0NMSUVOVF9TRUNSRVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhdyBgKG9hdXRoQ2xpZW50SWR8b2F1dGhDbGllbnRTZWNyZXR8Y2xpZW50U2VjcmV0KShbXFwnXFxcIlxcczo9XSspKFthLXowLTkhXFxcIiNcXCQlJlxcXFxcXCdcXChcXClcXCpcXCtcXCwtXFwuLzo7PD0+XFw/XFxAXFxbXFxdXFxeX2AgK1xuICAgICAgICAnYCcgK1xuICAgICAgICBTdHJpbmcucmF3IGBcXHtcXHxcXH1+XXs4LH0pYCwgJ2dpJyk7XG4gICAgZnVuY3Rpb24gbWFza0F3c0tleXModGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKEFXU19LRVlfUEFUVEVSTiwgU3RyaW5nLnJhdyBgJDEkMioqKipgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza0F3c1Rva2VuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShBV1NfVE9LRU5fUEFUVEVSTiwgU3RyaW5nLnJhdyBgJDFcIjpcIlhYWFhcImApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrU2FzVG9rZW4odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFNBU19UT0tFTl9QQVRURVJOLCBTdHJpbmcucmF3IGAkMT0qKioqYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hc2tQcml2YXRlS2V5KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShQUklWQVRFX0tFWV9QQVRURVJOLCBTdHJpbmcucmF3IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXFxcXFxcXG5YWFhYXFxcXFxcXFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWApOyAvLyBwcmFnbWE6IGFsbG93bGlzdCBzZWNyZXRcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza1ByaXZhdGVLZXlEYXRhKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShQUklWQVRFX0tFWV9EQVRBX1BBVFRFUk4sIFN0cmluZy5yYXcgYFwicHJpdmF0ZUtleURhdGFcIjogXCJYWFhYXCJgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza0Nvbm5lY3Rpb25Ub2tlbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoQ09OTkVDVElPTl9UT0tFTl9QQVRURVJOLCBTdHJpbmcucmF3IGAkMSQyKioqKmApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNrUGFzc3dvcmQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFBBU1NXT1JEX1BBVFRFUk4sIFN0cmluZy5yYXcgYCQxJDIqKioqYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hc2tQYXNzY29kZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoUEFTU0NPREVfUEFUVEVSTiwgU3RyaW5nLnJhdyBgJDEkMioqKipgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFza0NsaWVudFNlY3JldCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoT0FVVEhfQ0xJRU5UX1NFQ1JFVF9QQVRURVJOLCBTdHJpbmcucmF3IGAkMSQyKioqKmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXNrcyBhbnkgc2VjcmV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IG1heSBjb250YWluIGEgc2VjcmV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIG1hc2tlZCBzdHJpbmcuXG4gICAgICovXG4gICAgdGhpcy5tYXNrU2VjcmV0cyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG1hc2tlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWFza2VkdHh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGVycnN0cjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXNrZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1hc2tlZHR4dCA9ICcnO1xuICAgICAgICBsZXQgZXJyc3RyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChtb2NrKSB7XG4gICAgICAgICAgICAgICAgbW9jay5leGVjdXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXNrZWR0eHQgPSBtYXNrQ2xpZW50U2VjcmV0KG1hc2tQYXNzY29kZShtYXNrQ29ubmVjdGlvblRva2VuKG1hc2tQYXNzd29yZChtYXNrUHJpdmF0ZUtleURhdGEobWFza1ByaXZhdGVLZXkobWFza0F3c1Rva2VuKG1hc2tTYXNUb2tlbihtYXNrQXdzS2V5cyh0ZXh0KSkpKSkpKSkpO1xuICAgICAgICAgICAgaWYgKENVU1RPTV9QQVRURVJOU19MRU5HVEggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWFza2VkdHh0ID0gbWFza0N1c3RvbVBhdHRlcm4obWFza2VkdHh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXNrZWR0eHQgIT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICBtYXNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1hc2tlZCA9IHRydWU7XG4gICAgICAgICAgICBtYXNrZWR0eHQgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGVycnN0ciA9IGVyci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG1hc2tlZDogbWFza2VkLFxuICAgICAgICAgICAgbWFza2VkdHh0OiBtYXNrZWR0eHQsXG4gICAgICAgICAgICBlcnJzdHI6IGVycnN0cixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBTZWNyZXREZXRlY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3JldF9kZXRlY3Rvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/secret_detector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst ErrorCodes = Errors.codes;\n/**\n * Creates a new instance of an LargeResultSetService.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @constructor\n */\nfunction LargeResultSetService(connectionConfig, httpClient) {\n    // validate input\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    Errors.assertInternal(Util.isObject(httpClient));\n    /**\n     * Should HTTP client error be retried\n     * @param err Client error or null/undefined\n     * @return {boolean}\n     */\n    function isRetryableClientError(err) {\n        return (err &&\n            (err.code === 'ECONNRESET' ||\n                err.code === 'ETIMEDOUT' ||\n                // error code ECONNABORTED is thrown from axios on timeout\n                (err.name === 'AxiosError' && err.code === 'ECONNABORTED')));\n    }\n    function isRetryableError(response, err) {\n        // https://aws.amazon.com/articles/1904 (Handling Errors)\n        // Note: 403's are retried because of a bug in S3/Blob\n        return Util.isRetryableHttpError(response, true) || isRetryableClientError(err);\n    }\n    function isUnsuccessfulResponse(response) {\n        // even for 200 OK S3 can return xml error (large files are normally binary)\n        return (response &&\n            (response.statusCode !== 200 ||\n                response.getResponseHeader('Content-Type') === 'application/xml'));\n    }\n    /**\n     * Issues a request to get an object from S3/Blob.\n     *\n     * @param {Object} options\n     */\n    this.getObject = function getObject(options) {\n        let numRetries = 0, sleep = 1;\n        // get the maximum number of retries\n        let maxNumRetries = options.maxNumRetries;\n        if (!Util.exists(maxNumRetries)) {\n            maxNumRetries = connectionConfig.getRetryLargeResultSetMaxNumRetries();\n        }\n        Errors.assertInternal(Util.isNumber(maxNumRetries) && maxNumRetries >= 0);\n        // invoked when the request completes\n        const callback = function callback(err, response, body) {\n            // err happens on timeouts and response is passed when server responded\n            if (err || isUnsuccessfulResponse(response)) {\n                // if we're running in DEBUG loglevel, probably we want to see the full error too\n                const logErr = err\n                    ? JSON.stringify(err, Object.getOwnPropertyNames(err))\n                    : `status: ${JSON.stringify(response.status)} ${JSON.stringify(response.statusText)}` +\n                        ` headers: ${JSON.stringify(response.headers)}`;\n                Logger.getInstance().debug('Encountered an error when getting data from cloud storage: ' + logErr);\n                // if we haven't exceeded the maximum number of retries yet and the\n                // server came back with a retryable error code.\n                if (numRetries < maxNumRetries && isRetryableError(response, err)) {\n                    // increment the number of retries\n                    numRetries++;\n                    // use exponential backoff with decorrelated jitter to compute the\n                    // next sleep time:\n                    const cap = connectionConfig.getRetryLargeResultSetMaxSleepTime();\n                    sleep = Util.nextSleepTime(1, cap, sleep);\n                    // wait the appropriate amount of time before retrying the request\n                    const nextSendRequestWaitTimeMs = sleep * 1000;\n                    Logger.getInstance().trace('Request will be retried after %d milliseconds', Math.floor(nextSendRequestWaitTimeMs));\n                    setTimeout(sendRequest, nextSendRequestWaitTimeMs);\n                    return;\n                }\n                else {\n                    Logger.getInstance().trace(\"Request won't be retried\");\n                    if (isUnsuccessfulResponse(response)) {\n                        err = Errors.createLargeResultSetError(ErrorCodes.ERR_LARGE_RESULT_SET_RESPONSE_FAILURE, response);\n                    }\n                    else {\n                        err = Errors.createNetworkError(ErrorCodes.ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT, err);\n                    }\n                }\n            }\n            if (response) {\n                Logger.getInstance().trace(`Response headers are: ${JSON.stringify(response.headers)}`);\n            }\n            // if we have an error, clear the body\n            if (err) {\n                body = null;\n            }\n            // if a callback was specified, invoke it\n            if (Util.isFunction(options.callback)) {\n                try {\n                    options.callback(err, body);\n                }\n                catch (e) {\n                    Logger.getInstance().error(`Callback failed with ${e}`);\n                }\n            }\n        };\n        const sendRequest = function sendRequest() {\n            // issue a request to get the object from S3/Blob\n            httpClient.request({\n                method: 'GET',\n                url: options.url,\n                headers: options.headers,\n                gzip: true, // gunzip the response\n                appendRequestId: false,\n                callback,\n            });\n        };\n        sendRequest();\n    };\n}\nUtil.inherits(LargeResultSetService, EventEmitter);\nmodule.exports = LargeResultSetService;\n//# sourceMappingURL=large_result_set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZXJ2aWNlcy9sYXJnZV9yZXN1bHRfc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscUJBQXFCLDBEQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQyxFQUFFLG9DQUFvQztBQUN4RyxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxpQ0FBaUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvc2VydmljZXMvbGFyZ2VfcmVzdWx0X3NldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2Rlcztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBMYXJnZVJlc3VsdFNldFNlcnZpY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTGFyZ2VSZXN1bHRTZXRTZXJ2aWNlKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbm5lY3Rpb25Db25maWcpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChodHRwQ2xpZW50KSk7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIEhUVFAgY2xpZW50IGVycm9yIGJlIHJldHJpZWRcbiAgICAgKiBAcGFyYW0gZXJyIENsaWVudCBlcnJvciBvciBudWxsL3VuZGVmaW5lZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXRyeWFibGVDbGllbnRFcnJvcihlcnIpIHtcbiAgICAgICAgcmV0dXJuIChlcnIgJiZcbiAgICAgICAgICAgIChlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPT09ICdFVElNRURPVVQnIHx8XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgY29kZSBFQ09OTkFCT1JURUQgaXMgdGhyb3duIGZyb20gYXhpb3Mgb24gdGltZW91dFxuICAgICAgICAgICAgICAgIChlcnIubmFtZSA9PT0gJ0F4aW9zRXJyb3InICYmIGVyci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJykpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZXRyeWFibGVFcnJvcihyZXNwb25zZSwgZXJyKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vYXdzLmFtYXpvbi5jb20vYXJ0aWNsZXMvMTkwNCAoSGFuZGxpbmcgRXJyb3JzKVxuICAgICAgICAvLyBOb3RlOiA0MDMncyBhcmUgcmV0cmllZCBiZWNhdXNlIG9mIGEgYnVnIGluIFMzL0Jsb2JcbiAgICAgICAgcmV0dXJuIFV0aWwuaXNSZXRyeWFibGVIdHRwRXJyb3IocmVzcG9uc2UsIHRydWUpIHx8IGlzUmV0cnlhYmxlQ2xpZW50RXJyb3IoZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNVbnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICAvLyBldmVuIGZvciAyMDAgT0sgUzMgY2FuIHJldHVybiB4bWwgZXJyb3IgKGxhcmdlIGZpbGVzIGFyZSBub3JtYWxseSBiaW5hcnkpXG4gICAgICAgIHJldHVybiAocmVzcG9uc2UgJiZcbiAgICAgICAgICAgIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDAgfHxcbiAgICAgICAgICAgICAgICByZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykgPT09ICdhcHBsaWNhdGlvbi94bWwnKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzc3VlcyBhIHJlcXVlc3QgdG8gZ2V0IGFuIG9iamVjdCBmcm9tIFMzL0Jsb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZ2V0T2JqZWN0ID0gZnVuY3Rpb24gZ2V0T2JqZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG51bVJldHJpZXMgPSAwLCBzbGVlcCA9IDE7XG4gICAgICAgIC8vIGdldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllc1xuICAgICAgICBsZXQgbWF4TnVtUmV0cmllcyA9IG9wdGlvbnMubWF4TnVtUmV0cmllcztcbiAgICAgICAgaWYgKCFVdGlsLmV4aXN0cyhtYXhOdW1SZXRyaWVzKSkge1xuICAgICAgICAgICAgbWF4TnVtUmV0cmllcyA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlMYXJnZVJlc3VsdFNldE1heE51bVJldHJpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc051bWJlcihtYXhOdW1SZXRyaWVzKSAmJiBtYXhOdW1SZXRyaWVzID49IDApO1xuICAgICAgICAvLyBpbnZva2VkIHdoZW4gdGhlIHJlcXVlc3QgY29tcGxldGVzXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLCByZXNwb25zZSwgYm9keSkge1xuICAgICAgICAgICAgLy8gZXJyIGhhcHBlbnMgb24gdGltZW91dHMgYW5kIHJlc3BvbnNlIGlzIHBhc3NlZCB3aGVuIHNlcnZlciByZXNwb25kZWRcbiAgICAgICAgICAgIGlmIChlcnIgfHwgaXNVbnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBydW5uaW5nIGluIERFQlVHIGxvZ2xldmVsLCBwcm9iYWJseSB3ZSB3YW50IHRvIHNlZSB0aGUgZnVsbCBlcnJvciB0b29cbiAgICAgICAgICAgICAgICBjb25zdCBsb2dFcnIgPSBlcnJcbiAgICAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikpXG4gICAgICAgICAgICAgICAgICAgIDogYHN0YXR1czogJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZS5zdGF0dXMpfSAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLnN0YXR1c1RleHQpfWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCBoZWFkZXJzOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmhlYWRlcnMpfWA7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0VuY291bnRlcmVkIGFuIGVycm9yIHdoZW4gZ2V0dGluZyBkYXRhIGZyb20gY2xvdWQgc3RvcmFnZTogJyArIGxvZ0Vycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZW4ndCBleGNlZWRlZCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyB5ZXQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlcnZlciBjYW1lIGJhY2sgd2l0aCBhIHJldHJ5YWJsZSBlcnJvciBjb2RlLlxuICAgICAgICAgICAgICAgIGlmIChudW1SZXRyaWVzIDwgbWF4TnVtUmV0cmllcyAmJiBpc1JldHJ5YWJsZUVycm9yKHJlc3BvbnNlLCBlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgbnVtYmVyIG9mIHJldHJpZXNcbiAgICAgICAgICAgICAgICAgICAgbnVtUmV0cmllcysrO1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGRlY29ycmVsYXRlZCBqaXR0ZXIgdG8gY29tcHV0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBzbGVlcCB0aW1lOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXAgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5TGFyZ2VSZXN1bHRTZXRNYXhTbGVlcFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2xlZXAgPSBVdGlsLm5leHRTbGVlcFRpbWUoMSwgY2FwLCBzbGVlcCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgdGhlIGFwcHJvcHJpYXRlIGFtb3VudCBvZiB0aW1lIGJlZm9yZSByZXRyeWluZyB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VuZFJlcXVlc3RXYWl0VGltZU1zID0gc2xlZXAgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCB3aWxsIGJlIHJldHJpZWQgYWZ0ZXIgJWQgbWlsbGlzZWNvbmRzJywgTWF0aC5mbG9vcihuZXh0U2VuZFJlcXVlc3RXYWl0VGltZU1zKSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIG5leHRTZW5kUmVxdWVzdFdhaXRUaW1lTXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShcIlJlcXVlc3Qgd29uJ3QgYmUgcmV0cmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlTGFyZ2VSZXN1bHRTZXRFcnJvcihFcnJvckNvZGVzLkVSUl9MQVJHRV9SRVNVTFRfU0VUX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVOZXR3b3JrRXJyb3IoRXJyb3JDb2Rlcy5FUlJfTEFSR0VfUkVTVUxUX1NFVF9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNULCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFJlc3BvbnNlIGhlYWRlcnMgYXJlOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmhlYWRlcnMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBlcnJvciwgY2xlYXIgdGhlIGJvZHlcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgaW52b2tlIGl0XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgQ2FsbGJhY2sgZmFpbGVkIHdpdGggJHtlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiBzZW5kUmVxdWVzdCgpIHtcbiAgICAgICAgICAgIC8vIGlzc3VlIGEgcmVxdWVzdCB0byBnZXQgdGhlIG9iamVjdCBmcm9tIFMzL0Jsb2JcbiAgICAgICAgICAgIGh0dHBDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBnemlwOiB0cnVlLCAvLyBndW56aXAgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgYXBwZW5kUmVxdWVzdElkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBzZW5kUmVxdWVzdCgpO1xuICAgIH07XG59XG5VdGlsLmluaGVyaXRzKExhcmdlUmVzdWx0U2V0U2VydmljZSwgRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gTGFyZ2VSZXN1bHRTZXRTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFyZ2VfcmVzdWx0X3NldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/services/large_result_set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/services/sf.js":
/*!************************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/services/sf.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*\n  SnowflakeService state machine\n\n  Preconnected - enter()      - Preconnected\n               - connect()    - Connecting\n               - request()    - Connecting\n               - destroy()    - Preconnected\n\n  Connecting   - enter()      - async operation\n                                - Connected if operation succeeds\n                                - Disconnected if network error (we need another PreConnected state)\n                                - Disconnected if operation fails\n                 connect()    - error\n                 request()    - enqueue\n                 destroy()    - enqueue\n\n  Connected    - enter()      - Connected\n                 connect()    - error\n                 request()    - async operation\n                                - Connected if operation succeeds\n                                - Connected if network error\n                                - Renewing if GS says session token has expired\n                                - Disconnected if GS says session token is invalid\n                 destroy()    - async operation\n                              - Disconnected if operation succeeds\n                              - Connected if network error\n                              - Connected if operation fails\n\n  Renewing     - enter()      - async operation\n                                - Connected if operation succeeds\n                                - Connected if network error\n                                - Disconnected if operation fails\n               - connect()    - error\n               - request()    - enqueue\n               - destroy()    - enqueue\n\n  Disconnected - enter()      - Disconnected\n               - connect()    - Disconnected\n               - request()    - Disconnected\n               - destroy()    - Disconnected\n */\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/index.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/parameters.js\");\nconst GSErrors = __webpack_require__(/*! ../constants/gs_errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/gs_errors.js\");\nconst QueryContextCache = __webpack_require__(/*! ../queryContextCache */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/queryContextCache.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/global_config.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication_types.js\");\nconst AuthOkta = __webpack_require__(/*! ../authentication/auth_okta */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_okta.js\");\nconst AuthKeypair = __webpack_require__(/*! ../authentication/auth_keypair */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_keypair.js\");\nconst AuthIDToken = __webpack_require__(/*! ../authentication/auth_idtoken */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_idtoken.js\");\nconst Authenticator = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/authentication.js\");\nconst AuthOauthAuthorizationCode = __webpack_require__(/*! ../authentication/auth_oauth_authorization_code */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/authentication/auth_oauth_authorization_code.js\");\nconst sfParams = __webpack_require__(/*! ../constants/sf_params */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/constants/sf_params.js\");\nfunction isRetryableNetworkError(err) {\n    // anything other than REVOKED error can be retryable.\n    return (!Object.prototype.hasOwnProperty.call(err, 'cause') ||\n        err.cause === undefined ||\n        !Object.prototype.hasOwnProperty.call(err.cause, 'code') ||\n        (err.cause.code !== ErrorCodes.ERR_OCSP_REVOKED &&\n            err.cause.code !== 'DEPTH_ZERO_SELF_SIGNED_CERT' &&\n            err.cause.code !== 'CERT_HAS_EXPIRED' &&\n            err.cause.code !== 'UNABLE_TO_VERIFY_LEAF_SIGNATURE' &&\n            err.cause.code !== 'SELF_SIGNED_CERT_IN_CHAIN' &&\n            err.cause.code !== ErrorCodes.ERR_CRL_ERROR));\n}\nfunction isRetryableHttpError(err) {\n    return (Object.prototype.hasOwnProperty.call(err, 'response') &&\n        Util.isRetryableHttpError(err.response, false));\n}\n/**\n * Creates a new SnowflakeService instance.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {Object} [config]\n * @constructor\n */\nfunction SnowflakeService(connectionConfig, httpClient, config) {\n    // validate input\n    Errors.assertInternal(Util.isObject(connectionConfig));\n    Errors.assertInternal(Util.isObject(httpClient));\n    Errors.assertInternal(!Util.exists(config) || Util.isObject(config));\n    // if a config object was specified, verify\n    // that it has all the information we need\n    let tokenInfoConfig;\n    if (Util.exists(config)) {\n        Errors.assertInternal(Util.isObject(config));\n        Errors.assertInternal(Util.isObject(config.tokenInfo));\n        tokenInfoConfig = config.tokenInfo;\n    }\n    else if (connectionConfig.sessionToken) {\n        tokenInfoConfig = {\n            sessionToken: connectionConfig.sessionToken,\n            masterToken: connectionConfig.masterToken || connectionConfig.sessionToken,\n            sessionTokenExpirationTime: connectionConfig.sessionTokenExpirationTime || Date.now() + 1000 * 60 * 60 * 24,\n            masterTokenExpirationTime: connectionConfig.masterTokenExpirationTime || Date.now() + 1000 * 60 * 60 * 24,\n        };\n    }\n    // create a new TokenInfo instance\n    const tokenInfo = new TokenInfo(tokenInfoConfig);\n    try {\n        Logger.getInstance().debug('Retrieving authenticator');\n        this.authenticator = Authenticator.getAuthenticator(connectionConfig, httpClient);\n    }\n    catch (error) {\n        const message = `Failed to initialize authenticator: ${error}`;\n        Logger.getInstance().error(message);\n        throw Errors.createClientError(ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_UNSUPPORTED, true, message);\n    }\n    // create state objects for all the different states we can be in\n    const stateOptions = {\n        snowflakeService: this,\n        httpClient: httpClient,\n        connectionConfig: connectionConfig,\n        tokenInfo: tokenInfo,\n    };\n    const statePristine = new StatePristine(stateOptions);\n    const stateConnecting = new StateConnecting(stateOptions);\n    const stateConnected = new StateConnected(stateOptions);\n    const stateRenewing = new StateRenewing(stateOptions);\n    const stateDisconnected = new StateDisconnected(stateOptions);\n    let currentState;\n    /**\n     * Transitions to a given state.\n     *\n     * @param {Object} state\n     * @param {Object} [transitionContext]\n     */\n    const transitionTo = function (state, transitionContext) {\n        // this check is necessary to make sure we don't re-enter a transient state\n        // like Renewing when we're already in it\n        if (currentState !== state) {\n            // if we have a current state, exit it; the null check is necessary\n            // because the currentState is undefined at bootstrap time when we\n            // transition to the first state\n            if (currentState) {\n                currentState.exit();\n            }\n            // update the current state\n            currentState = state;\n            // enter the new state\n            currentState.enter(transitionContext);\n        }\n    };\n    /**\n     * Set the session id for the current SnowflakeService\n     * @param sessionId\n     */\n    this.setSessionId = function (sessionId) {\n        this.sessionId = sessionId;\n    };\n    /**\n     * Get the session id.\n     * @returns {number}\n     */\n    this.getSessionId = function () {\n        return this.sessionId;\n    };\n    /**\n     * Transitions to the Pristine state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToPristine = function (transitionContext) {\n        transitionTo(statePristine, transitionContext);\n    };\n    /**\n     * Transitions to the Connecting state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToConnecting = function (transitionContext) {\n        transitionTo(stateConnecting, transitionContext);\n    };\n    /**\n     * Transitions to the Connected state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToConnected = function (transitionContext) {\n        transitionTo(stateConnected, transitionContext);\n    };\n    /**\n     * Transitions to the Renewing state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToRenewing = function (transitionContext) {\n        transitionTo(stateRenewing, transitionContext);\n    };\n    /**\n     * Transitions to the Disconnected state.\n     *\n     * {Object} [transitionContext]\n     */\n    this.transitionToDisconnected = function (transitionContext) {\n        transitionTo(stateDisconnected, transitionContext);\n        // clear the tokens because we're in a fatal state and we don't want the\n        // tokens to be available via getConfig() anymore\n        tokenInfo.clearTokens();\n    };\n    /**\n     * Returns a configuration object that can be passed to the SnowflakeService\n     * constructor to get an equivalent SnowflakeService object.\n     *\n     * @returns {Object}\n     */\n    this.getConfig = function () {\n        return {\n            tokenInfo: tokenInfo.getConfig(),\n        };\n    };\n    /**\n     * Establishes a connection to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.connect = function (options) {\n        new OperationConnect(options).validate().execute();\n    };\n    /**\n     * Issues a connect-continue request to Snowflake.\n     *\n     * @param {Object} [options]\n     */\n    this.continue = function (options) {\n        new OperationContinue(options).validate().execute();\n    };\n    /**\n     * Issues a generic request to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.request = function (options) {\n        new OperationRequest(options).validate().execute();\n    };\n    /**\n     * Issues a generic async request to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.requestAsync = async function (options) {\n        return await new OperationRequest(options).validate().executeAsync();\n    };\n    /**\n     * Terminates the current connection to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.destroy = function (options) {\n        this.clearCache();\n        new OperationDestroy(options).validate().execute();\n    };\n    /**\n     * Creates a new OperationAbstract.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationAbstract(options) {\n        this.options = options;\n    }\n    /**\n     * Validates the operation options.\n     *\n     * @returns {Object} the operation.\n     */\n    OperationAbstract.prototype.validate = function () {\n        return this;\n    };\n    /**\n     * Executes the operation.\n     */\n    OperationAbstract.prototype.execute = function () { };\n    /**\n     * Creates a new OperationConnect.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationConnect(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationConnect, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationConnect.prototype.validate = function () {\n        // verify that the options object contains a callback function\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options) && Util.isFunction(options.callback));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationConnect.prototype.execute = function () {\n        currentState.connect(this.options);\n    };\n    /**\n     * Creates a new OperationContinue.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationContinue(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationContinue, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationContinue.prototype.validate = function () {\n        // verify that the options contain a json object\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options) && Util.isObject(options.json));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationContinue.prototype.execute = function () {\n        currentState.continue(this.options);\n    };\n    /**\n     * Creates a new OperationRequest.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationRequest(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationRequest, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationRequest.prototype.validate = function () {\n        // verify that the options object contains all the necessary information\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options));\n        Errors.assertInternal(Util.isString(options.method));\n        Errors.assertInternal(!Util.exists(options.headers) || Util.isObject(options.headers));\n        Errors.assertInternal(Util.isString(options.url));\n        Errors.assertInternal(!Util.exists(options.json) || Util.isObject(options.json));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationRequest.prototype.execute = function () {\n        currentState.request(this.options);\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationRequest.prototype.executeAsync = async function () {\n        return await currentState.requestAsync(this.options);\n    };\n    /**\n     * Creates a new OperationDestroy.\n     *\n     * @param {Object} options\n     * @constructor\n     */\n    function OperationDestroy(options) {\n        OperationAbstract.apply(this, [options]);\n    }\n    Util.inherits(OperationDestroy, OperationAbstract);\n    /**\n     * @inheritDoc\n     */\n    OperationDestroy.prototype.validate = function () {\n        // verify that the options object contains a callback function\n        const options = this.options;\n        Errors.assertInternal(Util.isObject(options) && Util.isFunction(options.callback));\n        return this;\n    };\n    /**\n     * @inheritDoc\n     */\n    OperationDestroy.prototype.execute = function () {\n        // delegate to current state\n        currentState.destroy(this.options);\n    };\n    /* All queued operations will be added to this array */\n    const operationQueue = [];\n    /**\n     * Appends a request operation to the queue.\n     *\n     * @param {Object} options\n     */\n    this.enqueueRequest = function (options) {\n        operationQueue.push(new OperationRequest(options));\n    };\n    /**\n     * Appends a destroy operation to the queue.\n     *\n     * @param {Object} options\n     */\n    this.enqueueDestroy = function (options) {\n        operationQueue.push(new OperationDestroy(options));\n    };\n    /**\n     * Executes all the operations in the queue.\n     */\n    this.drainOperationQueue = function () {\n        // execute all the operations in the queue\n        for (let index = 0, length = operationQueue.length; index < length; index++) {\n            operationQueue[index].execute();\n        }\n        // empty the queue\n        operationQueue.length = 0;\n    };\n    this.isConnected = function () {\n        return (currentState === stateConnected ||\n            currentState === stateConnecting ||\n            currentState === stateRenewing);\n    };\n    this.getServiceName = function () {\n        return Parameters.getValue(Parameters.names.SERVICE_NAME);\n    };\n    this.getClientSessionKeepAlive = function () {\n        return Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE);\n    };\n    this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n        return Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY);\n    };\n    this.getJsTreatIntegerAsBigInt = function () {\n        return Parameters.getValue(Parameters.names.JS_TREAT_INTEGER_AS_BIGINT);\n    };\n    this.getAuthenticator = function () {\n        return this.authenticator;\n    };\n    // if we don't have any tokens, start out as pristine\n    if (tokenInfo.isEmpty()) {\n        this.transitionToPristine();\n    }\n    else {\n        // we're already connected\n        this.transitionToConnected();\n    }\n    /**\n     * Issues a post request to Snowflake.\n     *\n     * @param {Object} options\n     */\n    this.postAsync = function (options) {\n        return new OperationRequest(options).validate().executeAsync();\n    };\n    this.getQueryContextDTO = function () {\n        if (!this.qcc) {\n            return;\n        }\n        return this.qcc.getQueryContextDTO();\n    };\n    this.deserializeQueryContext = function (data) {\n        if (!this.qcc) {\n            return;\n        }\n        this.qcc.deserializeQueryContext(data);\n    };\n    this.clearCache = function () {\n        if (!this.qcc) {\n            return;\n        }\n        this.qcc.clearCache();\n    };\n    this.initializeQueryContextCache = function (size) {\n        if (!connectionConfig.getDisableQueryContextCache()) {\n            this.qcc = new QueryContextCache(size, this.getSessionId());\n        }\n        else {\n            Logger.getInstance().debug(`QueryContextCache initialization skipped as it is disabled for connection with sessionId: ${this.sessionId}`);\n        }\n    };\n    // testing purpose\n    this.getQueryContextCacheSize = function () {\n        if (!this.qcc) {\n            return;\n        }\n        return this.qcc.getSize();\n    };\n}\nUtil.inherits(SnowflakeService, EventEmitter);\nmodule.exports = SnowflakeService;\n///////////////////////////////////////////////////////////////////////////\n////                StateAbstract                                      ////\n///////////////////////////////////////////////////////////////////////////\n/**\n * Creates a new StateAbstract instance.\n *\n * @param {Object} options\n * @constructor\n */\nfunction StateAbstract(options) {\n    /**\n     * Issues an http request to Snowflake.\n     *\n     * @param {Object} requestOptions\n     * @param {Object} httpClient\n     * @param {Object} auth\n     * @returns {Object} the http request object.\n     */\n    function sendHttpRequest(requestOptions, httpClient, auth) {\n        const params = requestOptions.params || {};\n        if (!requestOptions.excludeGuid) {\n            addGuidToParams(params);\n        }\n        const realRequestOptions = {\n            method: requestOptions.method,\n            headers: requestOptions.headers,\n            url: requestOptions.absoluteUrl,\n            gzip: requestOptions.gzip,\n            json: requestOptions.json,\n            params: params,\n            callback: async function (err, response, body) {\n                // if we got an error, wrap it into a network error\n                if (err) {\n                    // if we're running in DEBUG loglevel, probably we want to see the full error instead\n                    Logger.getInstance().debug('Encountered an error when sending the request. Details: ' +\n                        JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                    err = Errors.createNetworkError(ErrorCodes.ERR_SF_NETWORK_COULD_NOT_CONNECT, err);\n                }\n                else if (!response) {\n                    // empty response\n                    err = Errors.createUnexpectedContentError(ErrorCodes.ERR_SF_RESPONSE_NOT_JSON, '(EMPTY)');\n                }\n                else if (Object.prototype.hasOwnProperty.call(response, 'statusCode') &&\n                    response.statusCode !== 200) {\n                    // if we didn't get a 200, the request failed\n                    if (response.statusCode === 401 && response.body) {\n                        let innerCode;\n                        try {\n                            innerCode = JSON.parse(response.body).code;\n                        }\n                        catch (e) {\n                            err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                            Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                        }\n                        if (innerCode === '390104') {\n                            err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_INVALID_TOKEN, response);\n                            Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                        }\n                        else {\n                            err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                            Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                        }\n                    }\n                    else {\n                        err = Errors.createRequestFailedError(ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                        Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n                    }\n                }\n                else {\n                    // if the response body is a non-empty string and the response is\n                    // supposed to contain json, try to json-parse the body\n                    if (Util.isString(body) &&\n                        response.getResponseHeader('Content-Type') === 'application/json') {\n                        try {\n                            if (body.includes('smkId')) {\n                                body = Util.convertSmkIdToString(body);\n                            }\n                            body = JSON.parse(body);\n                        }\n                        catch (parseError) {\n                            // we expected to get json\n                            err = Errors.createUnexpectedContentError(ErrorCodes.ERR_SF_RESPONSE_NOT_JSON, response.body);\n                        }\n                    }\n                    // if we were able to successfully json-parse the body and the\n                    // success flag is false, the operation we tried to perform failed\n                    if (body && !body.success) {\n                        const data = body.data;\n                        if ((body.code === GSErrors.code.ID_TOKEN_INVALID && auth instanceof AuthIDToken) ||\n                            (body.code === GSErrors.code.OAUTH_TOKEN_EXPIRED &&\n                                auth instanceof AuthOauthAuthorizationCode)) {\n                            Logger.getInstance().debug('ID Token being used has expired. Reauthenticating');\n                            await auth.reauthenticate(requestOptions.json);\n                            return httpClient.request(realRequestOptions);\n                        }\n                        err = Errors.createOperationFailedError(body.code, data, body.message, data && data.sqlState ? data.sqlState : undefined);\n                    }\n                }\n                // if we have an error, clear the body\n                if (err) {\n                    body = undefined;\n                }\n                // if a callback was specified, invoke it\n                if (Util.isFunction(requestOptions.callback)) {\n                    await requestOptions.callback.apply(requestOptions.scope, [err, body, response]);\n                }\n            },\n        };\n        if (requestOptions.retry > 2) {\n            const includesParam = requestOptions.url.includes('?');\n            realRequestOptions.url += includesParam ? '&' : '?';\n            realRequestOptions.url +=\n                'clientStartTime=' +\n                    requestOptions.startTime +\n                    '&' +\n                    'retryCount=' +\n                    (requestOptions.retry - 1);\n        }\n        return httpClient.request(realRequestOptions);\n    }\n    this.snowflakeService = options.snowflakeService;\n    this.httpClient = options.httpClient;\n    this.connectionConfig = options.connectionConfig;\n    this.tokenInfo = options.tokenInfo;\n    const connectionConfig = options.connectionConfig;\n    const snowflakeService = options.snowflakeService;\n    const httpClient = options.httpClient;\n    ///////////////////////////////////////////////////////////////////////////\n    ////                Request                                            ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * Creates a new Request to Snowflake.\n     *\n     * @param {Object} requestOptions\n     * @constructor\n     */\n    function Request(requestOptions) {\n        this.requestOptions = requestOptions;\n    }\n    /**\n     * Sends out the request.\n     *\n     * @returns {Object} the request that was issued.\n     */\n    Request.prototype.sendAsync = async function () {\n        // pre-process the request options\n        this.preprocessOptions(this.requestOptions);\n        // issue the http request\n        return new Promise((resolve, reject) => {\n            sendHttpRequest({\n                ...this.requestOptions,\n                callback: (err, _body, response) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(response);\n                    }\n                },\n            }, httpClient, snowflakeService.getAuthenticator());\n        });\n    };\n    function addGuidToParams(params) {\n        // In case of repeated requests for the same request ID,\n        // the Global UID is added for better traceability.\n        const guid = uuidv4();\n        params[sfParams.paramsNames.SF_REQUEST_GUID] = guid;\n    }\n    /**\n     * Sends out the request.\n     *\n     * @returns {Object} the request that was issued.\n     */\n    Request.prototype.send = function () {\n        // pre-process the request options\n        this.preprocessOptions(this.requestOptions);\n        // issue the http request\n        sendHttpRequest(this.requestOptions, httpClient, snowflakeService.getAuthenticator());\n    };\n    /**\n     * Pre-processes the request options just before the request is sent.\n     *\n     * @param {Object} requestOptions\n     */\n    Request.prototype.preprocessOptions = function (requestOptions) {\n        // augment the headers with the default request headers\n        requestOptions.headers = Util.apply(this.getDefaultReqHeaders(), requestOptions.headers || {});\n        if (Util.isLoginRequest(requestOptions.url)) {\n            Util.apply(requestOptions.headers, {\n                CLIENT_APP_VERSION: requestOptions.json.data.CLIENT_APP_VERSION,\n                CLIENT_APP_ID: requestOptions.json.data.CLIENT_APP_ID,\n            });\n        }\n        // augment the options with the absolute url\n        requestOptions.absoluteUrl = this.buildFullUrl(requestOptions.url);\n        requestOptions.excludeGuid = !Util.exists(requestOptions.excludeGuid)\n            ? false\n            : requestOptions.excludeGuid;\n    };\n    /**\n     * Converts a relative url to an absolute url.\n     *\n     * @param {String} relativeUrl\n     *\n     * @returns {String}\n     */\n    Request.prototype.buildFullUrl = function (relativeUrl) {\n        return connectionConfig.accessUrl + relativeUrl;\n    };\n    /**\n     * Returns the default headers to send with every request.\n     *\n     * @returns {Object}\n     */\n    Request.prototype.getDefaultReqHeaders = function () {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n        };\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////                SessionTokenRequest                                ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * @constructor\n     */\n    function SessionTokenRequest() {\n        Request.apply(this, arguments);\n    }\n    Util.inherits(SessionTokenRequest, Request);\n    /**\n     * @inheritDoc\n     */\n    SessionTokenRequest.prototype.preprocessOptions = function (requestOptions) {\n        // call super\n        Request.prototype.preprocessOptions.apply(this, arguments);\n        // add the current session token to the request headers\n        requestOptions.headers = requestOptions.headers || {};\n        requestOptions.headers.Authorization =\n            'Snowflake Token=\"' + options.tokenInfo.getSessionToken() + '\"';\n        if (Util.string.isNotNullOrEmpty(Parameters.getValue(Parameters.names.SERVICE_NAME))) {\n            requestOptions.headers['X-Snowflake-Service'] = Parameters.getValue(Parameters.names.SERVICE_NAME);\n        }\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////                MasterTokenRequest                                 ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * @constructor\n     */\n    function MasterTokenRequest() {\n        Request.apply(this, arguments);\n    }\n    Util.inherits(MasterTokenRequest, Request);\n    /**\n     * @inheritDoc\n     */\n    MasterTokenRequest.prototype.preprocessOptions = function (requestOptions) {\n        // call super\n        Request.prototype.preprocessOptions.apply(this, arguments);\n        // add the current master token to the request headers\n        requestOptions.headers = requestOptions.headers || {};\n        requestOptions.headers.Authorization =\n            'Snowflake Token=\"' + options.tokenInfo.getMasterToken() + '\"';\n    };\n    ///////////////////////////////////////////////////////////////////////////\n    ////                UnauthenticatedRequest                             ////\n    ///////////////////////////////////////////////////////////////////////////\n    /**\n     * Creates a new UnauthenticatedRequest.\n     *\n     * @constructor\n     */\n    function UnauthenticatedRequest() {\n        Request.apply(this, arguments);\n    }\n    Util.inherits(UnauthenticatedRequest, Request);\n    /**\n     * Creates a new SessionTokenRequest.\n     *\n     * @param {Object} requestOptions\n     *\n     * @returns {Object}\n     */\n    this.createSessionTokenRequest = function (requestOptions) {\n        return new SessionTokenRequest(requestOptions);\n    };\n    /**\n     * Creates a new MasterTokenRequest.\n     *\n     * @param {Object} requestOptions\n     *\n     * @returns {Object}\n     */\n    this.createMasterTokenRequest = function (requestOptions) {\n        return new MasterTokenRequest(requestOptions);\n    };\n    /**\n     * Creates a new UnauthenticatedRequest.\n     *\n     * @param {Object} requestOptions\n     *\n     * @returns {Object}\n     */\n    this.createUnauthenticatedRequest = function (requestOptions) {\n        return new UnauthenticatedRequest(requestOptions);\n    };\n}\n/**\n * Enters this state.\n * @abstract\n */\nStateAbstract.prototype.enter = function () { };\n/**\n * Exits this state.\n * @abstract\n */\nStateAbstract.prototype.exit = function () { };\n/**\n * Establishes a connection to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.connect = function () { };\n/**\n * Issues a connect-continue request to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.continue = function () { };\n/**\n * Issues a generic request to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.request = function () { };\n/**\n * Terminates the current connection to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.destroy = function () { };\n///////////////////////////////////////////////////////////////////////////\n////                StatePristine                                      ////\n///////////////////////////////////////////////////////////////////////////\nfunction StatePristine() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StatePristine, StateAbstract);\n/**\n * @inheritDoc\n */\nStatePristine.prototype.connect = function (options) {\n    // transition to the Connecting state with the callback in the transition\n    // context\n    this.snowflakeService.transitionToConnecting({\n        options: options,\n    });\n};\n/**\n * @inheritDoc\n */\nStatePristine.prototype.request = function (options) {\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_REQUEST_STATUS_PRISTINE));\n    });\n};\n/**\n * @inheritDoc\n */\nStatePristine.prototype.destroy = function (options) {\n    // we're still in the preconnected state so any\n    // attempts to destroy should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_DESTROY_STATUS_PRISTINE));\n    });\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateConnecting                                    ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateConnecting() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateConnecting, StateAbstract);\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.enter = function (context) {\n    // save the context\n    this.context = context;\n    // initiate the connection process\n    this.continue();\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.exit = function () {\n    // clear the context\n    this.context = null;\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.connect = function (options) {\n    // we're already connecting so any attempts\n    // to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTING));\n    });\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.continue = function () {\n    const context = this.context;\n    const err = context.options.err;\n    let json = context.options.json;\n    // if no json was specified, treat this as the first connect\n    // and get the necessary information from connectionConfig\n    if (!json) {\n        json = {\n            data: {\n                ACCOUNT_NAME: this.connectionConfig.account,\n                LOGIN_NAME: this.connectionConfig.username,\n                PASSWORD: this.connectionConfig.password,\n            },\n        };\n    }\n    // extract the inflight context from the error and put it back in the json\n    if (err && err.data && err.data.inFlightCtx) {\n        json.inFlightCtx = err.data.inFlightCtx;\n    }\n    // initialize the json data if necessary\n    json.data = json.data || {};\n    // add the client-app-id, client-app-version, and client-app-name\n    const clientInfo = {\n        CLIENT_APP_ID: this.connectionConfig.getClientType(),\n        CLIENT_APP_VERSION: this.connectionConfig.getClientVersion(),\n    };\n    // if we have some information about the client environment, add it as well\n    const clientEnvironment = this.connectionConfig.getClientEnvironment();\n    if (Util.isObject(clientEnvironment)) {\n        clientInfo.CLIENT_ENVIRONMENT = {\n            CERT_REVOCATION_CHECK_MODE: this.connectionConfig.crlValidatorConfig.checkMode,\n            ...json.data.CLIENT_ENVIRONMENT,\n            ...clientEnvironment,\n        };\n    }\n    const clientApplication = this.connectionConfig.getClientApplication();\n    if (Util.isString(clientApplication)) {\n        clientEnvironment['APPLICATION'] = clientApplication;\n    }\n    const sessionParameters = {\n        SESSION_PARAMETERS: {},\n    };\n    if (Util.exists(this.connectionConfig.getClientSessionKeepAlive())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_SESSION_KEEP_ALIVE =\n            this.connectionConfig.getClientSessionKeepAlive();\n    }\n    if (Util.exists(this.connectionConfig.getClientSessionKeepAliveHeartbeatFrequency())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY =\n            this.connectionConfig.getClientSessionKeepAliveHeartbeatFrequency();\n    }\n    if (Util.exists(this.connectionConfig.getJsTreatIntegerAsBigInt())) {\n        sessionParameters.SESSION_PARAMETERS.JS_TREAT_INTEGER_AS_BIGINT =\n            this.connectionConfig.getJsTreatIntegerAsBigInt();\n    }\n    if (Util.exists(this.connectionConfig.getGcsUseDownscopedCredential())) {\n        sessionParameters.SESSION_PARAMETERS.GCS_USE_DOWNSCOPED_CREDENTIAL =\n            this.connectionConfig.getGcsUseDownscopedCredential();\n    }\n    if (Util.exists(this.connectionConfig.getClientRequestMFAToken())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_REQUEST_MFA_TOKEN =\n            this.connectionConfig.getClientRequestMFAToken();\n    }\n    if (Util.exists(this.connectionConfig.getClientStoreTemporaryCredential())) {\n        sessionParameters.SESSION_PARAMETERS.CLIENT_STORE_TEMPORARY_CREDENTIAL =\n            this.connectionConfig.getClientStoreTemporaryCredential();\n    }\n    if (Util.exists(this.connectionConfig.queryTag)) {\n        sessionParameters.SESSION_PARAMETERS.QUERY_TAG = this.connectionConfig.queryTag;\n    }\n    Util.apply(json.data, clientInfo);\n    Util.apply(json.data, sessionParameters);\n    const connectionConfig = this.connectionConfig;\n    const maxLoginRetries = connectionConfig.getRetrySfMaxLoginRetries();\n    const maxRetryTimeout = connectionConfig.getRetryTimeout();\n    const startTime = connectionConfig.accessUrl.startsWith('https://')\n        ? Date.now()\n        : 'FIXEDTIMESTAMP';\n    let numRetries = 0;\n    let sleep = connectionConfig.getRetrySfStartingSleepTime();\n    let totalElapsedTime = 0;\n    Logger.getInstance().debug('Total retryTimeout is for the retries = ' + maxRetryTimeout === 0\n        ? 0\n        : maxRetryTimeout);\n    const parent = this;\n    const requestCallback = async function (err, body) {\n        // clear credential-related information\n        connectionConfig.clearCredentials();\n        // if the request succeeded\n        if (!err) {\n            Errors.assertInternal(Util.exists(body));\n            Errors.assertInternal(Util.exists(body.data));\n            parent.snowflakeService.setSessionId(body.data.sessionId);\n            Logger.getInstance().debug(`New session with id ${parent.snowflakeService.getSessionId()} initialized`);\n            // update the parameters\n            Parameters.update(body.data.parameters);\n            // update all token-related information\n            parent.tokenInfo.update(body.data);\n            if (connectionConfig.getClientRequestMFAToken() && body.data.mfaToken) {\n                const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR);\n                await GlobalConfig.getCredentialManager().write(key, body.data.mfaToken);\n            }\n            if (connectionConfig.getClientStoreTemporaryCredential() && body.data.idToken) {\n                const key = Util.buildCredentialCacheKey(connectionConfig.host, connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n                await GlobalConfig.getCredentialManager().write(key, body.data.idToken);\n            }\n            // we're now connected\n            parent.snowflakeService.transitionToConnected();\n            const qccSize = Parameters.getValue('QUERY_CONTEXT_CACHE_SIZE');\n            parent.snowflakeService.initializeQueryContextCache(qccSize);\n        }\n        else {\n            if (Errors.isNetworkError(err) || Errors.isRequestFailedError(err)) {\n                if (numRetries < maxLoginRetries &&\n                    (isRetryableNetworkError(err) || isRetryableHttpError(err)) &&\n                    (maxRetryTimeout === 0 || totalElapsedTime < maxRetryTimeout)) {\n                    numRetries++;\n                    const jitter = Util.getJitteredSleepTime(numRetries, sleep, totalElapsedTime, maxRetryTimeout);\n                    sleep = jitter.sleep;\n                    totalElapsedTime = jitter.totalElapsedTime;\n                    if (sleep <= 0) {\n                        Logger.getInstance().debug('Reached out to the max Login Timeout');\n                        parent.snowflakeService.transitionToDisconnected();\n                    }\n                    const auth = parent.snowflakeService.getAuthenticator();\n                    if (auth instanceof AuthOkta) {\n                        Logger.getInstance().debug('OKTA authentication requires token refresh.');\n                        const retryOption = {\n                            totalElapsedTime,\n                            numRetries,\n                        };\n                        await auth.reauthenticate(context.options.json, retryOption);\n                        numRetries = retryOption.numRetries;\n                        totalElapsedTime = retryOption.totalElapsedTime;\n                    }\n                    else if (auth instanceof AuthKeypair) {\n                        Logger.getInstance().debug('AuthKeyPair authentication requires token refresh.');\n                        await auth.reauthenticate(context.options.json);\n                    }\n                    setTimeout(sendRequest, sleep * 1000);\n                    return;\n                }\n                else {\n                    Logger.getInstance().debug('Failed to all retries to SF.');\n                    // we're now disconnected\n                    parent.snowflakeService.transitionToDisconnected();\n                }\n            }\n            else {\n                // we're now disconnected\n                parent.snowflakeService.transitionToDisconnected();\n            }\n        }\n        // invoke the transition-context callback that was passed to us by the\n        // Pristine state on connect()\n        if (Util.isFunction(context.options.callback)) {\n            context.options.callback(err);\n        }\n        // all queued operations are now free to go\n        parent.snowflakeService.drainOperationQueue();\n    };\n    // issue a login request\n    const sendRequest = function () {\n        const targetUrl = buildLoginUrl(connectionConfig);\n        Logger.getInstance().debug('Contacting SF: %s, (%s/%s)', targetUrl, numRetries, maxLoginRetries);\n        const request = parent.createUnauthenticatedRequest({\n            method: 'POST',\n            url: targetUrl,\n            json: json,\n            scope: this,\n            startTime: startTime,\n            retry: numRetries,\n            callback: requestCallback,\n        });\n        request.send();\n    };\n    sendRequest();\n};\n/**\n * Builds the url for a login request.\n *\n * @param connectionConfig\n *\n * @returns {*}\n */\nfunction buildLoginUrl(connectionConfig) {\n    const queryParams = [\n        { name: 'warehouse', value: connectionConfig.getWarehouse() },\n        { name: 'databaseName', value: connectionConfig.getDatabase() },\n        { name: 'schemaName', value: connectionConfig.getSchema() },\n        { name: 'roleName', value: connectionConfig.getRole() },\n    ];\n    const queryStringObject = {};\n    if (!connectionConfig.isQaMode()) {\n        // No requestId is attached to login-request in test mode.\n        queryStringObject.requestId = uuidv4();\n    }\n    for (let index = 0, length = queryParams.length; index < length; index++) {\n        const queryParam = queryParams[index];\n        if (Util.string.isNotNullOrEmpty(queryParam.value)) {\n            queryStringObject[queryParam.name] = queryParam.value;\n        }\n    }\n    return Url.format({\n        pathname: '/session/v1/login-request',\n        search: QueryString.stringify(queryStringObject),\n    });\n}\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.request = function (options) {\n    // enqueue the request operation\n    this.snowflakeService.enqueueRequest(options);\n};\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.destroy = function (options) {\n    // enqueue the destroy operation\n    this.snowflakeService.enqueueDestroy(options);\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateConnected                                     ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateConnected() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateConnected, StateAbstract);\n/**\n * @inheritDoc\n */\nStateConnected.prototype.connect = function (options) {\n    // we're already connected so any attempts\n    // to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTED));\n    });\n};\nStateConnected.prototype.requestAsync = async function (options) {\n    // create a session token request from the options and send out the request\n    return await this.createSessionTokenRequest(options).sendAsync();\n};\n/**\n * @inheritDoc\n */\nStateConnected.prototype.request = function (options) {\n    const scopeOrig = options.scope;\n    const callbackOrig = options.callback;\n    // define our own scope and callback\n    options.scope = this;\n    options.callback = async function (err, body) {\n        // if there was no error, invoke the callback if one was specified\n        if (!err) {\n            if (Util.isFunction(callbackOrig)) {\n                await callbackOrig.apply(scopeOrig, [err, body]);\n            }\n        }\n        else {\n            // restore the original scope and callback to the options object because\n            // we might need to repeat the request\n            options.scope = scopeOrig;\n            options.callback = callbackOrig;\n            // if the session token has expired\n            if (err.code === GSErrors.code.SESSION_TOKEN_EXPIRED) {\n                // enqueue the request operation\n                this.snowflakeService.enqueueRequest(options);\n                // if a session token renewal isn't already in progress, issue a\n                // request to renew the session token\n                this.snowflakeService.transitionToRenewing();\n            }\n            else if (err.code === GSErrors.code.SESSION_TOKEN_INVALID ||\n                err.code === GSErrors.code.GONE_SESSION) {\n                // if the session token is invalid or it doesn't exist\n                // enqueue the request operation\n                this.snowflakeService.enqueueRequest(options);\n                // we're disconnected\n                this.snowflakeService.transitionToDisconnected();\n                // all queued operations are now free to go\n                this.snowflakeService.drainOperationQueue();\n                // TODO: remember that a session renewal is no longer in progress\n                // TODO: make sure the last session renewal did not time out\n            }\n            else {\n                // it's a normal failure\n                // if a callback was specified, invoke it\n                if (Util.isFunction(callbackOrig)) {\n                    callbackOrig.apply(scopeOrig, [err, body]);\n                }\n            }\n        }\n    };\n    // create a session token request from the options and send out the request\n    this.createSessionTokenRequest(options).send();\n};\n/**\n * @inheritDoc\n */\nStateConnected.prototype.destroy = function (options) {\n    const requestID = uuidv4();\n    // send out a session token request to terminate the current connection\n    this.createSessionTokenRequest({\n        method: 'POST',\n        url: `/session?delete=true&requestId=${requestID}`,\n        scope: this,\n        callback: function (err) {\n            // if the destroy request succeeded or the session already expired, we're disconnected\n            if (!err ||\n                err.code === GSErrors.code.GONE_SESSION ||\n                err.code === GSErrors.code.SESSION_TOKEN_EXPIRED) {\n                err = undefined;\n                this.snowflakeService.transitionToDisconnected();\n            }\n            // invoke the original callback\n            options.callback(err);\n        },\n    }).send();\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateRenewing                                      ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateRenewing() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateRenewing, StateAbstract);\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.enter = function () {\n    // send out a master token request to renew the current session token\n    this.createMasterTokenRequest({\n        method: 'POST',\n        url: '/session/token-request',\n        headers: {\n            CLIENT_APP_ID: this.connectionConfig.getClientType(),\n            CLIENT_APP_VERSION: this.connectionConfig.getClientVersion(),\n        },\n        json: {\n            REQUEST_TYPE: 'RENEW',\n            oldSessionToken: this.tokenInfo.getSessionToken(),\n        },\n        scope: this,\n        callback: function (err, body) {\n            // if the request succeeded\n            if (!err) {\n                // update the token information\n                this.tokenInfo.update(body.data);\n                // we're now connected again\n                this.snowflakeService.transitionToConnected();\n            }\n            else {\n                // if the master token has expired, transition to the disconnected\n                // state\n                if (err.code === GSErrors.code.MASTER_TOKEN_EXPIRED) {\n                    this.snowflakeService.transitionToDisconnected();\n                }\n                else if (Errors.isNetworkError(err)) {\n                    // go back to the connected state\n                    this.snowflakeService.transitionToConnected();\n                }\n                else {\n                    // if the renewal failed for some other reason, we're\n                    // disconnected\n                    // TODO: what should our state be here? also disconnected?\n                    this.snowflakeService.transitionToDisconnected();\n                }\n            }\n            // all queued operations are now free to go\n            this.snowflakeService.drainOperationQueue();\n        },\n    }).send();\n};\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.connect = function (options) {\n    // we're renewing the session token, which means we're connected,\n    // so any attempts to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTED));\n    });\n};\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.request = function (options) {\n    // enqueue the request operation\n    this.snowflakeService.enqueueRequest(options);\n};\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.destroy = function (options) {\n    // enqueue the destroy operation\n    this.snowflakeService.enqueueDestroy(options);\n};\n///////////////////////////////////////////////////////////////////////////\n////                StateDisconnected                                  ////\n///////////////////////////////////////////////////////////////////////////\nfunction StateDisconnected() {\n    StateAbstract.apply(this, arguments);\n}\nUtil.inherits(StateDisconnected, StateAbstract);\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.connect = function (options) {\n    // we're disconnected -- and fatally so -- so any\n    // attempts to connect should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_STATUS_DISCONNECTED));\n    });\n};\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.request = function (options) {\n    // we're disconnected, so any attempts to\n    // send a request should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_REQUEST_STATUS_DISCONNECTED, true));\n    });\n};\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.destroy = function (options) {\n    // we're already disconnected so any attempts\n    // to destroy should result in an error\n    const callback = options.callback;\n    process.nextTick(function () {\n        callback(Errors.createClientError(ErrorCodes.ERR_CONN_DESTROY_STATUS_DISCONNECTED));\n    });\n};\n/**\n * Creates a TokenInfo object that encapsulates all token-related information,\n * e.g. the master token, the session token, the tokens' expiration times, etc.\n *\n * @param {Object} [config]\n *\n * @constructor\n */\nfunction TokenInfo(config) {\n    let masterToken;\n    let sessionToken;\n    let masterTokenExpirationTime;\n    let sessionTokenExpirationTime;\n    if (Util.isObject(config)) {\n        masterToken = config.masterToken;\n        sessionToken = config.sessionToken;\n        masterTokenExpirationTime = config.masterTokenExpirationTime;\n        sessionTokenExpirationTime = config.sessionTokenExpirationTime;\n    }\n    /**\n     * Returns true if no token-related information is available, false otherwise.\n     *\n     * @returns {Boolean}\n     */\n    this.isEmpty = function () {\n        return (!Util.exists(masterToken) ||\n            !Util.exists(masterTokenExpirationTime) ||\n            !Util.exists(sessionToken) ||\n            !Util.exists(sessionTokenExpirationTime));\n    };\n    /**\n     * Clears all token-related information.\n     */\n    this.clearTokens = function () {\n        masterToken = undefined;\n        masterTokenExpirationTime = undefined;\n        sessionToken = undefined;\n        sessionTokenExpirationTime = undefined;\n    };\n    /**\n     * Updates the tokens and their expiration times.\n     *\n     * @param {Object} data\n     */\n    this.update = function (data) {\n        masterToken = data.masterToken;\n        sessionToken = data.token || data.sessionToken;\n        const currentTime = new Date().getTime();\n        masterTokenExpirationTime =\n            currentTime + 1000 * (data.masterValidityInSeconds || data.validityInSecondsMT);\n        sessionTokenExpirationTime =\n            currentTime + 1000 * (data.validityInSeconds || data.validityInSecondsST);\n    };\n    /**\n     * Returns the master token.\n     *\n     * @returns {String}\n     */\n    this.getMasterToken = function () {\n        return masterToken;\n    };\n    /**\n     * Returns the expiration time of the master token.\n     *\n     * @returns {Number}\n     */\n    this.getMasterTokenExpirationTime = function () {\n        return masterTokenExpirationTime;\n    };\n    /**\n     * Returns the session token.\n     *\n     * @returns {String}\n     */\n    this.getSessionToken = function () {\n        return sessionToken;\n    };\n    /**\n     * Returns the expiration time of the session token.\n     *\n     * @returns {Number}\n     */\n    this.getSessionTokenExpirationTime = function () {\n        return sessionTokenExpirationTime;\n    };\n    /**\n     * Returns a configuration object that can be passed to the TokenInfo\n     * constructor to get an equivalent TokenInfo object.\n     *\n     * @returns {Object}\n     */\n    this.getConfig = function () {\n        return {\n            masterToken: masterToken,\n            masterTokenExpirationTime: masterTokenExpirationTime,\n            sessionToken: sessionToken,\n            sessionTokenExpirationTime: sessionTokenExpirationTime,\n        };\n    };\n}\n//# sourceMappingURL=sf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zZXJ2aWNlcy9zZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyx5RkFBTTtBQUNyQyxxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyxvRUFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEM7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsa0dBQXdCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLDhGQUFzQjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsd0VBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWtCO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLGtJQUF3QztBQUM1RSxpQkFBaUIsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsa0hBQWdDO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLGtIQUFnQztBQUM1RCxzQkFBc0IsbUJBQU8sQ0FBQyxzSEFBa0M7QUFDaEUsbUNBQW1DLG1CQUFPLENBQUMsb0pBQWlEO0FBQzVGLGlCQUFpQixtQkFBTyxDQUFDLGtHQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksZUFBZTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxDQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHdDQUF3QztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyREFBMkQ7QUFDckUsVUFBVSw2REFBNkQ7QUFDdkUsVUFBVSx5REFBeUQ7QUFDbkUsVUFBVSxxREFBcUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL3NlcnZpY2VzL3NmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAgU25vd2ZsYWtlU2VydmljZSBzdGF0ZSBtYWNoaW5lXG5cbiAgUHJlY29ubmVjdGVkIC0gZW50ZXIoKSAgICAgIC0gUHJlY29ubmVjdGVkXG4gICAgICAgICAgICAgICAtIGNvbm5lY3QoKSAgICAtIENvbm5lY3RpbmdcbiAgICAgICAgICAgICAgIC0gcmVxdWVzdCgpICAgIC0gQ29ubmVjdGluZ1xuICAgICAgICAgICAgICAgLSBkZXN0cm95KCkgICAgLSBQcmVjb25uZWN0ZWRcblxuICBDb25uZWN0aW5nICAgLSBlbnRlcigpICAgICAgLSBhc3luYyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBDb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIG5ldHdvcmsgZXJyb3IgKHdlIG5lZWQgYW5vdGhlciBQcmVDb25uZWN0ZWQgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIG9wZXJhdGlvbiBmYWlsc1xuICAgICAgICAgICAgICAgICBjb25uZWN0KCkgICAgLSBlcnJvclxuICAgICAgICAgICAgICAgICByZXF1ZXN0KCkgICAgLSBlbnF1ZXVlXG4gICAgICAgICAgICAgICAgIGRlc3Ryb3koKSAgICAtIGVucXVldWVcblxuICBDb25uZWN0ZWQgICAgLSBlbnRlcigpICAgICAgLSBDb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgY29ubmVjdCgpICAgIC0gZXJyb3JcbiAgICAgICAgICAgICAgICAgcmVxdWVzdCgpICAgIC0gYXN5bmMgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQ29ubmVjdGVkIGlmIG9wZXJhdGlvbiBzdWNjZWVkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gUmVuZXdpbmcgaWYgR1Mgc2F5cyBzZXNzaW9uIHRva2VuIGhhcyBleHBpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIEdTIHNheXMgc2Vzc2lvbiB0b2tlbiBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgIGRlc3Ryb3koKSAgICAtIGFzeW5jIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEaXNjb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBvcGVyYXRpb24gZmFpbHNcblxuICBSZW5ld2luZyAgICAgLSBlbnRlcigpICAgICAgLSBhc3luYyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBDb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQ29ubmVjdGVkIGlmIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEaXNjb25uZWN0ZWQgaWYgb3BlcmF0aW9uIGZhaWxzXG4gICAgICAgICAgICAgICAtIGNvbm5lY3QoKSAgICAtIGVycm9yXG4gICAgICAgICAgICAgICAtIHJlcXVlc3QoKSAgICAtIGVucXVldWVcbiAgICAgICAgICAgICAgIC0gZGVzdHJveSgpICAgIC0gZW5xdWV1ZVxuXG4gIERpc2Nvbm5lY3RlZCAtIGVudGVyKCkgICAgICAtIERpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgLSBjb25uZWN0KCkgICAgLSBEaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgIC0gcmVxdWVzdCgpICAgIC0gRGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAtIGRlc3Ryb3koKSAgICAtIERpc2Nvbm5lY3RlZFxuICovXG5jb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IFF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuLi9wYXJhbWV0ZXJzJyk7XG5jb25zdCBHU0Vycm9ycyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9nc19lcnJvcnMnKTtcbmNvbnN0IFF1ZXJ5Q29udGV4dENhY2hlID0gcmVxdWlyZSgnLi4vcXVlcnlDb250ZXh0Q2FjaGUnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgQXV0aGVudGljYXRpb25UeXBlcyA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBBdXRoT2t0YSA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhfb2t0YScpO1xuY29uc3QgQXV0aEtleXBhaXIgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXInKTtcbmNvbnN0IEF1dGhJRFRva2VuID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aF9pZHRva2VuJyk7XG5jb25zdCBBdXRoZW50aWNhdG9yID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24nKTtcbmNvbnN0IEF1dGhPYXV0aEF1dGhvcml6YXRpb25Db2RlID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aF9vYXV0aF9hdXRob3JpemF0aW9uX2NvZGUnKTtcbmNvbnN0IHNmUGFyYW1zID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL3NmX3BhcmFtcycpO1xuZnVuY3Rpb24gaXNSZXRyeWFibGVOZXR3b3JrRXJyb3IoZXJyKSB7XG4gICAgLy8gYW55dGhpbmcgb3RoZXIgdGhhbiBSRVZPS0VEIGVycm9yIGNhbiBiZSByZXRyeWFibGUuXG4gICAgcmV0dXJuICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ2NhdXNlJykgfHxcbiAgICAgICAgZXJyLmNhdXNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIuY2F1c2UsICdjb2RlJykgfHxcbiAgICAgICAgKGVyci5jYXVzZS5jb2RlICE9PSBFcnJvckNvZGVzLkVSUl9PQ1NQX1JFVk9LRUQgJiZcbiAgICAgICAgICAgIGVyci5jYXVzZS5jb2RlICE9PSAnREVQVEhfWkVST19TRUxGX1NJR05FRF9DRVJUJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09ICdDRVJUX0hBU19FWFBJUkVEJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09ICdVTkFCTEVfVE9fVkVSSUZZX0xFQUZfU0lHTkFUVVJFJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09ICdTRUxGX1NJR05FRF9DRVJUX0lOX0NIQUlOJyAmJlxuICAgICAgICAgICAgZXJyLmNhdXNlLmNvZGUgIT09IEVycm9yQ29kZXMuRVJSX0NSTF9FUlJPUikpO1xufVxuZnVuY3Rpb24gaXNSZXRyeWFibGVIdHRwRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAncmVzcG9uc2UnKSAmJlxuICAgICAgICBVdGlsLmlzUmV0cnlhYmxlSHR0cEVycm9yKGVyci5yZXNwb25zZSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTbm93Zmxha2VTZXJ2aWNlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU25vd2ZsYWtlU2VydmljZShjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBjb25maWcpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbm5lY3Rpb25Db25maWcpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChodHRwQ2xpZW50KSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKCFVdGlsLmV4aXN0cyhjb25maWcpIHx8IFV0aWwuaXNPYmplY3QoY29uZmlnKSk7XG4gICAgLy8gaWYgYSBjb25maWcgb2JqZWN0IHdhcyBzcGVjaWZpZWQsIHZlcmlmeVxuICAgIC8vIHRoYXQgaXQgaGFzIGFsbCB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZFxuICAgIGxldCB0b2tlbkluZm9Db25maWc7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGNvbmZpZykpIHtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29uZmlnKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZy50b2tlbkluZm8pKTtcbiAgICAgICAgdG9rZW5JbmZvQ29uZmlnID0gY29uZmlnLnRva2VuSW5mbztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29ubmVjdGlvbkNvbmZpZy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgdG9rZW5JbmZvQ29uZmlnID0ge1xuICAgICAgICAgICAgc2Vzc2lvblRva2VuOiBjb25uZWN0aW9uQ29uZmlnLnNlc3Npb25Ub2tlbixcbiAgICAgICAgICAgIG1hc3RlclRva2VuOiBjb25uZWN0aW9uQ29uZmlnLm1hc3RlclRva2VuIHx8IGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuLFxuICAgICAgICAgICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU6IGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgfHwgRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICAgICAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lOiBjb25uZWN0aW9uQ29uZmlnLm1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgfHwgRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIG5ldyBUb2tlbkluZm8gaW5zdGFuY2VcbiAgICBjb25zdCB0b2tlbkluZm8gPSBuZXcgVG9rZW5JbmZvKHRva2VuSW5mb0NvbmZpZyk7XG4gICAgdHJ5IHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JldHJpZXZpbmcgYXV0aGVudGljYXRvcicpO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0b3IgPSBBdXRoZW50aWNhdG9yLmdldEF1dGhlbnRpY2F0b3IoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBpbml0aWFsaXplIGF1dGhlbnRpY2F0b3I6ICR7ZXJyb3J9YDtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FVVEhfVU5TVVBQT1JURUQsIHRydWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc3RhdGUgb2JqZWN0cyBmb3IgYWxsIHRoZSBkaWZmZXJlbnQgc3RhdGVzIHdlIGNhbiBiZSBpblxuICAgIGNvbnN0IHN0YXRlT3B0aW9ucyA9IHtcbiAgICAgICAgc25vd2ZsYWtlU2VydmljZTogdGhpcyxcbiAgICAgICAgaHR0cENsaWVudDogaHR0cENsaWVudCxcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZzogY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgdG9rZW5JbmZvOiB0b2tlbkluZm8sXG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZVByaXN0aW5lID0gbmV3IFN0YXRlUHJpc3RpbmUoc3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzdGF0ZUNvbm5lY3RpbmcgPSBuZXcgU3RhdGVDb25uZWN0aW5nKHN0YXRlT3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhdGVDb25uZWN0ZWQgPSBuZXcgU3RhdGVDb25uZWN0ZWQoc3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzdGF0ZVJlbmV3aW5nID0gbmV3IFN0YXRlUmVuZXdpbmcoc3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzdGF0ZURpc2Nvbm5lY3RlZCA9IG5ldyBTdGF0ZURpc2Nvbm5lY3RlZChzdGF0ZU9wdGlvbnMpO1xuICAgIGxldCBjdXJyZW50U3RhdGU7XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdHJhbnNpdGlvbkNvbnRleHRdXG4gICAgICovXG4gICAgY29uc3QgdHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHN0YXRlLCB0cmFuc2l0aW9uQ29udGV4dCkge1xuICAgICAgICAvLyB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmUtZW50ZXIgYSB0cmFuc2llbnQgc3RhdGVcbiAgICAgICAgLy8gbGlrZSBSZW5ld2luZyB3aGVuIHdlJ3JlIGFscmVhZHkgaW4gaXRcbiAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBjdXJyZW50IHN0YXRlLCBleGl0IGl0OyB0aGUgbnVsbCBjaGVjayBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGN1cnJlbnRTdGF0ZSBpcyB1bmRlZmluZWQgYXQgYm9vdHN0cmFwIHRpbWUgd2hlbiB3ZVxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiB0byB0aGUgZmlyc3Qgc3RhdGVcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUuZXhpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIC8vIGVudGVyIHRoZSBuZXcgc3RhdGVcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZS5lbnRlcih0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2Vzc2lvbiBpZCBmb3IgdGhlIGN1cnJlbnQgU25vd2ZsYWtlU2VydmljZVxuICAgICAqIEBwYXJhbSBzZXNzaW9uSWRcbiAgICAgKi9cbiAgICB0aGlzLnNldFNlc3Npb25JZCA9IGZ1bmN0aW9uIChzZXNzaW9uSWQpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNlc3Npb24gaWQuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbklkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFByaXN0aW5lIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvUHJpc3RpbmUgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdHJhbnNpdGlvblRvKHN0YXRlUHJpc3RpbmUsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBDb25uZWN0aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvQ29ubmVjdGluZyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uQ29udGV4dCkge1xuICAgICAgICB0cmFuc2l0aW9uVG8oc3RhdGVDb25uZWN0aW5nLCB0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgQ29ubmVjdGVkIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvQ29ubmVjdGVkID0gZnVuY3Rpb24gKHRyYW5zaXRpb25Db250ZXh0KSB7XG4gICAgICAgIHRyYW5zaXRpb25UbyhzdGF0ZUNvbm5lY3RlZCwgdHJhbnNpdGlvbkNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFJlbmV3aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblRvUmVuZXdpbmcgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdHJhbnNpdGlvblRvKHN0YXRlUmVuZXdpbmcsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBEaXNjb25uZWN0ZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiB7T2JqZWN0fSBbdHJhbnNpdGlvbkNvbnRleHRdXG4gICAgICovXG4gICAgdGhpcy50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdHJhbnNpdGlvblRvKHN0YXRlRGlzY29ubmVjdGVkLCB0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgICAgIC8vIGNsZWFyIHRoZSB0b2tlbnMgYmVjYXVzZSB3ZSdyZSBpbiBhIGZhdGFsIHN0YXRlIGFuZCB3ZSBkb24ndCB3YW50IHRoZVxuICAgICAgICAvLyB0b2tlbnMgdG8gYmUgYXZhaWxhYmxlIHZpYSBnZXRDb25maWcoKSBhbnltb3JlXG4gICAgICAgIHRva2VuSW5mby5jbGVhclRva2VucygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgU25vd2ZsYWtlU2VydmljZVxuICAgICAqIGNvbnN0cnVjdG9yIHRvIGdldCBhbiBlcXVpdmFsZW50IFNub3dmbGFrZVNlcnZpY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuSW5mbzogdG9rZW5JbmZvLmdldENvbmZpZygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIFNub3dmbGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgbmV3IE9wZXJhdGlvbkNvbm5lY3Qob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJc3N1ZXMgYSBjb25uZWN0LWNvbnRpbnVlIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIHRoaXMuY29udGludWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBuZXcgT3BlcmF0aW9uQ29udGludWUob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJc3N1ZXMgYSBnZW5lcmljIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBuZXcgT3BlcmF0aW9uUmVxdWVzdChvcHRpb25zKS52YWxpZGF0ZSgpLmV4ZWN1dGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElzc3VlcyBhIGdlbmVyaWMgYXN5bmMgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpLnZhbGlkYXRlKCkuZXhlY3V0ZUFzeW5jKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gdG8gU25vd2ZsYWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgbmV3IE9wZXJhdGlvbkRlc3Ryb3kob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wZXJhdGlvbkFic3RyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVyYXRpb25BYnN0cmFjdChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgb3BlcmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIE9wZXJhdGlvbkFic3RyYWN0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIE9wZXJhdGlvbkFic3RyYWN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0aW9uQ29ubmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uQ29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIE9wZXJhdGlvbkFic3RyYWN0LmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgfVxuICAgIFV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uQ29ubmVjdCwgT3BlcmF0aW9uQWJzdHJhY3QpO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uQ29ubmVjdC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBvcHRpb25zIG9iamVjdCBjb250YWlucyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpICYmIFV0aWwuaXNGdW5jdGlvbihvcHRpb25zLmNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25Db25uZWN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50U3RhdGUuY29ubmVjdCh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25Db250aW51ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uQ29udGludWUob3B0aW9ucykge1xuICAgICAgICBPcGVyYXRpb25BYnN0cmFjdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIH1cbiAgICBVdGlsLmluaGVyaXRzKE9wZXJhdGlvbkNvbnRpbnVlLCBPcGVyYXRpb25BYnN0cmFjdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25Db250aW51ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBvcHRpb25zIGNvbnRhaW4gYSBqc29uIG9iamVjdFxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSAmJiBVdGlsLmlzT2JqZWN0KG9wdGlvbnMuanNvbikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uQ29udGludWUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5jb250aW51ZSh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgT3BlcmF0aW9uQWJzdHJhY3QuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB9XG4gICAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25SZXF1ZXN0LCBPcGVyYXRpb25BYnN0cmFjdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25SZXF1ZXN0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNTdHJpbmcob3B0aW9ucy5tZXRob2QpKTtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKCFVdGlsLmV4aXN0cyhvcHRpb25zLmhlYWRlcnMpIHx8IFV0aWwuaXNPYmplY3Qob3B0aW9ucy5oZWFkZXJzKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKG9wdGlvbnMudXJsKSk7XG4gICAgICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbCghVXRpbC5leGlzdHMob3B0aW9ucy5qc29uKSB8fCBVdGlsLmlzT2JqZWN0KG9wdGlvbnMuanNvbikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudFN0YXRlLnJlcXVlc3QodGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgT3BlcmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgY3VycmVudFN0YXRlLnJlcXVlc3RBc3luYyh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25EZXN0cm95LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcGVyYXRpb25EZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgT3BlcmF0aW9uQWJzdHJhY3QuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB9XG4gICAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25EZXN0cm95LCBPcGVyYXRpb25BYnN0cmFjdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBPcGVyYXRpb25EZXN0cm95LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5zIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykgJiYgVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE9wZXJhdGlvbkRlc3Ryb3kucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRlbGVnYXRlIHRvIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgY3VycmVudFN0YXRlLmRlc3Ryb3kodGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qIEFsbCBxdWV1ZWQgb3BlcmF0aW9ucyB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgYXJyYXkgKi9cbiAgICBjb25zdCBvcGVyYXRpb25RdWV1ZSA9IFtdO1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSByZXF1ZXN0IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZW5xdWV1ZVJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5wdXNoKG5ldyBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBkZXN0cm95IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZW5xdWV1ZURlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5wdXNoKG5ldyBPcGVyYXRpb25EZXN0cm95KG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGFsbCB0aGUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWUuXG4gICAgICovXG4gICAgdGhpcy5kcmFpbk9wZXJhdGlvblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBleGVjdXRlIGFsbCB0aGUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWVcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBvcGVyYXRpb25RdWV1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25RdWV1ZVtpbmRleF0uZXhlY3V0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVtcHR5IHRoZSBxdWV1ZVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50U3RhdGUgPT09IHN0YXRlQ29ubmVjdGVkIHx8XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPT09IHN0YXRlQ29ubmVjdGluZyB8fFxuICAgICAgICAgICAgY3VycmVudFN0YXRlID09PSBzdGF0ZVJlbmV3aW5nKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2VydmljZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuU0VSVklDRV9OQU1FKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1kpO1xuICAgIH07XG4gICAgdGhpcy5nZXRKc1RyZWF0SW50ZWdlckFzQmlnSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLkpTX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0QXV0aGVudGljYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aGVudGljYXRvcjtcbiAgICB9O1xuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHRva2Vucywgc3RhcnQgb3V0IGFzIHByaXN0aW5lXG4gICAgaWYgKHRva2VuSW5mby5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9QcmlzdGluZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWRcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXNzdWVzIGEgcG9zdCByZXF1ZXN0IHRvIFNub3dmbGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5wb3N0QXN5bmMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvblJlcXVlc3Qob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlQXN5bmMoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UXVlcnlDb250ZXh0RFRPID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucWNjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucWNjLmdldFF1ZXJ5Q29udGV4dERUTygpO1xuICAgIH07XG4gICAgdGhpcy5kZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5xY2MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnFjYy5kZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dChkYXRhKTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnFjYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucWNjLmNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZVF1ZXJ5Q29udGV4dENhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uQ29uZmlnLmdldERpc2FibGVRdWVyeUNvbnRleHRDYWNoZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnFjYyA9IG5ldyBRdWVyeUNvbnRleHRDYWNoZShzaXplLCB0aGlzLmdldFNlc3Npb25JZCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRdWVyeUNvbnRleHRDYWNoZSBpbml0aWFsaXphdGlvbiBza2lwcGVkIGFzIGl0IGlzIGRpc2FibGVkIGZvciBjb25uZWN0aW9uIHdpdGggc2Vzc2lvbklkOiAke3RoaXMuc2Vzc2lvbklkfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB0ZXN0aW5nIHB1cnBvc2VcbiAgICB0aGlzLmdldFF1ZXJ5Q29udGV4dENhY2hlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnFjYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnFjYy5nZXRTaXplKCk7XG4gICAgfTtcbn1cblV0aWwuaW5oZXJpdHMoU25vd2ZsYWtlU2VydmljZSwgRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gU25vd2ZsYWtlU2VydmljZTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZUFic3RyYWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTdGF0ZUFic3RyYWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdGVBYnN0cmFjdChvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogSXNzdWVzIGFuIGh0dHAgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIGh0dHAgcmVxdWVzdCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEh0dHBSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBodHRwQ2xpZW50LCBhdXRoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHJlcXVlc3RPcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0T3B0aW9ucy5leGNsdWRlR3VpZCkge1xuICAgICAgICAgICAgYWRkR3VpZFRvUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhbFJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0T3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgdXJsOiByZXF1ZXN0T3B0aW9ucy5hYnNvbHV0ZVVybCxcbiAgICAgICAgICAgIGd6aXA6IHJlcXVlc3RPcHRpb25zLmd6aXAsXG4gICAgICAgICAgICBqc29uOiByZXF1ZXN0T3B0aW9ucy5qc29uLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBnb3QgYW4gZXJyb3IsIHdyYXAgaXQgaW50byBhIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gREVCVUcgbG9nbGV2ZWwsIHByb2JhYmx5IHdlIHdhbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0VuY291bnRlcmVkIGFuIGVycm9yIHdoZW4gc2VuZGluZyB0aGUgcmVxdWVzdC4gRGV0YWlsczogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU5ldHdvcmtFcnJvcihFcnJvckNvZGVzLkVSUl9TRl9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNULCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVVuZXhwZWN0ZWRDb250ZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfU0ZfUkVTUE9OU0VfTk9UX0pTT04sICcoRU1QVFkpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXNwb25zZSwgJ3N0YXR1c0NvZGUnKSAmJlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIDIwMCwgdGhlIHJlcXVlc3QgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDEgJiYgcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb2RlID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlUmVxdWVzdEZhaWxlZEVycm9yKEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSFRUUCBFcnJvcjogJXMnLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lckNvZGUgPT09ICczOTAxMDQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVJlcXVlc3RGYWlsZWRFcnJvcihFcnJvckNvZGVzLkVSUl9TRl9SRVNQT05TRV9JTlZBTElEX1RPS0VOLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0hUVFAgRXJyb3I6ICVzJywgcmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlUmVxdWVzdEZhaWxlZEVycm9yKEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSFRUUCBFcnJvcjogJXMnLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVSZXF1ZXN0RmFpbGVkRXJyb3IoRXJyb3JDb2Rlcy5FUlJfU0ZfUkVTUE9OU0VfRkFJTFVSRSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0hUVFAgRXJyb3I6ICVzJywgcmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZXNwb25zZSBib2R5IGlzIGEgbm9uLWVtcHR5IHN0cmluZyBhbmQgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4ganNvbiwgdHJ5IHRvIGpzb24tcGFyc2UgdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNTdHJpbmcoYm9keSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5LmluY2x1ZGVzKCdzbWtJZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBVdGlsLmNvbnZlcnRTbWtJZFRvU3RyaW5nKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZXhwZWN0ZWQgdG8gZ2V0IGpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlVW5leHBlY3RlZENvbnRlbnRFcnJvcihFcnJvckNvZGVzLkVSUl9TRl9SRVNQT05TRV9OT1RfSlNPTiwgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2Ugd2VyZSBhYmxlIHRvIHN1Y2Nlc3NmdWxseSBqc29uLXBhcnNlIHRoZSBib2R5IGFuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2VzcyBmbGFnIGlzIGZhbHNlLCB0aGUgb3BlcmF0aW9uIHdlIHRyaWVkIHRvIHBlcmZvcm0gZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5ICYmICFib2R5LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBib2R5LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJvZHkuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5JRF9UT0tFTl9JTlZBTElEICYmIGF1dGggaW5zdGFuY2VvZiBBdXRoSURUb2tlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYm9keS5jb2RlID09PSBHU0Vycm9ycy5jb2RlLk9BVVRIX1RPS0VOX0VYUElSRUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aCBpbnN0YW5jZW9mIEF1dGhPYXV0aEF1dGhvcml6YXRpb25Db2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdJRCBUb2tlbiBiZWluZyB1c2VkIGhhcyBleHBpcmVkLiBSZWF1dGhlbnRpY2F0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aC5yZWF1dGhlbnRpY2F0ZShyZXF1ZXN0T3B0aW9ucy5qc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cENsaWVudC5yZXF1ZXN0KHJlYWxSZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlT3BlcmF0aW9uRmFpbGVkRXJyb3IoYm9keS5jb2RlLCBkYXRhLCBib2R5Lm1lc3NhZ2UsIGRhdGEgJiYgZGF0YS5zcWxTdGF0ZSA/IGRhdGEuc3FsU3RhdGUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYW4gZXJyb3IsIGNsZWFyIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIGludm9rZSBpdFxuICAgICAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24ocmVxdWVzdE9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RPcHRpb25zLmNhbGxiYWNrLmFwcGx5KHJlcXVlc3RPcHRpb25zLnNjb3BlLCBbZXJyLCBib2R5LCByZXNwb25zZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yZXRyeSA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVzUGFyYW0gPSByZXF1ZXN0T3B0aW9ucy51cmwuaW5jbHVkZXMoJz8nKTtcbiAgICAgICAgICAgIHJlYWxSZXF1ZXN0T3B0aW9ucy51cmwgKz0gaW5jbHVkZXNQYXJhbSA/ICcmJyA6ICc/JztcbiAgICAgICAgICAgIHJlYWxSZXF1ZXN0T3B0aW9ucy51cmwgKz1cbiAgICAgICAgICAgICAgICAnY2xpZW50U3RhcnRUaW1lPScgK1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5zdGFydFRpbWUgK1xuICAgICAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICAncmV0cnlDb3VudD0nICtcbiAgICAgICAgICAgICAgICAgICAgKHJlcXVlc3RPcHRpb25zLnJldHJ5IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQucmVxdWVzdChyZWFsUmVxdWVzdE9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UgPSBvcHRpb25zLnNub3dmbGFrZVNlcnZpY2U7XG4gICAgdGhpcy5odHRwQ2xpZW50ID0gb3B0aW9ucy5odHRwQ2xpZW50O1xuICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IG9wdGlvbnMuY29ubmVjdGlvbkNvbmZpZztcbiAgICB0aGlzLnRva2VuSW5mbyA9IG9wdGlvbnMudG9rZW5JbmZvO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBvcHRpb25zLmNvbm5lY3Rpb25Db25maWc7XG4gICAgY29uc3Qgc25vd2ZsYWtlU2VydmljZSA9IG9wdGlvbnMuc25vd2ZsYWtlU2VydmljZTtcbiAgICBjb25zdCBodHRwQ2xpZW50ID0gb3B0aW9ucy5odHRwQ2xpZW50O1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8gICAgICAgICAgICAgICAgUmVxdWVzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdE9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgb3V0IHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLnNlbmRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcHJlLXByb2Nlc3MgdGhlIHJlcXVlc3Qgb3B0aW9uc1xuICAgICAgICB0aGlzLnByZXByb2Nlc3NPcHRpb25zKHRoaXMucmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAvLyBpc3N1ZSB0aGUgaHR0cCByZXF1ZXN0XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzZW5kSHR0cFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMucmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIsIF9ib2R5LCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIGh0dHBDbGllbnQsIHNub3dmbGFrZVNlcnZpY2UuZ2V0QXV0aGVudGljYXRvcigpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGRHdWlkVG9QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgcmVwZWF0ZWQgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIHJlcXVlc3QgSUQsXG4gICAgICAgIC8vIHRoZSBHbG9iYWwgVUlEIGlzIGFkZGVkIGZvciBiZXR0ZXIgdHJhY2VhYmlsaXR5LlxuICAgICAgICBjb25zdCBndWlkID0gdXVpZHY0KCk7XG4gICAgICAgIHBhcmFtc1tzZlBhcmFtcy5wYXJhbXNOYW1lcy5TRl9SRVFVRVNUX0dVSURdID0gZ3VpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgb3V0IHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHByZS1wcm9jZXNzIHRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5wcmVwcm9jZXNzT3B0aW9ucyh0aGlzLnJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgLy8gaXNzdWUgdGhlIGh0dHAgcmVxdWVzdFxuICAgICAgICBzZW5kSHR0cFJlcXVlc3QodGhpcy5yZXF1ZXN0T3B0aW9ucywgaHR0cENsaWVudCwgc25vd2ZsYWtlU2VydmljZS5nZXRBdXRoZW50aWNhdG9yKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJlLXByb2Nlc3NlcyB0aGUgcmVxdWVzdCBvcHRpb25zIGp1c3QgYmVmb3JlIHRoZSByZXF1ZXN0IGlzIHNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5wcmVwcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAvLyBhdWdtZW50IHRoZSBoZWFkZXJzIHdpdGggdGhlIGRlZmF1bHQgcmVxdWVzdCBoZWFkZXJzXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBVdGlsLmFwcGx5KHRoaXMuZ2V0RGVmYXVsdFJlcUhlYWRlcnMoKSwgcmVxdWVzdE9wdGlvbnMuaGVhZGVycyB8fCB7fSk7XG4gICAgICAgIGlmIChVdGlsLmlzTG9naW5SZXF1ZXN0KHJlcXVlc3RPcHRpb25zLnVybCkpIHtcbiAgICAgICAgICAgIFV0aWwuYXBwbHkocmVxdWVzdE9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIENMSUVOVF9BUFBfVkVSU0lPTjogcmVxdWVzdE9wdGlvbnMuanNvbi5kYXRhLkNMSUVOVF9BUFBfVkVSU0lPTixcbiAgICAgICAgICAgICAgICBDTElFTlRfQVBQX0lEOiByZXF1ZXN0T3B0aW9ucy5qc29uLmRhdGEuQ0xJRU5UX0FQUF9JRCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF1Z21lbnQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgYWJzb2x1dGUgdXJsXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmFic29sdXRlVXJsID0gdGhpcy5idWlsZEZ1bGxVcmwocmVxdWVzdE9wdGlvbnMudXJsKTtcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuZXhjbHVkZUd1aWQgPSAhVXRpbC5leGlzdHMocmVxdWVzdE9wdGlvbnMuZXhjbHVkZUd1aWQpXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHJlcXVlc3RPcHRpb25zLmV4Y2x1ZGVHdWlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSByZWxhdGl2ZSB1cmwgdG8gYW4gYWJzb2x1dGUgdXJsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlVXJsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmJ1aWxkRnVsbFVybCA9IGZ1bmN0aW9uIChyZWxhdGl2ZVVybCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwgKyByZWxhdGl2ZVVybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgaGVhZGVycyB0byBzZW5kIHdpdGggZXZlcnkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuZ2V0RGVmYXVsdFJlcUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vICAgICAgICAgICAgICAgIFNlc3Npb25Ub2tlblJlcXVlc3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXNzaW9uVG9rZW5SZXF1ZXN0KCkge1xuICAgICAgICBSZXF1ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFV0aWwuaW5oZXJpdHMoU2Vzc2lvblRva2VuUmVxdWVzdCwgUmVxdWVzdCk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTZXNzaW9uVG9rZW5SZXF1ZXN0LnByb3RvdHlwZS5wcmVwcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAvLyBjYWxsIHN1cGVyXG4gICAgICAgIFJlcXVlc3QucHJvdG90eXBlLnByZXByb2Nlc3NPcHRpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGFkZCB0aGUgY3VycmVudCBzZXNzaW9uIHRva2VuIHRvIHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgICAgICAgICAnU25vd2ZsYWtlIFRva2VuPVwiJyArIG9wdGlvbnMudG9rZW5JbmZvLmdldFNlc3Npb25Ub2tlbigpICsgJ1wiJztcbiAgICAgICAgaWYgKFV0aWwuc3RyaW5nLmlzTm90TnVsbE9yRW1wdHkoUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLlNFUlZJQ0VfTkFNRSkpKSB7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydYLVNub3dmbGFrZS1TZXJ2aWNlJ10gPSBQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuU0VSVklDRV9OQU1FKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLyAgICAgICAgICAgICAgICBNYXN0ZXJUb2tlblJlcXVlc3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFzdGVyVG9rZW5SZXF1ZXN0KCkge1xuICAgICAgICBSZXF1ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFV0aWwuaW5oZXJpdHMoTWFzdGVyVG9rZW5SZXF1ZXN0LCBSZXF1ZXN0KTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE1hc3RlclRva2VuUmVxdWVzdC5wcm90b3R5cGUucHJlcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2FsbCBzdXBlclxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5wcmVwcm9jZXNzT3B0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyBhZGQgdGhlIGN1cnJlbnQgbWFzdGVyIHRva2VuIHRvIHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgICAgICAgICAnU25vd2ZsYWtlIFRva2VuPVwiJyArIG9wdGlvbnMudG9rZW5JbmZvLmdldE1hc3RlclRva2VuKCkgKyAnXCInO1xuICAgIH07XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLyAgICAgICAgICAgICAgICBVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgpIHtcbiAgICAgICAgUmVxdWVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBVdGlsLmluaGVyaXRzKFVuYXV0aGVudGljYXRlZFJlcXVlc3QsIFJlcXVlc3QpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2Vzc2lvblRva2VuUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZVNlc3Npb25Ub2tlblJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uVG9rZW5SZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWFzdGVyVG9rZW5SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlTWFzdGVyVG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFzdGVyVG9rZW5SZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVW5hdXRoZW50aWNhdGVkUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZVVuYXV0aGVudGljYXRlZFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICB9O1xufVxuLyoqXG4gKiBFbnRlcnMgdGhpcyBzdGF0ZS5cbiAqIEBhYnN0cmFjdFxuICovXG5TdGF0ZUFic3RyYWN0LnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qKlxuICogRXhpdHMgdGhpcyBzdGF0ZS5cbiAqIEBhYnN0cmFjdFxuICovXG5TdGF0ZUFic3RyYWN0LnByb3RvdHlwZS5leGl0ID0gZnVuY3Rpb24gKCkgeyB9O1xuLyoqXG4gKiBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gdG8gU25vd2ZsYWtlLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5TdGF0ZUFic3RyYWN0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkgeyB9O1xuLyoqXG4gKiBJc3N1ZXMgYSBjb25uZWN0LWNvbnRpbnVlIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5TdGF0ZUFic3RyYWN0LnByb3RvdHlwZS5jb250aW51ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qKlxuICogSXNzdWVzIGEgZ2VuZXJpYyByZXF1ZXN0IHRvIFNub3dmbGFrZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8qKlxuICogVGVybWluYXRlcyB0aGUgY3VycmVudCBjb25uZWN0aW9uIHRvIFNub3dmbGFrZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZVByaXN0aW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIFN0YXRlUHJpc3RpbmUoKSB7XG4gICAgU3RhdGVBYnN0cmFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuVXRpbC5pbmhlcml0cyhTdGF0ZVByaXN0aW5lLCBTdGF0ZUFic3RyYWN0KTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVQcmlzdGluZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gdHJhbnNpdGlvbiB0byB0aGUgQ29ubmVjdGluZyBzdGF0ZSB3aXRoIHRoZSBjYWxsYmFjayBpbiB0aGUgdHJhbnNpdGlvblxuICAgIC8vIGNvbnRleHRcbiAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvQ29ubmVjdGluZyh7XG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgfSk7XG59O1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZVByaXN0aW5lLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX1JFUVVFU1RfU1RBVFVTX1BSSVNUSU5FKSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZVByaXN0aW5lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyB3ZSdyZSBzdGlsbCBpbiB0aGUgcHJlY29ubmVjdGVkIHN0YXRlIHNvIGFueVxuICAgIC8vIGF0dGVtcHRzIHRvIGRlc3Ryb3kgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfUFJJU1RJTkUpKTtcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVDb25uZWN0aW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBTdGF0ZUNvbm5lY3RpbmcoKSB7XG4gICAgU3RhdGVBYnN0cmFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuVXRpbC5pbmhlcml0cyhTdGF0ZUNvbm5lY3RpbmcsIFN0YXRlQWJzdHJhY3QpO1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RpbmcucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAvLyBzYXZlIHRoZSBjb250ZXh0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAvLyBpbml0aWF0ZSB0aGUgY29ubmVjdGlvbiBwcm9jZXNzXG4gICAgdGhpcy5jb250aW51ZSgpO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5leGl0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNsZWFyIHRoZSBjb250ZXh0XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGluZy5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gd2UncmUgYWxyZWFkeSBjb25uZWN0aW5nIHNvIGFueSBhdHRlbXB0c1xuICAgIC8vIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfQ09OTkVDVElORykpO1xuICAgIH0pO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5jb250aW51ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGVyciA9IGNvbnRleHQub3B0aW9ucy5lcnI7XG4gICAgbGV0IGpzb24gPSBjb250ZXh0Lm9wdGlvbnMuanNvbjtcbiAgICAvLyBpZiBubyBqc29uIHdhcyBzcGVjaWZpZWQsIHRyZWF0IHRoaXMgYXMgdGhlIGZpcnN0IGNvbm5lY3RcbiAgICAvLyBhbmQgZ2V0IHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gZnJvbSBjb25uZWN0aW9uQ29uZmlnXG4gICAgaWYgKCFqc29uKSB7XG4gICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgQUNDT1VOVF9OQU1FOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuYWNjb3VudCxcbiAgICAgICAgICAgICAgICBMT0dJTl9OQU1FOiB0aGlzLmNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgUEFTU1dPUkQ6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5wYXNzd29yZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGV4dHJhY3QgdGhlIGluZmxpZ2h0IGNvbnRleHQgZnJvbSB0aGUgZXJyb3IgYW5kIHB1dCBpdCBiYWNrIGluIHRoZSBqc29uXG4gICAgaWYgKGVyciAmJiBlcnIuZGF0YSAmJiBlcnIuZGF0YS5pbkZsaWdodEN0eCkge1xuICAgICAgICBqc29uLmluRmxpZ2h0Q3R4ID0gZXJyLmRhdGEuaW5GbGlnaHRDdHg7XG4gICAgfVxuICAgIC8vIGluaXRpYWxpemUgdGhlIGpzb24gZGF0YSBpZiBuZWNlc3NhcnlcbiAgICBqc29uLmRhdGEgPSBqc29uLmRhdGEgfHwge307XG4gICAgLy8gYWRkIHRoZSBjbGllbnQtYXBwLWlkLCBjbGllbnQtYXBwLXZlcnNpb24sIGFuZCBjbGllbnQtYXBwLW5hbWVcbiAgICBjb25zdCBjbGllbnRJbmZvID0ge1xuICAgICAgICBDTElFTlRfQVBQX0lEOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLFxuICAgICAgICBDTElFTlRfQVBQX1ZFUlNJT046IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCksXG4gICAgfTtcbiAgICAvLyBpZiB3ZSBoYXZlIHNvbWUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudCBlbnZpcm9ubWVudCwgYWRkIGl0IGFzIHdlbGxcbiAgICBjb25zdCBjbGllbnRFbnZpcm9ubWVudCA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpO1xuICAgIGlmIChVdGlsLmlzT2JqZWN0KGNsaWVudEVudmlyb25tZW50KSkge1xuICAgICAgICBjbGllbnRJbmZvLkNMSUVOVF9FTlZJUk9OTUVOVCA9IHtcbiAgICAgICAgICAgIENFUlRfUkVWT0NBVElPTl9DSEVDS19NT0RFOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuY3JsVmFsaWRhdG9yQ29uZmlnLmNoZWNrTW9kZSxcbiAgICAgICAgICAgIC4uLmpzb24uZGF0YS5DTElFTlRfRU5WSVJPTk1FTlQsXG4gICAgICAgICAgICAuLi5jbGllbnRFbnZpcm9ubWVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50QXBwbGljYXRpb24gPSB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50QXBwbGljYXRpb24oKTtcbiAgICBpZiAoVXRpbC5pc1N0cmluZyhjbGllbnRBcHBsaWNhdGlvbikpIHtcbiAgICAgICAgY2xpZW50RW52aXJvbm1lbnRbJ0FQUExJQ0FUSU9OJ10gPSBjbGllbnRBcHBsaWNhdGlvbjtcbiAgICB9XG4gICAgY29uc3Qgc2Vzc2lvblBhcmFtZXRlcnMgPSB7XG4gICAgICAgIFNFU1NJT05fUEFSQU1FVEVSUzoge30sXG4gICAgfTtcbiAgICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmUoKSkpIHtcbiAgICAgICAgc2Vzc2lvblBhcmFtZXRlcnMuU0VTU0lPTl9QQVJBTUVURVJTLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkUgPVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmUoKTtcbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KCkpKSB7XG4gICAgICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1kgPVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3koKTtcbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRKc1RyZWF0SW50ZWdlckFzQmlnSW50KCkpKSB7XG4gICAgICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5KU19UUkVBVF9JTlRFR0VSX0FTX0JJR0lOVCA9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCgpO1xuICAgIH1cbiAgICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKCkpKSB7XG4gICAgICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5HQ1NfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTCA9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0R2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWwoKTtcbiAgICB9XG4gICAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRSZXF1ZXN0TUZBVG9rZW4oKSkpIHtcbiAgICAgICAgc2Vzc2lvblBhcmFtZXRlcnMuU0VTU0lPTl9QQVJBTUVURVJTLkNMSUVOVF9SRVFVRVNUX01GQV9UT0tFTiA9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50UmVxdWVzdE1GQVRva2VuKCk7XG4gICAgfVxuICAgIGlmIChVdGlsLmV4aXN0cyh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKCkpKSB7XG4gICAgICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5DTElFTlRfU1RPUkVfVEVNUE9SQVJZX0NSRURFTlRJQUwgPVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpO1xuICAgIH1cbiAgICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLnF1ZXJ5VGFnKSkge1xuICAgICAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuUVVFUllfVEFHID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLnF1ZXJ5VGFnO1xuICAgIH1cbiAgICBVdGlsLmFwcGx5KGpzb24uZGF0YSwgY2xpZW50SW5mbyk7XG4gICAgVXRpbC5hcHBseShqc29uLmRhdGEsIHNlc3Npb25QYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnO1xuICAgIGNvbnN0IG1heExvZ2luUmV0cmllcyA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heExvZ2luUmV0cmllcygpO1xuICAgIGNvbnN0IG1heFJldHJ5VGltZW91dCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlUaW1lb3V0KCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKVxuICAgICAgICA/IERhdGUubm93KClcbiAgICAgICAgOiAnRklYRURUSU1FU1RBTVAnO1xuICAgIGxldCBudW1SZXRyaWVzID0gMDtcbiAgICBsZXQgc2xlZXAgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZTdGFydGluZ1NsZWVwVGltZSgpO1xuICAgIGxldCB0b3RhbEVsYXBzZWRUaW1lID0gMDtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnVG90YWwgcmV0cnlUaW1lb3V0IGlzIGZvciB0aGUgcmV0cmllcyA9ICcgKyBtYXhSZXRyeVRpbWVvdXQgPT09IDBcbiAgICAgICAgPyAndW5saW1pdGVkJ1xuICAgICAgICA6IG1heFJldHJ5VGltZW91dCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0Q2FsbGJhY2sgPSBhc3luYyBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgICAgIC8vIGNsZWFyIGNyZWRlbnRpYWwtcmVsYXRlZCBpbmZvcm1hdGlvblxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmNsZWFyQ3JlZGVudGlhbHMoKTtcbiAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMoYm9keSkpO1xuICAgICAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKGJvZHkuZGF0YSkpO1xuICAgICAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2Uuc2V0U2Vzc2lvbklkKGJvZHkuZGF0YS5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYE5ldyBzZXNzaW9uIHdpdGggaWQgJHtwYXJlbnQuc25vd2ZsYWtlU2VydmljZS5nZXRTZXNzaW9uSWQoKX0gaW5pdGlhbGl6ZWRgKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgUGFyYW1ldGVycy51cGRhdGUoYm9keS5kYXRhLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGFsbCB0b2tlbi1yZWxhdGVkIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBwYXJlbnQudG9rZW5JbmZvLnVwZGF0ZShib2R5LmRhdGEpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50UmVxdWVzdE1GQVRva2VuKCkgJiYgYm9keS5kYXRhLm1mYVRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gVXRpbC5idWlsZENyZWRlbnRpYWxDYWNoZUtleShjb25uZWN0aW9uQ29uZmlnLmhvc3QsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIEF1dGhlbnRpY2F0aW9uVHlwZXMuVVNFUl9QV0RfTUZBX0FVVEhFTlRJQ0FUT1IpO1xuICAgICAgICAgICAgICAgIGF3YWl0IEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLndyaXRlKGtleSwgYm9keS5kYXRhLm1mYVRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpICYmIGJvZHkuZGF0YS5pZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gVXRpbC5idWlsZENyZWRlbnRpYWxDYWNoZUtleShjb25uZWN0aW9uQ29uZmlnLmhvc3QsIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIEF1dGhlbnRpY2F0aW9uVHlwZXMuSURfVE9LRU5fQVVUSEVOVElDQVRPUik7XG4gICAgICAgICAgICAgICAgYXdhaXQgR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkud3JpdGUoa2V5LCBib2R5LmRhdGEuaWRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSdyZSBub3cgY29ubmVjdGVkXG4gICAgICAgICAgICBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHFjY1NpemUgPSBQYXJhbWV0ZXJzLmdldFZhbHVlKCdRVUVSWV9DT05URVhUX0NBQ0hFX1NJWkUnKTtcbiAgICAgICAgICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLmluaXRpYWxpemVRdWVyeUNvbnRleHRDYWNoZShxY2NTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChFcnJvcnMuaXNOZXR3b3JrRXJyb3IoZXJyKSB8fCBFcnJvcnMuaXNSZXF1ZXN0RmFpbGVkRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgIGlmIChudW1SZXRyaWVzIDwgbWF4TG9naW5SZXRyaWVzICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1JldHJ5YWJsZU5ldHdvcmtFcnJvcihlcnIpIHx8IGlzUmV0cnlhYmxlSHR0cEVycm9yKGVycikpICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXhSZXRyeVRpbWVvdXQgPT09IDAgfHwgdG90YWxFbGFwc2VkVGltZSA8IG1heFJldHJ5VGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUmV0cmllcysrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBVdGlsLmdldEppdHRlcmVkU2xlZXBUaW1lKG51bVJldHJpZXMsIHNsZWVwLCB0b3RhbEVsYXBzZWRUaW1lLCBtYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBzbGVlcCA9IGppdHRlci5zbGVlcDtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxFbGFwc2VkVGltZSA9IGppdHRlci50b3RhbEVsYXBzZWRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xlZXAgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlYWNoZWQgb3V0IHRvIHRoZSBtYXggTG9naW4gVGltZW91dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aCA9IHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLmdldEF1dGhlbnRpY2F0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dGggaW5zdGFuY2VvZiBBdXRoT2t0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ09LVEEgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgdG9rZW4gcmVmcmVzaC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5T3B0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRWxhcHNlZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtUmV0cmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhdXRoLnJlYXV0aGVudGljYXRlKGNvbnRleHQub3B0aW9ucy5qc29uLCByZXRyeU9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1SZXRyaWVzID0gcmV0cnlPcHRpb24ubnVtUmV0cmllcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRWxhcHNlZFRpbWUgPSByZXRyeU9wdGlvbi50b3RhbEVsYXBzZWRUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF1dGggaW5zdGFuY2VvZiBBdXRoS2V5cGFpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0F1dGhLZXlQYWlyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIHRva2VuIHJlZnJlc2guJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhdXRoLnJlYXV0aGVudGljYXRlKGNvbnRleHQub3B0aW9ucy5qc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCBzbGVlcCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIGFsbCByZXRyaWVzIHRvIFNGLicpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBub3cgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIG5vdyBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZva2UgdGhlIHRyYW5zaXRpb24tY29udGV4dCBjYWxsYmFjayB0aGF0IHdhcyBwYXNzZWQgdG8gdXMgYnkgdGhlXG4gICAgICAgIC8vIFByaXN0aW5lIHN0YXRlIG9uIGNvbm5lY3QoKVxuICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNvbnRleHQub3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5jYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbCBxdWV1ZWQgb3BlcmF0aW9ucyBhcmUgbm93IGZyZWUgdG8gZ29cbiAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UuZHJhaW5PcGVyYXRpb25RdWV1ZSgpO1xuICAgIH07XG4gICAgLy8gaXNzdWUgYSBsb2dpbiByZXF1ZXN0XG4gICAgY29uc3Qgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFVybCA9IGJ1aWxkTG9naW5VcmwoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb250YWN0aW5nIFNGOiAlcywgKCVzLyVzKScsIHRhcmdldFVybCwgbnVtUmV0cmllcywgbWF4TG9naW5SZXRyaWVzKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHBhcmVudC5jcmVhdGVVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsOiB0YXJnZXRVcmwsXG4gICAgICAgICAgICBqc29uOiBqc29uLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMsXG4gICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHJldHJ5OiBudW1SZXRyaWVzLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHJlcXVlc3RDYWxsYmFjayxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH07XG4gICAgc2VuZFJlcXVlc3QoKTtcbn07XG4vKipcbiAqIEJ1aWxkcyB0aGUgdXJsIGZvciBhIGxvZ2luIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb2dpblVybChjb25uZWN0aW9uQ29uZmlnKSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBbXG4gICAgICAgIHsgbmFtZTogJ3dhcmVob3VzZScsIHZhbHVlOiBjb25uZWN0aW9uQ29uZmlnLmdldFdhcmVob3VzZSgpIH0sXG4gICAgICAgIHsgbmFtZTogJ2RhdGFiYXNlTmFtZScsIHZhbHVlOiBjb25uZWN0aW9uQ29uZmlnLmdldERhdGFiYXNlKCkgfSxcbiAgICAgICAgeyBuYW1lOiAnc2NoZW1hTmFtZScsIHZhbHVlOiBjb25uZWN0aW9uQ29uZmlnLmdldFNjaGVtYSgpIH0sXG4gICAgICAgIHsgbmFtZTogJ3JvbGVOYW1lJywgdmFsdWU6IGNvbm5lY3Rpb25Db25maWcuZ2V0Um9sZSgpIH0sXG4gICAgXTtcbiAgICBjb25zdCBxdWVyeVN0cmluZ09iamVjdCA9IHt9O1xuICAgIGlmICghY29ubmVjdGlvbkNvbmZpZy5pc1FhTW9kZSgpKSB7XG4gICAgICAgIC8vIE5vIHJlcXVlc3RJZCBpcyBhdHRhY2hlZCB0byBsb2dpbi1yZXF1ZXN0IGluIHRlc3QgbW9kZS5cbiAgICAgICAgcXVlcnlTdHJpbmdPYmplY3QucmVxdWVzdElkID0gdXVpZHY0KCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gcXVlcnlQYXJhbXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtID0gcXVlcnlQYXJhbXNbaW5kZXhdO1xuICAgICAgICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eShxdWVyeVBhcmFtLnZhbHVlKSkge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmdPYmplY3RbcXVlcnlQYXJhbS5uYW1lXSA9IHF1ZXJ5UGFyYW0udmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVybC5mb3JtYXQoe1xuICAgICAgICBwYXRobmFtZTogJy9zZXNzaW9uL3YxL2xvZ2luLXJlcXVlc3QnLFxuICAgICAgICBzZWFyY2g6IFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShxdWVyeVN0cmluZ09iamVjdCksXG4gICAgfSk7XG59XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGluZy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gZW5xdWV1ZSB0aGUgcmVxdWVzdCBvcGVyYXRpb25cbiAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZW5xdWV1ZVJlcXVlc3Qob3B0aW9ucyk7XG59O1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGVucXVldWUgdGhlIGRlc3Ryb3kgb3BlcmF0aW9uXG4gICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVEZXN0cm95KG9wdGlvbnMpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZUNvbm5lY3RlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIFN0YXRlQ29ubmVjdGVkKCkge1xuICAgIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblV0aWwuaW5oZXJpdHMoU3RhdGVDb25uZWN0ZWQsIFN0YXRlQWJzdHJhY3QpO1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RlZC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQgc28gYW55IGF0dGVtcHRzXG4gICAgLy8gdG8gY29ubmVjdCBzaG91bGQgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX1NUQVRVU19DT05ORUNURUQpKTtcbiAgICB9KTtcbn07XG5TdGF0ZUNvbm5lY3RlZC5wcm90b3R5cGUucmVxdWVzdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBjcmVhdGUgYSBzZXNzaW9uIHRva2VuIHJlcXVlc3QgZnJvbSB0aGUgb3B0aW9ucyBhbmQgc2VuZCBvdXQgdGhlIHJlcXVlc3RcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVTZXNzaW9uVG9rZW5SZXF1ZXN0KG9wdGlvbnMpLnNlbmRBc3luYygpO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0ZWQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHNjb3BlT3JpZyA9IG9wdGlvbnMuc2NvcGU7XG4gICAgY29uc3QgY2FsbGJhY2tPcmlnID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICAvLyBkZWZpbmUgb3VyIG93biBzY29wZSBhbmQgY2FsbGJhY2tcbiAgICBvcHRpb25zLnNjb3BlID0gdGhpcztcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gZXJyb3IsIGludm9rZSB0aGUgY2FsbGJhY2sgaWYgb25lIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2tPcmlnKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrT3JpZy5hcHBseShzY29wZU9yaWcsIFtlcnIsIGJvZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjb3BlIGFuZCBjYWxsYmFjayB0byB0aGUgb3B0aW9ucyBvYmplY3QgYmVjYXVzZVxuICAgICAgICAgICAgLy8gd2UgbWlnaHQgbmVlZCB0byByZXBlYXQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGUgPSBzY29wZU9yaWc7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrID0gY2FsbGJhY2tPcmlnO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHNlc3Npb24gdG9rZW4gaGFzIGV4cGlyZWRcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIHRoZSByZXF1ZXN0IG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS5lbnF1ZXVlUmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHNlc3Npb24gdG9rZW4gcmVuZXdhbCBpc24ndCBhbHJlYWR5IGluIHByb2dyZXNzLCBpc3N1ZSBhXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCB0byByZW5ldyB0aGUgc2Vzc2lvbiB0b2tlblxuICAgICAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9SZW5ld2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyLmNvZGUgPT09IEdTRXJyb3JzLmNvZGUuU0VTU0lPTl9UT0tFTl9JTlZBTElEIHx8XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPT09IEdTRXJyb3JzLmNvZGUuR09ORV9TRVNTSU9OKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNlc3Npb24gdG9rZW4gaXMgaW52YWxpZCBvciBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgLy8gZW5xdWV1ZSB0aGUgcmVxdWVzdCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZW5xdWV1ZVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIC8vIGFsbCBxdWV1ZWQgb3BlcmF0aW9ucyBhcmUgbm93IGZyZWUgdG8gZ29cbiAgICAgICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZHJhaW5PcGVyYXRpb25RdWV1ZSgpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbWVtYmVyIHRoYXQgYSBzZXNzaW9uIHJlbmV3YWwgaXMgbm8gbG9uZ2VyIGluIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBzdXJlIHRoZSBsYXN0IHNlc3Npb24gcmVuZXdhbCBkaWQgbm90IHRpbWUgb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgbm9ybWFsIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIGludm9rZSBpdFxuICAgICAgICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2tPcmlnKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja09yaWcuYXBwbHkoc2NvcGVPcmlnLCBbZXJyLCBib2R5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjcmVhdGUgYSBzZXNzaW9uIHRva2VuIHJlcXVlc3QgZnJvbSB0aGUgb3B0aW9ucyBhbmQgc2VuZCBvdXQgdGhlIHJlcXVlc3RcbiAgICB0aGlzLmNyZWF0ZVNlc3Npb25Ub2tlblJlcXVlc3Qob3B0aW9ucykuc2VuZCgpO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0ZWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHJlcXVlc3RJRCA9IHV1aWR2NCgpO1xuICAgIC8vIHNlbmQgb3V0IGEgc2Vzc2lvbiB0b2tlbiByZXF1ZXN0IHRvIHRlcm1pbmF0ZSB0aGUgY3VycmVudCBjb25uZWN0aW9uXG4gICAgdGhpcy5jcmVhdGVTZXNzaW9uVG9rZW5SZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHVybDogYC9zZXNzaW9uP2RlbGV0ZT10cnVlJnJlcXVlc3RJZD0ke3JlcXVlc3RJRH1gLFxuICAgICAgICBzY29wZTogdGhpcyxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBkZXN0cm95IHJlcXVlc3Qgc3VjY2VlZGVkIG9yIHRoZSBzZXNzaW9uIGFscmVhZHkgZXhwaXJlZCwgd2UncmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBpZiAoIWVyciB8fFxuICAgICAgICAgICAgICAgIGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLkdPTkVfU0VTU0lPTiB8fFxuICAgICAgICAgICAgICAgIGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLlNFU1NJT05fVE9LRU5fRVhQSVJFRCkge1xuICAgICAgICAgICAgICAgIGVyciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnZva2UgdGhlIG9yaWdpbmFsIGNhbGxiYWNrXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVycik7XG4gICAgICAgIH0sXG4gICAgfSkuc2VuZCgpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZVJlbmV3aW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIFN0YXRlUmVuZXdpbmcoKSB7XG4gICAgU3RhdGVBYnN0cmFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuVXRpbC5pbmhlcml0cyhTdGF0ZVJlbmV3aW5nLCBTdGF0ZUFic3RyYWN0KTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2VuZCBvdXQgYSBtYXN0ZXIgdG9rZW4gcmVxdWVzdCB0byByZW5ldyB0aGUgY3VycmVudCBzZXNzaW9uIHRva2VuXG4gICAgdGhpcy5jcmVhdGVNYXN0ZXJUb2tlblJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgdXJsOiAnL3Nlc3Npb24vdG9rZW4tcmVxdWVzdCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIENMSUVOVF9BUFBfSUQ6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRUeXBlKCksXG4gICAgICAgICAgICBDTElFTlRfQVBQX1ZFUlNJT046IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCksXG4gICAgICAgIH0sXG4gICAgICAgIGpzb246IHtcbiAgICAgICAgICAgIFJFUVVFU1RfVFlQRTogJ1JFTkVXJyxcbiAgICAgICAgICAgIG9sZFNlc3Npb25Ub2tlbjogdGhpcy50b2tlbkluZm8uZ2V0U2Vzc2lvblRva2VuKCksXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlOiB0aGlzLFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkXG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdG9rZW4gaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuSW5mby51cGRhdGUoYm9keS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBub3cgY29ubmVjdGVkIGFnYWluXG4gICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG1hc3RlciB0b2tlbiBoYXMgZXhwaXJlZCwgdHJhbnNpdGlvbiB0byB0aGUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEdTRXJyb3JzLmNvZGUuTUFTVEVSX1RPS0VOX0VYUElSRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChFcnJvcnMuaXNOZXR3b3JrRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnbyBiYWNrIHRvIHRoZSBjb25uZWN0ZWQgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlbmV3YWwgZmFpbGVkIGZvciBzb21lIG90aGVyIHJlYXNvbiwgd2UncmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgc2hvdWxkIG91ciBzdGF0ZSBiZSBoZXJlPyBhbHNvIGRpc2Nvbm5lY3RlZD9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsbCBxdWV1ZWQgb3BlcmF0aW9ucyBhcmUgbm93IGZyZWUgdG8gZ29cbiAgICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS5kcmFpbk9wZXJhdGlvblF1ZXVlKCk7XG4gICAgICAgIH0sXG4gICAgfSkuc2VuZCgpO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gd2UncmUgcmVuZXdpbmcgdGhlIHNlc3Npb24gdG9rZW4sIHdoaWNoIG1lYW5zIHdlJ3JlIGNvbm5lY3RlZCxcbiAgICAvLyBzbyBhbnkgYXR0ZW1wdHMgdG8gY29ubmVjdCBzaG91bGQgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX1NUQVRVU19DT05ORUNURUQpKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlUmVuZXdpbmcucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGVucXVldWUgdGhlIHJlcXVlc3Qgb3BlcmF0aW9uXG4gICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVSZXF1ZXN0KG9wdGlvbnMpO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gZW5xdWV1ZSB0aGUgZGVzdHJveSBvcGVyYXRpb25cbiAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZW5xdWV1ZURlc3Ryb3kob3B0aW9ucyk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vICAgICAgICAgICAgICAgIFN0YXRlRGlzY29ubmVjdGVkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gU3RhdGVEaXNjb25uZWN0ZWQoKSB7XG4gICAgU3RhdGVBYnN0cmFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuVXRpbC5pbmhlcml0cyhTdGF0ZURpc2Nvbm5lY3RlZCwgU3RhdGVBYnN0cmFjdCk7XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlRGlzY29ubmVjdGVkLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyB3ZSdyZSBkaXNjb25uZWN0ZWQgLS0gYW5kIGZhdGFsbHkgc28gLS0gc28gYW55XG4gICAgLy8gYXR0ZW1wdHMgdG8gY29ubmVjdCBzaG91bGQgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX1NUQVRVU19ESVNDT05ORUNURUQpKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlRGlzY29ubmVjdGVkLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyB3ZSdyZSBkaXNjb25uZWN0ZWQsIHNvIGFueSBhdHRlbXB0cyB0b1xuICAgIC8vIHNlbmQgYSByZXF1ZXN0IHNob3VsZCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihFcnJvckNvZGVzLkVSUl9DT05OX1JFUVVFU1RfU1RBVFVTX0RJU0NPTk5FQ1RFRCwgdHJ1ZSkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVEaXNjb25uZWN0ZWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIHdlJ3JlIGFscmVhZHkgZGlzY29ubmVjdGVkIHNvIGFueSBhdHRlbXB0c1xuICAgIC8vIHRvIGRlc3Ryb3kgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfRElTQ09OTkVDVEVEKSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgVG9rZW5JbmZvIG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyBhbGwgdG9rZW4tcmVsYXRlZCBpbmZvcm1hdGlvbixcbiAqIGUuZy4gdGhlIG1hc3RlciB0b2tlbiwgdGhlIHNlc3Npb24gdG9rZW4sIHRoZSB0b2tlbnMnIGV4cGlyYXRpb24gdGltZXMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG9rZW5JbmZvKGNvbmZpZykge1xuICAgIGxldCBtYXN0ZXJUb2tlbjtcbiAgICBsZXQgc2Vzc2lvblRva2VuO1xuICAgIGxldCBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lO1xuICAgIGxldCBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICBpZiAoVXRpbC5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgIG1hc3RlclRva2VuID0gY29uZmlnLm1hc3RlclRva2VuO1xuICAgICAgICBzZXNzaW9uVG9rZW4gPSBjb25maWcuc2Vzc2lvblRva2VuO1xuICAgICAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID0gY29uZmlnLm1hc3RlclRva2VuRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lID0gY29uZmlnLnNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgbm8gdG9rZW4tcmVsYXRlZCBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICghVXRpbC5leGlzdHMobWFzdGVyVG9rZW4pIHx8XG4gICAgICAgICAgICAhVXRpbC5leGlzdHMobWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSkgfHxcbiAgICAgICAgICAgICFVdGlsLmV4aXN0cyhzZXNzaW9uVG9rZW4pIHx8XG4gICAgICAgICAgICAhVXRpbC5leGlzdHMoc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgdG9rZW4tcmVsYXRlZCBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyVG9rZW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXN0ZXJUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2Vzc2lvblRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRva2VucyBhbmQgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBtYXN0ZXJUb2tlbiA9IGRhdGEubWFzdGVyVG9rZW47XG4gICAgICAgIHNlc3Npb25Ub2tlbiA9IGRhdGEudG9rZW4gfHwgZGF0YS5zZXNzaW9uVG9rZW47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgPVxuICAgICAgICAgICAgY3VycmVudFRpbWUgKyAxMDAwICogKGRhdGEubWFzdGVyVmFsaWRpdHlJblNlY29uZHMgfHwgZGF0YS52YWxpZGl0eUluU2Vjb25kc01UKTtcbiAgICAgICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPVxuICAgICAgICAgICAgY3VycmVudFRpbWUgKyAxMDAwICogKGRhdGEudmFsaWRpdHlJblNlY29uZHMgfHwgZGF0YS52YWxpZGl0eUluU2Vjb25kc1NUKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hc3RlciB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZXRNYXN0ZXJUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1hc3RlclRva2VuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXhwaXJhdGlvbiB0aW1lIG9mIHRoZSBtYXN0ZXIgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdldFNlc3Npb25Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25Ub2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgc2Vzc2lvbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRTZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgVG9rZW5JbmZvXG4gICAgICogY29uc3RydWN0b3IgdG8gZ2V0IGFuIGVxdWl2YWxlbnQgVG9rZW5JbmZvIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXN0ZXJUb2tlbjogbWFzdGVyVG9rZW4sXG4gICAgICAgICAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lOiBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgc2Vzc2lvblRva2VuOiBzZXNzaW9uVG9rZW4sXG4gICAgICAgICAgICBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTogc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUsXG4gICAgICAgIH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNmLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/services/sf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/snowflake.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/snowflake.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/core.js\");\nconst Util = __importStar(__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\"));\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst clientEnvironment = process.versions;\n// if we're not using the minimum supported version of node.js, raise an error\nconst minimumNodeVersion = '6.0.0';\nif (Util.string.compareVersions(clientEnvironment.node, minimumNodeVersion) < 0) {\n    throw (0, errors_1.createClientError)(errors_1.codes.ERR_UNSUPPORTED_NODE_JS_VERSION, true, minimumNodeVersion);\n}\nmodule.exports = core({\n    httpClientClass: (__webpack_require__(/*! ./http/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/http/node.js\").NodeHttpClient),\n    loggerClass: __webpack_require__(/*! ./logger/node */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger/node.js\"),\n    client: {\n        version: Util.driverVersion,\n        name: Util.driverName,\n        environment: clientEnvironment,\n    },\n});\n//# sourceMappingURL=snowflake.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi9zbm93Zmxha2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1FQUFRO0FBQzdCLDBCQUEwQixtQkFBTyxDQUFDLG1FQUFRO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1IQUFxQztBQUMxRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL3Nub3dmbGFrZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuY29uc3QgVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsXCIpKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgY2xpZW50RW52aXJvbm1lbnQgPSBwcm9jZXNzLnZlcnNpb25zO1xuLy8gaWYgd2UncmUgbm90IHVzaW5nIHRoZSBtaW5pbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIG9mIG5vZGUuanMsIHJhaXNlIGFuIGVycm9yXG5jb25zdCBtaW5pbXVtTm9kZVZlcnNpb24gPSAnNi4wLjAnO1xuaWYgKFV0aWwuc3RyaW5nLmNvbXBhcmVWZXJzaW9ucyhjbGllbnRFbnZpcm9ubWVudC5ub2RlLCBtaW5pbXVtTm9kZVZlcnNpb24pIDwgMCkge1xuICAgIHRocm93ICgwLCBlcnJvcnNfMS5jcmVhdGVDbGllbnRFcnJvcikoZXJyb3JzXzEuY29kZXMuRVJSX1VOU1VQUE9SVEVEX05PREVfSlNfVkVSU0lPTiwgdHJ1ZSwgbWluaW11bU5vZGVWZXJzaW9uKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gY29yZSh7XG4gICAgaHR0cENsaWVudENsYXNzOiByZXF1aXJlKCcuL2h0dHAvbm9kZScpLk5vZGVIdHRwQ2xpZW50LFxuICAgIGxvZ2dlckNsYXNzOiByZXF1aXJlKCcuL2xvZ2dlci9ub2RlJyksXG4gICAgY2xpZW50OiB7XG4gICAgICAgIHZlcnNpb246IFV0aWwuZHJpdmVyVmVyc2lvbixcbiAgICAgICAgbmFtZTogVXRpbC5kcml2ZXJOYW1lLFxuICAgICAgICBlbnZpcm9ubWVudDogY2xpZW50RW52aXJvbm1lbnQsXG4gICAgfSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25vd2ZsYWtlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/snowflake.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/url_util.js":
/*!*********************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/url_util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\");\n/**\n * Determines if a given URL is valid.\n *\n * @param url\n *\n * @returns {Boolean}\n */\nexports.isValidURL = function (url) {\n    const regex = '^http(s?)\\\\:\\\\/\\\\/[0-9a-zA-Z]([-.\\\\w]*[0-9a-zA-Z@:])*(:(0-9)*)*(\\\\/?)([a-zA-Z0-9\\\\-\\\\.\\\\?\\\\,\\\\&\\\\(\\\\)\\\\/\\\\\\\\\\\\+&%\\\\$#_=@]*)?$';\n    if (!url.match(regex)) {\n        Logger.getInstance().debug('The provided URL is not a valid URL. URL: %s', url);\n        return false;\n    }\n    return true;\n};\n/**\n * Encodes the given URL.\n *\n * @param {String} url\n *\n * @returns {String} the encoded URL\n */\nexports.urlEncode = function (url) {\n    /** The encodeURIComponent() method encodes special characters including: , / ? : @ & = + $ #\n       but escapes space as %20B. Replace with + for consistency across drivers. */\n    return encodeURIComponent(url).replace(/%20/g, '+');\n};\n//# sourceMappingURL=url_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi91cmxfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyx1RUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2Rpc3QvbGliL3VybF91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIFVSTCBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdXJsXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBjb25zdCByZWdleCA9ICdeaHR0cChzPylcXFxcOlxcXFwvXFxcXC9bMC05YS16QS1aXShbLS5cXFxcd10qWzAtOWEtekEtWkA6XSkqKDooMC05KSopKihcXFxcLz8pKFthLXpBLVowLTlcXFxcLVxcXFwuXFxcXD9cXFxcLFxcXFwmXFxcXChcXFxcKVxcXFwvXFxcXFxcXFxcXFxcKyYlXFxcXCQjXz1AXSopPyQnO1xuICAgIGlmICghdXJsLm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnVGhlIHByb3ZpZGVkIFVSTCBpcyBub3QgYSB2YWxpZCBVUkwuIFVSTDogJXMnLCB1cmwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gVVJMLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZW5jb2RlZCBVUkxcbiAqL1xuZXhwb3J0cy51cmxFbmNvZGUgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgLyoqIFRoZSBlbmNvZGVVUklDb21wb25lbnQoKSBtZXRob2QgZW5jb2RlcyBzcGVjaWFsIGNoYXJhY3RlcnMgaW5jbHVkaW5nOiAsIC8gPyA6IEAgJiA9ICsgJCAjXG4gICAgICAgYnV0IGVzY2FwZXMgc3BhY2UgYXMgJTIwQi4gUmVwbGFjZSB3aXRoICsgZm9yIGNvbnNpc3RlbmN5IGFjcm9zcyBkcml2ZXJzLiAqL1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodXJsKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxfdXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/url_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/lib/util.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.url = exports.string = exports.number = exports.userAgent = exports.driverVersion = exports.driverName = void 0;\nexports.inherits = inherits;\nexports.format = format;\nexports.isFunction = isFunction;\nexports.isObject = isObject;\nexports.isDate = isDate;\nexports.isArray = isArray;\nexports.isString = isString;\nexports.isBoolean = isBoolean;\nexports.isNumber = isNumber;\nexports.isPrivateKey = isPrivateKey;\nexports.exists = exists;\nexports.apply = apply;\nexports.isBrowser = isBrowser;\nexports.isNode = isNode;\nexports.nextSleepTime = nextSleepTime;\nexports.getJitteredSleepTime = getJitteredSleepTime;\nexports.chooseRandom = chooseRandom;\nexports.getNextSleepTime = getNextSleepTime;\nexports.getJitter = getJitter;\nexports.isLoginRequest = isLoginRequest;\nexports.isRetryableHttpError = isRetryableHttpError;\nexports.validateClientSessionKeepAliveHeartbeatFrequency = validateClientSessionKeepAliveHeartbeatFrequency;\nexports.constructHostname = constructHostname;\nexports.isPrivateLink = isPrivateLink;\nexports.createOcspResponseCacheServerUrl = createOcspResponseCacheServerUrl;\nexports.isPutCommand = isPutCommand;\nexports.isGetCommand = isGetCommand;\nexports.convertSmkIdToString = convertSmkIdToString;\nexports.getCircularReplacer = getCircularReplacer;\nexports.isCorrectSubdomain = isCorrectSubdomain;\nexports.buildCredentialCacheKey = buildCredentialCacheKey;\nexports.checkValidCustomCredentialManager = checkValidCustomCredentialManager;\nexports.checkParametersDefined = checkParametersDefined;\nexports.isFileModeCorrect = isFileModeCorrect;\nexports.isFileNotWritableByGroupOrOthers = isFileNotWritableByGroupOrOthers;\nexports.shouldRetryOktaAuth = shouldRetryOktaAuth;\nexports.getDriverDirectory = getDriverDirectory;\nexports.validatePath = validatePath;\nexports.getEnvVar = getEnvVar;\nexports.validateEmptyString = validateEmptyString;\nexports.isNotEmptyAsString = isNotEmptyAsString;\nexports.isNotEmptyString = isNotEmptyString;\nexports.isEmptyObject = isEmptyObject;\nexports.isWindows = isWindows;\nexports.getFreePort = getFreePort;\nexports.isPortOpen = isPortOpen;\nexports.lstrip = lstrip;\nexports.escapeHTML = escapeHTML;\nexports.dynamicImportESMInTypescriptWithCommonJS = dynamicImportESMInTypescriptWithCommonJS;\nconst util_1 = __importDefault(__webpack_require__(/*! util */ \"util\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst os_1 = __importDefault(__webpack_require__(/*! os */ \"os\"));\nconst Logger = __importStar(__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/logger.js\"));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\n// NOTE: keeping require as it's a circular dependency so * as Errors doesn't work\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/dist/lib/errors.js\");\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst package_json_1 = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/snowflake-sdk/dist/package.json\");\nObject.defineProperty(exports, \"driverName\", ({ enumerable: true, get: function () { return package_json_1.name; } }));\nObject.defineProperty(exports, \"driverVersion\", ({ enumerable: true, get: function () { return package_json_1.version; } }));\nconst nodeJSVersion = process.version?.startsWith('v')\n    ? process.version.substring(1)\n    : process.version;\nexports.userAgent = `JavaScript/${package_json_1.version} (${process.platform}-${process.arch}) NodeJS/${nodeJSVersion}`;\n/**\n * Note: A simple wrapper around util.inherits() for now, but this might change\n * in the future.\n *\n * Inherits the prototype methods from one constructor into another. The\n * prototype of constructor will be set to a new object created from\n * superConstructor.\n *\n * @param constructor\n * @param superConstructor\n *\n * @returns {Object}\n */\nfunction inherits(constructor, superConstructor) {\n    return util_1.default.inherits.apply(util_1.default, [constructor, superConstructor]);\n}\n/**\n * Note: A simple wrapper around util.format() for now, but this will likely\n * change in the future.\n *\n * Returns a formatted string using the first argument as a printf-like format.\n *\n * The first argument is a string that contains zero or more placeholders.\n * Each placeholder is replaced with the converted value from its corresponding\n * argument. Supported placeholders are:\n *   %s - String.\n *   %d - Number (both integer and float).\n *   %j - JSON. Replaced with the string '[Circular]' if the argument contains\n *        circular references.\n *   %% - single percent sign ('%'). This does not consume an argument.\n *\n * If the placeholder does not have a corresponding argument, the placeholder is\n * not replaced.\n *\n * If there are more arguments than placeholders, the extra arguments are\n * coerced to strings (for objects and symbols, util.inspect() is used) and then\n * concatenated, delimited by a space.\n *\n * If the first argument is not a format string then util.format() returns a\n * string that is the concatenation of all its arguments separated by spaces.\n * Each argument is converted to a string with util.inspect().\n */\nfunction format(format, ...params) {\n    return util_1.default.format.apply(util_1.default, [format, ...params]);\n}\n/**\n * Determines if a given value is a function.\n */\nfunction isFunction(value) {\n    return !!value && typeof value === 'function';\n}\nconst toString = Object.prototype.toString;\n/**\n * Determines if a given value is an object.\n */\nfunction isObject(value) {\n    return toString.call(value) === '[object Object]';\n}\n/**\n * Determines if a given value is a Date.\n */\nfunction isDate(value) {\n    return toString.call(value) === '[object Date]';\n}\n/**\n * Determines if a given value is an array.\n */\nfunction isArray(value) {\n    return toString.call(value) === '[object Array]';\n}\n/**\n * Determines if a given value is a string.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\n/**\n * Determines if a given value is a boolean.\n */\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n/**\n * Determines if a given value is a number.\n */\nfunction isNumber(value) {\n    return typeof value === 'number' && isFinite(value);\n}\n/**\n * Determines if a given value is a private key string in pem format of type pkcs8.\n */\nfunction isPrivateKey(value) {\n    const trimmedValue = value.trim();\n    // The private key is expected to be decrypted when set in the connection string\n    // secret scanner complains about first check since it looks like private key, but it's only check\n    // pragma: allowlist nextline secret\n    return (trimmedValue.startsWith('-----BEGIN PRIVATE KEY-----') &&\n        trimmedValue.endsWith('\\n-----END PRIVATE KEY-----'));\n}\n/**\n * A collection of number-related utility functions.\n */\nexports.number = {\n    /**\n     * Determines if a given value is a positive number.\n     */\n    isPositive: function (value) {\n        return isNumber(value) && value > 0;\n    },\n    /**\n     * Determines if a given value is a non-negative number.\n     */\n    isNonNegative: function (value) {\n        return isNumber(value) && value >= 0;\n    },\n    /**\n     * Determines if a given value is an integer.\n     */\n    isInteger: function (value) {\n        return isNumber(value) && Math.floor(value) === value;\n    },\n    /**\n     * Determines if a given value is a positive integer.\n     */\n    isPositiveInteger: function (value) {\n        return this.isInteger(value) && value > 0;\n    },\n    /**\n     * Determines if a given value is a non-negative integer.\n     */\n    isNonNegativeInteger: function (value) {\n        return this.isInteger(value) && value >= 0;\n    },\n};\n/**\n * A collection of string-related utility functions.\n */\nexports.string = {\n    /**\n     * Determines if a given string is not null or empty.\n     */\n    isNotNullOrEmpty: function (value) {\n        return isString(value) && value;\n    },\n    /**\n     * Compares two version numbers of the form 'a.b.c' where a, b and c are\n     * numbers (e.g. '1.0.12'). If one or both inputs are invalid versions, the\n     * function will return NaN, otherwise, it will return -1 if the first\n     * version is smaller, 1 if the first version is bigger, and 0 if the two\n     * versions are equal.\n     */\n    compareVersions: function (version1, version2) {\n        // if one or both inputs are valid, return NaN\n        if (!isString(version1) || !isString(version2)) {\n            return NaN;\n        }\n        // split on dot\n        const version1Parts = version1.split('.');\n        const version2Parts = version2.split('.');\n        // add trailing zeros to make the parts arrays the same length\n        while (version1Parts.length < version2Parts.length) {\n            version1Parts.push('0');\n        }\n        while (version2Parts.length < version1Parts.length) {\n            version2Parts.push('0');\n        }\n        // compare elements in the two arrays one by one\n        let result = 0;\n        let version1Part, version2Part;\n        for (let index = 0, length = version1Parts.length; index < length; index++) {\n            // convert to number before doing any arithmetic\n            version1Part = Number(version1Parts[index]);\n            version2Part = Number(version2Parts[index]);\n            // if one or both values are not numerical, consider the input invalid\n            if (!isNumber(version1Part) || !isNumber(version2Part)) {\n                result = NaN;\n                break;\n            }\n            // if the two values are different, pick the\n            // correct result based on which value is smaller\n            if (version1Part !== version2Part) {\n                result = version1Part < version2Part ? -1 : 1;\n                break;\n            }\n        }\n        return result;\n    },\n};\n/**\n * Determines if a given value is not null or undefined.\n *\n * @deprecated Just use if (!value) instead\n */\nfunction exists(value) {\n    return value !== null && value !== undefined;\n}\n/**\n * A collection of url-related utility functions.\n */\nexports.url = {\n    /**\n     * Appends a query parameter to a url. If an invalid url is specified, an\n     * exception is thrown.\n     *\n     * @param url\n     * @param paramName the name of the query parameter.\n     * @param paramValue the value of the query parameter.\n     */\n    appendParam: function (url, paramName, paramValue) {\n        // if the specified url is valid\n        const urlAsObject = url_1.default.parse(url);\n        if (urlAsObject) {\n            // if the url already has query parameters, use '&' as the separator\n            // when appending the additional query parameter, otherwise use '?'\n            url += (urlAsObject.search ? '&' : '?') + paramName + '=' + paramValue;\n        }\n        return url;\n    },\n    appendRetryParam: function (option) {\n        let retryUrl = this.appendParam(option.url, 'retryCount', option.retryCount);\n        if (option.includeRetryReason) {\n            retryUrl = this.appendParam(retryUrl, 'retryReason', option.retryReason);\n        }\n        return retryUrl;\n    },\n};\n/**\n * Shallow-copies everything from a source object into a destination object.\n *\n * @param {Object} dst the object to copy properties to.\n * @param {Object} src the object to copy properties from.\n */\nfunction apply(dst, src) {\n    // if both dst and src are objects, copy everything from src to dst\n    if (isObject(dst) && isObject(src)) {\n        for (const key in src) {\n            if (Object.prototype.hasOwnProperty.call(src, key)) {\n                dst[key] = src[key];\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Returns true if the code is currently being run in the browser, false\n * otherwise.\n */\nfunction isBrowser() {\n    // @ts-ignore TS2339: Property 'browser' does not exist on type 'Process'\n    return !!(process && false);\n}\n/**\n * Returns true if the code is currently being run in node, false otherwise.\n */\nfunction isNode() {\n    return !isBrowser();\n}\n/**\n * Returns the next sleep time calculated by exponential backoff with\n * decorrelated jitter.\n * sleep = min(cap, random_between(base, sleep * 3))\n * for more details, check out:\n * http://www.awsarchitectureblog.com/2015/03/backoff.html\n * @param base minimum seconds\n * @param cap maximum seconds\n * @param previousSleep previous sleep time\n */\nfunction nextSleepTime(base, cap, previousSleep) {\n    return Math.min(cap, Math.abs(previousSleep * 3 - base) * Math.random() + Math.min(base, previousSleep * 3));\n}\n/**\n * Return next sleep time calculated by the jitter rule.\n */\nfunction getJitteredSleepTime(numofRetries, currentSleepTime, totalElapsedTime, maxRetryTimeout) {\n    const nextsleep = getNextSleepTime(numofRetries, currentSleepTime);\n    const sleep = maxRetryTimeout !== 0 ? Math.min(maxRetryTimeout - totalElapsedTime, nextsleep) : nextsleep;\n    totalElapsedTime += sleep;\n    return { sleep, totalElapsedTime };\n}\n/**\n * Choose one of the number between two numbers.\n */\nfunction chooseRandom(firstNumber, secondNumber) {\n    return Math.random() * (firstNumber - secondNumber) + secondNumber;\n}\n/**\n * return the next sleep Time.\n */\nfunction getNextSleepTime(numofRetries, currentSleepTime) {\n    const nextSleep = 2 ** numofRetries;\n    return chooseRandom(currentSleepTime + getJitter(currentSleepTime), nextSleep + getJitter(currentSleepTime));\n}\n/**\n * return the jitter value.\n */\nfunction getJitter(currentSleepTime) {\n    const multiplicationFactor = chooseRandom(1, -1);\n    return 0.5 * currentSleepTime * multiplicationFactor;\n}\n/**\n * Check whether the request is the login-request or not.\n */\nfunction isLoginRequest(loginUrl) {\n    const endPoints = ['/v1/login-request', '/authenticator-request'];\n    return endPoints.some((endPoint) => loginUrl.includes(endPoint));\n}\n/**\n * Checks if the HTTP response code is retryable\n *\n * @param response HTTP response object\n * @param retry403 will retry HTTP 403?\n */\nfunction isRetryableHttpError(response, retry403) {\n    return (response &&\n        ((response.statusCode >= 500 && response.statusCode < 600) ||\n            (retry403 && response.statusCode === 403) ||\n            response.statusCode === 408 ||\n            response.statusCode === 429));\n}\nfunction validateClientSessionKeepAliveHeartbeatFrequency(input, masterValidity) {\n    let heartbeatFrequency = input;\n    const realMax = Math.floor(masterValidity / 4);\n    const realMin = Math.floor(realMax / 4);\n    if (input > realMax) {\n        heartbeatFrequency = realMax;\n    }\n    else if (input < realMin) {\n        heartbeatFrequency = realMin;\n    }\n    heartbeatFrequency = Math.floor(heartbeatFrequency);\n    return heartbeatFrequency;\n}\n/**\n * Constructs host name using region and account\n *\n * @param region where the account is located\n * @param account which account to connect to\n */\nfunction constructHostname(region, account) {\n    let host;\n    if (region === 'us-west-2') {\n        host = account + '.snowflakecomputing.com';\n    }\n    else if (region != null) {\n        if (account.indexOf('.') > 0) {\n            account = account.substring(0, account.indexOf('.'));\n        }\n        if (region.startsWith('cn-') || region.startsWith('CN-')) {\n            host = account + '.' + region + '.snowflakecomputing.cn';\n        }\n        else {\n            host = account + '.' + region + '.snowflakecomputing.com';\n        }\n    }\n    else {\n        host = account + '.snowflakecomputing.com';\n    }\n    return host;\n}\n/**\n * Returns true if host indicates private link\n */\nfunction isPrivateLink(host) {\n    Errors.checkArgumentExists(exists(host), Errors.codes.ERR_CONN_CREATE_MISSING_HOST);\n    return host.toLowerCase().includes('privatelink.snowflakecomputing.');\n}\nfunction createOcspResponseCacheServerUrl(host) {\n    return `http://ocsp.${host}/ocsp_response_cache.json`;\n}\n/**\n * Returns if command is a PUT command\n */\nfunction isPutCommand(sqlText) {\n    return sqlText.trim().substring(0, 3).toUpperCase() === 'PUT';\n}\n/**\n * Returns if command is a GET command\n */\nfunction isGetCommand(sqlText) {\n    return sqlText.trim().substring(0, 3).toUpperCase() === 'GET';\n}\n/**\n * Add double quotes to smkId's value to parse it as a string instead of integer\n * to preserve precision of numbers exceeding JavaScript's max safe integer\n * e.g (inputting 32621973126123526\toutputs 32621973126123530)\n *\n * @param body the data in JSON\n */\nfunction convertSmkIdToString(body) {\n    return body.replace(/\"smkId\"(\\s*):(\\s*)([0-9]+)/g, '\"smkId\"$1:$2\"$3\"');\n}\n/**\n * Under some circumstances the object passed to JSON.stringify in exception handling\n * can contain circular reference, on which JSON.stringify bails out\n * MDN way of handling such error\n */\nfunction getCircularReplacer() {\n    const ancestors = [];\n    return function (key, value) {\n        if (typeof value !== 'object' || value === null) {\n            return value;\n        }\n        // `this` is the object that value is contained in,\n        // i.e., its direct parent.\n        // @ts-ignore TS2683: 'this' implicitly has type 'any' because it does not have a type annotation.\n        while (ancestors.length > 0 && ancestors[ancestors.length - 1] !== this) {\n            ancestors.pop();\n        }\n        if (ancestors.includes(value)) {\n            return '[Circular]';\n        }\n        ancestors.push(value);\n        return value;\n    };\n}\n/**\n * Returns if the provided string is a valid subdomain.\n */\nfunction isCorrectSubdomain(value) {\n    const subdomainRegex = RegExp(/^\\w+([.-]\\w+)*$/i);\n    return subdomainRegex.test(value);\n}\nfunction buildCredentialCacheKey(host, username, credType) {\n    if (!host || !username || !credType) {\n        Logger.getInstance().debug('Cannot build the credential cache key because one of host, username, and credType is null');\n        return null;\n    }\n    return `{${host.toUpperCase()}}:{${username.toUpperCase()}}:{${credType.toUpperCase()}}`;\n}\nfunction checkValidCustomCredentialManager(customCredentialManager) {\n    if (typeof customCredentialManager !== 'object') {\n        return false;\n    }\n    const requireMethods = ['write', 'read', 'remove'];\n    for (const method of requireMethods) {\n        if (!Object.hasOwnProperty.call(customCredentialManager, method) ||\n            typeof customCredentialManager[method] !== 'function') {\n            return false;\n        }\n    }\n    return true;\n}\nfunction checkParametersDefined(...parameters) {\n    return parameters.every((element) => element !== undefined && element !== null);\n}\n/**\n * Checks if the provided file or directory permissions are correct.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nasync function isFileModeCorrect(filePath, expectedMode, fsPromises) {\n    if (os_1.default.platform() === 'win32') {\n        return true;\n    }\n    return await fsPromises.stat(filePath).then((stats) => {\n        // we have to limit the number of LSB bits to 9 with the mask, as the stats.mode starts with the file type,\n        // e.g. the directory with permissions 755 will have stats.mask of 40755.\n        const mask = (1 << 9) - 1;\n        return (stats.mode & mask) === expectedMode;\n    });\n}\n/**\n * Checks if the provided file or directory is writable only by the user.\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nasync function isFileNotWritableByGroupOrOthers(configFilePath, fsPromises) {\n    if (os_1.default.platform() === 'win32') {\n        return true;\n    }\n    const stats = await fsPromises.stat(configFilePath);\n    return (stats.mode & (1 << 4)) === 0 && (stats.mode & (1 << 1)) === 0;\n}\nfunction shouldRetryOktaAuth({ maxRetryTimeout, maxRetryCount, numRetries, startTime, remainingTimeout, }) {\n    return ((maxRetryTimeout === 0 || Date.now() < startTime + remainingTimeout) &&\n        numRetries <= maxRetryCount);\n}\nfunction getDriverDirectory() {\n    return __dirname;\n}\nfunction validatePath(dir) {\n    try {\n        const stat = fs_1.default.statSync(dir);\n        return stat.isDirectory();\n    }\n    catch {\n        Logger.getInstance().error('The location is invalid. Please check this location is accessible or existing');\n        return false;\n    }\n}\nfunction getEnvVar(variable) {\n    return process.env[variable.toLowerCase()] || process.env[variable.toUpperCase()];\n}\nfunction validateEmptyString(value) {\n    return value !== '' ? value : undefined;\n}\nfunction isNotEmptyAsString(variable) {\n    if (typeof variable === 'string') {\n        return variable;\n    }\n    return exists(variable);\n}\nfunction isNotEmptyString(variable) {\n    return exists(variable) && variable !== '';\n}\n/**\n * Checks Whether the object is empty (can be null or undefined) or not.\n */\nfunction isEmptyObject(object) {\n    if (!exists(object)) {\n        return true;\n    }\n    if (typeof object !== 'object') {\n        return false;\n    }\n    return Object.keys(object).length === 0;\n}\nfunction isWindows() {\n    return os_1.default.platform() === 'win32';\n}\nasync function getFreePort() {\n    return new Promise((res) => {\n        const srv = net_1.default.createServer();\n        srv.listen(0, () => {\n            // @ts-ignore TS2339: Property 'port' does not exist on type 'string | AddressInfo'\n            const port = srv.address().port;\n            srv.close(() => res(port));\n        });\n    });\n}\nasync function isPortOpen(port) {\n    return new Promise((resolve, reject) => {\n        const s = net_1.default.createServer();\n        s.once('error', (err) => {\n            s.close();\n            if (err['code'] === 'EADDRINUSE') {\n                Logger.getInstance().trace(`Port: ${port} is not available. Verification failed`);\n                reject('Port not available.');\n            }\n            else {\n                Logger.getInstance().trace(`There is unexpected error during verification of port availability. Port: ${port}. Error: ${JSON.stringify(err)}`);\n            }\n        });\n        s.once('listening', () => {\n            s.close();\n            Logger.getInstance().trace(`Closing server run for verification whether the port is available. Port: ${port}`);\n            resolve('Listening');\n        });\n        s.listen(port);\n    });\n}\n/**\n * Left strip the specified character from a string.\n */\nfunction lstrip(str, remove) {\n    while (str.length > 0 && remove.indexOf(str.charAt(0)) !== -1) {\n        str = str.substr(1);\n    }\n    return str;\n}\n/**\n * This method transforms HTML special characters into their corresponding entity representations.\n */\nfunction escapeHTML(value) {\n    if (!exists(value)) {\n        return value;\n    }\n    return value\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n/**\n * Typescript with \"module\": \"commonjs\" will transform every import() to a require() statement.\n *\n * This will break ESM dynamic imports resulting in a runtime error:\n * -require() of ES Module... from ... not supported.\n *\n * A hacky solution - https://github.com/microsoft/TypeScript/issues/43329\n *\n * This could be removed once we drop node 18 support as Node 20+ support esm in require()\n */\nasync function dynamicImportESMInTypescriptWithCommonJS(moduleName) {\n    return Function(`return import(\"${moduleName}\")`)();\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9kaXN0L2xpYi91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCO0FBQzlHLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2QsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLHdEQUF3RDtBQUN4RCx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHdDQUF3QztBQUN4QyxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qix3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGdEQUFnRDtBQUNoRCwrQkFBK0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQyw2QkFBNkIsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pDLDRCQUE0QixtQkFBTyxDQUFDLHVFQUFVO0FBQzlDLDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekM7QUFDQSxlQUFlLG1CQUFPLENBQUMsdUVBQVU7QUFDakMsOEJBQThCLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsNkVBQWlCO0FBQ2hELDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxpREFBZ0QsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQix3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLFdBQVcsY0FBYztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxFQUFFLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEVBQTBFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILEtBQUssV0FBVyxvQkFBb0I7QUFDNUo7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1IQUFtSCxLQUFLO0FBQ3hIO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvZGlzdC9saWIvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51cmwgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy51c2VyQWdlbnQgPSBleHBvcnRzLmRyaXZlclZlcnNpb24gPSBleHBvcnRzLmRyaXZlck5hbWUgPSB2b2lkIDA7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNQcml2YXRlS2V5ID0gaXNQcml2YXRlS2V5O1xuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuaXNOb2RlID0gaXNOb2RlO1xuZXhwb3J0cy5uZXh0U2xlZXBUaW1lID0gbmV4dFNsZWVwVGltZTtcbmV4cG9ydHMuZ2V0Sml0dGVyZWRTbGVlcFRpbWUgPSBnZXRKaXR0ZXJlZFNsZWVwVGltZTtcbmV4cG9ydHMuY2hvb3NlUmFuZG9tID0gY2hvb3NlUmFuZG9tO1xuZXhwb3J0cy5nZXROZXh0U2xlZXBUaW1lID0gZ2V0TmV4dFNsZWVwVGltZTtcbmV4cG9ydHMuZ2V0Sml0dGVyID0gZ2V0Sml0dGVyO1xuZXhwb3J0cy5pc0xvZ2luUmVxdWVzdCA9IGlzTG9naW5SZXF1ZXN0O1xuZXhwb3J0cy5pc1JldHJ5YWJsZUh0dHBFcnJvciA9IGlzUmV0cnlhYmxlSHR0cEVycm9yO1xuZXhwb3J0cy52YWxpZGF0ZUNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kgPSB2YWxpZGF0ZUNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3k7XG5leHBvcnRzLmNvbnN0cnVjdEhvc3RuYW1lID0gY29uc3RydWN0SG9zdG5hbWU7XG5leHBvcnRzLmlzUHJpdmF0ZUxpbmsgPSBpc1ByaXZhdGVMaW5rO1xuZXhwb3J0cy5jcmVhdGVPY3NwUmVzcG9uc2VDYWNoZVNlcnZlclVybCA9IGNyZWF0ZU9jc3BSZXNwb25zZUNhY2hlU2VydmVyVXJsO1xuZXhwb3J0cy5pc1B1dENvbW1hbmQgPSBpc1B1dENvbW1hbmQ7XG5leHBvcnRzLmlzR2V0Q29tbWFuZCA9IGlzR2V0Q29tbWFuZDtcbmV4cG9ydHMuY29udmVydFNta0lkVG9TdHJpbmcgPSBjb252ZXJ0U21rSWRUb1N0cmluZztcbmV4cG9ydHMuZ2V0Q2lyY3VsYXJSZXBsYWNlciA9IGdldENpcmN1bGFyUmVwbGFjZXI7XG5leHBvcnRzLmlzQ29ycmVjdFN1YmRvbWFpbiA9IGlzQ29ycmVjdFN1YmRvbWFpbjtcbmV4cG9ydHMuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkgPSBidWlsZENyZWRlbnRpYWxDYWNoZUtleTtcbmV4cG9ydHMuY2hlY2tWYWxpZEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyID0gY2hlY2tWYWxpZEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyO1xuZXhwb3J0cy5jaGVja1BhcmFtZXRlcnNEZWZpbmVkID0gY2hlY2tQYXJhbWV0ZXJzRGVmaW5lZDtcbmV4cG9ydHMuaXNGaWxlTW9kZUNvcnJlY3QgPSBpc0ZpbGVNb2RlQ29ycmVjdDtcbmV4cG9ydHMuaXNGaWxlTm90V3JpdGFibGVCeUdyb3VwT3JPdGhlcnMgPSBpc0ZpbGVOb3RXcml0YWJsZUJ5R3JvdXBPck90aGVycztcbmV4cG9ydHMuc2hvdWxkUmV0cnlPa3RhQXV0aCA9IHNob3VsZFJldHJ5T2t0YUF1dGg7XG5leHBvcnRzLmdldERyaXZlckRpcmVjdG9yeSA9IGdldERyaXZlckRpcmVjdG9yeTtcbmV4cG9ydHMudmFsaWRhdGVQYXRoID0gdmFsaWRhdGVQYXRoO1xuZXhwb3J0cy5nZXRFbnZWYXIgPSBnZXRFbnZWYXI7XG5leHBvcnRzLnZhbGlkYXRlRW1wdHlTdHJpbmcgPSB2YWxpZGF0ZUVtcHR5U3RyaW5nO1xuZXhwb3J0cy5pc05vdEVtcHR5QXNTdHJpbmcgPSBpc05vdEVtcHR5QXNTdHJpbmc7XG5leHBvcnRzLmlzTm90RW1wdHlTdHJpbmcgPSBpc05vdEVtcHR5U3RyaW5nO1xuZXhwb3J0cy5pc0VtcHR5T2JqZWN0ID0gaXNFbXB0eU9iamVjdDtcbmV4cG9ydHMuaXNXaW5kb3dzID0gaXNXaW5kb3dzO1xuZXhwb3J0cy5nZXRGcmVlUG9ydCA9IGdldEZyZWVQb3J0O1xuZXhwb3J0cy5pc1BvcnRPcGVuID0gaXNQb3J0T3BlbjtcbmV4cG9ydHMubHN0cmlwID0gbHN0cmlwO1xuZXhwb3J0cy5lc2NhcGVIVE1MID0gZXNjYXBlSFRNTDtcbmV4cG9ydHMuZHluYW1pY0ltcG9ydEVTTUluVHlwZXNjcmlwdFdpdGhDb21tb25KUyA9IGR5bmFtaWNJbXBvcnRFU01JblR5cGVzY3JpcHRXaXRoQ29tbW9uSlM7XG5jb25zdCB1dGlsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInV0aWxcIikpO1xuY29uc3QgdXJsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybFwiKSk7XG5jb25zdCBvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJvc1wiKSk7XG5jb25zdCBMb2dnZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2VyXCIpKTtcbmNvbnN0IGZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZzXCIpKTtcbi8vIE5PVEU6IGtlZXBpbmcgcmVxdWlyZSBhcyBpdCdzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBzbyAqIGFzIEVycm9ycyBkb2Vzbid0IHdvcmtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBuZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IHBhY2thZ2VfanNvbl8xID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRyaXZlck5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhY2thZ2VfanNvbl8xLm5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkcml2ZXJWZXJzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uOyB9IH0pO1xuY29uc3Qgbm9kZUpTVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbj8uc3RhcnRzV2l0aCgndicpXG4gICAgPyBwcm9jZXNzLnZlcnNpb24uc3Vic3RyaW5nKDEpXG4gICAgOiBwcm9jZXNzLnZlcnNpb247XG5leHBvcnRzLnVzZXJBZ2VudCA9IGBKYXZhU2NyaXB0LyR7cGFja2FnZV9qc29uXzEudmVyc2lvbn0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX0tJHtwcm9jZXNzLmFyY2h9KSBOb2RlSlMvJHtub2RlSlNWZXJzaW9ufWA7XG4vKipcbiAqIE5vdGU6IEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHV0aWwuaW5oZXJpdHMoKSBmb3Igbm93LCBidXQgdGhpcyBtaWdodCBjaGFuZ2VcbiAqIGluIHRoZSBmdXR1cmUuXG4gKlxuICogSW5oZXJpdHMgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci4gVGhlXG4gKiBwcm90b3R5cGUgb2YgY29uc3RydWN0b3Igd2lsbCBiZSBzZXQgdG8gYSBuZXcgb2JqZWN0IGNyZWF0ZWQgZnJvbVxuICogc3VwZXJDb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSBzdXBlckNvbnN0cnVjdG9yXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdHMoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdXRpbF8xLmRlZmF1bHQuaW5oZXJpdHMuYXBwbHkodXRpbF8xLmRlZmF1bHQsIFtjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcl0pO1xufVxuLyoqXG4gKiBOb3RlOiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB1dGlsLmZvcm1hdCgpIGZvciBub3csIGJ1dCB0aGlzIHdpbGwgbGlrZWx5XG4gKiBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyB1c2luZyB0aGUgZmlyc3QgYXJndW1lbnQgYXMgYSBwcmludGYtbGlrZSBmb3JtYXQuXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgemVybyBvciBtb3JlIHBsYWNlaG9sZGVycy5cbiAqIEVhY2ggcGxhY2Vob2xkZXIgaXMgcmVwbGFjZWQgd2l0aCB0aGUgY29udmVydGVkIHZhbHVlIGZyb20gaXRzIGNvcnJlc3BvbmRpbmdcbiAqIGFyZ3VtZW50LiBTdXBwb3J0ZWQgcGxhY2Vob2xkZXJzIGFyZTpcbiAqICAgJXMgLSBTdHJpbmcuXG4gKiAgICVkIC0gTnVtYmVyIChib3RoIGludGVnZXIgYW5kIGZsb2F0KS5cbiAqICAgJWogLSBKU09OLiBSZXBsYWNlZCB3aXRoIHRoZSBzdHJpbmcgJ1tDaXJjdWxhcl0nIGlmIHRoZSBhcmd1bWVudCBjb250YWluc1xuICogICAgICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKiAgICUlIC0gc2luZ2xlIHBlcmNlbnQgc2lnbiAoJyUnKS4gVGhpcyBkb2VzIG5vdCBjb25zdW1lIGFuIGFyZ3VtZW50LlxuICpcbiAqIElmIHRoZSBwbGFjZWhvbGRlciBkb2VzIG5vdCBoYXZlIGEgY29ycmVzcG9uZGluZyBhcmd1bWVudCwgdGhlIHBsYWNlaG9sZGVyIGlzXG4gKiBub3QgcmVwbGFjZWQuXG4gKlxuICogSWYgdGhlcmUgYXJlIG1vcmUgYXJndW1lbnRzIHRoYW4gcGxhY2Vob2xkZXJzLCB0aGUgZXh0cmEgYXJndW1lbnRzIGFyZVxuICogY29lcmNlZCB0byBzdHJpbmdzIChmb3Igb2JqZWN0cyBhbmQgc3ltYm9scywgdXRpbC5pbnNwZWN0KCkgaXMgdXNlZCkgYW5kIHRoZW5cbiAqIGNvbmNhdGVuYXRlZCwgZGVsaW1pdGVkIGJ5IGEgc3BhY2UuXG4gKlxuICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhIGZvcm1hdCBzdHJpbmcgdGhlbiB1dGlsLmZvcm1hdCgpIHJldHVybnMgYVxuICogc3RyaW5nIHRoYXQgaXMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGl0cyBhcmd1bWVudHMgc2VwYXJhdGVkIGJ5IHNwYWNlcy5cbiAqIEVhY2ggYXJndW1lbnQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIHdpdGggdXRpbC5pbnNwZWN0KCkuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChmb3JtYXQsIC4uLnBhcmFtcykge1xuICAgIHJldHVybiB1dGlsXzEuZGVmYXVsdC5mb3JtYXQuYXBwbHkodXRpbF8xLmRlZmF1bHQsIFtmb3JtYXQsIC4uLnBhcmFtc10pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBEYXRlLlxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgcHJpdmF0ZSBrZXkgc3RyaW5nIGluIHBlbSBmb3JtYXQgb2YgdHlwZSBwa2NzOC5cbiAqL1xuZnVuY3Rpb24gaXNQcml2YXRlS2V5KHZhbHVlKSB7XG4gICAgY29uc3QgdHJpbW1lZFZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIC8vIFRoZSBwcml2YXRlIGtleSBpcyBleHBlY3RlZCB0byBiZSBkZWNyeXB0ZWQgd2hlbiBzZXQgaW4gdGhlIGNvbm5lY3Rpb24gc3RyaW5nXG4gICAgLy8gc2VjcmV0IHNjYW5uZXIgY29tcGxhaW5zIGFib3V0IGZpcnN0IGNoZWNrIHNpbmNlIGl0IGxvb2tzIGxpa2UgcHJpdmF0ZSBrZXksIGJ1dCBpdCdzIG9ubHkgY2hlY2tcbiAgICAvLyBwcmFnbWE6IGFsbG93bGlzdCBuZXh0bGluZSBzZWNyZXRcbiAgICByZXR1cm4gKHRyaW1tZWRWYWx1ZS5zdGFydHNXaXRoKCctLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS0nKSAmJlxuICAgICAgICB0cmltbWVkVmFsdWUuZW5kc1dpdGgoJ1xcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0nKSk7XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBudW1iZXItcmVsYXRlZCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0cy5udW1iZXIgPSB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgcG9zaXRpdmUgbnVtYmVyLlxuICAgICAqL1xuICAgIGlzUG9zaXRpdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlID4gMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gICAgICovXG4gICAgaXNOb25OZWdhdGl2ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGlzSW50ZWdlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAgICAgKi9cbiAgICBpc1Bvc2l0aXZlSW50ZWdlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPiAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gICAgICovXG4gICAgaXNOb25OZWdhdGl2ZUludGVnZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG4gICAgfSxcbn07XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBzdHJpbmctcmVsYXRlZCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0cy5zdHJpbmcgPSB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBub3QgbnVsbCBvciBlbXB0eS5cbiAgICAgKi9cbiAgICBpc05vdE51bGxPckVtcHR5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byB2ZXJzaW9uIG51bWJlcnMgb2YgdGhlIGZvcm0gJ2EuYi5jJyB3aGVyZSBhLCBiIGFuZCBjIGFyZVxuICAgICAqIG51bWJlcnMgKGUuZy4gJzEuMC4xMicpLiBJZiBvbmUgb3IgYm90aCBpbnB1dHMgYXJlIGludmFsaWQgdmVyc2lvbnMsIHRoZVxuICAgICAqIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIE5hTiwgb3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiAtMSBpZiB0aGUgZmlyc3RcbiAgICAgKiB2ZXJzaW9uIGlzIHNtYWxsZXIsIDEgaWYgdGhlIGZpcnN0IHZlcnNpb24gaXMgYmlnZ2VyLCBhbmQgMCBpZiB0aGUgdHdvXG4gICAgICogdmVyc2lvbnMgYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIGNvbXBhcmVWZXJzaW9uczogZnVuY3Rpb24gKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICAgICAgICAvLyBpZiBvbmUgb3IgYm90aCBpbnB1dHMgYXJlIHZhbGlkLCByZXR1cm4gTmFOXG4gICAgICAgIGlmICghaXNTdHJpbmcodmVyc2lvbjEpIHx8ICFpc1N0cmluZyh2ZXJzaW9uMikpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BsaXQgb24gZG90XG4gICAgICAgIGNvbnN0IHZlcnNpb24xUGFydHMgPSB2ZXJzaW9uMS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uMlBhcnRzID0gdmVyc2lvbjIuc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gYWRkIHRyYWlsaW5nIHplcm9zIHRvIG1ha2UgdGhlIHBhcnRzIGFycmF5cyB0aGUgc2FtZSBsZW5ndGhcbiAgICAgICAgd2hpbGUgKHZlcnNpb24xUGFydHMubGVuZ3RoIDwgdmVyc2lvbjJQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZlcnNpb24xUGFydHMucHVzaCgnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh2ZXJzaW9uMlBhcnRzLmxlbmd0aCA8IHZlcnNpb24xUGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2ZXJzaW9uMlBhcnRzLnB1c2goJzAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wYXJlIGVsZW1lbnRzIGluIHRoZSB0d28gYXJyYXlzIG9uZSBieSBvbmVcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGxldCB2ZXJzaW9uMVBhcnQsIHZlcnNpb24yUGFydDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSB2ZXJzaW9uMVBhcnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gbnVtYmVyIGJlZm9yZSBkb2luZyBhbnkgYXJpdGhtZXRpY1xuICAgICAgICAgICAgdmVyc2lvbjFQYXJ0ID0gTnVtYmVyKHZlcnNpb24xUGFydHNbaW5kZXhdKTtcbiAgICAgICAgICAgIHZlcnNpb24yUGFydCA9IE51bWJlcih2ZXJzaW9uMlBhcnRzW2luZGV4XSk7XG4gICAgICAgICAgICAvLyBpZiBvbmUgb3IgYm90aCB2YWx1ZXMgYXJlIG5vdCBudW1lcmljYWwsIGNvbnNpZGVyIHRoZSBpbnB1dCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZlcnNpb24xUGFydCkgfHwgIWlzTnVtYmVyKHZlcnNpb24yUGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOYU47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgdHdvIHZhbHVlcyBhcmUgZGlmZmVyZW50LCBwaWNrIHRoZVxuICAgICAgICAgICAgLy8gY29ycmVjdCByZXN1bHQgYmFzZWQgb24gd2hpY2ggdmFsdWUgaXMgc21hbGxlclxuICAgICAgICAgICAgaWYgKHZlcnNpb24xUGFydCAhPT0gdmVyc2lvbjJQYXJ0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmVyc2lvbjFQYXJ0IDwgdmVyc2lvbjJQYXJ0ID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgSnVzdCB1c2UgaWYgKCF2YWx1ZSkgaW5zdGVhZFxuICovXG5mdW5jdGlvbiBleGlzdHModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHVybC1yZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5leHBvcnRzLnVybCA9IHtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcXVlcnkgcGFyYW1ldGVyIHRvIGEgdXJsLiBJZiBhbiBpbnZhbGlkIHVybCBpcyBzcGVjaWZpZWQsIGFuXG4gICAgICogZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKiBAcGFyYW0gcGFyYW1OYW1lIHRoZSBuYW1lIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHBhcmFtVmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgYXBwZW5kUGFyYW06IGZ1bmN0aW9uICh1cmwsIHBhcmFtTmFtZSwgcGFyYW1WYWx1ZSkge1xuICAgICAgICAvLyBpZiB0aGUgc3BlY2lmaWVkIHVybCBpcyB2YWxpZFxuICAgICAgICBjb25zdCB1cmxBc09iamVjdCA9IHVybF8xLmRlZmF1bHQucGFyc2UodXJsKTtcbiAgICAgICAgaWYgKHVybEFzT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdXJsIGFscmVhZHkgaGFzIHF1ZXJ5IHBhcmFtZXRlcnMsIHVzZSAnJicgYXMgdGhlIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gd2hlbiBhcHBlbmRpbmcgdGhlIGFkZGl0aW9uYWwgcXVlcnkgcGFyYW1ldGVyLCBvdGhlcndpc2UgdXNlICc/J1xuICAgICAgICAgICAgdXJsICs9ICh1cmxBc09iamVjdC5zZWFyY2ggPyAnJicgOiAnPycpICsgcGFyYW1OYW1lICsgJz0nICsgcGFyYW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0sXG4gICAgYXBwZW5kUmV0cnlQYXJhbTogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBsZXQgcmV0cnlVcmwgPSB0aGlzLmFwcGVuZFBhcmFtKG9wdGlvbi51cmwsICdyZXRyeUNvdW50Jywgb3B0aW9uLnJldHJ5Q291bnQpO1xuICAgICAgICBpZiAob3B0aW9uLmluY2x1ZGVSZXRyeVJlYXNvbikge1xuICAgICAgICAgICAgcmV0cnlVcmwgPSB0aGlzLmFwcGVuZFBhcmFtKHJldHJ5VXJsLCAncmV0cnlSZWFzb24nLCBvcHRpb24ucmV0cnlSZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRyeVVybDtcbiAgICB9LFxufTtcbi8qKlxuICogU2hhbGxvdy1jb3BpZXMgZXZlcnl0aGluZyBmcm9tIGEgc291cmNlIG9iamVjdCBpbnRvIGEgZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkc3QgdGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjIHRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGRzdCwgc3JjKSB7XG4gICAgLy8gaWYgYm90aCBkc3QgYW5kIHNyYyBhcmUgb2JqZWN0cywgY29weSBldmVyeXRoaW5nIGZyb20gc3JjIHRvIGRzdFxuICAgIGlmIChpc09iamVjdChkc3QpICYmIGlzT2JqZWN0KHNyYykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywga2V5KSkge1xuICAgICAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2RlIGlzIGN1cnJlbnRseSBiZWluZyBydW4gaW4gdGhlIGJyb3dzZXIsIGZhbHNlXG4gKiBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICAvLyBAdHMtaWdub3JlIFRTMjMzOTogUHJvcGVydHkgJ2Jyb3dzZXInIGRvZXMgbm90IGV4aXN0IG9uIHR5cGUgJ1Byb2Nlc3MnXG4gICAgcmV0dXJuICEhKHByb2Nlc3MgJiYgcHJvY2Vzcy5icm93c2VyKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2RlIGlzIGN1cnJlbnRseSBiZWluZyBydW4gaW4gbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgcmV0dXJuICFpc0Jyb3dzZXIoKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBzbGVlcCB0aW1lIGNhbGN1bGF0ZWQgYnkgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoXG4gKiBkZWNvcnJlbGF0ZWQgaml0dGVyLlxuICogc2xlZXAgPSBtaW4oY2FwLCByYW5kb21fYmV0d2VlbihiYXNlLCBzbGVlcCAqIDMpKVxuICogZm9yIG1vcmUgZGV0YWlscywgY2hlY2sgb3V0OlxuICogaHR0cDovL3d3dy5hd3NhcmNoaXRlY3R1cmVibG9nLmNvbS8yMDE1LzAzL2JhY2tvZmYuaHRtbFxuICogQHBhcmFtIGJhc2UgbWluaW11bSBzZWNvbmRzXG4gKiBAcGFyYW0gY2FwIG1heGltdW0gc2Vjb25kc1xuICogQHBhcmFtIHByZXZpb3VzU2xlZXAgcHJldmlvdXMgc2xlZXAgdGltZVxuICovXG5mdW5jdGlvbiBuZXh0U2xlZXBUaW1lKGJhc2UsIGNhcCwgcHJldmlvdXNTbGVlcCkge1xuICAgIHJldHVybiBNYXRoLm1pbihjYXAsIE1hdGguYWJzKHByZXZpb3VzU2xlZXAgKiAzIC0gYmFzZSkgKiBNYXRoLnJhbmRvbSgpICsgTWF0aC5taW4oYmFzZSwgcHJldmlvdXNTbGVlcCAqIDMpKTtcbn1cbi8qKlxuICogUmV0dXJuIG5leHQgc2xlZXAgdGltZSBjYWxjdWxhdGVkIGJ5IHRoZSBqaXR0ZXIgcnVsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Sml0dGVyZWRTbGVlcFRpbWUobnVtb2ZSZXRyaWVzLCBjdXJyZW50U2xlZXBUaW1lLCB0b3RhbEVsYXBzZWRUaW1lLCBtYXhSZXRyeVRpbWVvdXQpIHtcbiAgICBjb25zdCBuZXh0c2xlZXAgPSBnZXROZXh0U2xlZXBUaW1lKG51bW9mUmV0cmllcywgY3VycmVudFNsZWVwVGltZSk7XG4gICAgY29uc3Qgc2xlZXAgPSBtYXhSZXRyeVRpbWVvdXQgIT09IDAgPyBNYXRoLm1pbihtYXhSZXRyeVRpbWVvdXQgLSB0b3RhbEVsYXBzZWRUaW1lLCBuZXh0c2xlZXApIDogbmV4dHNsZWVwO1xuICAgIHRvdGFsRWxhcHNlZFRpbWUgKz0gc2xlZXA7XG4gICAgcmV0dXJuIHsgc2xlZXAsIHRvdGFsRWxhcHNlZFRpbWUgfTtcbn1cbi8qKlxuICogQ2hvb3NlIG9uZSBvZiB0aGUgbnVtYmVyIGJldHdlZW4gdHdvIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGNob29zZVJhbmRvbShmaXJzdE51bWJlciwgc2Vjb25kTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoZmlyc3ROdW1iZXIgLSBzZWNvbmROdW1iZXIpICsgc2Vjb25kTnVtYmVyO1xufVxuLyoqXG4gKiByZXR1cm4gdGhlIG5leHQgc2xlZXAgVGltZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dFNsZWVwVGltZShudW1vZlJldHJpZXMsIGN1cnJlbnRTbGVlcFRpbWUpIHtcbiAgICBjb25zdCBuZXh0U2xlZXAgPSAyICoqIG51bW9mUmV0cmllcztcbiAgICByZXR1cm4gY2hvb3NlUmFuZG9tKGN1cnJlbnRTbGVlcFRpbWUgKyBnZXRKaXR0ZXIoY3VycmVudFNsZWVwVGltZSksIG5leHRTbGVlcCArIGdldEppdHRlcihjdXJyZW50U2xlZXBUaW1lKSk7XG59XG4vKipcbiAqIHJldHVybiB0aGUgaml0dGVyIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRKaXR0ZXIoY3VycmVudFNsZWVwVGltZSkge1xuICAgIGNvbnN0IG11bHRpcGxpY2F0aW9uRmFjdG9yID0gY2hvb3NlUmFuZG9tKDEsIC0xKTtcbiAgICByZXR1cm4gMC41ICogY3VycmVudFNsZWVwVGltZSAqIG11bHRpcGxpY2F0aW9uRmFjdG9yO1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSByZXF1ZXN0IGlzIHRoZSBsb2dpbi1yZXF1ZXN0IG9yIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNMb2dpblJlcXVlc3QobG9naW5VcmwpIHtcbiAgICBjb25zdCBlbmRQb2ludHMgPSBbJy92MS9sb2dpbi1yZXF1ZXN0JywgJy9hdXRoZW50aWNhdG9yLXJlcXVlc3QnXTtcbiAgICByZXR1cm4gZW5kUG9pbnRzLnNvbWUoKGVuZFBvaW50KSA9PiBsb2dpblVybC5pbmNsdWRlcyhlbmRQb2ludCkpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIEhUVFAgcmVzcG9uc2UgY29kZSBpcyByZXRyeWFibGVcbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgSFRUUCByZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSByZXRyeTQwMyB3aWxsIHJldHJ5IEhUVFAgNDAzP1xuICovXG5mdW5jdGlvbiBpc1JldHJ5YWJsZUh0dHBFcnJvcihyZXNwb25zZSwgcmV0cnk0MDMpIHtcbiAgICByZXR1cm4gKHJlc3BvbnNlICYmXG4gICAgICAgICgocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA1MDAgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDYwMCkgfHxcbiAgICAgICAgICAgIChyZXRyeTQwMyAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDMpIHx8XG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDggfHxcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KGlucHV0LCBtYXN0ZXJWYWxpZGl0eSkge1xuICAgIGxldCBoZWFydGJlYXRGcmVxdWVuY3kgPSBpbnB1dDtcbiAgICBjb25zdCByZWFsTWF4ID0gTWF0aC5mbG9vcihtYXN0ZXJWYWxpZGl0eSAvIDQpO1xuICAgIGNvbnN0IHJlYWxNaW4gPSBNYXRoLmZsb29yKHJlYWxNYXggLyA0KTtcbiAgICBpZiAoaW5wdXQgPiByZWFsTWF4KSB7XG4gICAgICAgIGhlYXJ0YmVhdEZyZXF1ZW5jeSA9IHJlYWxNYXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IDwgcmVhbE1pbikge1xuICAgICAgICBoZWFydGJlYXRGcmVxdWVuY3kgPSByZWFsTWluO1xuICAgIH1cbiAgICBoZWFydGJlYXRGcmVxdWVuY3kgPSBNYXRoLmZsb29yKGhlYXJ0YmVhdEZyZXF1ZW5jeSk7XG4gICAgcmV0dXJuIGhlYXJ0YmVhdEZyZXF1ZW5jeTtcbn1cbi8qKlxuICogQ29uc3RydWN0cyBob3N0IG5hbWUgdXNpbmcgcmVnaW9uIGFuZCBhY2NvdW50XG4gKlxuICogQHBhcmFtIHJlZ2lvbiB3aGVyZSB0aGUgYWNjb3VudCBpcyBsb2NhdGVkXG4gKiBAcGFyYW0gYWNjb3VudCB3aGljaCBhY2NvdW50IHRvIGNvbm5lY3QgdG9cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0SG9zdG5hbWUocmVnaW9uLCBhY2NvdW50KSB7XG4gICAgbGV0IGhvc3Q7XG4gICAgaWYgKHJlZ2lvbiA9PT0gJ3VzLXdlc3QtMicpIHtcbiAgICAgICAgaG9zdCA9IGFjY291bnQgKyAnLnNub3dmbGFrZWNvbXB1dGluZy5jb20nO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWdpb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAoYWNjb3VudC5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgICAgICBhY2NvdW50ID0gYWNjb3VudC5zdWJzdHJpbmcoMCwgYWNjb3VudC5pbmRleE9mKCcuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpb24uc3RhcnRzV2l0aCgnY24tJykgfHwgcmVnaW9uLnN0YXJ0c1dpdGgoJ0NOLScpKSB7XG4gICAgICAgICAgICBob3N0ID0gYWNjb3VudCArICcuJyArIHJlZ2lvbiArICcuc25vd2ZsYWtlY29tcHV0aW5nLmNuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3QgPSBhY2NvdW50ICsgJy4nICsgcmVnaW9uICsgJy5zbm93Zmxha2Vjb21wdXRpbmcuY29tJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGFjY291bnQgKyAnLnNub3dmbGFrZWNvbXB1dGluZy5jb20nO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdDtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGhvc3QgaW5kaWNhdGVzIHByaXZhdGUgbGlua1xuICovXG5mdW5jdGlvbiBpc1ByaXZhdGVMaW5rKGhvc3QpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhleGlzdHMoaG9zdCksIEVycm9ycy5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19IT1NUKTtcbiAgICByZXR1cm4gaG9zdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwcml2YXRlbGluay5zbm93Zmxha2Vjb21wdXRpbmcuJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVPY3NwUmVzcG9uc2VDYWNoZVNlcnZlclVybChob3N0KSB7XG4gICAgcmV0dXJuIGBodHRwOi8vb2NzcC4ke2hvc3R9L29jc3BfcmVzcG9uc2VfY2FjaGUuanNvbmA7XG59XG4vKipcbiAqIFJldHVybnMgaWYgY29tbWFuZCBpcyBhIFBVVCBjb21tYW5kXG4gKi9cbmZ1bmN0aW9uIGlzUHV0Q29tbWFuZChzcWxUZXh0KSB7XG4gICAgcmV0dXJuIHNxbFRleHQudHJpbSgpLnN1YnN0cmluZygwLCAzKS50b1VwcGVyQ2FzZSgpID09PSAnUFVUJztcbn1cbi8qKlxuICogUmV0dXJucyBpZiBjb21tYW5kIGlzIGEgR0VUIGNvbW1hbmRcbiAqL1xuZnVuY3Rpb24gaXNHZXRDb21tYW5kKHNxbFRleHQpIHtcbiAgICByZXR1cm4gc3FsVGV4dC50cmltKCkuc3Vic3RyaW5nKDAsIDMpLnRvVXBwZXJDYXNlKCkgPT09ICdHRVQnO1xufVxuLyoqXG4gKiBBZGQgZG91YmxlIHF1b3RlcyB0byBzbWtJZCdzIHZhbHVlIHRvIHBhcnNlIGl0IGFzIGEgc3RyaW5nIGluc3RlYWQgb2YgaW50ZWdlclxuICogdG8gcHJlc2VydmUgcHJlY2lzaW9uIG9mIG51bWJlcnMgZXhjZWVkaW5nIEphdmFTY3JpcHQncyBtYXggc2FmZSBpbnRlZ2VyXG4gKiBlLmcgKGlucHV0dGluZyAzMjYyMTk3MzEyNjEyMzUyNlx0b3V0cHV0cyAzMjYyMTk3MzEyNjEyMzUzMClcbiAqXG4gKiBAcGFyYW0gYm9keSB0aGUgZGF0YSBpbiBKU09OXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTbWtJZFRvU3RyaW5nKGJvZHkpIHtcbiAgICByZXR1cm4gYm9keS5yZXBsYWNlKC9cInNta0lkXCIoXFxzKik6KFxccyopKFswLTldKykvZywgJ1wic21rSWRcIiQxOiQyXCIkM1wiJyk7XG59XG4vKipcbiAqIFVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcyB0aGUgb2JqZWN0IHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSBpbiBleGNlcHRpb24gaGFuZGxpbmdcbiAqIGNhbiBjb250YWluIGNpcmN1bGFyIHJlZmVyZW5jZSwgb24gd2hpY2ggSlNPTi5zdHJpbmdpZnkgYmFpbHMgb3V0XG4gKiBNRE4gd2F5IG9mIGhhbmRsaW5nIHN1Y2ggZXJyb3JcbiAqL1xuZnVuY3Rpb24gZ2V0Q2lyY3VsYXJSZXBsYWNlcigpIHtcbiAgICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgdGhpc2AgaXMgdGhlIG9iamVjdCB0aGF0IHZhbHVlIGlzIGNvbnRhaW5lZCBpbixcbiAgICAgICAgLy8gaS5lLiwgaXRzIGRpcmVjdCBwYXJlbnQuXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVFMyNjgzOiAndGhpcycgaW1wbGljaXRseSBoYXMgdHlwZSAnYW55JyBiZWNhdXNlIGl0IGRvZXMgbm90IGhhdmUgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICAgIHdoaWxlIChhbmNlc3RvcnMubGVuZ3RoID4gMCAmJiBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBhbmNlc3RvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2VzdG9ycy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3JzLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBpZiB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3ViZG9tYWluLlxuICovXG5mdW5jdGlvbiBpc0NvcnJlY3RTdWJkb21haW4odmFsdWUpIHtcbiAgICBjb25zdCBzdWJkb21haW5SZWdleCA9IFJlZ0V4cCgvXlxcdysoWy4tXVxcdyspKiQvaSk7XG4gICAgcmV0dXJuIHN1YmRvbWFpblJlZ2V4LnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoaG9zdCwgdXNlcm5hbWUsIGNyZWRUeXBlKSB7XG4gICAgaWYgKCFob3N0IHx8ICF1c2VybmFtZSB8fCAhY3JlZFR5cGUpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nhbm5vdCBidWlsZCB0aGUgY3JlZGVudGlhbCBjYWNoZSBrZXkgYmVjYXVzZSBvbmUgb2YgaG9zdCwgdXNlcm5hbWUsIGFuZCBjcmVkVHlwZSBpcyBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYHske2hvc3QudG9VcHBlckNhc2UoKX19Onske3VzZXJuYW1lLnRvVXBwZXJDYXNlKCl9fTp7JHtjcmVkVHlwZS50b1VwcGVyQ2FzZSgpfX1gO1xufVxuZnVuY3Rpb24gY2hlY2tWYWxpZEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKSB7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21DcmVkZW50aWFsTWFuYWdlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlTWV0aG9kcyA9IFsnd3JpdGUnLCAncmVhZCcsICdyZW1vdmUnXTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiByZXF1aXJlTWV0aG9kcykge1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyLCBtZXRob2QpIHx8XG4gICAgICAgICAgICB0eXBlb2YgY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXJbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2hlY2tQYXJhbWV0ZXJzRGVmaW5lZCguLi5wYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuZXZlcnkoKGVsZW1lbnQpID0+IGVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50ICE9PSBudWxsKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBmaWxlIG9yIGRpcmVjdG9yeSBwZXJtaXNzaW9ucyBhcmUgY29ycmVjdC5cbiAqIEBwYXJhbSBmaWxlUGF0aFxuICogQHBhcmFtIGV4cGVjdGVkTW9kZVxuICogQHBhcmFtIGZzUHJvbWlzZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSByZXNvbHZlcyBhbHdheXMgdG8gdHJ1ZSBmb3IgV2luZG93c1xuICovXG5hc3luYyBmdW5jdGlvbiBpc0ZpbGVNb2RlQ29ycmVjdChmaWxlUGF0aCwgZXhwZWN0ZWRNb2RlLCBmc1Byb21pc2VzKSB7XG4gICAgaWYgKG9zXzEuZGVmYXVsdC5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZnNQcm9taXNlcy5zdGF0KGZpbGVQYXRoKS50aGVuKChzdGF0cykgPT4ge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgTFNCIGJpdHMgdG8gOSB3aXRoIHRoZSBtYXNrLCBhcyB0aGUgc3RhdHMubW9kZSBzdGFydHMgd2l0aCB0aGUgZmlsZSB0eXBlLFxuICAgICAgICAvLyBlLmcuIHRoZSBkaXJlY3Rvcnkgd2l0aCBwZXJtaXNzaW9ucyA3NTUgd2lsbCBoYXZlIHN0YXRzLm1hc2sgb2YgNDA3NTUuXG4gICAgICAgIGNvbnN0IG1hc2sgPSAoMSA8PCA5KSAtIDE7XG4gICAgICAgIHJldHVybiAoc3RhdHMubW9kZSAmIG1hc2spID09PSBleHBlY3RlZE1vZGU7XG4gICAgfSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgZmlsZSBvciBkaXJlY3RvcnkgaXMgd3JpdGFibGUgb25seSBieSB0aGUgdXNlci5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSByZXNvbHZlcyBhbHdheXMgdG8gdHJ1ZSBmb3IgV2luZG93c1xuICovXG5hc3luYyBmdW5jdGlvbiBpc0ZpbGVOb3RXcml0YWJsZUJ5R3JvdXBPck90aGVycyhjb25maWdGaWxlUGF0aCwgZnNQcm9taXNlcykge1xuICAgIGlmIChvc18xLmRlZmF1bHQucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmc1Byb21pc2VzLnN0YXQoY29uZmlnRmlsZVBhdGgpO1xuICAgIHJldHVybiAoc3RhdHMubW9kZSAmICgxIDw8IDQpKSA9PT0gMCAmJiAoc3RhdHMubW9kZSAmICgxIDw8IDEpKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5T2t0YUF1dGgoeyBtYXhSZXRyeVRpbWVvdXQsIG1heFJldHJ5Q291bnQsIG51bVJldHJpZXMsIHN0YXJ0VGltZSwgcmVtYWluaW5nVGltZW91dCwgfSkge1xuICAgIHJldHVybiAoKG1heFJldHJ5VGltZW91dCA9PT0gMCB8fCBEYXRlLm5vdygpIDwgc3RhcnRUaW1lICsgcmVtYWluaW5nVGltZW91dCkgJiZcbiAgICAgICAgbnVtUmV0cmllcyA8PSBtYXhSZXRyeUNvdW50KTtcbn1cbmZ1bmN0aW9uIGdldERyaXZlckRpcmVjdG9yeSgpIHtcbiAgICByZXR1cm4gX19kaXJuYW1lO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQYXRoKGRpcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YXQgPSBmc18xLmRlZmF1bHQuc3RhdFN5bmMoZGlyKTtcbiAgICAgICAgcmV0dXJuIHN0YXQuaXNEaXJlY3RvcnkoKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignVGhlIGxvY2F0aW9uIGlzIGludmFsaWQuIFBsZWFzZSBjaGVjayB0aGlzIGxvY2F0aW9uIGlzIGFjY2Vzc2libGUgb3IgZXhpc3RpbmcnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudlZhcih2YXJpYWJsZSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudlt2YXJpYWJsZS50b0xvd2VyQ2FzZSgpXSB8fCBwcm9jZXNzLmVudlt2YXJpYWJsZS50b1VwcGVyQ2FzZSgpXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRW1wdHlTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09ICcnID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc05vdEVtcHR5QXNTdHJpbmcodmFyaWFibGUpIHtcbiAgICBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfVxuICAgIHJldHVybiBleGlzdHModmFyaWFibGUpO1xufVxuZnVuY3Rpb24gaXNOb3RFbXB0eVN0cmluZyh2YXJpYWJsZSkge1xuICAgIHJldHVybiBleGlzdHModmFyaWFibGUpICYmIHZhcmlhYmxlICE9PSAnJztcbn1cbi8qKlxuICogQ2hlY2tzIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBlbXB0eSAoY2FuIGJlIG51bGwgb3IgdW5kZWZpbmVkKSBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqZWN0KSB7XG4gICAgaWYgKCFleGlzdHMob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gaXNXaW5kb3dzKCkge1xuICAgIHJldHVybiBvc18xLmRlZmF1bHQucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEZyZWVQb3J0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHNydiA9IG5ldF8xLmRlZmF1bHQuY3JlYXRlU2VydmVyKCk7XG4gICAgICAgIHNydi5saXN0ZW4oMCwgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzIzMzk6IFByb3BlcnR5ICdwb3J0JyBkb2VzIG5vdCBleGlzdCBvbiB0eXBlICdzdHJpbmcgfCBBZGRyZXNzSW5mbydcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBzcnYuYWRkcmVzcygpLnBvcnQ7XG4gICAgICAgICAgICBzcnYuY2xvc2UoKCkgPT4gcmVzKHBvcnQpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBpc1BvcnRPcGVuKHBvcnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBzID0gbmV0XzEuZGVmYXVsdC5jcmVhdGVTZXJ2ZXIoKTtcbiAgICAgICAgcy5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHMuY2xvc2UoKTtcbiAgICAgICAgICAgIGlmIChlcnJbJ2NvZGUnXSA9PT0gJ0VBRERSSU5VU0UnKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFBvcnQ6ICR7cG9ydH0gaXMgbm90IGF2YWlsYWJsZS4gVmVyaWZpY2F0aW9uIGZhaWxlZGApO1xuICAgICAgICAgICAgICAgIHJlamVjdCgnUG9ydCBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFRoZXJlIGlzIHVuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIHZlcmlmaWNhdGlvbiBvZiBwb3J0IGF2YWlsYWJpbGl0eS4gUG9ydDogJHtwb3J0fS4gRXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZXJyKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHMub25jZSgnbGlzdGVuaW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgcy5jbG9zZSgpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYENsb3Npbmcgc2VydmVyIHJ1biBmb3IgdmVyaWZpY2F0aW9uIHdoZXRoZXIgdGhlIHBvcnQgaXMgYXZhaWxhYmxlLiBQb3J0OiAke3BvcnR9YCk7XG4gICAgICAgICAgICByZXNvbHZlKCdMaXN0ZW5pbmcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHMubGlzdGVuKHBvcnQpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBMZWZ0IHN0cmlwIHRoZSBzcGVjaWZpZWQgY2hhcmFjdGVyIGZyb20gYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGxzdHJpcChzdHIsIHJlbW92ZSkge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoID4gMCAmJiByZW1vdmUuaW5kZXhPZihzdHIuY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgdHJhbnNmb3JtcyBIVE1MIHNwZWNpYWwgY2hhcmFjdGVycyBpbnRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgZW50aXR5IHJlcHJlc2VudGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlSFRNTCh2YWx1ZSkge1xuICAgIGlmICghZXhpc3RzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cbi8qKlxuICogVHlwZXNjcmlwdCB3aXRoIFwibW9kdWxlXCI6IFwiY29tbW9uanNcIiB3aWxsIHRyYW5zZm9ybSBldmVyeSBpbXBvcnQoKSB0byBhIHJlcXVpcmUoKSBzdGF0ZW1lbnQuXG4gKlxuICogVGhpcyB3aWxsIGJyZWFrIEVTTSBkeW5hbWljIGltcG9ydHMgcmVzdWx0aW5nIGluIGEgcnVudGltZSBlcnJvcjpcbiAqIC1yZXF1aXJlKCkgb2YgRVMgTW9kdWxlLi4uIGZyb20gLi4uIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQSBoYWNreSBzb2x1dGlvbiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDMzMjlcbiAqXG4gKiBUaGlzIGNvdWxkIGJlIHJlbW92ZWQgb25jZSB3ZSBkcm9wIG5vZGUgMTggc3VwcG9ydCBhcyBOb2RlIDIwKyBzdXBwb3J0IGVzbSBpbiByZXF1aXJlKClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZHluYW1pY0ltcG9ydEVTTUluVHlwZXNjcmlwdFdpdGhDb21tb25KUyhtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGByZXR1cm4gaW1wb3J0KFwiJHttb2R1bGVOYW1lfVwiKWApKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/dist/lib/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/dist/package.json":
/*!******************************************************!*\
  !*** ./node_modules/snowflake-sdk/dist/package.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"snowflake-sdk","version":"2.3.0","description":"Node.js driver for Snowflake","dependencies":{"@aws-crypto/sha256-js":"^5.2.0","@aws-sdk/client-s3":"^3.726.0","@aws-sdk/credential-provider-node":"^3.823.0","@aws-sdk/ec2-metadata-service":"^3.826.0","@azure/identity":"^4.10.1","@azure/storage-blob":"12.26.x","@google-cloud/storage":"^7.7.0","@smithy/node-http-handler":"^4.0.1","@smithy/protocol-http":"^5.1.3","@smithy/signature-v4":"^5.2.1","@techteamer/ocsp":"1.0.1","asn1.js-rfc2560":"^5.0.0","asn1.js-rfc5280":"^3.0.0","axios":"^1.12.2","big-integer":"^1.6.43","bignumber.js":"^9.1.2","bn.js":"^5.2.1","browser-request":"^0.3.3","expand-tilde":"^2.0.2","fast-xml-parser":"^4.2.5","fastest-levenshtein":"^1.0.16","generic-pool":"^3.8.2","glob":"^10.0.0","google-auth-library":"^10.1.0","https-proxy-agent":"^7.0.2","jsonwebtoken":"^9.0.0","mime-types":"^2.1.29","moment":"^2.29.4","moment-timezone":"^0.5.15","oauth4webapi":"^3.0.1","open":"^7.3.1","simple-lru-cache":"^0.0.2","toml":"^3.0.0","uuid":"^8.3.2","winston":"^3.1.0"},"devDependencies":{"@aws-sdk/types":"^3.387.0","@types/mocha":"^10.0.10","@types/node":"^22.15.18","@types/sinon":"^17.0.4","async":"^3.2.3","eslint":"^8.41.0","husky":"^9.1.7","lint-staged":"^16.0.0","mocha":"^11.1.0","mock-require":"^3.0.3","nyc":"^15.1.0","prettier":"^3.5.3","rewiremock":"^3.14.6","sinon":"^20.0.0","test-console":"^2.0.0","ts-node":"^10.9.2","typescript":"^5.8.3","wiremock":"^3.10.0","wiremock-rest-client":"^1.11.0"},"peerDependencies":{"asn1.js":"^5.4.1"},"overrides":{"semver":"^7.5.2"},"repository":{"type":"git","url":"https://github.com/snowflakedb/snowflake-connector-nodejs"},"main":"./dist/index.js","typings":"./dist/index.d.ts","lint-staged":{"*":"npm run prettier:format","*.js":"npm run lint:check"},"scripts":{"prepack":"node ci/build_typescript.js","prepare":"husky","check-ts":"npm run prepack && tsc --noEmit ci/typescript-test.ts","lint:check":"eslint .","lint:fix":"eslint --fix","prettier:check":"prettier --check .","prettier:format":"prettier -w .","test":"mocha \'test/unit/**/*.{js,ts}\'","test:authentication":"mocha \'test/authentication/**/*.{js,ts}\'","test:auth-workload-identity-e2e":"mocha test/auth-workload-identity-e2e.ts","test:integration":"mocha \'test/integration/**/*.{js,ts}\'","test:single":"mocha","test:system":"mocha \'system_test/**/*.{js,ts}\'","test:unit":"mocha \'test/unit/**/*.{js,ts}\'","test:unit:coverage":"nyc npm run test:unit","test:ci":"mocha \'test/{unit,integration}/**/*.{js,ts}\'","test:ci:coverage":"nyc npm run test:ci","test:ci:withSystemTests":"mocha \'test/{unit,integration}/**/*.{js,ts}\' \'system_test/**/*.{js,ts}\'","test:ci:withSystemTests:coverage":"nyc npm run test:ci:withSystemTests","test:manual":"mocha test/integration/testManualConnection.js","serve-wiremock":"wiremock --enable-browser-proxying --proxy-pass-through  false --port 8081","wiremock":"npm run serve-wiremock"},"author":{"name":"Snowflake Computing, Inc.","email":"support@snowflake.com","url":"https://www.snowflake.com/"},"license":"Apache-2.0"}');

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    this.length = num === 0 ? 1 : this.length;\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsb0RBQXdCO0FBQ3ZDO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsY0FBYztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbbnVtYmVyICYgMHgzZmZmZmZmXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICcwJyAtICc5J1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHtcbiAgICAgIHJldHVybiBjIC0gNDg7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgfSBlbHNlIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIGNoYXJhY3RlciBpbiAnICsgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgYiA9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgYiA9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gYztcbiAgICAgIH1cbiAgICAgIGFzc2VydChjID49IDAgJiYgYiA8IG11bCwgJ0ludmFsaWQgY2hhcmFjdGVyJyk7XG4gICAgICByICs9IGI7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1vdmUgKGRlc3QsIHNyYykge1xuICAgIGRlc3Qud29yZHMgPSBzcmMud29yZHM7XG4gICAgZGVzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSBzcmMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSBzcmMucmVkO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gX21vdmUgKGRlc3QpIHtcbiAgICBtb3ZlKGRlc3QsIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIENoZWNrIFN5bWJvbC5mb3IgYmVjYXVzZSBub3QgZXZlcnl3aGVyZSB3aGVyZSBTeW1ib2wgZGVmaW5lZFxuICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgQk4ucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gaW5zcGVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kcm4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICB9O1xuXG4gIGlmIChCdWZmZXIpIHtcbiAgICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZSAoQXJyYXlUeXBlLCBzaXplKSB7XG4gICAgaWYgKEFycmF5VHlwZS5hbGxvY1Vuc2FmZSkge1xuICAgICAgcmV0dXJuIEFycmF5VHlwZS5hbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc2l6ZSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdmFyIHJlcyA9IGFsbG9jYXRlKEFycmF5VHlwZSwgcmVxTGVuZ3RoKTtcbiAgICB2YXIgcG9zdGZpeCA9IGVuZGlhbiA9PT0gJ2xlJyA/ICdMRScgOiAnQkUnO1xuICAgIHRoaXNbJ190b0FycmF5TGlrZScgKyBwb3N0Zml4XShyZXMsIGJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlTEUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUJFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSByZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gPj4+IHdiaXQpICYgMHgwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICAvLyBUZW1wb3JhcnkgZGlzYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL2lzc3Vlcy8yMTFcbiAgICAvLyB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgLy8gcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gICAgcmV0dXJuIGJpZ011bFRvKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBudW0gPT09IDAgPyAxIDogdGhpcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5fc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuX3N0cmlwKCk7XG4gICAgfVxuICAgIGEuX3N0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IChyMiA9PT0gMSAmJiBjbXAgPT09IDApKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uIG1vZHJuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IC1hY2MgOiBhY2M7XG4gIH07XG5cbiAgLy8gV0FSTklORzogREVQUkVDQVRFRFxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLm1vZHJuKG51bSk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICBtb3ZlKGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/bn.js/lib/bn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1E7QUFDRTtBQUNFIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/md5.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/md5.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/nil.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/nil.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsc0NBQXNDIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/parse.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/parse.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDOztBQUVyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxLQUFLIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/regex.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/regex.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcseUNBQXlDIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/rng.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/rng.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7QUFDNUIsdUNBQXVDOztBQUV2QztBQUNlO0FBQ2Y7QUFDQSxJQUFJLDREQUFxQjtBQUN6QjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcblxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/sha1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/sha1.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxTQUFTLHdEQUFpQjtBQUMxQjs7QUFFQSxpRUFBZSxJQUFJIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRnQkFBNGdCO0FBQzVnQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLFNBQVMiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgY29uc3QgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v1.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNZLENBQUM7QUFDeEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7OztBQUdmO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsK0NBQUc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFOztBQUVBLDRFQUE0RTs7QUFFNUUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG9DQUFvQzs7QUFFcEMsOEJBQThCOztBQUU5QixrQ0FBa0M7O0FBRWxDLDRCQUE0Qjs7QUFFNUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxnQkFBZ0IseURBQVM7QUFDekI7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v3.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v3.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNBO0FBQzNCLFdBQVcsbURBQUcsYUFBYSwrQ0FBRztBQUM5QixpRUFBZSxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG5jb25zdCB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v35.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v35.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUNSOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNQLDZCQUFlLG9DQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcseURBQVM7QUFDcEIsSUFBSTs7O0FBR0o7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSSxlQUFlOzs7QUFHbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSBwYXJzZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v4.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v4.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNZOztBQUV2QztBQUNBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLHlEQUFTO0FBQ2xCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v5.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v5.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNFO0FBQzdCLFdBQVcsbURBQUcsYUFBYSxnREFBSTtBQUMvQixpRUFBZSxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbmNvbnN0IHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCOztBQUUvQjtBQUNBLHFDQUFxQyxpREFBSztBQUMxQzs7QUFFQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/version.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxPQUFPIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/node_modules/uuid/dist/esm-node/version.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/glob";
exports.ids = ["vendor-chunks/glob"];
exports.modules = {

/***/ "(rsc)/./node_modules/glob/dist/commonjs/glob.js":
/*!*************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/glob.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Glob = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst path_scurry_1 = __webpack_require__(/*! path-scurry */ \"(rsc)/./node_modules/path-scurry/dist/commonjs/index.js\");\nconst pattern_js_1 = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/commonjs/pattern.js\");\nconst walker_js_1 = __webpack_require__(/*! ./walker.js */ \"(rsc)/./node_modules/glob/dist/commonjs/walker.js\");\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * An object that can perform glob pattern traversals.\n */\nclass Glob {\n    absolute;\n    cwd;\n    root;\n    dot;\n    dotRelative;\n    follow;\n    ignore;\n    magicalBraces;\n    mark;\n    matchBase;\n    maxDepth;\n    nobrace;\n    nocase;\n    nodir;\n    noext;\n    noglobstar;\n    pattern;\n    platform;\n    realpath;\n    scurry;\n    stat;\n    signal;\n    windowsPathsNoEscape;\n    withFileTypes;\n    includeChildMatches;\n    /**\n     * The options provided to the constructor.\n     */\n    opts;\n    /**\n     * An array of parsed immutable {@link Pattern} objects.\n     */\n    patterns;\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */\n    constructor(pattern, opts) {\n        /* c8 ignore start */\n        if (!opts)\n            throw new TypeError('glob options required');\n        /* c8 ignore stop */\n        this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = '';\n        }\n        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n            opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);\n        }\n        this.cwd = opts.cwd || '';\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth =\n            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error('cannot set absolute and withFileTypes:true');\n        }\n        if (typeof pattern === 'string') {\n            pattern = [pattern];\n        }\n        this.windowsPathsNoEscape =\n            !!opts.windowsPathsNoEscape ||\n                opts.allowWindowsEscape ===\n                    false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map(p => p.replace(/\\\\/g, '/'));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError('base matching requires globstar');\n            }\n            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = { ...opts, platform: this.platform };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined &&\n                opts.nocase !== opts.scurry.nocase) {\n                throw new Error('nocase option contradicts provided scurry option');\n            }\n        }\n        else {\n            const Scurry = opts.platform === 'win32' ? path_scurry_1.PathScurryWin32\n                : opts.platform === 'darwin' ? path_scurry_1.PathScurryDarwin\n                    : opts.platform ? path_scurry_1.PathScurryPosix\n                        : path_scurry_1.PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs,\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug,\n        };\n        const mms = this.pattern.map(p => new minimatch_1.Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m) => {\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [[], []]);\n        this.patterns = matchSet.map((set, i) => {\n            const g = globParts[i];\n            /* c8 ignore start */\n            if (!g)\n                throw new Error('invalid pattern object');\n            /* c8 ignore stop */\n            return new pattern_js_1.Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...(await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walk()),\n        ];\n    }\n    walkSync() {\n        return [\n            ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walkSync(),\n        ];\n    }\n    stream() {\n        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).stream();\n    }\n    streamSync() {\n        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */\n    iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */\n    iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2dsb2IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFXO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDBCQUFVO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLDRFQUFhO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLHdFQUFjO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvZ2xvYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2xvYiA9IHZvaWQgMDtcbmNvbnN0IG1pbmltYXRjaF8xID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbmNvbnN0IG5vZGVfdXJsXzEgPSByZXF1aXJlKFwibm9kZTp1cmxcIik7XG5jb25zdCBwYXRoX3NjdXJyeV8xID0gcmVxdWlyZShcInBhdGgtc2N1cnJ5XCIpO1xuY29uc3QgcGF0dGVybl9qc18xID0gcmVxdWlyZShcIi4vcGF0dGVybi5qc1wiKTtcbmNvbnN0IHdhbGtlcl9qc18xID0gcmVxdWlyZShcIi4vd2Fsa2VyLmpzXCIpO1xuLy8gaWYgbm8gcHJvY2VzcyBnbG9iYWwsIGp1c3QgY2FsbCBpdCBsaW51eC5cbi8vIHNvIHdlIGRlZmF1bHQgdG8gY2FzZS1zZW5zaXRpdmUsIC8gc2VwYXJhdG9yc1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3N0cmluZycpID9cbiAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAnbGludXgnO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcGVyZm9ybSBnbG9iIHBhdHRlcm4gdHJhdmVyc2Fscy5cbiAqL1xuY2xhc3MgR2xvYiB7XG4gICAgYWJzb2x1dGU7XG4gICAgY3dkO1xuICAgIHJvb3Q7XG4gICAgZG90O1xuICAgIGRvdFJlbGF0aXZlO1xuICAgIGZvbGxvdztcbiAgICBpZ25vcmU7XG4gICAgbWFnaWNhbEJyYWNlcztcbiAgICBtYXJrO1xuICAgIG1hdGNoQmFzZTtcbiAgICBtYXhEZXB0aDtcbiAgICBub2JyYWNlO1xuICAgIG5vY2FzZTtcbiAgICBub2RpcjtcbiAgICBub2V4dDtcbiAgICBub2dsb2JzdGFyO1xuICAgIHBhdHRlcm47XG4gICAgcGxhdGZvcm07XG4gICAgcmVhbHBhdGg7XG4gICAgc2N1cnJ5O1xuICAgIHN0YXQ7XG4gICAgc2lnbmFsO1xuICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlO1xuICAgIHdpdGhGaWxlVHlwZXM7XG4gICAgaW5jbHVkZUNoaWxkTWF0Y2hlcztcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgb3B0cztcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBwYXJzZWQgaW1tdXRhYmxlIHtAbGluayBQYXR0ZXJufSBvYmplY3RzLlxuICAgICAqL1xuICAgIHBhdHRlcm5zO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcHRpb25zIGFyZSBzdG9yZWQgYXMgcHJvcGVydGllcyBvbiB0aGUgYEdsb2JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgR2xvYk9wdGlvbnN9IGZvciBmdWxsIG9wdGlvbnMgZGVzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGEgcHJldmlvdXMgYEdsb2JgIG9iamVjdCBjYW4gYmUgcGFzc2VkIGFzIHRoZVxuICAgICAqIGBHbG9iT3B0aW9uc2AgdG8gYW5vdGhlciBgR2xvYmAgaW5zdGFudGlhdGlvbiB0byByZS11c2Ugc2V0dGluZ3NcbiAgICAgKiBhbmQgY2FjaGVzIHdpdGggYSBuZXcgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIFRyYXZlcnNhbCBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBydW4gdGhlIHdhbGtcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRzKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIG9wdGlvbnMgcmVxdWlyZWQnKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53aXRoRmlsZVR5cGVzID0gISFvcHRzLndpdGhGaWxlVHlwZXM7XG4gICAgICAgIHRoaXMuc2lnbmFsID0gb3B0cy5zaWduYWw7XG4gICAgICAgIHRoaXMuZm9sbG93ID0gISFvcHRzLmZvbGxvdztcbiAgICAgICAgdGhpcy5kb3QgPSAhIW9wdHMuZG90O1xuICAgICAgICB0aGlzLmRvdFJlbGF0aXZlID0gISFvcHRzLmRvdFJlbGF0aXZlO1xuICAgICAgICB0aGlzLm5vZGlyID0gISFvcHRzLm5vZGlyO1xuICAgICAgICB0aGlzLm1hcmsgPSAhIW9wdHMubWFyaztcbiAgICAgICAgaWYgKCFvcHRzLmN3ZCkge1xuICAgICAgICAgICAgdGhpcy5jd2QgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmN3ZCBpbnN0YW5jZW9mIFVSTCB8fCBvcHRzLmN3ZC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgICAgICAgIG9wdHMuY3dkID0gKDAsIG5vZGVfdXJsXzEuZmlsZVVSTFRvUGF0aCkob3B0cy5jd2QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3dkID0gb3B0cy5jd2QgfHwgJyc7XG4gICAgICAgIHRoaXMucm9vdCA9IG9wdHMucm9vdDtcbiAgICAgICAgdGhpcy5tYWdpY2FsQnJhY2VzID0gISFvcHRzLm1hZ2ljYWxCcmFjZXM7XG4gICAgICAgIHRoaXMubm9icmFjZSA9ICEhb3B0cy5ub2JyYWNlO1xuICAgICAgICB0aGlzLm5vZXh0ID0gISFvcHRzLm5vZXh0O1xuICAgICAgICB0aGlzLnJlYWxwYXRoID0gISFvcHRzLnJlYWxwYXRoO1xuICAgICAgICB0aGlzLmFic29sdXRlID0gb3B0cy5hYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzID0gb3B0cy5pbmNsdWRlQ2hpbGRNYXRjaGVzICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub2dsb2JzdGFyID0gISFvcHRzLm5vZ2xvYnN0YXI7XG4gICAgICAgIHRoaXMubWF0Y2hCYXNlID0gISFvcHRzLm1hdGNoQmFzZTtcbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0cy5tYXhEZXB0aCA9PT0gJ251bWJlcicgPyBvcHRzLm1heERlcHRoIDogSW5maW5pdHk7XG4gICAgICAgIHRoaXMuc3RhdCA9ICEhb3B0cy5zdGF0O1xuICAgICAgICB0aGlzLmlnbm9yZSA9IG9wdHMuaWdub3JlO1xuICAgICAgICBpZiAodGhpcy53aXRoRmlsZVR5cGVzICYmIHRoaXMuYWJzb2x1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGFic29sdXRlIGFuZCB3aXRoRmlsZVR5cGVzOnRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRzLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8XG4gICAgICAgICAgICAgICAgb3B0cy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSkge1xuICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ubWFwKHAgPT4gcC5yZXBsYWNlKC9cXFxcL2csICcvJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoQmFzZSkge1xuICAgICAgICAgICAgaWYgKG9wdHMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Jhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLm1hcChwID0+IChwLmluY2x1ZGVzKCcvJykgPyBwIDogYC4vKiovJHtwfWApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0cy5wbGF0Zm9ybSB8fCBkZWZhdWx0UGxhdGZvcm07XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0gfTtcbiAgICAgICAgaWYgKG9wdHMuc2N1cnJ5KSB7XG4gICAgICAgICAgICB0aGlzLnNjdXJyeSA9IG9wdHMuc2N1cnJ5O1xuICAgICAgICAgICAgaWYgKG9wdHMubm9jYXNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvcHRzLm5vY2FzZSAhPT0gb3B0cy5zY3Vycnkubm9jYXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2Nhc2Ugb3B0aW9uIGNvbnRyYWRpY3RzIHByb3ZpZGVkIHNjdXJyeSBvcHRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFNjdXJyeSA9IG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicgPyBwYXRoX3NjdXJyeV8xLlBhdGhTY3VycnlXaW4zMlxuICAgICAgICAgICAgICAgIDogb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgPyBwYXRoX3NjdXJyeV8xLlBhdGhTY3VycnlEYXJ3aW5cbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLnBsYXRmb3JtID8gcGF0aF9zY3VycnlfMS5QYXRoU2N1cnJ5UG9zaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGF0aF9zY3VycnlfMS5QYXRoU2N1cnJ5O1xuICAgICAgICAgICAgdGhpcy5zY3VycnkgPSBuZXcgU2N1cnJ5KHRoaXMuY3dkLCB7XG4gICAgICAgICAgICAgICAgbm9jYXNlOiBvcHRzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBmczogb3B0cy5mcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9jYXNlID0gdGhpcy5zY3Vycnkubm9jYXNlO1xuICAgICAgICAvLyBJZiB5b3UgZG8gbm9jYXNlOnRydWUgb24gYSBjYXNlLXNlbnNpdGl2ZSBmaWxlIHN5c3RlbSwgdGhlblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSByZWdleHBzIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3Igbm9uLW1hZ2ljXG4gICAgICAgIC8vIHBhdGggcG9ydGlvbnMsIGJlY2F1c2Ugc3RhdHRpbmcgYGFCY2Agd29uJ3QgcmV0dXJuIHJlc3VsdHNcbiAgICAgICAgLy8gZm9yIHRoZSBmaWxlIGBBYkNgIGZvciBleGFtcGxlLlxuICAgICAgICBjb25zdCBub2Nhc2VNYWdpY09ubHkgPSB0aGlzLnBsYXRmb3JtID09PSAnZGFyd2luJyB8fCB0aGlzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgICAgICBjb25zdCBtbW8gPSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IG5vY2FzZSBiYXNlZCBvbiBwbGF0Zm9ybVxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIGRvdDogdGhpcy5kb3QsXG4gICAgICAgICAgICBtYXRjaEJhc2U6IHRoaXMubWF0Y2hCYXNlLFxuICAgICAgICAgICAgbm9icmFjZTogdGhpcy5ub2JyYWNlLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIG5vY2FzZU1hZ2ljT25seSxcbiAgICAgICAgICAgIG5vY29tbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIG5vZXh0OiB0aGlzLm5vZXh0LFxuICAgICAgICAgICAgbm9uZWdhdGU6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWl6YXRpb25MZXZlbDogMixcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgd2luZG93c1BhdGhzTm9Fc2NhcGU6IHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUsXG4gICAgICAgICAgICBkZWJ1ZzogISF0aGlzLm9wdHMuZGVidWcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1tcyA9IHRoaXMucGF0dGVybi5tYXAocCA9PiBuZXcgbWluaW1hdGNoXzEuTWluaW1hdGNoKHAsIG1tbykpO1xuICAgICAgICBjb25zdCBbbWF0Y2hTZXQsIGdsb2JQYXJ0c10gPSBtbXMucmVkdWNlKChzZXQsIG0pID0+IHtcbiAgICAgICAgICAgIHNldFswXS5wdXNoKC4uLm0uc2V0KTtcbiAgICAgICAgICAgIHNldFsxXS5wdXNoKC4uLm0uZ2xvYlBhcnRzKTtcbiAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH0sIFtbXSwgW11dKTtcbiAgICAgICAgdGhpcy5wYXR0ZXJucyA9IG1hdGNoU2V0Lm1hcCgoc2V0LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gZ2xvYlBhcnRzW2ldO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoIWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhdHRlcm4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXR0ZXJuX2pzXzEuUGF0dGVybihzZXQsIGcsIDAsIHRoaXMucGxhdGZvcm0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FsaygpIHtcbiAgICAgICAgLy8gV2Fsa2VycyBhbHdheXMgcmV0dXJuIGFycmF5IG9mIFBhdGggb2JqZWN0cywgc28gd2UganVzdCBoYXZlIHRvXG4gICAgICAgIC8vIGNvZXJjZSB0aGVtIGludG8gdGhlIHJpZ2h0IHNoYXBlLiAgSXQgd2lsbCBoYXZlIGFscmVhZHkgY2FsbGVkXG4gICAgICAgIC8vIHJlYWxwYXRoKCkgaWYgdGhlIG9wdGlvbiB3YXMgc2V0IHRvIGRvIHNvLCBzbyB3ZSBrbm93IHRoYXQncyBjYWNoZWQuXG4gICAgICAgIC8vIHN0YXJ0IG91dCBrbm93aW5nIHRoZSBjd2QsIGF0IGxlYXN0XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi4oYXdhaXQgbmV3IHdhbGtlcl9qc18xLkdsb2JXYWxrZXIodGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICAgICAgfSkud2FsaygpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgd2Fsa1N5bmMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5uZXcgd2Fsa2VyX2pzXzEuR2xvYldhbGtlcih0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgICAgICB9KS53YWxrU3luYygpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2Fsa2VyX2pzXzEuR2xvYlN0cmVhbSh0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgfSkuc3RyZWFtKCk7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2Fsa2VyX2pzXzEuR2xvYlN0cmVhbSh0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgfSkuc3RyZWFtU3luYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN5bmMgaXRlcmF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGEgR2VuZXJhdG9yIHRoYXRcbiAgICAgKiBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGl0ZXJhdGVTeW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1TeW5jKClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZVN5bmMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBhc3luYyBpdGVyYXRpb24gZnVuY3Rpb24uIFJldHVybnMgYW4gQXN5bmNHZW5lcmF0b3IgdGhhdFxuICAgICAqIGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdHMuXG4gICAgICovXG4gICAgaXRlcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtKClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG59XG5leHBvcnRzLkdsb2IgPSBHbG9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/glob.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/has-magic.js":
/*!******************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/has-magic.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hasMagic = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nconst hasMagic = (pattern, options = {}) => {\n    if (!Array.isArray(pattern)) {\n        pattern = [pattern];\n    }\n    for (const p of pattern) {\n        if (new minimatch_1.Minimatch(p, options).hasMagic())\n            return true;\n    }\n    return false;\n};\nexports.hasMagic = hasMagic;\n//# sourceMappingURL=has-magic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2hhcy1tYWdpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2hhcy1tYWdpYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzTWFnaWMgPSB2b2lkIDA7XG5jb25zdCBtaW5pbWF0Y2hfMSA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBwYXR0ZXJucyBwcm92aWRlZCBjb250YWluIGFueSBtYWdpYyBnbG9iIGNoYXJhY3RlcnMsXG4gKiBnaXZlbiB0aGUgb3B0aW9ucyBwcm92aWRlZC5cbiAqXG4gKiBCcmFjZSBleHBhbnNpb24gaXMgbm90IGNvbnNpZGVyZWQgXCJtYWdpY1wiIHVubGVzcyB0aGUgYG1hZ2ljYWxCcmFjZXNgIG9wdGlvblxuICogaXMgc2V0LCBhcyBicmFjZSBleHBhbnNpb24ganVzdCB0dXJucyBvbmUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIFNvIGEgcGF0dGVybiBsaWtlIGAneHthLGJ9eSdgIHdvdWxkIHJldHVybiBgZmFsc2VgLCBiZWNhdXNlIGAneGF5J2AgYW5kXG4gKiBgJ3hieSdgIGJvdGggZG8gbm90IGNvbnRhaW4gYW55IG1hZ2ljIGdsb2IgY2hhcmFjdGVycywgYW5kIGl0J3MgdHJlYXRlZCB0aGVcbiAqIHNhbWUgYXMgaWYgeW91IGhhZCBjYWxsZWQgaXQgb24gYFsneGF5JywgJ3hieSddYC4gV2hlbiBgbWFnaWNhbEJyYWNlczp0cnVlYFxuICogaXMgaW4gdGhlIG9wdGlvbnMsIGJyYWNlIGV4cGFuc2lvbiBfaXNfIHRyZWF0ZWQgYXMgYSBwYXR0ZXJuIGhhdmluZyBtYWdpYy5cbiAqL1xuY29uc3QgaGFzTWFnaWMgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICAgIHBhdHRlcm4gPSBbcGF0dGVybl07XG4gICAgfVxuICAgIGZvciAoY29uc3QgcCBvZiBwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChuZXcgbWluaW1hdGNoXzEuTWluaW1hdGNoKHAsIG9wdGlvbnMpLmhhc01hZ2ljKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMuaGFzTWFnaWMgPSBoYXNNYWdpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1tYWdpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/has-magic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/ignore.js":
/*!***************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/ignore.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Ignore = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\nconst pattern_js_1 = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/commonjs/pattern.js\");\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    platform;\n    mmopts;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        for (const ign of ignored)\n            this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new minimatch_1.Minimatch(ign, this.mmopts);\n        for (let i = 0; i < mm.set.length; i++) {\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */\n            if (!parsed || !globParts) {\n                throw new Error('invalid pattern object');\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while (parsed[0] === '.' && globParts[0] === '.') {\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */\n            const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);\n            const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === '**';\n            const absolute = p.isAbsolute();\n            if (absolute)\n                this.absolute.push(m);\n            else\n                this.relative.push(m);\n            if (children) {\n                if (absolute)\n                    this.absoluteChildren.push(m);\n                else\n                    this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\nexports.Ignore = Ignore;\n//# sourceMappingURL=ignore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2lnbm9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBVztBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyx3RUFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWlFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9jb21tb25qcy9pZ25vcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBnaXZlIGl0IGEgcGF0dGVybiwgYW5kIGl0J2xsIGJlIGFibGUgdG8gdGVsbCB5b3UgaWZcbi8vIGEgZ2l2ZW4gcGF0aCBzaG91bGQgYmUgaWdub3JlZC5cbi8vIElnbm9yaW5nIGEgcGF0aCBpZ25vcmVzIGl0cyBjaGlsZHJlbiBpZiB0aGUgcGF0dGVybiBlbmRzIGluIC8qKlxuLy8gSWdub3JlcyBhcmUgYWx3YXlzIHBhcnNlZCBpbiBkb3Q6dHJ1ZSBtb2RlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklnbm9yZSA9IHZvaWQgMDtcbmNvbnN0IG1pbmltYXRjaF8xID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbmNvbnN0IHBhdHRlcm5fanNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm4uanNcIik7XG5jb25zdCBkZWZhdWx0UGxhdGZvcm0gPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgcHJvY2VzcyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnBsYXRmb3JtID09PSAnc3RyaW5nJykgP1xuICAgIHByb2Nlc3MucGxhdGZvcm1cbiAgICA6ICdsaW51eCc7XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gcHJvY2VzcyBpZ25vcmVkIHBhdHRlcm5zXG4gKi9cbmNsYXNzIElnbm9yZSB7XG4gICAgcmVsYXRpdmU7XG4gICAgcmVsYXRpdmVDaGlsZHJlbjtcbiAgICBhYnNvbHV0ZTtcbiAgICBhYnNvbHV0ZUNoaWxkcmVuO1xuICAgIHBsYXRmb3JtO1xuICAgIG1tb3B0cztcbiAgICBjb25zdHJ1Y3RvcihpZ25vcmVkLCB7IG5vYnJhY2UsIG5vY2FzZSwgbm9leHQsIG5vZ2xvYnN0YXIsIHBsYXRmb3JtID0gZGVmYXVsdFBsYXRmb3JtLCB9KSB7XG4gICAgICAgIHRoaXMucmVsYXRpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZSA9IFtdO1xuICAgICAgICB0aGlzLnJlbGF0aXZlQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZUNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5tbW9wdHMgPSB7XG4gICAgICAgICAgICBkb3Q6IHRydWUsXG4gICAgICAgICAgICBub2JyYWNlLFxuICAgICAgICAgICAgbm9jYXNlLFxuICAgICAgICAgICAgbm9leHQsXG4gICAgICAgICAgICBub2dsb2JzdGFyLFxuICAgICAgICAgICAgb3B0aW1pemF0aW9uTGV2ZWw6IDIsXG4gICAgICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgICAgIG5vY29tbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIG5vbmVnYXRlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGlnbiBvZiBpZ25vcmVkKVxuICAgICAgICAgICAgdGhpcy5hZGQoaWduKTtcbiAgICB9XG4gICAgYWRkKGlnbikge1xuICAgICAgICAvLyB0aGlzIGlzIGEgbGl0dGxlIHdlaXJkLCBidXQgaXQgZ2l2ZXMgdXMgYSBjbGVhbiBzZXQgb2Ygb3B0aW1pemVkXG4gICAgICAgIC8vIG1pbmltYXRjaCBtYXRjaGVycywgd2l0aG91dCBnZXR0aW5nIHRyaXBwZWQgdXAgaWYgb25lIG9mIHRoZW1cbiAgICAgICAgLy8gZW5kcyBpbiAvKiogaW5zaWRlIGEgYnJhY2Ugc2VjdGlvbiwgYW5kIGl0J3Mgb25seSBpbmVmZmljaWVudCBhdFxuICAgICAgICAvLyB0aGUgc3RhcnQgb2YgdGhlIHdhbGssIG5vdCBhbG9uZyBpdC5cbiAgICAgICAgLy8gSXQnZCBiZSBuaWNlIGlmIHRoZSBQYXR0ZXJuIGNsYXNzIGp1c3QgaGFkIGEgLnRlc3QoKSBtZXRob2QsIGJ1dFxuICAgICAgICAvLyBoYW5kbGluZyBnbG9ic3RhcnMgaXMgYSBiaXQgb2YgYSBwaXRhLCBhbmQgdGhhdCBjb2RlIGFscmVhZHkgbGl2ZXNcbiAgICAgICAgLy8gaW4gbWluaW1hdGNoIGFueXdheS5cbiAgICAgICAgLy8gQW5vdGhlciB3YXkgd291bGQgYmUgaWYgbWF5YmUgTWluaW1hdGNoIGNvdWxkIHRha2UgaXRzIHNldC9nbG9iUGFydHNcbiAgICAgICAgLy8gYXMgYW4gb3B0aW9uLCBhbmQgdGhlbiB3ZSBjb3VsZCBhdCBsZWFzdCBqdXN0IHVzZSBQYXR0ZXJuIHRvIHRlc3RcbiAgICAgICAgLy8gZm9yIGFic29sdXRlLW5lc3MuXG4gICAgICAgIC8vIFlldCBhbm90aGVyIHdheSwgTWluaW1hdGNoIGNvdWxkIHRha2UgYW4gYXJyYXkgb2YgZ2xvYiBzdHJpbmdzLCBhbmRcbiAgICAgICAgLy8gYSBjd2Qgb3B0aW9uLCBhbmQgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAgICAgICBjb25zdCBtbSA9IG5ldyBtaW5pbWF0Y2hfMS5NaW5pbWF0Y2goaWduLCB0aGlzLm1tb3B0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW0uc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBtbS5zZXRbaV07XG4gICAgICAgICAgICBjb25zdCBnbG9iUGFydHMgPSBtbS5nbG9iUGFydHNbaV07XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICghcGFyc2VkIHx8ICFnbG9iUGFydHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGF0dGVybiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0cmlwIG9mZiBsZWFkaW5nIC4vIHBvcnRpb25zXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvNTcwXG4gICAgICAgICAgICB3aGlsZSAocGFyc2VkWzBdID09PSAnLicgJiYgZ2xvYlBhcnRzWzBdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBnbG9iUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IHBhdHRlcm5fanNfMS5QYXR0ZXJuKHBhcnNlZCwgZ2xvYlBhcnRzLCAwLCB0aGlzLnBsYXRmb3JtKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgbWluaW1hdGNoXzEuTWluaW1hdGNoKHAuZ2xvYlN0cmluZygpLCB0aGlzLm1tb3B0cyk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdsb2JQYXJ0c1tnbG9iUGFydHMubGVuZ3RoIC0gMV0gPT09ICcqKic7XG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZSA9IHAuaXNBYnNvbHV0ZSgpO1xuICAgICAgICAgICAgaWYgKGFic29sdXRlKVxuICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGUucHVzaChtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlLnB1c2gobSk7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVDaGlsZHJlbi5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZUNoaWxkcmVuLnB1c2gobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlZChwKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gcC5mdWxscGF0aCgpO1xuICAgICAgICBjb25zdCBmdWxscGF0aHMgPSBgJHtmdWxscGF0aH0vYDtcbiAgICAgICAgY29uc3QgcmVsYXRpdmUgPSBwLnJlbGF0aXZlKCkgfHwgJy4nO1xuICAgICAgICBjb25zdCByZWxhdGl2ZXMgPSBgJHtyZWxhdGl2ZX0vYDtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMucmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKHJlbGF0aXZlKSB8fCBtLm1hdGNoKHJlbGF0aXZlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMuYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKGZ1bGxwYXRoKSB8fCBtLm1hdGNoKGZ1bGxwYXRocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGlsZHJlbklnbm9yZWQocCkge1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHAuZnVsbHBhdGgoKSArICcvJztcbiAgICAgICAgY29uc3QgcmVsYXRpdmUgPSAocC5yZWxhdGl2ZSgpIHx8ICcuJykgKyAnLyc7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLnJlbGF0aXZlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKHJlbGF0aXZlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5hYnNvbHV0ZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAobS5tYXRjaChmdWxscGF0aCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuSWdub3JlID0gSWdub3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWdub3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/ignore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;\nexports.globStreamSync = globStreamSync;\nexports.globStream = globStream;\nexports.globSync = globSync;\nexports.globIterateSync = globIterateSync;\nexports.globIterate = globIterate;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\nconst glob_js_1 = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/dist/commonjs/glob.js\");\nconst has_magic_js_1 = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/glob/dist/commonjs/has-magic.js\");\nvar minimatch_2 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return minimatch_2.escape; } }));\nObject.defineProperty(exports, \"unescape\", ({ enumerable: true, get: function () { return minimatch_2.unescape; } }));\nvar glob_js_2 = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/dist/commonjs/glob.js\");\nObject.defineProperty(exports, \"Glob\", ({ enumerable: true, get: function () { return glob_js_2.Glob; } }));\nvar has_magic_js_2 = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/glob/dist/commonjs/has-magic.js\");\nObject.defineProperty(exports, \"hasMagic\", ({ enumerable: true, get: function () { return has_magic_js_2.hasMagic; } }));\nvar ignore_js_1 = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/commonjs/ignore.js\");\nObject.defineProperty(exports, \"Ignore\", ({ enumerable: true, get: function () { return ignore_js_1.Ignore; } }));\nfunction globStreamSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).streamSync();\n}\nfunction globStream(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).stream();\n}\nfunction globSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).walk();\n}\nfunction globIterateSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).iterateSync();\n}\nfunction globIterate(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexports.streamSync = globStreamSync;\nexports.stream = Object.assign(globStream, { sync: globStreamSync });\nexports.iterateSync = globIterateSync;\nexports.iterate = Object.assign(globIterate, {\n    sync: globIterateSync,\n});\nexports.sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync,\n});\nexports.glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync: exports.sync,\n    globStream,\n    stream: exports.stream,\n    globStreamSync,\n    streamSync: exports.streamSync,\n    globIterate,\n    iterate: exports.iterate,\n    globIterateSync,\n    iterateSync: exports.iterateSync,\n    Glob: glob_js_1.Glob,\n    hasMagic: has_magic_js_1.hasMagic,\n    escape: minimatch_1.escape,\n    unescape: minimatch_1.unescape,\n});\nexports.glob.glob = exports.glob;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLGdCQUFnQixHQUFHLGNBQWM7QUFDaE0sc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBVztBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBVztBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsd0VBQVc7QUFDckMsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLDRDQUEyQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNuSCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBVztBQUNuQyx3Q0FBdUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDekcscUJBQXFCLG1CQUFPLENBQUMsNEVBQWdCO0FBQzdDLDRDQUEyQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN0SCxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYTtBQUN2QywwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYywrQkFBK0Isc0JBQXNCO0FBQ25FLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2Y7QUFDQSxDQUFDO0FBQ0QsWUFBWTtBQUNaO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdsb2IgPSBleHBvcnRzLnN5bmMgPSBleHBvcnRzLml0ZXJhdGUgPSBleHBvcnRzLml0ZXJhdGVTeW5jID0gZXhwb3J0cy5zdHJlYW0gPSBleHBvcnRzLnN0cmVhbVN5bmMgPSBleHBvcnRzLklnbm9yZSA9IGV4cG9ydHMuaGFzTWFnaWMgPSBleHBvcnRzLkdsb2IgPSBleHBvcnRzLnVuZXNjYXBlID0gZXhwb3J0cy5lc2NhcGUgPSB2b2lkIDA7XG5leHBvcnRzLmdsb2JTdHJlYW1TeW5jID0gZ2xvYlN0cmVhbVN5bmM7XG5leHBvcnRzLmdsb2JTdHJlYW0gPSBnbG9iU3RyZWFtO1xuZXhwb3J0cy5nbG9iU3luYyA9IGdsb2JTeW5jO1xuZXhwb3J0cy5nbG9iSXRlcmF0ZVN5bmMgPSBnbG9iSXRlcmF0ZVN5bmM7XG5leHBvcnRzLmdsb2JJdGVyYXRlID0gZ2xvYkl0ZXJhdGU7XG5jb25zdCBtaW5pbWF0Y2hfMSA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XG5jb25zdCBnbG9iX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iLmpzXCIpO1xuY29uc3QgaGFzX21hZ2ljX2pzXzEgPSByZXF1aXJlKFwiLi9oYXMtbWFnaWMuanNcIik7XG52YXIgbWluaW1hdGNoXzIgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5pbWF0Y2hfMi5lc2NhcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluaW1hdGNoXzIudW5lc2NhcGU7IH0gfSk7XG52YXIgZ2xvYl9qc18yID0gcmVxdWlyZShcIi4vZ2xvYi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdsb2JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JfanNfMi5HbG9iOyB9IH0pO1xudmFyIGhhc19tYWdpY19qc18yID0gcmVxdWlyZShcIi4vaGFzLW1hZ2ljLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzTWFnaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc19tYWdpY19qc18yLmhhc01hZ2ljOyB9IH0pO1xudmFyIGlnbm9yZV9qc18xID0gcmVxdWlyZShcIi4vaWdub3JlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWdub3JlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZ25vcmVfanNfMS5JZ25vcmU7IH0gfSk7XG5mdW5jdGlvbiBnbG9iU3RyZWFtU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLnN0cmVhbVN5bmMoKTtcbn1cbmZ1bmN0aW9uIGdsb2JTdHJlYW0ocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBnbG9iX2pzXzEuR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5zdHJlYW0oKTtcbn1cbmZ1bmN0aW9uIGdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgZ2xvYl9qc18xLkdsb2IocGF0dGVybiwgb3B0aW9ucykud2Fsa1N5bmMoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdsb2JfKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgZ2xvYl9qc18xLkdsb2IocGF0dGVybiwgb3B0aW9ucykud2FsaygpO1xufVxuZnVuY3Rpb24gZ2xvYkl0ZXJhdGVTeW5jKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgZ2xvYl9qc18xLkdsb2IocGF0dGVybiwgb3B0aW9ucykuaXRlcmF0ZVN5bmMoKTtcbn1cbmZ1bmN0aW9uIGdsb2JJdGVyYXRlKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgZ2xvYl9qc18xLkdsb2IocGF0dGVybiwgb3B0aW9ucykuaXRlcmF0ZSgpO1xufVxuLy8gYWxpYXNlczogZ2xvYi5zeW5jLnN0cmVhbSgpIGdsb2Iuc3RyZWFtLnN5bmMoKSBnbG9iLnN5bmMoKSBldGNcbmV4cG9ydHMuc3RyZWFtU3luYyA9IGdsb2JTdHJlYW1TeW5jO1xuZXhwb3J0cy5zdHJlYW0gPSBPYmplY3QuYXNzaWduKGdsb2JTdHJlYW0sIHsgc3luYzogZ2xvYlN0cmVhbVN5bmMgfSk7XG5leHBvcnRzLml0ZXJhdGVTeW5jID0gZ2xvYkl0ZXJhdGVTeW5jO1xuZXhwb3J0cy5pdGVyYXRlID0gT2JqZWN0LmFzc2lnbihnbG9iSXRlcmF0ZSwge1xuICAgIHN5bmM6IGdsb2JJdGVyYXRlU3luYyxcbn0pO1xuZXhwb3J0cy5zeW5jID0gT2JqZWN0LmFzc2lnbihnbG9iU3luYywge1xuICAgIHN0cmVhbTogZ2xvYlN0cmVhbVN5bmMsXG4gICAgaXRlcmF0ZTogZ2xvYkl0ZXJhdGVTeW5jLFxufSk7XG5leHBvcnRzLmdsb2IgPSBPYmplY3QuYXNzaWduKGdsb2JfLCB7XG4gICAgZ2xvYjogZ2xvYl8sXG4gICAgZ2xvYlN5bmMsXG4gICAgc3luYzogZXhwb3J0cy5zeW5jLFxuICAgIGdsb2JTdHJlYW0sXG4gICAgc3RyZWFtOiBleHBvcnRzLnN0cmVhbSxcbiAgICBnbG9iU3RyZWFtU3luYyxcbiAgICBzdHJlYW1TeW5jOiBleHBvcnRzLnN0cmVhbVN5bmMsXG4gICAgZ2xvYkl0ZXJhdGUsXG4gICAgaXRlcmF0ZTogZXhwb3J0cy5pdGVyYXRlLFxuICAgIGdsb2JJdGVyYXRlU3luYyxcbiAgICBpdGVyYXRlU3luYzogZXhwb3J0cy5pdGVyYXRlU3luYyxcbiAgICBHbG9iOiBnbG9iX2pzXzEuR2xvYixcbiAgICBoYXNNYWdpYzogaGFzX21hZ2ljX2pzXzEuaGFzTWFnaWMsXG4gICAgZXNjYXBlOiBtaW5pbWF0Y2hfMS5lc2NhcGUsXG4gICAgdW5lc2NhcGU6IG1pbmltYXRjaF8xLnVuZXNjYXBlLFxufSk7XG5leHBvcnRzLmdsb2IuZ2xvYiA9IGV4cG9ydHMuZ2xvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/pattern.js":
/*!****************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/pattern.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// this is just a very light wrapper around 2 arrays with an offset index\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Pattern = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0 ?\n                    this.isAbsolute() ?\n                        this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ?\n            this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ?\n            this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ?\n            this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?\n            p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\nexports.Pattern = Pattern;\n//# sourceMappingURL=pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3BhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Ysb0JBQW9CLG1CQUFPLENBQUMsd0VBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbmdoYW90YWkvRGVza3RvcC9lbHZlbmxhYi9IVFYvbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9jb21tb25qcy9wYXR0ZXJuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdGhpcyBpcyBqdXN0IGEgdmVyeSBsaWdodCB3cmFwcGVyIGFyb3VuZCAyIGFycmF5cyB3aXRoIGFuIG9mZnNldCBpbmRleFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXR0ZXJuID0gdm9pZCAwO1xuY29uc3QgbWluaW1hdGNoXzEgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuY29uc3QgaXNQYXR0ZXJuTGlzdCA9IChwbCkgPT4gcGwubGVuZ3RoID49IDE7XG5jb25zdCBpc0dsb2JMaXN0ID0gKGdsKSA9PiBnbC5sZW5ndGggPj0gMTtcbi8qKlxuICogQW4gaW1tdXRhYmxlLWlzaCB2aWV3IG9uIGFuIGFycmF5IG9mIGdsb2IgcGFydHMgYW5kIHRoZWlyIHBhcnNlZFxuICogcmVzdWx0c1xuICovXG5jbGFzcyBQYXR0ZXJuIHtcbiAgICAjcGF0dGVybkxpc3Q7XG4gICAgI2dsb2JMaXN0O1xuICAgICNpbmRleDtcbiAgICBsZW5ndGg7XG4gICAgI3BsYXRmb3JtO1xuICAgICNyZXN0O1xuICAgICNnbG9iU3RyaW5nO1xuICAgICNpc0RyaXZlO1xuICAgICNpc1VOQztcbiAgICAjaXNBYnNvbHV0ZTtcbiAgICAjZm9sbG93R2xvYnN0YXIgPSB0cnVlO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5MaXN0LCBnbG9iTGlzdCwgaW5kZXgsIHBsYXRmb3JtKSB7XG4gICAgICAgIGlmICghaXNQYXR0ZXJuTGlzdChwYXR0ZXJuTGlzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VtcHR5IHBhdHRlcm4gbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNHbG9iTGlzdChnbG9iTGlzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VtcHR5IGdsb2IgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iTGlzdC5sZW5ndGggIT09IHBhdHRlcm5MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzbWF0Y2hlZCBwYXR0ZXJuIGxpc3QgYW5kIGdsb2IgbGlzdCBsZW5ndGhzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggPSBwYXR0ZXJuTGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BhdHRlcm5MaXN0ID0gcGF0dGVybkxpc3Q7XG4gICAgICAgIHRoaXMuI2dsb2JMaXN0ID0gZ2xvYkxpc3Q7XG4gICAgICAgIHRoaXMuI2luZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuI3BsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIC8vIG5vcm1hbGl6ZSByb290IGVudHJpZXMgb2YgYWJzb2x1dGUgcGF0dGVybnMgb24gaW5pdGlhbCBjcmVhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuI2luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjOiA9PiBbJ2M6LyddXG4gICAgICAgICAgICAvLyBDOi8gPT4gWydDOi8nXVxuICAgICAgICAgICAgLy8gQzoveCA9PiBbJ0M6LycsICd4J11cbiAgICAgICAgICAgIC8vIC8vaG9zdC9zaGFyZSA9PiBbJy8vaG9zdC9zaGFyZS8nXVxuICAgICAgICAgICAgLy8gLy9ob3N0L3NoYXJlLyA9PiBbJy8vaG9zdC9zaGFyZS8nXVxuICAgICAgICAgICAgLy8gLy9ob3N0L3NoYXJlL3ggPT4gWycvL2hvc3Qvc2hhcmUvJywgJ3gnXVxuICAgICAgICAgICAgLy8gL2V0YyA9PiBbJy8nLCAnZXRjJ11cbiAgICAgICAgICAgIC8vIC8gPT4gWycvJ11cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVU5DKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAnJyAvICcnIC8gJ2hvc3QnIC8gJ3NoYXJlJ1xuICAgICAgICAgICAgICAgIGNvbnN0IFtwMCwgcDEsIHAyLCBwMywgLi4ucHJlc3RdID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgICAgICAgICAgY29uc3QgW2cwLCBnMSwgZzIsIGczLCAuLi5ncmVzdF0gPSB0aGlzLiNnbG9iTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAocHJlc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZHMgaW4gL1xuICAgICAgICAgICAgICAgICAgICBwcmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBncmVzdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwID0gW3AwLCBwMSwgcDIsIHAzLCAnJ10uam9pbignLycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBbZzAsIGcxLCBnMiwgZzMsICcnXS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGF0dGVybkxpc3QgPSBbcCwgLi4ucHJlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2dsb2JMaXN0ID0gW2csIC4uLmdyZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuI3BhdHRlcm5MaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNEcml2ZSgpIHx8IHRoaXMuaXNBYnNvbHV0ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3AxLCAuLi5wcmVzdF0gPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgICAgICAgICBjb25zdCBbZzEsIC4uLmdyZXN0XSA9IHRoaXMuI2dsb2JMaXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcmVzdFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kcyBpbiAvXG4gICAgICAgICAgICAgICAgICAgIHByZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGdyZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwMSArICcvJztcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gZzEgKyAnLyc7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGF0dGVybkxpc3QgPSBbcCwgLi4ucHJlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2dsb2JMaXN0ID0gW2csIC4uLmdyZXN0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuI3BhdHRlcm5MaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgZW50cnkgaW4gdGhlIHBhcnNlZCBsaXN0IG9mIHBhdHRlcm5zXG4gICAgICovXG4gICAgcGF0dGVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBvZiBpZiBwYXR0ZXJuKCkgcmV0dXJucyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGlzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuI3BhdHRlcm5MaXN0W3RoaXMuI2luZGV4XSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgb2YgaWYgcGF0dGVybigpIHJldHVybnMgR0xPQlNUQVJcbiAgICAgKi9cbiAgICBpc0dsb2JzdGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdID09PSBtaW5pbWF0Y2hfMS5HTE9CU1RBUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiBwYXR0ZXJuKCkgcmV0dXJucyBhIHJlZ2V4cFxuICAgICAqL1xuICAgIGlzUmVnRXhwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgLy1qb2luZWQgc2V0IG9mIGdsb2IgcGFydHMgdGhhdCBtYWtlIHVwIHRoaXMgcGF0dGVyblxuICAgICAqL1xuICAgIGdsb2JTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jZ2xvYlN0cmluZyA9XG4gICAgICAgICAgICB0aGlzLiNnbG9iU3RyaW5nIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuI2luZGV4ID09PSAwID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Fic29sdXRlKCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZ2xvYkxpc3RbMF0gKyB0aGlzLiNnbG9iTGlzdC5zbGljZSgxKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy4jZ2xvYkxpc3Quam9pbignLycpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy4jZ2xvYkxpc3Quc2xpY2UodGhpcy4jaW5kZXgpLmpvaW4oJy8nKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZXJlIGFyZSBtb3JlIHBhdHRlcm4gcGFydHMgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgKi9cbiAgICBoYXNNb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiB0aGlzLiNpbmRleCArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyIHRoaXMgcGFydCwgb3IgbnVsbCBpZiB0aGlzIGlzIHRoZSBlbmRcbiAgICAgKi9cbiAgICByZXN0KCkge1xuICAgICAgICBpZiAodGhpcy4jcmVzdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3Q7XG4gICAgICAgIGlmICghdGhpcy5oYXNNb3JlKCkpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3Jlc3QgPSBudWxsKTtcbiAgICAgICAgdGhpcy4jcmVzdCA9IG5ldyBQYXR0ZXJuKHRoaXMuI3BhdHRlcm5MaXN0LCB0aGlzLiNnbG9iTGlzdCwgdGhpcy4jaW5kZXggKyAxLCB0aGlzLiNwbGF0Zm9ybSk7XG4gICAgICAgIHRoaXMuI3Jlc3QuI2lzQWJzb2x1dGUgPSB0aGlzLiNpc0Fic29sdXRlO1xuICAgICAgICB0aGlzLiNyZXN0LiNpc1VOQyA9IHRoaXMuI2lzVU5DO1xuICAgICAgICB0aGlzLiNyZXN0LiNpc0RyaXZlID0gdGhpcy4jaXNEcml2ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHBhdHRlcm4gcmVwcmVzZW50cyBhIC8vdW5jL3BhdGgvIG9uIHdpbmRvd3NcbiAgICAgKi9cbiAgICBpc1VOQygpIHtcbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzVU5DICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy4jaXNVTkNcbiAgICAgICAgICAgIDogKHRoaXMuI2lzVU5DID1cbiAgICAgICAgICAgICAgICB0aGlzLiNwbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNpbmRleCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBwbFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcGxbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwbFsyXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgISFwbFsyXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGxbM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICEhcGxbM10pO1xuICAgIH1cbiAgICAvLyBwYXR0ZXJuIGxpa2UgQzovLi4uXG4gICAgLy8gc3BsaXQgPSBbJ0M6JywgLi4uXVxuICAgIC8vIFhYWDogd291bGQgYmUgbmljZSB0byBoYW5kbGUgcGF0dGVybnMgbGlrZSBgYzoqYCB0byB0ZXN0IHRoZSBjd2RcbiAgICAvLyBpbiBjOiBmb3IgKiwgYnV0IEkgZG9uJ3Qga25vdyBvZiBhIHdheSB0byBldmVuIGZpZ3VyZSBvdXQgd2hhdCB0aGF0XG4gICAgLy8gY3dkIGlzIHdpdGhvdXQgYWN0dWFsbHkgY2hkaXInaW5nIGludG8gaXQ/XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBhIGRyaXZlIGxldHRlciBvbiBXaW5kb3dzXG4gICAgICovXG4gICAgaXNEcml2ZSgpIHtcbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzRHJpdmUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLiNpc0RyaXZlXG4gICAgICAgICAgICA6ICh0aGlzLiNpc0RyaXZlID1cbiAgICAgICAgICAgICAgICB0aGlzLiNwbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNpbmRleCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBsWzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBsWzBdKSk7XG4gICAgfVxuICAgIC8vIHBhdHRlcm4gPSAnLycgb3IgJy8uLi4nIG9yICcveC8uLi4nXG4gICAgLy8gc3BsaXQgPSBbJycsICcnXSBvciBbJycsIC4uLl0gb3IgWycnLCAneCcsIC4uLl1cbiAgICAvLyBEcml2ZSBhbmQgVU5DIGJvdGggY29uc2lkZXJlZCBhYnNvbHV0ZSBvbiB3aW5kb3dzXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcGF0dGVybiBpcyByb290ZWQgb24gYW4gYWJzb2x1dGUgcGF0aFxuICAgICAqL1xuICAgIGlzQWJzb2x1dGUoKSB7XG4gICAgICAgIGNvbnN0IHBsID0gdGhpcy4jcGF0dGVybkxpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc0Fic29sdXRlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy4jaXNBYnNvbHV0ZVxuICAgICAgICAgICAgOiAodGhpcy4jaXNBYnNvbHV0ZSA9XG4gICAgICAgICAgICAgICAgKHBsWzBdID09PSAnJyAmJiBwbC5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJpdmUoKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVU5DKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25zdW1lIHRoZSByb290IG9mIHRoZSBwYXR0ZXJuLCBhbmQgcmV0dXJuIGl0XG4gICAgICovXG4gICAgcm9vdCgpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuI3BhdHRlcm5MaXN0WzBdO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBwID09PSAnc3RyaW5nJyAmJiB0aGlzLmlzQWJzb2x1dGUoKSAmJiB0aGlzLiNpbmRleCA9PT0gMCkgP1xuICAgICAgICAgICAgcFxuICAgICAgICAgICAgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IGdsb2JzdGFyIHBhdHRlcm4gaXMgYWxsb3dlZCB0byBmb2xsb3dcbiAgICAgKiBhIHN5bWJvbGljIGxpbmsuXG4gICAgICovXG4gICAgY2hlY2tGb2xsb3dHbG9ic3RhcigpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy4jaW5kZXggPT09IDAgfHxcbiAgICAgICAgICAgICF0aGlzLmlzR2xvYnN0YXIoKSB8fFxuICAgICAgICAgICAgIXRoaXMuI2ZvbGxvd0dsb2JzdGFyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayB0aGF0IHRoZSBjdXJyZW50IGdsb2JzdGFyIHBhdHRlcm4gaXMgZm9sbG93aW5nIGEgc3ltYm9saWMgbGlua1xuICAgICAqL1xuICAgIG1hcmtGb2xsb3dHbG9ic3RhcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2luZGV4ID09PSAwIHx8ICF0aGlzLmlzR2xvYnN0YXIoKSB8fCAhdGhpcy4jZm9sbG93R2xvYnN0YXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuI2ZvbGxvd0dsb2JzdGFyID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0dGVybiA9IFBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/processor.js":
/*!******************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/processor.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/commonjs/index.js\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache =\n            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined ?\n                    this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === minimatch_1.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch_1.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\nexports.Processor = Processor;\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQjtBQUNuRixvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YW5naGFvdGFpL0Rlc2t0b3AvZWx2ZW5sYWIvSFRWL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvcHJvY2Vzc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gc3luY2hyb25vdXMgdXRpbGl0eSBmb3IgZmlsdGVyaW5nIGVudHJpZXMgYW5kIGNhbGN1bGF0aW5nIHN1YndhbGtzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2Nlc3NvciA9IGV4cG9ydHMuU3ViV2Fsa3MgPSBleHBvcnRzLk1hdGNoUmVjb3JkID0gZXhwb3J0cy5IYXNXYWxrZWRDYWNoZSA9IHZvaWQgMDtcbmNvbnN0IG1pbmltYXRjaF8xID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbi8qKlxuICogQSBjYWNoZSBvZiB3aGljaCBwYXR0ZXJucyBoYXZlIGJlZW4gcHJvY2Vzc2VkIGZvciBhIGdpdmVuIFBhdGhcbiAqL1xuY2xhc3MgSGFzV2Fsa2VkQ2FjaGUge1xuICAgIHN0b3JlO1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlID0gbmV3IE1hcCgpKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIYXNXYWxrZWRDYWNoZShuZXcgTWFwKHRoaXMuc3RvcmUpKTtcbiAgICB9XG4gICAgaGFzV2Fsa2VkKHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXQodGFyZ2V0LmZ1bGxwYXRoKCkpPy5oYXMocGF0dGVybi5nbG9iU3RyaW5nKCkpO1xuICAgIH1cbiAgICBzdG9yZVdhbGtlZCh0YXJnZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0YXJnZXQuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5zdG9yZS5nZXQoZnVsbHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgY2FjaGVkLmFkZChwYXR0ZXJuLmdsb2JTdHJpbmcoKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0KGZ1bGxwYXRoLCBuZXcgU2V0KFtwYXR0ZXJuLmdsb2JTdHJpbmcoKV0pKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc1dhbGtlZENhY2hlID0gSGFzV2Fsa2VkQ2FjaGU7XG4vKipcbiAqIEEgcmVjb3JkIG9mIHdoaWNoIHBhdGhzIGhhdmUgYmVlbiBtYXRjaGVkIGluIGEgZ2l2ZW4gd2FsayBzdGVwLFxuICogYW5kIHdoZXRoZXIgdGhleSBvbmx5IGFyZSBjb25zaWRlcmVkIGEgbWF0Y2ggaWYgdGhleSBhcmUgYSBkaXJlY3RvcnksXG4gKiBhbmQgd2hldGhlciB0aGVpciBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIHNob3VsZCBiZSByZXR1cm5lZC5cbiAqL1xuY2xhc3MgTWF0Y2hSZWNvcmQge1xuICAgIHN0b3JlID0gbmV3IE1hcCgpO1xuICAgIGFkZCh0YXJnZXQsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBuID0gKGFic29sdXRlID8gMiA6IDApIHwgKGlmRGlyID8gMSA6IDApO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zdG9yZS5zZXQodGFyZ2V0LCBjdXJyZW50ID09PSB1bmRlZmluZWQgPyBuIDogbiAmIGN1cnJlbnQpO1xuICAgIH1cbiAgICAvLyBtYXRjaCwgYWJzb2x1dGUsIGlmZGlyXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnN0b3JlLmVudHJpZXMoKV0ubWFwKChbcGF0aCwgbl0pID0+IFtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAhIShuICYgMiksXG4gICAgICAgICAgICAhIShuICYgMSksXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWF0Y2hSZWNvcmQgPSBNYXRjaFJlY29yZDtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHBhdHRlcm5zIHRoYXQgbXVzdCBiZSBwcm9jZXNzZWQgaW4gYSBzdWJzZXF1ZW50IHN0ZXBcbiAqIGZvciBhIGdpdmVuIHBhdGguXG4gKi9cbmNsYXNzIFN1YldhbGtzIHtcbiAgICBzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICBhZGQodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghdGFyZ2V0LmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN0b3JlLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgaWYgKCFzdWJzLmZpbmQocCA9PiBwLmdsb2JTdHJpbmcoKSA9PT0gcGF0dGVybi5nbG9iU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgc3Vicy5wdXNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0KHRhcmdldCwgW3BhdHRlcm5dKTtcbiAgICB9XG4gICAgZ2V0KHRhcmdldCkge1xuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghc3Vicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0aW5nIHRvIHdhbGsgdW5rbm93biBwYXRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHN1YnM7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5tYXAoayA9PiBbaywgdGhpcy5zdG9yZS5nZXQoayldKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnN0b3JlLmtleXMoKV0uZmlsdGVyKHQgPT4gdC5jYW5SZWFkZGlyKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViV2Fsa3MgPSBTdWJXYWxrcztcbi8qKlxuICogVGhlIGNsYXNzIHRoYXQgcHJvY2Vzc2VzIHBhdHRlcm5zIGZvciBhIGdpdmVuIHBhdGguXG4gKlxuICogSGFuZGxlcyBjaGlsZCBlbnRyeSBmaWx0ZXJpbmcsIGFuZCBkZXRlcm1pbmluZyB3aGV0aGVyIGEgcGF0aCdzXG4gKiBkaXJlY3RvcnkgY29udGVudHMgbXVzdCBiZSByZWFkLlxuICovXG5jbGFzcyBQcm9jZXNzb3Ige1xuICAgIGhhc1dhbGtlZENhY2hlO1xuICAgIG1hdGNoZXMgPSBuZXcgTWF0Y2hSZWNvcmQoKTtcbiAgICBzdWJ3YWxrcyA9IG5ldyBTdWJXYWxrcygpO1xuICAgIHBhdHRlcm5zO1xuICAgIGZvbGxvdztcbiAgICBkb3Q7XG4gICAgb3B0cztcbiAgICBjb25zdHJ1Y3RvcihvcHRzLCBoYXNXYWxrZWRDYWNoZSkge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmZvbGxvdyA9ICEhb3B0cy5mb2xsb3c7XG4gICAgICAgIHRoaXMuZG90ID0gISFvcHRzLmRvdDtcbiAgICAgICAgdGhpcy5oYXNXYWxrZWRDYWNoZSA9XG4gICAgICAgICAgICBoYXNXYWxrZWRDYWNoZSA/IGhhc1dhbGtlZENhY2hlLmNvcHkoKSA6IG5ldyBIYXNXYWxrZWRDYWNoZSgpO1xuICAgIH1cbiAgICBwcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdTZXQgPSBwYXR0ZXJucy5tYXAocCA9PiBbdGFyZ2V0LCBwXSk7XG4gICAgICAgIC8vIG1hcCBvZiBwYXRocyB0byB0aGUgbWFnaWMtc3RhcnRpbmcgc3Vid2Fsa3MgdGhleSBuZWVkIHRvIHdhbGtcbiAgICAgICAgLy8gZmlyc3QgaXRlbSBpbiBwYXR0ZXJucyBpcyB0aGUgZmlsdGVyXG4gICAgICAgIGZvciAobGV0IFt0LCBwYXR0ZXJuXSBvZiBwcm9jZXNzaW5nU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dhbGtlZENhY2hlLnN0b3JlV2Fsa2VkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHBhdHRlcm4ucm9vdCgpO1xuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwYXR0ZXJuLmlzQWJzb2x1dGUoKSAmJiB0aGlzLm9wdHMuYWJzb2x1dGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgLy8gc3RhcnQgYWJzb2x1dGUgcGF0dGVybnMgYXQgcm9vdFxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICB0ID0gdC5yZXNvbHZlKHJvb3QgPT09ICcvJyAmJiB0aGlzLm9wdHMucm9vdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLnJvb3RcbiAgICAgICAgICAgICAgICAgICAgOiByb290KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gcGF0dGVybi5yZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0LmlzRU5PRU5UKCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgIGxldCByZXN0O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgKHAgPSBwYXR0ZXJuLnBhdHRlcm4oKSkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgKHJlc3QgPSBwYXR0ZXJuLnJlc3QoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdC5yZXNvbHZlKHApO1xuICAgICAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXN0O1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHBhdHRlcm4ucGF0dGVybigpO1xuICAgICAgICAgICAgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXYWxrZWRDYWNoZS5oYXNXYWxrZWQodCwgcGF0dGVybikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzV2Fsa2VkQ2FjaGUuc3RvcmVXYWxrZWQodCwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cgd2UgaGF2ZSBlaXRoZXIgYSBmaW5hbCBzdHJpbmcgZm9yIGEga25vd24gZW50cnksXG4gICAgICAgICAgICAvLyBtb3JlIHN0cmluZ3MgZm9yIGFuIHVua25vd24gZW50cnksXG4gICAgICAgICAgICAvLyBvciBhIHBhdHRlcm4gc3RhcnRpbmcgd2l0aCBtYWdpYywgbW91bnRlZCBvbiB0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIG11c3Qgbm90IGJlIGZpbmFsIGVudHJ5LCBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIGNvbmNhdGVuYXRlZCBpdCBlYXJsaWVyLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlmRGlyID0gcCA9PT0gJy4uJyB8fCBwID09PSAnJyB8fCBwID09PSAnLic7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0LnJlc29sdmUocCksIGFic29sdXRlLCBpZkRpcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSBtaW5pbWF0Y2hfMS5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHJlc3QsIG1hdGNoIGFuZCBzdWJ3YWxrIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAvLyBpZiByZXN0LCBwcm9jZXNzIHJlc3QgYW5kIHN1YndhbGsgcGF0dGVyblxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBzeW1saW5rLCBidXQgd2UgZGlkbid0IGdldCBoZXJlIGJ5IHdheSBvZiBhXG4gICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgbWF0Y2ggKG1lYW5pbmcgaXQncyB0aGUgZmlyc3QgdGltZSBUSElTIGdsb2JzdGFyXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRyYXZlcnNlZCBhIHN5bWxpbmspLCB0aGVuIHdlIGZvbGxvdyBpdC4gT3RoZXJ3aXNlLCBzdG9wLlxuICAgICAgICAgICAgICAgIGlmICghdC5pc1N5bWJvbGljTGluaygpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sbG93IHx8XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uY2hlY2tGb2xsb3dHbG9ic3RhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBycCA9IHJlc3Q/LnBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBycmVzdCA9IHJlc3Q/LnJlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3QgfHwgKChycCA9PT0gJycgfHwgcnAgPT09ICcuJykgJiYgIXJyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IEhBUyB0byBiZSBhIGRpciBpZiBpdCBlbmRzIGluICoqLyBvciAqKi8uXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBlbmRpbmcgaW4gKiogd2lsbCBtYXRjaCBmaWxlcyBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHQsIGFic29sdXRlLCBycCA9PT0gJycgfHwgcnAgPT09ICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnAgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgbWVhbiB5b3UncmUgbWF0Y2hpbmcgKiovLi4gYXQgdGhlIGZzIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm8gdGhhbmtzLCBJJ20gbm90IGdvbm5hIHRlc3QgdGhhdCBzcGVjaWZpYyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cCA9IHQucGFyZW50IHx8IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFycmVzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHRwLCBhYnNvbHV0ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNXYWxrZWRDYWNoZS5oYXNXYWxrZWQodHAsIHJyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHRwLCBycmVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQodCwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN1YndhbGtUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ3YWxrcy5rZXlzKCk7XG4gICAgfVxuICAgIGNoaWxkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3Nvcih0aGlzLm9wdHMsIHRoaXMuaGFzV2Fsa2VkQ2FjaGUpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gYSBuZXcgUHJvY2Vzc29yIGNvbnRhaW5pbmcgdGhlIHN1YndhbGtzIGZvciBlYWNoXG4gICAgLy8gY2hpbGQgZW50cnksIGFuZCBhIHNldCBvZiBtYXRjaGVzLCBhbmRcbiAgICAvLyBhIGhhc1dhbGtlZENhY2hlIHRoYXQncyBhIGNvcHkgb2YgdGhpcyBvbmVcbiAgICAvLyB0aGVuIHdlJ3JlIGdvaW5nIHRvIGNhbGxcbiAgICBmaWx0ZXJFbnRyaWVzKHBhcmVudCwgZW50cmllcykge1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IHRoaXMuc3Vid2Fsa3MuZ2V0KHBhcmVudCk7XG4gICAgICAgIC8vIHB1dCBtYXRjaGVzIGFuZCBlbnRyeSB3YWxrcyBpbnRvIHRoZSByZXN1bHRzIHByb2Nlc3NvclxuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5jaGlsZCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwYXR0ZXJuLmlzQWJzb2x1dGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0dGVybi5wYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSBtaW5pbWF0Y2hfMS5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnRlc3RHbG9ic3RhcihlLCBwYXR0ZXJuLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy50ZXN0UmVnRXhwKGUsIHAsIHJlc3QsIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudGVzdFN0cmluZyhlLCBwLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICB0ZXN0R2xvYnN0YXIoZSwgcGF0dGVybiwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZG90IHx8ICFlLm5hbWUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4uaGFzTW9yZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlLCBhYnNvbHV0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gZm9sbG93IG1vZGUgb3IgaXQncyBub3QgYSBzeW1saW5rLCBqdXN0IGtlZXBcbiAgICAgICAgICAgICAgICAvLyB0ZXN0aW5nIHRoZSBzYW1lIHBhdHRlcm4uIElmIHRoZXJlJ3MgbW9yZSBhZnRlciB0aGUgZ2xvYnN0YXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB0aGlzIHN5bWxpbmsgY29uc3VtZXMgdGhlIGdsb2JzdGFyLiBJZiBub3QsIHRoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gZm9sbG93IGF0IG1vc3QgT05FIHN5bWxpbmsgYWxvbmcgdGhlIHdheSwgc28gd2UgbWFyayBpdCwgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGNoZWNrcyB0byBlbnN1cmUgdGhhdCBpdCB3YXNuJ3QgYWxyZWFkeSBtYXJrZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sbG93IHx8ICFlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCAmJiBwYXR0ZXJuLmNoZWNrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybi5tYXJrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIE5FWFQgdGhpbmcgbWF0Y2hlcyB0aGlzIGVudHJ5LCB0aGVuIGFsc28gYWRkXG4gICAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgY29uc3QgcnAgPSByZXN0LnBhdHRlcm4oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnAgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgLy8gZG90cyBhbmQgZW1wdHkgd2VyZSBoYW5kbGVkIGFscmVhZHlcbiAgICAgICAgICAgICAgICBycCAhPT0gJy4uJyAmJlxuICAgICAgICAgICAgICAgIHJwICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgIHJwICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RTdHJpbmcoZSwgcnAsIHJlc3QucmVzdCgpLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChycCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGVwID0gZS5wYXJlbnQgfHwgZTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGVwLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0UmVnRXhwKGUsIHJwLCByZXN0LnJlc3QoKSwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRlc3RSZWdFeHAoZSwgcCwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKCFwLnRlc3QoZS5uYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUsIGFic29sdXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCByZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXN0U3RyaW5nKGUsIHAsIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4/XG4gICAgICAgIGlmICghZS5pc05hbWVkKHApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSwgYWJzb2x1dGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHJlc3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/walker.js":
/*!***************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/walker.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nconst minipass_1 = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/commonjs/index.js\");\nconst ignore_js_1 = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/commonjs/ignore.js\");\nconst processor_js_1 = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/glob/dist/commonjs/processor.js\");\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts)\n    : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    includeChildMatches;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches &&\n                typeof this.#ignore.add !== 'function') {\n                const m = 'cannot ignore child matches, ignore lacks add() method.';\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */\n            if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n            /* c8 ignore stop */\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return (e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            (!this.opts.nodir ||\n                !this.opts.follow ||\n                !e.isSymbolicLink() ||\n                !e.realpathCached()?.isDirectory()) &&\n            !this.#ignored(e)) ?\n            e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n                '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n    matches = new Set();\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new minipass_1.Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\nexports.GlobStream = GlobStream;\n//# sourceMappingURL=walker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3dhbGtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDMUQ7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBVTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxzRUFBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyIvVXNlcnMvd2FuZ2hhb3RhaS9EZXNrdG9wL2VsdmVubGFiL0hUVi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3dhbGtlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2xvYlN0cmVhbSA9IGV4cG9ydHMuR2xvYldhbGtlciA9IGV4cG9ydHMuR2xvYlV0aWwgPSB2b2lkIDA7XG4vKipcbiAqIFNpbmdsZS11c2UgdXRpbGl0eSBjbGFzc2VzIHRvIHByb3ZpZGUgZnVuY3Rpb25hbGl0eSB0byB0aGUge0BsaW5rIEdsb2J9XG4gKiBtZXRob2RzLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgbWluaXBhc3NfMSA9IHJlcXVpcmUoXCJtaW5pcGFzc1wiKTtcbmNvbnN0IGlnbm9yZV9qc18xID0gcmVxdWlyZShcIi4vaWdub3JlLmpzXCIpO1xuY29uc3QgcHJvY2Vzc29yX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9jZXNzb3IuanNcIik7XG5jb25zdCBtYWtlSWdub3JlID0gKGlnbm9yZSwgb3B0cykgPT4gdHlwZW9mIGlnbm9yZSA9PT0gJ3N0cmluZycgPyBuZXcgaWdub3JlX2pzXzEuSWdub3JlKFtpZ25vcmVdLCBvcHRzKVxuICAgIDogQXJyYXkuaXNBcnJheShpZ25vcmUpID8gbmV3IGlnbm9yZV9qc18xLklnbm9yZShpZ25vcmUsIG9wdHMpXG4gICAgICAgIDogaWdub3JlO1xuLyoqXG4gKiBiYXNpYyB3YWxraW5nIHV0aWxpdGllcyB0aGF0IGFsbCB0aGUgZ2xvYiB3YWxrZXIgdHlwZXMgdXNlXG4gKi9cbmNsYXNzIEdsb2JVdGlsIHtcbiAgICBwYXRoO1xuICAgIHBhdHRlcm5zO1xuICAgIG9wdHM7XG4gICAgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBhYm9ydGVkID0gZmFsc2U7XG4gICAgI29uUmVzdW1lID0gW107XG4gICAgI2lnbm9yZTtcbiAgICAjc2VwO1xuICAgIHNpZ25hbDtcbiAgICBtYXhEZXB0aDtcbiAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy4jc2VwID0gIW9wdHMucG9zaXggJiYgb3B0cy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICdcXFxcJyA6ICcvJztcbiAgICAgICAgdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzID0gb3B0cy5pbmNsdWRlQ2hpbGRNYXRjaGVzICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdHMuaWdub3JlIHx8ICF0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuI2lnbm9yZSA9IG1ha2VJZ25vcmUob3B0cy5pZ25vcmUgPz8gW10sIG9wdHMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy4jaWdub3JlLmFkZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSAnY2Fubm90IGlnbm9yZSBjaGlsZCBtYXRjaGVzLCBpZ25vcmUgbGFja3MgYWRkKCkgbWV0aG9kLic7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlnbm9yZSwgYWx3YXlzIHNldCB3aXRoIG1heERlcHRoLCBidXQgaXQncyBvcHRpb25hbCBvbiB0aGVcbiAgICAgICAgLy8gR2xvYk9wdGlvbnMgdHlwZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9IG9wdHMubWF4RGVwdGggfHwgSW5maW5pdHk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChvcHRzLnNpZ25hbCkge1xuICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBvcHRzLnNpZ25hbDtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI29uUmVzdW1lLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjaWdub3JlZChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZW4uaGFzKHBhdGgpIHx8ICEhdGhpcy4jaWdub3JlPy5pZ25vcmVkPy4ocGF0aCk7XG4gICAgfVxuICAgICNjaGlsZHJlbklnbm9yZWQocGF0aCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNpZ25vcmU/LmNoaWxkcmVuSWdub3JlZD8uKHBhdGgpO1xuICAgIH1cbiAgICAvLyBiYWNrcHJlc3N1cmUgbWVjaGFuaXNtXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5wYXVzZWQgJiYgKGZuID0gdGhpcy4jb25SZXN1bWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25SZXN1bWUoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNvblJlc3VtZS5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkbyB0aGUgcmVxdWlzaXRlIHJlYWxwYXRoL3N0YXQgY2hlY2tpbmcsIGFuZCByZXR1cm4gdGhlIHBhdGhcbiAgICAvLyB0byBhZGQgb3IgdW5kZWZpbmVkIHRvIGZpbHRlciBpdCBvdXQuXG4gICAgYXN5bmMgbWF0Y2hDaGVjayhlLCBpZkRpcikge1xuICAgICAgICBpZiAoaWZEaXIgJiYgdGhpcy5vcHRzLm5vZGlyKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJwYztcbiAgICAgICAgaWYgKHRoaXMub3B0cy5yZWFscGF0aCkge1xuICAgICAgICAgICAgcnBjID0gZS5yZWFscGF0aENhY2hlZCgpIHx8IChhd2FpdCBlLnJlYWxwYXRoKCkpO1xuICAgICAgICAgICAgaWYgKCFycGMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGUgPSBycGM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZFN0YXQgPSBlLmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0O1xuICAgICAgICBjb25zdCBzID0gbmVlZFN0YXQgPyBhd2FpdCBlLmxzdGF0KCkgOiBlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmZvbGxvdyAmJiB0aGlzLm9wdHMubm9kaXIgJiYgcz8uaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgcy5yZWFscGF0aCgpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQuaXNVbmtub3duKCkgfHwgdGhpcy5vcHRzLnN0YXQpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGFyZ2V0LmxzdGF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoQ2hlY2tUZXN0KHMsIGlmRGlyKTtcbiAgICB9XG4gICAgbWF0Y2hDaGVja1Rlc3QoZSwgaWZEaXIpIHtcbiAgICAgICAgcmV0dXJuIChlICYmXG4gICAgICAgICAgICAodGhpcy5tYXhEZXB0aCA9PT0gSW5maW5pdHkgfHwgZS5kZXB0aCgpIDw9IHRoaXMubWF4RGVwdGgpICYmXG4gICAgICAgICAgICAoIWlmRGlyIHx8IGUuY2FuUmVhZGRpcigpKSAmJlxuICAgICAgICAgICAgKCF0aGlzLm9wdHMubm9kaXIgfHwgIWUuaXNEaXJlY3RvcnkoKSkgJiZcbiAgICAgICAgICAgICghdGhpcy5vcHRzLm5vZGlyIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMub3B0cy5mb2xsb3cgfHxcbiAgICAgICAgICAgICAgICAhZS5pc1N5bWJvbGljTGluaygpIHx8XG4gICAgICAgICAgICAgICAgIWUucmVhbHBhdGhDYWNoZWQoKT8uaXNEaXJlY3RvcnkoKSkgJiZcbiAgICAgICAgICAgICF0aGlzLiNpZ25vcmVkKGUpKSA/XG4gICAgICAgICAgICBlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbWF0Y2hDaGVja1N5bmMoZSwgaWZEaXIpIHtcbiAgICAgICAgaWYgKGlmRGlyICYmIHRoaXMub3B0cy5ub2RpcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBycGM7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucmVhbHBhdGgpIHtcbiAgICAgICAgICAgIHJwYyA9IGUucmVhbHBhdGhDYWNoZWQoKSB8fCBlLnJlYWxwYXRoU3luYygpO1xuICAgICAgICAgICAgaWYgKCFycGMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGUgPSBycGM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZFN0YXQgPSBlLmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0O1xuICAgICAgICBjb25zdCBzID0gbmVlZFN0YXQgPyBlLmxzdGF0U3luYygpIDogZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5mb2xsb3cgJiYgdGhpcy5vcHRzLm5vZGlyICYmIHM/LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHMucmVhbHBhdGhTeW5jKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQ/LmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5sc3RhdFN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaENoZWNrVGVzdChzLCBpZkRpcik7XG4gICAgfVxuICAgIG1hdGNoRmluaXNoKGUsIGFic29sdXRlKSB7XG4gICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyB3ZSBrbm93IHdlIGhhdmUgYW4gaWdub3JlIGlmIHRoaXMgaXMgZmFsc2UsIGJ1dCBUUyBkb2Vzbid0XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzICYmIHRoaXMuI2lnbm9yZT8uYWRkKSB7XG4gICAgICAgICAgICBjb25zdCBpZ24gPSBgJHtlLnJlbGF0aXZlUG9zaXgoKX0vKipgO1xuICAgICAgICAgICAgdGhpcy4jaWdub3JlLmFkZChpZ24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFicyA9IHRoaXMub3B0cy5hYnNvbHV0ZSA9PT0gdW5kZWZpbmVkID8gYWJzb2x1dGUgOiB0aGlzLm9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMuc2Vlbi5hZGQoZSk7XG4gICAgICAgIGNvbnN0IG1hcmsgPSB0aGlzLm9wdHMubWFyayAmJiBlLmlzRGlyZWN0b3J5KCkgPyB0aGlzLiNzZXAgOiAnJztcbiAgICAgICAgLy8gb2ssIHdlIGhhdmUgd2hhdCB3ZSBuZWVkIVxuICAgICAgICBpZiAodGhpcy5vcHRzLndpdGhGaWxlVHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hFbWl0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFicykge1xuICAgICAgICAgICAgY29uc3QgYWJzID0gdGhpcy5vcHRzLnBvc2l4ID8gZS5mdWxscGF0aFBvc2l4KCkgOiBlLmZ1bGxwYXRoKCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdChhYnMgKyBtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbCA9IHRoaXMub3B0cy5wb3NpeCA/IGUucmVsYXRpdmVQb3NpeCgpIDogZS5yZWxhdGl2ZSgpO1xuICAgICAgICAgICAgY29uc3QgcHJlID0gdGhpcy5vcHRzLmRvdFJlbGF0aXZlICYmICFyZWwuc3RhcnRzV2l0aCgnLi4nICsgdGhpcy4jc2VwKSA/XG4gICAgICAgICAgICAgICAgJy4nICsgdGhpcy4jc2VwXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2hFbWl0KCFyZWwgPyAnLicgKyBtYXJrIDogcHJlICsgcmVsICsgbWFyayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbWF0Y2goZSwgYWJzb2x1dGUsIGlmRGlyKSB7XG4gICAgICAgIGNvbnN0IHAgPSBhd2FpdCB0aGlzLm1hdGNoQ2hlY2soZSwgaWZEaXIpO1xuICAgICAgICBpZiAocClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hGaW5pc2gocCwgYWJzb2x1dGUpO1xuICAgIH1cbiAgICBtYXRjaFN5bmMoZSwgYWJzb2x1dGUsIGlmRGlyKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLm1hdGNoQ2hlY2tTeW5jKGUsIGlmRGlyKTtcbiAgICAgICAgaWYgKHApXG4gICAgICAgICAgICB0aGlzLm1hdGNoRmluaXNoKHAsIGFic29sdXRlKTtcbiAgICB9XG4gICAgd2Fsa0NCKHRhcmdldCwgcGF0dGVybnMsIGNiKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgbmV3IHByb2Nlc3Nvcl9qc18xLlByb2Nlc3Nvcih0aGlzLm9wdHMpLCBjYik7XG4gICAgfVxuICAgIHdhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBpZiAodGhpcy4jY2hpbGRyZW5JZ25vcmVkKHRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVzdW1lKCgpID0+IHRoaXMud2Fsa0NCMih0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IsIGNiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3NQYXR0ZXJucyh0YXJnZXQsIHBhdHRlcm5zKTtcbiAgICAgICAgLy8gZG9uZSBwcm9jZXNzaW5nLiAgYWxsIG9mIHRoZSBhYm92ZSBpcyBzeW5jLCBjYW4gYmUgYWJzdHJhY3RlZCBvdXQuXG4gICAgICAgIC8vIHN1YndhbGtzIGlzIGEgbWFwIG9mIHBhdGhzIHRvIHRoZSBlbnRyeSBmaWx0ZXJzIHRoZXkgbmVlZFxuICAgICAgICAvLyBtYXRjaGVzIGlzIGEgbWFwIG9mIHBhdGhzIHRvIFthYnNvbHV0ZSwgaWZEaXJdIHR1cGxlcy5cbiAgICAgICAgbGV0IHRhc2tzID0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLXRhc2tzID09PSAwKVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW20sIGFic29sdXRlLCBpZkRpcl0gb2YgcHJvY2Vzc29yLm1hdGNoZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaWdub3JlZChtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKG0sIGFic29sdXRlLCBpZkRpcikudGhlbigoKSA9PiBuZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBwcm9jZXNzb3Iuc3Vid2Fsa1RhcmdldHMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ICYmIHQuZGVwdGgoKSA+PSB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5DYWNoZWQgPSB0LnJlYWRkaXJDYWNoZWQoKTtcbiAgICAgICAgICAgIGlmICh0LmNhbGxlZFJlYWRkaXIoKSlcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtDQjModCwgY2hpbGRyZW5DYWNoZWQsIHByb2Nlc3NvciwgbmV4dCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0LnJlYWRkaXJDQigoXywgZW50cmllcykgPT4gdGhpcy53YWxrQ0IzKHQsIGVudHJpZXMsIHByb2Nlc3NvciwgbmV4dCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgd2Fsa0NCMyh0YXJnZXQsIGVudHJpZXMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc29yLmZpbHRlckVudHJpZXModGFyZ2V0LCBlbnRyaWVzKTtcbiAgICAgICAgbGV0IHRhc2tzID0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLXRhc2tzID09PSAwKVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW20sIGFic29sdXRlLCBpZkRpcl0gb2YgcHJvY2Vzc29yLm1hdGNoZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaWdub3JlZChtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKG0sIGFic29sdXRlLCBpZkRpcikudGhlbigoKSA9PiBuZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3RhcmdldCwgcGF0dGVybnNdIG9mIHByb2Nlc3Nvci5zdWJ3YWxrcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLmNoaWxkKCksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgd2Fsa0NCU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBuZXcgcHJvY2Vzc29yX2pzXzEuUHJvY2Vzc29yKHRoaXMub3B0cyksIGNiKTtcbiAgICB9XG4gICAgd2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBpZiAodGhpcy4jY2hpbGRyZW5JZ25vcmVkKHRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVzdW1lKCgpID0+IHRoaXMud2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucyk7XG4gICAgICAgIC8vIGRvbmUgcHJvY2Vzc2luZy4gIGFsbCBvZiB0aGUgYWJvdmUgaXMgc3luYywgY2FuIGJlIGFic3RyYWN0ZWQgb3V0LlxuICAgICAgICAvLyBzdWJ3YWxrcyBpcyBhIG1hcCBvZiBwYXRocyB0byB0aGUgZW50cnkgZmlsdGVycyB0aGV5IG5lZWRcbiAgICAgICAgLy8gbWF0Y2hlcyBpcyBhIG1hcCBvZiBwYXRocyB0byBbYWJzb2x1dGUsIGlmRGlyXSB0dXBsZXMuXG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm1hdGNoU3luYyhtLCBhYnNvbHV0ZSwgaWZEaXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBwcm9jZXNzb3Iuc3Vid2Fsa1RhcmdldHMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ICYmIHQuZGVwdGgoKSA+PSB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0LnJlYWRkaXJTeW5jKCk7XG4gICAgICAgICAgICB0aGlzLndhbGtDQjNTeW5jKHQsIGNoaWxkcmVuLCBwcm9jZXNzb3IsIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgd2Fsa0NCM1N5bmModGFyZ2V0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3Nvci5maWx0ZXJFbnRyaWVzKHRhcmdldCwgZW50cmllcyk7XG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm1hdGNoU3luYyhtLCBhYnNvbHV0ZSwgaWZEaXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3RhcmdldCwgcGF0dGVybnNdIG9mIHByb2Nlc3Nvci5zdWJ3YWxrcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICB0aGlzLndhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3Nvci5jaGlsZCgpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5HbG9iVXRpbCA9IEdsb2JVdGlsO1xuY2xhc3MgR2xvYldhbGtlciBleHRlbmRzIEdsb2JVdGlsIHtcbiAgICBtYXRjaGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHBhdHRlcm5zLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgbWF0Y2hFbWl0KGUpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlKTtcbiAgICB9XG4gICAgYXN5bmMgd2FsaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5zaWduYWwucmVhc29uO1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhdGgubHN0YXQoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWoodGhpcy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyh0aGlzLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgICB9XG4gICAgd2Fsa1N5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoLmxzdGF0U3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGhpbmcgZm9yIHRoZSBjYWxsYmFjayB0byBkbywgYmVjYXVzZSB0aGlzIG5ldmVyIHBhdXNlc1xuICAgICAgICB0aGlzLndhbGtDQlN5bmModGhpcy5wYXRoLCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5zaWduYWwucmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgICB9XG59XG5leHBvcnRzLkdsb2JXYWxrZXIgPSBHbG9iV2Fsa2VyO1xuY2xhc3MgR2xvYlN0cmVhbSBleHRlbmRzIEdsb2JVdGlsIHtcbiAgICByZXN1bHRzO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHBhdHRlcm5zLCBwYXRoLCBvcHRzKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gbmV3IG1pbmlwYXNzXzEuTWluaXBhc3Moe1xuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbCxcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3VsdHMub24oJ2RyYWluJywgKCkgPT4gdGhpcy5yZXN1bWUoKSk7XG4gICAgICAgIHRoaXMucmVzdWx0cy5vbigncmVzdW1lJywgKCkgPT4gdGhpcy5yZXN1bWUoKSk7XG4gICAgfVxuICAgIG1hdGNoRW1pdChlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0cy53cml0ZShlKTtcbiAgICAgICAgaWYgKCF0aGlzLnJlc3VsdHMuZmxvd2luZylcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gICAgc3RyZWFtKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICh0YXJnZXQuaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5sc3RhdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRhcmdldCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IodGFyZ2V0LCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB0aGlzLnJlc3VsdHMuZW5kKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHM7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aC5sc3RhdFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtDQlN5bmModGhpcy5wYXRoLCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB0aGlzLnJlc3VsdHMuZW5kKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuR2xvYlN0cmVhbSA9IEdsb2JTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/walker.js\n");

/***/ })

};
;